Liquid War 6, a unique multiplayer wargame.

1 Introduction
1.1 In a nutshell
1.2 Project status
  1.2.1 What works, and what does not (yet)
  1.2.2 What has changed since Liquid War 5.x?
  1.2.3 Revision history
  1.2.4 Road map
1.3 How you can help
  1.3.1 Help GNU
  1.3.2 Todo list
2 User's manual
2.1 Mailing lists
  2.1.1 General discussion
  2.1.2 Announcements
  2.1.3 Bugs
  2.1.4 IRC channel
2.2 Getting the game
  2.2.1 Download source
  2.2.2 Download binaries
  2.2.3 GIT repository
  2.2.4 Daily snapshots
  2.2.5 Check integrity
2.3 Installation
  2.3.1 Requirements
  2.3.2 Optional libraries
  2.3.3 Optional tools
  2.3.4 Installing requirements using RPM/DEB packages
  2.3.5 Compiling
2.4 Extra maps
  2.4.1 The extra maps package
  2.4.2 Install extra maps on GNU/Linux and POSIX systems
  2.4.3 Raw install of extra maps (all-platforms)
2.5 Troubleshooting
  2.5.1 Compilation problems
  2.5.2 Check installation
  2.5.3 Problems running the game
2.6 Quick start
  2.6.1 Quick start
2.7 Strategy tips
2.8 User interface
  2.8.1 A reduced set of keys
  2.8.2 Combining mouse, keyboard and joysticks
  2.8.3 Quit with F10
2.9 Solo game
  2.9.1 Current state
  2.9.2 Team profiles
  2.9.3 Weapons
2.10 Network games
  2.10.1 Choose your "public url"
  2.10.2 Starting a node
  2.10.3 Connecting to a node
  2.10.4 Communities
  2.10.5 Firewall settings
  2.10.6 Is the game secure?
2.11 Graphics
  2.11.1 Standard, high and low resolution
  2.11.2 Display rate
2.12 Sound & music
  2.12.1 Current status
  2.12.2 The future
2.13 Config file
2.14 Logs
2.15 Report bugs
3 Hacker's guide
3.1 Designing levels
  3.1.1 Why is level design so important?
  3.1.2 Format overview
  3.1.3 Resolution (map size)
  3.1.4 Metadata
  3.1.5 map.png
  3.1.6 layer2.png ... layer7.png
  3.1.7 texture.png, texture.jpeg and texture-alpha.jpeg
  3.1.8 glue.png and boost.png
  3.1.9 danger.png and medicine.png
  3.1.10 one-way-<direction>.png
  3.1.11 cursor.png and cursor-color.png
  3.1.12 rules.xml
  3.1.13 hints.xml
  3.1.14 style.xml
  3.1.15 teams.xml
  3.1.16 Resampling
  3.1.17 Music
  3.1.18 Experience ("exp")
3.2 Translating
  3.2.1 Using gettext
  3.2.2 Formatted strings
  3.2.3 Partial translation
3.3 Architecture
  3.3.1 C + Guile
  3.3.2 Threading and SMP
  3.3.3 Internal libraries
3.4 Memory structures
3.5 100% predictable algorithm
3.6 Graphics backends
  3.6.1 Modularity
  3.6.2 List of backends
  3.6.3 How to write a new backend
3.7 Core algorithm
  3.7.1 Introduction
  3.7.2 Level, game struct, game state and pilot
  3.7.3 Getting informations about where fighters are
3.8 Compilation tips
  3.8.1 Advanced ./configure options
  3.8.2 Debian packages
  3.8.3 Red Hat packages
  3.8.4 Microsoft Windows msys/mingw32 port
  3.8.5 Mac OS X port
  3.8.6 GP2X port
3.9 Coding guidelines
  3.9.1 Project goals reminder
  3.9.2 Common sense
  3.9.3 Unitary tests
  3.9.4 Memory allocation
  3.9.5 Private and public interfaces
  3.9.6 Commit policy
  3.9.7 Audit the code
3.10 Using the console
3.11 Advanced tweaking
  3.11.1 Hacking ressources
  3.11.2 Optimize for speed
3.12 Writing modules
3.13 Use as a library
3.14 Network protocol
  3.14.1 No server, no client, only nodes
  3.14.2 Out of band messages
  3.14.3 Regular messages overview
  3.14.4 Regular control messages
  3.14.5 Regular MISS messages
  3.14.6 Regular META messages
  3.14.7 Regular DATA messages
  3.14.8 Other raw technical stuff (WIP)
3.15 Technical HOWTOs
  3.15.1 Release check-list
  3.15.2 Add a new option
  3.15.3 Add a new internal library
  3.15.4 Add a new module
3.16 Using GNU Arch
  3.16.1 About GNU Arch
  3.16.2 Getting the latest version from the repository
  3.16.3 Setting up your own arch repository
  3.16.4 Synchronizing your repository with upstream releases
  3.16.5 Submitting patches
  3.16.6 Recover from broken lock
3.17 Using GIT
  3.17.1 About GIT
  3.17.2 Getting the latest source
  3.17.3 Developper access
  3.17.4 Submitting patches
3.18 Jenkins builds
4 Reference
4.1 Basic options
  4.1.1 about
  4.1.2 audit
  4.1.3 copyright
  4.1.4 credits
  4.1.5 debug
  4.1.6 defaults
  4.1.7 help
  4.1.8 host
  4.1.9 list
  4.1.10 modules
  4.1.11 pedigree
  4.1.12 test
  4.1.13 version
4.2 Doc options
  4.2.1 example-hints-xml
  4.2.2 example-rules-xml
  4.2.3 example-style-xml
  4.2.4 example-teams-xml
  4.2.5 list-advanced
  4.2.6 list-aliases
  4.2.7 list-doc
  4.2.8 list-funcs
  4.2.9 list-graphics
  4.2.10 list-hooks
  4.2.11 list-input
  4.2.12 list-map
  4.2.13 list-map-hints
  4.2.14 list-map-rules
  4.2.15 list-map-style
  4.2.16 list-map-teams
  4.2.17 list-network
  4.2.18 list-path
  4.2.19 list-players
  4.2.20 list-quick
  4.2.21 list-show
  4.2.22 list-sound
  4.2.23 list-team-colors
  4.2.24 list-weapons
4.3 Show options
  4.3.1 show-build-abs-srcdir
  4.3.2 show-build-bin-id
  4.3.3 show-build-bugs-url
  4.3.4 show-build-cflags
  4.3.5 show-build-codename
  4.3.6 show-build-configure-args
  4.3.7 show-build-copyright
  4.3.8 show-build-datadir
  4.3.9 show-build-date
  4.3.10 show-build-docdir
  4.3.11 show-build-enable-allinone
  4.3.12 show-build-enable-console
  4.3.13 show-build-enable-fullstatic
  4.3.14 show-build-enable-gcov
  4.3.15 show-build-enable-gprof
  4.3.16 show-build-enable-gtk
  4.3.17 show-build-enable-instrument
  4.3.18 show-build-enable-mod-caca
  4.3.19 show-build-enable-mod-csound
  4.3.20 show-build-enable-mod-gl1
  4.3.21 show-build-enable-mod-gles2
  4.3.22 show-build-enable-mod-http
  4.3.23 show-build-enable-mod-ogg
  4.3.24 show-build-enable-mod-soft
  4.3.25 show-build-enable-openmp
  4.3.26 show-build-enable-optimize
  4.3.27 show-build-enable-paranoid
  4.3.28 show-build-enable-profiler
  4.3.29 show-build-enable-valgrind
  4.3.30 show-build-endianness
  4.3.31 show-build-gcc-version
  4.3.32 show-build-gnu
  4.3.33 show-build-gp2x
  4.3.34 show-build-home-url
  4.3.35 show-build-host-cpu
  4.3.36 show-build-host-os
  4.3.37 show-build-hostname
  4.3.38 show-build-includedir
  4.3.39 show-build-ldflags
  4.3.40 show-build-libdir
  4.3.41 show-build-license
  4.3.42 show-build-localedir
  4.3.43 show-build-mac-os-x
  4.3.44 show-build-md5sum
  4.3.45 show-build-ms-windows
  4.3.46 show-build-package-id
  4.3.47 show-build-package-name
  4.3.48 show-build-package-string
  4.3.49 show-build-package-tarname
  4.3.50 show-build-pointer-size
  4.3.51 show-build-prefix
  4.3.52 show-build-stamp
  4.3.53 show-build-time
  4.3.54 show-build-top-srcdir
  4.3.55 show-build-unix
  4.3.56 show-build-version
  4.3.57 show-build-version-base
  4.3.58 show-build-version-major
  4.3.59 show-build-version-minor
  4.3.60 show-build-x86
  4.3.61 show-config-file
  4.3.62 show-cwd
  4.3.63 show-data-dir
  4.3.64 show-default-config-file
  4.3.65 show-default-data-dir
  4.3.66 show-default-log-file
  4.3.67 show-default-map-dir
  4.3.68 show-default-map-path
  4.3.69 show-default-mod-dir
  4.3.70 show-default-music-dir
  4.3.71 show-default-music-path
  4.3.72 show-default-prefix
  4.3.73 show-default-script-file
  4.3.74 show-default-user-dir
  4.3.75 show-log-file
  4.3.76 show-map-dir
  4.3.77 show-map-path
  4.3.78 show-mod-dir
  4.3.79 show-music-dir
  4.3.80 show-music-path
  4.3.81 show-prefix
  4.3.82 show-run-dir
  4.3.83 show-script-file
  4.3.84 show-user-dir
4.4 Path options
  4.4.1 config-file
  4.4.2 data-dir
  4.4.3 log-file
  4.4.4 map-dir
  4.4.5 map-path
  4.4.6 mod-dir
  4.4.7 music-dir
  4.4.8 music-path
  4.4.9 prefix
  4.4.10 script-file
  4.4.11 user-dir
4.5 Players options
  4.5.1 player1-control
  4.5.2 player1-name
  4.5.3 player1-status
  4.5.4 player2-control
  4.5.5 player2-name
  4.5.6 player2-status
  4.5.7 player3-control
  4.5.8 player3-name
  4.5.9 player3-status
  4.5.10 player4-control
  4.5.11 player4-name
  4.5.12 player4-status
4.6 Input options
  4.6.1 auto-release-delay
  4.6.2 click-to-focus
  4.6.3 cursor-sensitivity
  4.6.4 custom-alt
  4.6.5 custom-ctrl
  4.6.6 custom-down
  4.6.7 custom-enter
  4.6.8 custom-esc
  4.6.9 custom-left
  4.6.10 custom-pgdown
  4.6.11 custom-pgup
  4.6.12 custom-right
  4.6.13 custom-up
  4.6.14 double-click-delay
  4.6.15 max-cursor-speed
  4.6.16 mouse-sensitivity
  4.6.17 repeat-delay
  4.6.18 repeat-interval
  4.6.19 use-double-click
  4.6.20 use-esc-button
  4.6.21 zoom-step
  4.6.22 zoom-stick-delay
4.7 Graphics options
  4.7.1 capture
  4.7.2 fullscreen
  4.7.3 gfx-backend
  4.7.4 gfx-quality
  4.7.5 height
  4.7.6 width
  4.7.7 windowed-mode-limit
4.8 Sound options
  4.8.1 ambiance-exclude
  4.8.2 ambiance-file
  4.8.3 ambiance-filter
  4.8.4 fx-volume
  4.8.5 music-volume
  4.8.6 snd-backend
  4.8.7 water-volume
4.9 Network options
  4.9.1 bind-ip
  4.9.2 bind-port
  4.9.3 broadcast
  4.9.4 cli-backends
  4.9.5 known-nodes
  4.9.6 node-description
  4.9.7 node-title
  4.9.8 password
  4.9.9 public-url
  4.9.10 skip-network
  4.9.11 srv-backends
4.10 Map parameters
  4.10.1 chosen-map
  4.10.2 force
  4.10.3 use-cursor-texture
  4.10.4 use-hints-xml
  4.10.5 use-music-file
  4.10.6 use-rules-xml
  4.10.7 use-style-xml
  4.10.8 use-teams-xml
  4.10.9 use-texture
4.11 Map rules.xml
  4.11.1 boost-power
  4.11.2 color-conflict-mode
  4.11.3 cursor-pot-init
  4.11.4 danger-power
  4.11.5 exp
  4.11.6 fighter-attack
  4.11.7 fighter-defense
  4.11.8 fighter-new-health
  4.11.9 fighter-regenerate
  4.11.10 frags-fade-out
  4.11.11 frags-mode
  4.11.12 frags-to-distribute
  4.11.13 glue-power
  4.11.14 highest-team-color-allowed
  4.11.15 highest-weapon-allowed
  4.11.16 max-cursor-pot
  4.11.17 max-cursor-pot-offset
  4.11.18 max-nb-cursors
  4.11.19 max-nb-nodes
  4.11.20 max-nb-teams
  4.11.21 max-round-delta
  4.11.22 max-zone-size
  4.11.23 medicine-power
  4.11.24 moves-per-round
  4.11.25 nb-attack-tries
  4.11.26 nb-defense-tries
  4.11.27 nb-move-tries
  4.11.28 respawn-delay
  4.11.29 respawn-position-mode
  4.11.30 respawn-team
  4.11.31 round-delta
  4.11.32 rounds-per-sec
  4.11.33 side-attack-factor
  4.11.34 side-defense-factor
  4.11.35 single-army-size
  4.11.36 spread-mode
  4.11.37 spread-thread
  4.11.38 spreads-per-round
  4.11.39 start-blue-x
  4.11.40 start-blue-y
  4.11.41 start-cyan-x
  4.11.42 start-cyan-y
  4.11.43 start-green-x
  4.11.44 start-green-y
  4.11.45 start-lightblue-x
  4.11.46 start-lightblue-y
  4.11.47 start-magenta-x
  4.11.48 start-magenta-y
  4.11.49 start-orange-x
  4.11.50 start-orange-y
  4.11.51 start-pink-x
  4.11.52 start-pink-y
  4.11.53 start-position-mode
  4.11.54 start-purple-x
  4.11.55 start-purple-y
  4.11.56 start-red-x
  4.11.57 start-red-y
  4.11.58 start-yellow-x
  4.11.59 start-yellow-y
  4.11.60 team-profile-blue-aggressive
  4.11.61 team-profile-blue-fast
  4.11.62 team-profile-blue-handicap
  4.11.63 team-profile-blue-mobile
  4.11.64 team-profile-blue-vulnerable
  4.11.65 team-profile-blue-weapon-alternate-id
  4.11.66 team-profile-blue-weapon-id
  4.11.67 team-profile-blue-weapon-mode
  4.11.68 team-profile-cyan-aggressive
  4.11.69 team-profile-cyan-fast
  4.11.70 team-profile-cyan-handicap
  4.11.71 team-profile-cyan-mobile
  4.11.72 team-profile-cyan-vulnerable
  4.11.73 team-profile-cyan-weapon-alternate-id
  4.11.74 team-profile-cyan-weapon-id
  4.11.75 team-profile-cyan-weapon-mode
  4.11.76 team-profile-green-aggressive
  4.11.77 team-profile-green-fast
  4.11.78 team-profile-green-handicap
  4.11.79 team-profile-green-mobile
  4.11.80 team-profile-green-vulnerable
  4.11.81 team-profile-green-weapon-alternate-id
  4.11.82 team-profile-green-weapon-id
  4.11.83 team-profile-green-weapon-mode
  4.11.84 team-profile-lightblue-aggressive
  4.11.85 team-profile-lightblue-fast
  4.11.86 team-profile-lightblue-handicap
  4.11.87 team-profile-lightblue-mobile
  4.11.88 team-profile-lightblue-vulnerable
  4.11.89 team-profile-lightblue-weapon-alternate-id
  4.11.90 team-profile-lightblue-weapon-id
  4.11.91 team-profile-lightblue-weapon-mode
  4.11.92 team-profile-magenta-aggressive
  4.11.93 team-profile-magenta-fast
  4.11.94 team-profile-magenta-handicap
  4.11.95 team-profile-magenta-mobile
  4.11.96 team-profile-magenta-vulnerable
  4.11.97 team-profile-magenta-weapon-alternate-id
  4.11.98 team-profile-magenta-weapon-id
  4.11.99 team-profile-magenta-weapon-mode
  4.11.100 team-profile-orange-aggressive
  4.11.101 team-profile-orange-fast
  4.11.102 team-profile-orange-handicap
  4.11.103 team-profile-orange-mobile
  4.11.104 team-profile-orange-vulnerable
  4.11.105 team-profile-orange-weapon-alternate-id
  4.11.106 team-profile-orange-weapon-id
  4.11.107 team-profile-orange-weapon-mode
  4.11.108 team-profile-pink-aggressive
  4.11.109 team-profile-pink-fast
  4.11.110 team-profile-pink-handicap
  4.11.111 team-profile-pink-mobile
  4.11.112 team-profile-pink-vulnerable
  4.11.113 team-profile-pink-weapon-alternate-id
  4.11.114 team-profile-pink-weapon-id
  4.11.115 team-profile-pink-weapon-mode
  4.11.116 team-profile-purple-aggressive
  4.11.117 team-profile-purple-fast
  4.11.118 team-profile-purple-handicap
  4.11.119 team-profile-purple-mobile
  4.11.120 team-profile-purple-vulnerable
  4.11.121 team-profile-purple-weapon-alternate-id
  4.11.122 team-profile-purple-weapon-id
  4.11.123 team-profile-purple-weapon-mode
  4.11.124 team-profile-red-aggressive
  4.11.125 team-profile-red-fast
  4.11.126 team-profile-red-handicap
  4.11.127 team-profile-red-mobile
  4.11.128 team-profile-red-vulnerable
  4.11.129 team-profile-red-weapon-alternate-id
  4.11.130 team-profile-red-weapon-id
  4.11.131 team-profile-red-weapon-mode
  4.11.132 team-profile-yellow-aggressive
  4.11.133 team-profile-yellow-fast
  4.11.134 team-profile-yellow-handicap
  4.11.135 team-profile-yellow-mobile
  4.11.136 team-profile-yellow-vulnerable
  4.11.137 team-profile-yellow-weapon-alternate-id
  4.11.138 team-profile-yellow-weapon-id
  4.11.139 team-profile-yellow-weapon-mode
  4.11.140 total-armies-size
  4.11.141 total-time
  4.11.142 use-team-profiles
  4.11.143 vertical-move
  4.11.144 weapon-charge-delay
  4.11.145 weapon-charge-max
  4.11.146 weapon-duration
  4.11.147 weapon-tune-berzerk-power
  4.11.148 weapon-tune-turbo-power
  4.11.149 x-polarity
  4.11.150 y-polarity
  4.11.151 z-polarity
4.12 Map hints.xml
  4.12.1 background-color-auto
  4.12.2 downsize-using-bench-value
  4.12.3 downsize-using-fighter-scale
  4.12.4 fighter-scale
  4.12.5 guess-colors
  4.12.6 guess-moves-per-sec
  4.12.7 hud-color-auto
  4.12.8 max-map-height
  4.12.9 max-map-surface
  4.12.10 max-map-width
  4.12.11 menu-color-auto
  4.12.12 min-map-height
  4.12.13 min-map-surface
  4.12.14 min-map-width
  4.12.15 resample
  4.12.16 speed
  4.12.17 system-color-auto
  4.12.18 upsize-using-bench-value
  4.12.19 upsize-using-fighter-scale
  4.12.20 view-color-auto
  4.12.21 wall-grease
4.13 Map style.xml
  4.13.1 animation-density
  4.13.2 animation-speed
  4.13.3 background-color-root-bg
  4.13.4 background-color-root-fg
  4.13.5 background-color-stuff-bg
  4.13.6 background-color-stuff-fg
  4.13.7 background-style
  4.13.8 blink-cursor
  4.13.9 color-alternate-bg
  4.13.10 color-alternate-fg
  4.13.11 color-base-bg
  4.13.12 color-base-fg
  4.13.13 colorize
  4.13.14 colorize-cursor
  4.13.15 cursor-size
  4.13.16 hidden-layer-alpha
  4.13.17 hud-color-frame-bg
  4.13.18 hud-color-frame-fg
  4.13.19 hud-color-text-bg
  4.13.20 hud-color-text-fg
  4.13.21 hud-style
  4.13.22 keep-ratio
  4.13.23 menu-color-default-bg
  4.13.24 menu-color-default-fg
  4.13.25 menu-color-disabled-bg
  4.13.26 menu-color-disabled-fg
  4.13.27 menu-color-selected-bg
  4.13.28 menu-color-selected-fg
  4.13.29 menu-style
  4.13.30 music-exclude
  4.13.31 music-file
  4.13.32 music-filter
  4.13.33 pixelize
  4.13.34 system-color-bg
  4.13.35 system-color-fg
  4.13.36 team-color-blue
  4.13.37 team-color-cyan
  4.13.38 team-color-dead
  4.13.39 team-color-green
  4.13.40 team-color-lightblue
  4.13.41 team-color-magenta
  4.13.42 team-color-orange
  4.13.43 team-color-pink
  4.13.44 team-color-purple
  4.13.45 team-color-red
  4.13.46 team-color-yellow
  4.13.47 view-color-cursor-bg
  4.13.48 view-color-cursor-fg
  4.13.49 view-color-map-bg
  4.13.50 view-color-map-fg
  4.13.51 view-style
  4.13.52 waves
  4.13.53 x-wrap
  4.13.54 y-wrap
  4.13.55 zoom
  4.13.56 zoom-max
  4.13.57 zoom-min
4.14 Map teams.xml
  4.14.1 bot-iq
  4.14.2 bot-speed
  4.14.3 bot1-ai
  4.14.4 bot1-color
  4.14.5 bot2-ai
  4.14.6 bot2-color
  4.14.7 bot3-ai
  4.14.8 bot3-color
  4.14.9 bot4-ai
  4.14.10 bot4-color
  4.14.11 bot5-ai
  4.14.12 bot5-color
  4.14.13 bot6-ai
  4.14.14 bot6-color
  4.14.15 bot7-ai
  4.14.16 bot7-color
  4.14.17 bot8-ai
  4.14.18 bot8-color
  4.14.19 bot9-ai
  4.14.20 bot9-color
  4.14.21 nb-bots
  4.14.22 player1-color
  4.14.23 player2-color
  4.14.24 player3-color
  4.14.25 player4-color
4.15 Advanced settings
  4.15.1 base64-decode
  4.15.2 base64-encode
  4.15.3 bench
  4.15.4 bench-value
  4.15.5 bin-id
  4.15.6 check
  4.15.7 commands-per-sec
  4.15.8 cunit
  4.15.9 daemon
  4.15.10 debug-layer-id
  4.15.11 debug-team-id
  4.15.12 demo
  4.15.13 dialog-timeout
  4.15.14 dirty-read
  4.15.15 display-background
  4.15.16 display-console
  4.15.17 display-cursors
  4.15.18 display-debug-gradient
  4.15.19 display-debug-zones
  4.15.20 display-fighters
  4.15.21 display-fps
  4.15.22 display-hud
  4.15.23 display-log
  4.15.24 display-map
  4.15.25 display-menu
  4.15.26 display-meta
  4.15.27 display-mouse
  4.15.28 display-mps
  4.15.29 display-preview
  4.15.30 display-progress
  4.15.31 display-score
  4.15.32 display-splash
  4.15.33 display-url
  4.15.34 executed-again
  4.15.35 gfx-cpu-usage
  4.15.36 gfx-debug
  4.15.37 io-per-sec
  4.15.38 jpeg-quality
  4.15.39 loader-sleep
  4.15.40 local-bench-delta
  4.15.41 log-level
  4.15.42 log-timeout
  4.15.43 magic-number
  4.15.44 max-local-bench-value
  4.15.45 max-network-bench-value
  4.15.46 memory-bazooka-eraser
  4.15.47 memory-bazooka-size
  4.15.48 net-log
  4.15.49 net-per-sec
  4.15.50 network-bench-delta
  4.15.51 network-reliability
  4.15.52 open-relay
  4.15.53 pilot-lag
  4.15.54 quick-start
  4.15.55 reset
  4.15.56 reset-config-on-upgrade
  4.15.57 screenshots-per-min
  4.15.58 server
  4.15.59 simulate-basic
  4.15.60 simulate-full
  4.15.61 target-fps
  4.15.62 trap-errors
  4.15.63 trojan
  4.15.64 z-decode
  4.15.65 z-encode
4.16 C to Guile
  4.16.1 c-gettext
  4.16.2 c-lw6-exit
  4.16.3 c-lw6-get-ret
  4.16.4 c-lw6-release
  4.16.5 c-lw6-set-ret
  4.16.6 c-lw6bot-get-backends
  4.16.7 c-lw6bot-new
  4.16.8 c-lw6bot-next-move
  4.16.9 c-lw6cfg-defaults
  4.16.10 c-lw6cfg-get-option
  4.16.11 c-lw6cfg-init
  4.16.12 c-lw6cfg-load
  4.16.13 c-lw6cfg-option-exists
  4.16.14 c-lw6cfg-quit
  4.16.15 c-lw6cfg-save
  4.16.16 c-lw6cfg-set-option
  4.16.17 c-lw6cfg-unified-get-log-file
  4.16.18 c-lw6cfg-unified-get-map-path
  4.16.19 c-lw6cfg-unified-get-music-path
  4.16.20 c-lw6cfg-unified-get-user-dir
  4.16.21 c-lw6cli-get-backends
  4.16.22 c-lw6cns-console-support
  4.16.23 c-lw6cns-init
  4.16.24 c-lw6cns-poll
  4.16.25 c-lw6cns-quit
  4.16.26 c-lw6cns-term-support
  4.16.27 c-lw6dsp-get-average-fps
  4.16.28 c-lw6dsp-get-fullscreen-modes
  4.16.29 c-lw6dsp-get-instant-fps
  4.16.30 c-lw6dsp-get-last-frame-rendering-time
  4.16.31 c-lw6dsp-get-nb-frames
  4.16.32 c-lw6dsp-get-video-mode
  4.16.33 c-lw6dsp-new
  4.16.34 c-lw6dsp-release
  4.16.35 c-lw6dsp-update
  4.16.36 c-lw6gen-create-from-seed
  4.16.37 c-lw6gen-seed-new
  4.16.38 c-lw6gen-seed-normalize
  4.16.39 c-lw6gfx-get-backends
  4.16.40 c-lw6gui-default-look
  4.16.41 c-lw6gui-input-reset
  4.16.42 c-lw6gui-joystick1-get-move-pad
  4.16.43 c-lw6gui-joystick1-pop-button-a
  4.16.44 c-lw6gui-joystick1-pop-button-b
  4.16.45 c-lw6gui-joystick1-pop-button-c
  4.16.46 c-lw6gui-joystick1-pop-button-d
  4.16.47 c-lw6gui-joystick1-pop-button-e
  4.16.48 c-lw6gui-joystick1-pop-button-f
  4.16.49 c-lw6gui-joystick1-pop-pad-down
  4.16.50 c-lw6gui-joystick1-pop-pad-left
  4.16.51 c-lw6gui-joystick1-pop-pad-right
  4.16.52 c-lw6gui-joystick1-pop-pad-up
  4.16.53 c-lw6gui-joystick2-get-move-pad
  4.16.54 c-lw6gui-joystick2-pop-button-a
  4.16.55 c-lw6gui-joystick2-pop-button-b
  4.16.56 c-lw6gui-joystick2-pop-button-c
  4.16.57 c-lw6gui-joystick2-pop-button-d
  4.16.58 c-lw6gui-joystick2-pop-button-e
  4.16.59 c-lw6gui-joystick2-pop-button-f
  4.16.60 c-lw6gui-joystick2-pop-pad-down
  4.16.61 c-lw6gui-joystick2-pop-pad-left
  4.16.62 c-lw6gui-joystick2-pop-pad-right
  4.16.63 c-lw6gui-joystick2-pop-pad-up
  4.16.64 c-lw6gui-keyboard-get-move-pad
  4.16.65 c-lw6gui-keyboard-is-pressed
  4.16.66 c-lw6gui-keyboard-pop-arrow-down
  4.16.67 c-lw6gui-keyboard-pop-arrow-left
  4.16.68 c-lw6gui-keyboard-pop-arrow-right
  4.16.69 c-lw6gui-keyboard-pop-arrow-up
  4.16.70 c-lw6gui-keyboard-pop-key-alt
  4.16.71 c-lw6gui-keyboard-pop-key-ctrl
  4.16.72 c-lw6gui-keyboard-pop-key-enter
  4.16.73 c-lw6gui-keyboard-pop-key-esc
  4.16.74 c-lw6gui-keyboard-pop-key-pgdown
  4.16.75 c-lw6gui-keyboard-pop-key-pgup
  4.16.76 c-lw6gui-look-get
  4.16.77 c-lw6gui-look-set
  4.16.78 c-lw6gui-look-zoom-in
  4.16.79 c-lw6gui-look-zoom-out
  4.16.80 c-lw6gui-menu-append
  4.16.81 c-lw6gui-menu-close-popup
  4.16.82 c-lw6gui-menu-enable-esc
  4.16.83 c-lw6gui-menu-has-popup
  4.16.84 c-lw6gui-menu-new
  4.16.85 c-lw6gui-menu-remove
  4.16.86 c-lw6gui-menu-remove-all
  4.16.87 c-lw6gui-menu-scroll-down
  4.16.88 c-lw6gui-menu-scroll-up
  4.16.89 c-lw6gui-menu-select
  4.16.90 c-lw6gui-menu-select-esc
  4.16.91 c-lw6gui-menu-set-breadcrumbs
  4.16.92 c-lw6gui-menu-sync
  4.16.93 c-lw6gui-mouse-get-state
  4.16.94 c-lw6gui-mouse-poll-move
  4.16.95 c-lw6gui-mouse-pop-button-left
  4.16.96 c-lw6gui-mouse-pop-button-middle
  4.16.97 c-lw6gui-mouse-pop-button-right
  4.16.98 c-lw6gui-mouse-pop-double-click
  4.16.99 c-lw6gui-mouse-pop-simple-click
  4.16.100 c-lw6gui-mouse-pop-triple-click
  4.16.101 c-lw6gui-mouse-pop-wheel-down
  4.16.102 c-lw6gui-mouse-pop-wheel-up
  4.16.103 c-lw6hlp-about
  4.16.104 c-lw6hlp-get-default-value
  4.16.105 c-lw6hlp-list
  4.16.106 c-lw6hlp-list-advanced
  4.16.107 c-lw6hlp-list-aliases
  4.16.108 c-lw6hlp-list-doc
  4.16.109 c-lw6hlp-list-funcs
  4.16.110 c-lw6hlp-list-graphics
  4.16.111 c-lw6hlp-list-hooks
  4.16.112 c-lw6hlp-list-input
  4.16.113 c-lw6hlp-list-map
  4.16.114 c-lw6hlp-list-map-hints
  4.16.115 c-lw6hlp-list-map-rules
  4.16.116 c-lw6hlp-list-map-style
  4.16.117 c-lw6hlp-list-map-teams
  4.16.118 c-lw6hlp-list-network
  4.16.119 c-lw6hlp-list-path
  4.16.120 c-lw6hlp-list-players
  4.16.121 c-lw6hlp-list-quick
  4.16.122 c-lw6hlp-list-show
  4.16.123 c-lw6hlp-list-sound
  4.16.124 c-lw6hlp-list-team-colors
  4.16.125 c-lw6hlp-list-weapons
  4.16.126 c-lw6img-screenshot
  4.16.127 c-lw6ker-add-cursor
  4.16.128 c-lw6ker-build-game-state
  4.16.129 c-lw6ker-build-game-struct
  4.16.130 c-lw6ker-cursor-exists
  4.16.131 c-lw6ker-did-cursor-win
  4.16.132 c-lw6ker-do-round
  4.16.133 c-lw6ker-dup-game-state
  4.16.134 c-lw6ker-game-state-checksum
  4.16.135 c-lw6ker-game-struct-checksum
  4.16.136 c-lw6ker-get-cursor
  4.16.137 c-lw6ker-get-moves
  4.16.138 c-lw6ker-get-nb-colors
  4.16.139 c-lw6ker-get-nb-cursors
  4.16.140 c-lw6ker-get-nb-nodes
  4.16.141 c-lw6ker-get-rounds
  4.16.142 c-lw6ker-get-spreads
  4.16.143 c-lw6ker-is-over
  4.16.144 c-lw6ker-node-exists
  4.16.145 c-lw6ker-register-node
  4.16.146 c-lw6ker-remove-cursor
  4.16.147 c-lw6ker-set-cursor
  4.16.148 c-lw6ker-sync-game-state
  4.16.149 c-lw6ker-unregister-node
  4.16.150 c-lw6ldr-chain-entry
  4.16.151 c-lw6ldr-exp-validate
  4.16.152 c-lw6ldr-get-entries
  4.16.153 c-lw6ldr-hints-get-default
  4.16.154 c-lw6ldr-print-examples
  4.16.155 c-lw6ldr-read
  4.16.156 c-lw6ldr-read-relative
  4.16.157 c-lw6map-exp-get-unlocked-team-color
  4.16.158 c-lw6map-exp-get-unlocked-weapon
  4.16.159 c-lw6map-exp-is-team-color-allowed
  4.16.160 c-lw6map-exp-is-weapon-allowed
  4.16.161 c-lw6map-get-look
  4.16.162 c-lw6map-get-max-nb-colors
  4.16.163 c-lw6map-get-max-nb-cursors
  4.16.164 c-lw6map-get-max-nb-nodes
  4.16.165 c-lw6map-get-music-dir
  4.16.166 c-lw6map-get-title
  4.16.167 c-lw6map-param-get
  4.16.168 c-lw6map-rules-get-default
  4.16.169 c-lw6map-rules-get-int
  4.16.170 c-lw6map-rules-get-max
  4.16.171 c-lw6map-rules-get-min
  4.16.172 c-lw6map-style-get-default
  4.16.173 c-lw6map-team-color-index-to-key
  4.16.174 c-lw6map-team-color-index-to-label
  4.16.175 c-lw6map-team-color-key-to-index
  4.16.176 c-lw6map-team-color-list
  4.16.177 c-lw6map-teams-get-default
  4.16.178 c-lw6map-weapon-index-to-key
  4.16.179 c-lw6map-weapon-index-to-label
  4.16.180 c-lw6map-weapon-key-to-index
  4.16.181 c-lw6map-weapon-list
  4.16.182 c-lw6net-init
  4.16.183 c-lw6net-quit
  4.16.184 c-lw6p2p-db-default-name
  4.16.185 c-lw6p2p-db-new
  4.16.186 c-lw6p2p-db-reset
  4.16.187 c-lw6p2p-node-calibrate
  4.16.188 c-lw6p2p-node-client-join
  4.16.189 c-lw6p2p-node-close
  4.16.190 c-lw6p2p-node-disconnect
  4.16.191 c-lw6p2p-node-get-entries
  4.16.192 c-lw6p2p-node-get-id
  4.16.193 c-lw6p2p-node-get-local-seq-0
  4.16.194 c-lw6p2p-node-get-local-seq-last
  4.16.195 c-lw6p2p-node-get-next-draft-msg
  4.16.196 c-lw6p2p-node-get-next-reference-msg
  4.16.197 c-lw6p2p-node-get-seq-draft
  4.16.198 c-lw6p2p-node-get-seq-max
  4.16.199 c-lw6p2p-node-get-seq-min
  4.16.200 c-lw6p2p-node-get-seq-reference
  4.16.201 c-lw6p2p-node-is-dump-needed
  4.16.202 c-lw6p2p-node-is-peer-connected
  4.16.203 c-lw6p2p-node-is-peer-registered
  4.16.204 c-lw6p2p-node-is-seed-needed
  4.16.205 c-lw6p2p-node-new
  4.16.206 c-lw6p2p-node-poll
  4.16.207 c-lw6p2p-node-put-local-msg
  4.16.208 c-lw6p2p-node-refresh-peer
  4.16.209 c-lw6p2p-node-server-start
  4.16.210 c-lw6p2p-node-update-info
  4.16.211 c-lw6pil-bench
  4.16.212 c-lw6pil-build-pilot
  4.16.213 c-lw6pil-calibrate
  4.16.214 c-lw6pil-commit
  4.16.215 c-lw6pil-did-cursor-win
  4.16.216 c-lw6pil-dump-command-generate
  4.16.217 c-lw6pil-execute-command
  4.16.218 c-lw6pil-fix-coords
  4.16.219 c-lw6pil-fix-coords-x10
  4.16.220 c-lw6pil-get-last-commit-seq
  4.16.221 c-lw6pil-get-looser
  4.16.222 c-lw6pil-get-max-seq
  4.16.223 c-lw6pil-get-next-seq
  4.16.224 c-lw6pil-get-reference-current-seq
  4.16.225 c-lw6pil-get-reference-target-seq
  4.16.226 c-lw6pil-get-round-0
  4.16.227 c-lw6pil-get-seq-0
  4.16.228 c-lw6pil-get-winner
  4.16.229 c-lw6pil-is-over
  4.16.230 c-lw6pil-local-command
  4.16.231 c-lw6pil-local-cursors-set-main
  4.16.232 c-lw6pil-local-cursors-set-mouse-controlled
  4.16.233 c-lw6pil-make-backup
  4.16.234 c-lw6pil-poll-dump
  4.16.235 c-lw6pil-round2seq
  4.16.236 c-lw6pil-seed-command-generate
  4.16.237 c-lw6pil-send-command
  4.16.238 c-lw6pil-seq-random-0
  4.16.239 c-lw6pil-seq2round
  4.16.240 c-lw6pil-slow-down
  4.16.241 c-lw6pil-speed-up
  4.16.242 c-lw6pil-suite-get-checkpoint
  4.16.243 c-lw6pil-suite-get-commands-by-node-index
  4.16.244 c-lw6pil-suite-get-commands-by-stage
  4.16.245 c-lw6pil-suite-get-node-id
  4.16.246 c-lw6pil-suite-get-seq-0
  4.16.247 c-lw6pil-suite-init
  4.16.248 c-lw6pil-sync-from-backup
  4.16.249 c-lw6pil-sync-from-draft
  4.16.250 c-lw6pil-sync-from-reference
  4.16.251 c-lw6snd-get-backends
  4.16.252 c-lw6snd-is-music-file
  4.16.253 c-lw6snd-new
  4.16.254 c-lw6snd-play-fx
  4.16.255 c-lw6snd-play-music-file
  4.16.256 c-lw6snd-play-music-random
  4.16.257 c-lw6snd-poll
  4.16.258 c-lw6snd-release
  4.16.259 c-lw6snd-set-fx-volume
  4.16.260 c-lw6snd-set-music-volume
  4.16.261 c-lw6snd-set-water-volume
  4.16.262 c-lw6snd-stop-music
  4.16.263 c-lw6srv-get-backends
  4.16.264 c-lw6sys-build-get-abs-srcdir
  4.16.265 c-lw6sys-build-get-bin-id
  4.16.266 c-lw6sys-build-get-bugs-url
  4.16.267 c-lw6sys-build-get-cflags
  4.16.268 c-lw6sys-build-get-codename
  4.16.269 c-lw6sys-build-get-configure-args
  4.16.270 c-lw6sys-build-get-copyright
  4.16.271 c-lw6sys-build-get-datadir
  4.16.272 c-lw6sys-build-get-date
  4.16.273 c-lw6sys-build-get-docdir
  4.16.274 c-lw6sys-build-get-enable-allinone
  4.16.275 c-lw6sys-build-get-enable-console
  4.16.276 c-lw6sys-build-get-enable-fullstatic
  4.16.277 c-lw6sys-build-get-enable-gcov
  4.16.278 c-lw6sys-build-get-enable-gprof
  4.16.279 c-lw6sys-build-get-enable-gtk
  4.16.280 c-lw6sys-build-get-enable-instrument
  4.16.281 c-lw6sys-build-get-enable-mod-caca
  4.16.282 c-lw6sys-build-get-enable-mod-csound
  4.16.283 c-lw6sys-build-get-enable-mod-gl1
  4.16.284 c-lw6sys-build-get-enable-mod-gles2
  4.16.285 c-lw6sys-build-get-enable-mod-http
  4.16.286 c-lw6sys-build-get-enable-mod-ogg
  4.16.287 c-lw6sys-build-get-enable-mod-soft
  4.16.288 c-lw6sys-build-get-enable-openmp
  4.16.289 c-lw6sys-build-get-enable-optimize
  4.16.290 c-lw6sys-build-get-enable-paranoid
  4.16.291 c-lw6sys-build-get-enable-profiler
  4.16.292 c-lw6sys-build-get-enable-valgrind
  4.16.293 c-lw6sys-build-get-endianness
  4.16.294 c-lw6sys-build-get-gcc-version
  4.16.295 c-lw6sys-build-get-home-url
  4.16.296 c-lw6sys-build-get-host-cpu
  4.16.297 c-lw6sys-build-get-host-os
  4.16.298 c-lw6sys-build-get-hostname
  4.16.299 c-lw6sys-build-get-includedir
  4.16.300 c-lw6sys-build-get-ldflags
  4.16.301 c-lw6sys-build-get-libdir
  4.16.302 c-lw6sys-build-get-license
  4.16.303 c-lw6sys-build-get-localedir
  4.16.304 c-lw6sys-build-get-md5sum
  4.16.305 c-lw6sys-build-get-package-id
  4.16.306 c-lw6sys-build-get-package-name
  4.16.307 c-lw6sys-build-get-package-string
  4.16.308 c-lw6sys-build-get-package-tarname
  4.16.309 c-lw6sys-build-get-pointer-size
  4.16.310 c-lw6sys-build-get-prefix
  4.16.311 c-lw6sys-build-get-stamp
  4.16.312 c-lw6sys-build-get-time
  4.16.313 c-lw6sys-build-get-top-srcdir
  4.16.314 c-lw6sys-build-get-version
  4.16.315 c-lw6sys-build-get-version-base
  4.16.316 c-lw6sys-build-get-version-major
  4.16.317 c-lw6sys-build-get-version-minor
  4.16.318 c-lw6sys-build-is-gnu
  4.16.319 c-lw6sys-build-is-gp2x
  4.16.320 c-lw6sys-build-is-mac-os-x
  4.16.321 c-lw6sys-build-is-ms-windows
  4.16.322 c-lw6sys-build-is-unix
  4.16.323 c-lw6sys-build-is-x86
  4.16.324 c-lw6sys-debug-get
  4.16.325 c-lw6sys-debug-set
  4.16.326 c-lw6sys-delay
  4.16.327 c-lw6sys-dump
  4.16.328 c-lw6sys-dump-clear
  4.16.329 c-lw6sys-generate-id-16
  4.16.330 c-lw6sys-generate-id-32
  4.16.331 c-lw6sys-generate-id-64
  4.16.332 c-lw6sys-get-config-file
  4.16.333 c-lw6sys-get-cwd
  4.16.334 c-lw6sys-get-cycle
  4.16.335 c-lw6sys-get-data-dir
  4.16.336 c-lw6sys-get-default-config-file
  4.16.337 c-lw6sys-get-default-data-dir
  4.16.338 c-lw6sys-get-default-log-file
  4.16.339 c-lw6sys-get-default-map-dir
  4.16.340 c-lw6sys-get-default-map-path
  4.16.341 c-lw6sys-get-default-mod-dir
  4.16.342 c-lw6sys-get-default-music-dir
  4.16.343 c-lw6sys-get-default-music-path
  4.16.344 c-lw6sys-get-default-prefix
  4.16.345 c-lw6sys-get-default-script-file
  4.16.346 c-lw6sys-get-default-user-dir
  4.16.347 c-lw6sys-get-hostname
  4.16.348 c-lw6sys-get-log-file
  4.16.349 c-lw6sys-get-map-dir
  4.16.350 c-lw6sys-get-map-path
  4.16.351 c-lw6sys-get-memory-bazooka-eraser
  4.16.352 c-lw6sys-get-memory-bazooka-size
  4.16.353 c-lw6sys-get-mod-dir
  4.16.354 c-lw6sys-get-music-dir
  4.16.355 c-lw6sys-get-music-path
  4.16.356 c-lw6sys-get-prefix
  4.16.357 c-lw6sys-get-run-dir
  4.16.358 c-lw6sys-get-script-file
  4.16.359 c-lw6sys-get-timestamp
  4.16.360 c-lw6sys-get-uptime
  4.16.361 c-lw6sys-get-user-dir
  4.16.362 c-lw6sys-get-username
  4.16.363 c-lw6sys-getenv
  4.16.364 c-lw6sys-getenv-prefixed
  4.16.365 c-lw6sys-idle
  4.16.366 c-lw6sys-log
  4.16.367 c-lw6sys-log-get-backtrace-mode
  4.16.368 c-lw6sys-log-get-level
  4.16.369 c-lw6sys-log-set-backtrace-mode
  4.16.370 c-lw6sys-log-set-dialog-timeout
  4.16.371 c-lw6sys-log-set-level
  4.16.372 c-lw6sys-megabytes-available
  4.16.373 c-lw6sys-openmp-get-num-procs
  4.16.374 c-lw6sys-path-concat
  4.16.375 c-lw6sys-path-file-only
  4.16.376 c-lw6sys-path-parent
  4.16.377 c-lw6sys-path-split
  4.16.378 c-lw6sys-set-memory-bazooka-eraser
  4.16.379 c-lw6sys-set-memory-bazooka-size
  4.16.380 c-lw6sys-signal-custom
  4.16.381 c-lw6sys-signal-default
  4.16.382 c-lw6sys-signal-poll-quit
  4.16.383 c-lw6sys-signal-send-quit
  4.16.384 c-lw6sys-sleep
  4.16.385 c-lw6sys-snooze
  4.16.386 c-lw6sys-url-canonize
  4.16.387 c-lw6tsk-loader-get-stage
  4.16.388 c-lw6tsk-loader-new
  4.16.389 c-lw6tsk-loader-pop
  4.16.390 c-lw6tsk-loader-push-gen
  4.16.391 c-lw6tsk-loader-push-ldr
4.17 Script hooks
5 C API
5.1 libliquidwar6
  5.1.1 Overview
  5.1.2 API
5.2 libbot
  5.2.1 Overview
  5.2.2 API
5.3 mod-brute
  5.3.1 Overview
  5.3.2 API
5.4 mod-follow
  5.4.1 Overview
  5.4.2 API
5.5 mod-idiot
  5.5.1 Overview
  5.5.2 API
5.6 mod-random
  5.6.1 Overview
  5.6.2 API
5.7 libcfg
  5.7.1 Overview
  5.7.2 API
5.8 libcli
  5.8.1 Overview
  5.8.2 API
5.9 mod-http
  5.9.1 Overview
  5.9.2 API
5.10 mod-tcp
  5.10.1 Overview
  5.10.2 API
5.11 mod-udp
  5.11.1 Overview
  5.11.2 API
5.12 libcns
  5.12.1 Overview
  5.12.2 API
5.13 libcnx
  5.13.1 Overview
  5.13.2 API
5.14 libdat
  5.14.1 Overview
  5.14.2 API
5.15 libdef
  5.15.1 Overview
  5.15.2 API
5.16 libdsp
  5.16.1 Overview
  5.16.2 API
5.17 libdyn
  5.17.1 Overview
  5.17.2 API
5.18 libgen
  5.18.1 Overview
  5.18.2 API
5.19 libgfx
  5.19.1 Overview
  5.19.2 API
5.20 mod-gl1
  5.20.1 Overview
  5.20.2 API
5.21 mod-gles2
  5.21.1 Overview
  5.21.2 API
5.22 mod-soft
  5.22.1 Overview
  5.22.2 API
5.23 shared-sdl
  5.23.1 Overview
  5.23.2 API
5.24 mod-caca
  5.24.1 Overview
  5.24.2 API
5.25 libglb
  5.25.1 Overview
  5.25.2 API
5.26 libgui
  5.26.1 Overview
  5.26.2 API
5.27 libhlp
  5.27.1 Overview
  5.27.2 API
5.28 libimg
  5.28.1 Overview
  5.28.2 API
5.29 libker
  5.29.1 Overview
  5.29.2 API
5.30 libldr
  5.30.1 Overview
  5.30.2 API
5.31 libmap
  5.31.1 Overview
  5.31.2 API
5.32 libmat
  5.32.1 Overview
  5.32.2 API
5.33 libmsg
  5.33.1 Overview
  5.33.2 API
5.34 libnet
  5.34.1 Overview
  5.34.2 API
5.35 libnod
  5.35.1 Overview
  5.35.2 API
5.36 libp2p
  5.36.1 Overview
  5.36.2 API
5.37 libpil
  5.37.1 Overview
  5.37.2 API
5.38 libscm
  5.38.1 Overview
  5.38.2 API
5.39 libsim
  5.39.1 Overview
  5.39.2 API
5.40 libsnd
  5.40.1 Overview
  5.40.2 API
5.41 mod-csound
  5.41.1 Overview
  5.41.2 API
5.42 mod-ogg
  5.42.1 Overview
  5.42.2 API
5.43 libsrv
  5.43.1 Overview
  5.43.2 API
5.44 mod-httpd
  5.44.1 Overview
  5.44.2 API
5.45 mod-tcpd
  5.45.1 Overview
  5.45.2 API
5.46 mod-udpd
  5.46.1 Overview
  5.46.2 API
5.47 libsys
  5.47.1 Overview
  5.47.2 API
5.48 libtsk
  5.48.1 Overview
  5.48.2 API
5.49 libvox
  5.49.1 Overview
  5.49.2 API
Appendix A Authors
Appendix B 2005 .plan
B.1 Complete rewrite
B.2 Technologies
  B.2.1 Script + standard C + assembly
  B.2.2 OpenGL
  B.2.3 CSound
B.3 Functionnalities
  B.3.1 Visual enhancements
  B.3.2 Rules enhancements
  B.3.3 Hey, you forgot my idea!!!
B.4 Road map
Appendix C Fanfic
C.1 The Battle of Emberlificoted
Appendix D Links
D.1 Official links
D.2 Other sites
D.3 Old stuff
Appendix E GNU GENERAL PUBLIC LICENSE
Appendix F GNU Free Documentation License
Appendix G Indexes
G.1 Concept index
G.2 Function and keyword index
G.3 Data types index
1 Introduction
**************

Read this chapter to discover Liquid War 6.

1.1 In a nutshell
=================

Liquid War 6 is a unique multiplayer wargame.  Your army is a blob of
liquid and you have to try and eat your opponents.  Rules are very
simple yet original, they have been invented by Thomas Colcombet.  It is
possible to play alone against the computer but the game is really
designed to be played with friends, on a single computer, on a LAN, or
on Internet.

   An older version, Liquid War 5 (http://www.ufoot.org/liquidwar/v5),
is available, but is not part of the GNU Project.  Only Liquid War 6 is
part of the GNU Project (http://www.gnu.org/), it is a complete rewrite.

   The official page of Liquid War 6 is
<http://www.gnu.org/software/liquidwar6/>.  For more information, you
can read the Wikipedia article (http://en.wikipedia.org/wiki/Liquid_War)
about Liquid War.

1.2 Project status
==================

1.2.1 What works, and what does not (yet)
-----------------------------------------

As of today, the game is in beta state.  It can be installed, and you
can toy arround with.  You can even play with.  It is still far from
being complete as some key features are still missing.

   What works:

   * The whole framework is here, some functions are not implemented
     yet, but the bases are set up, and they are believed solid.  The
     game is very modular, and is fully threaded.  It is designed so
     that graphics, sound, network and bot backends can be hacked at
     will.  It has a complete self-test suite, many debugging built-in
     tools, and is regularly checked with automated tools.  For
     instance, you can check reports concerning global references
     (http://www.ufoot.org/liquidwar/v6/doc/global/), code coverage
     (http://www.ufoot.org/liquidwar/v6/doc/coverage/) and cyclomatic
     complexity (http://www.ufoot.org/liquidwar/v6/doc/cyclo/).  This is
     not a quick hack.
   * Documentation.  Yes, you're reading it.
   * Version 0.0.7beta is playable.  Local game between humans (up to 4
     players) is possible.  Two bots are implemented, named random and
     stupid.  No great players but well, they move the cursor.  A new
     "deatchmatch" mode, different from LW5, is in place.
   * Liquid War 6 already has some features which are nowhere to be
     found in Liquid War 5, such as multiple layers.  It can be worth
     the upgrade.
   * Maps.  A number of interesting maps have already been designed
     (thanks to Kasper Hviid).
   * The game runs natively on GNU/Linux and has been ported to
     Microsoft Windows and Mac OS X. Binaries are available for all
     those platforms.  Use at your own risk.  If in doubt, get the
     source and compile.

   In the near future:
   * Network play.  Top-level priority.  Yes, network has been promised
     for months (years?  ...yes, years) and is still not there.  I said
     "when it's done".
   * Fix bugs ;) The current engine is somewhat buggy, fighters might
     loose the cursor, it clearly needs polishing.

   In the long run:
   * Write new graphical backends so that the game does not require Mesa
     or any OpenGL-like subsystem.  The idea is to get rid of the
     3D-accelerator dependency.
   * Implement all the fancy 3D features, make it possible to play
     Liquid War 6 on a Moebius ring.
   * Use the cool features of CSound to provide dynamic, contextualized
     sounds & musics.
   * Optimize the bot algorithm, which is probably a complex AI problem.

   You might be interested in checking the following URLs, which give a
view on opened tasks and bugs:

   * bug list: <http://savannah.gnu.org/bugs/?group=liquidwar6>
   * task list: <http://savannah.gnu.org/task/?group=liquidwar6>

1.2.2 What has changed since Liquid War 5.x?
--------------------------------------------

Liquid War 6 is a complete rewrite of Liquid War 5
(http://www.ufoot.org/liquidwar/v5).  The rewrite started in 2005.  So a
good question is "was the rewrite worth it?"...

   Here's a list of key improvements:
   * appearance, global rendering quality.  Call it the way you want,
     Liquid War 6 simply looks nicer than any previous release.  Period.
   * level features, including multi-layer (allowing the map designer to
     create bridges and tunnels), wrapping (fighters disappearing on the
     left can reappear on the right).  Those really change the gameplay.
   * deathmatch mode.  Give it a try, it's now the default mode, and
     definitely changes the rules.
   * team profiles, as well as special "weapons", which are tricks you
     can play on opponents.
   * modularity, overall code quality.  While this is not a user-visible
     change, the game is far less monolithic, therefore hacking to
     revamp the graphics engine, the algorithm, whatever, is easier.
     The situation has changed from "this is impossible to hack" to "OK,
     how much time can this take?".  So while one can't promise every
     idea will be implemented some day, at least many more things become
     possible with the new codebase.

   The most interesting change is still to come, and concerns network
games.

   Stay tuned.

1.2.3 Revision history
----------------------

Liquid War 6 releases are "codenamed" after famous, historical, real or
mythical characters.  Here is a short revision history.  For details,
see the 'ChangeLog' and 'NEWS' files distributed with the game.
Additionnally, there's an ever-increasing "stamp" number which is
incremented each time a build is done with a different source.  Latest
versions use the stamp as the revision number (the version 3rd number).

   * 2006-12-18 : 0.0.1beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.1beta/)
   * 2007-09-07 : 0.0.2beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.2beta/)
   * 2008-01-30 : 0.0.3beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.3beta/),
     codename "Napoleon", stamp 549
   * 2008-09-19 : 0.0.4beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.4beta/),
     codename "Clovis", stamp 756
   * 2008-12-20 : 0.0.5beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.5beta/),
     codename "Henri IV", stamp 1082
   * 2009-01-10 : 0.0.6beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.6beta/),
     codename "Cesar", stamp 1124
   * 2009-10-03 : 0.0.7beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.7beta/),
     codename "Geronimo", stamp 1465
   * 2010-07-05 : 0.0.8beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.8beta/),
     codename "Attila", stamp 1658
   * 2010-08-23 : 0.0.9beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.9beta/),
     codename "Chuck", stamp 2096
   * 2011-07-29 : 0.0.10beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.10beta/),
     codename "Gengis Kahn", stamp 2562
   * 2011-10-02 : 0.0.11beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.11beta/),
     codename "Ho Chi Minh", stamp 2785
   * 2011-12-18 : 0.0.12beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.12beta/),
     codename "Aguirre", stamp 2938
   * 2011-12-24 : 0.0.13beta
     (http://download.savannah.gnu.org/releases/liquidwar6/0.0.13beta/),
     codename "Blackbeard", stamp 2950
   * 2014-01-04 : 0.2.3551
     (http://download.savannah.gnu.org/releases/liquidwar6/0.2.3551/),
     codename "Davy Crockett"
   * 2014-03-26 : 0.4.3681
     (http://download.savannah.gnu.org/releases/liquidwar6/0.4.3681/),
     codename "Hannibal"
   * 2015-05-06 : 0.6.3902
     (http://download.savannah.gnu.org/releases/liquidwar6/0.6.3902/),
     codename "Goliath"

1.2.4 Road map
--------------

The game will probably be labelled "6.0.0" when network mode is up and
running.  Until then there will probably be other improvements
concerning gameplay and appearance ("eye candy").  There's a balance to
keep between the major goals such as "make that network thingy work" and
the very real fact that "hacking must be fun".

1.3 How you can help
====================

1.3.1 Help GNU
--------------

Please remember that development of Liquid War 6 is a volunteer effort,
and you can also contribute to its development.  For information about
contributing to the GNU Project, please read How to help GNU
(http://www.gnu.org/help/help.html).

1.3.2 Todo list
---------------

Here's a short list of todo items.  It is probably too early to start
hacking the core engine itself, for it is still under heavy development,
might undergo major rewrites, and it's hard for documentation to keep up
with the reality of the code.  However, there are still many things to
do.

   * Try the game.  Play.  Test.  Send bug reports.  Without bug
     reports, bugs don't get fixed.
   * Write maps.  Obviously, this is something which can perfectly be
     delegated.  Experience shows user-contributed maps are, on average,
     better than maps conceived by the author...
   * Translate texts.  Liquid War 6 uses GNU gettext, so all messages
     can be translated.
   * ...any help is welcome.

   Feel free to join the mailing-lists, this is clearly the best place
to start with.

   There's also a list of opened tasks on Savannah at
<http://savannah.gnu.org/task/?group=liquidwar6> which you can browse
online.  Maybe there's some task for you!

   Alternatively, you can contact Christian Mauduit
(mailto:ufoot@ufoot.org).

2 User's manual
***************

The Liquid War 6 user's manual hopefully contains any usefull
information to install the program and play the game.  If you just want
to enjoy Liquid War 6 without diving into map creation and programming,
this is just for you.

2.1 Mailing lists
=================

2.1.1 General discussion
------------------------

The main discussion list is <help-liquidwar6@gnu.org>
(mailto:help-liquidwar6@gnu.org), and is used to discuss all aspects of
Liquid War 6, including installation, development, game strategies, and
whatever subject players and hackers might want to talk about, provided
it is Liquid War 6 related.  If you don't know on which list to
subscribe, this is the one.

   To subscribe to it, please send an empty mail with a Subject: header
line of just "subscribe" to the '-request' list, that is
<help-liquidwar6-request@gnu.org>
(mailto:help-liquidwar6-request@gnu.org).

   You can also subscribe to the list using the Mailman web interface
for help-liquidwar6
(http://lists.gnu.org/mailman/listinfo/help-liquidwar6) and consult
help-liquidwar6 archives
(http://lists.gnu.org/archive/html/help-liquidwar6/).

2.1.2 Announcements
-------------------

Announcements about LiquidWar 6 are made on <info-liquidwar6@gnu.org>
(mailto:info-liquidwar6@gnu.org).  Subscribe to it to be informed of
major releases, and other significant news.

   To subscribe to it, please send an empty mail with a Subject: header
line of just "subscribe" to the '-request' list, that is
<info-liquidwar6-request@gnu.org>
(mailto:info-liquidwar6-request@gnu.org).

   You can also subscribe to the list using the Mailman web interface
for info-liquidwar6
(http://lists.gnu.org/mailman/listinfo/info-liquidwar6) and consult
info-liquidwar6 archives
(http://lists.gnu.org/archive/html/info-liquidwar6/).

   Please also consider reading the latest news on Savannah
(http://savannah.gnu.org/news/?group=liquidwar6).

2.1.3 Bugs
----------

There is also a special list used for reporting bugs,
<bug-liquidwar6@gnu.org> (mailto:bug-liquidwar6@gnu.org).  Please try
and describe the bug as precisely as possible.  The more accurate the
description, the more chances it will get to be fixed.

   While this is the standard GNU way of reporting bugs, modern SPAM
standards make it very hard to filter real bug reports from junk on this
list.  It is more convenient to use a web interface, the URL is:
<http://savannah.gnu.org/bugs/?func=additem&group=liquidwar6> and you're
really encouraged to use it instead of sending emails.

   Please take a look at the bug list
(http://savannah.gnu.org/bugs/?group=liquidwar6) before submitting new
bugs.

2.1.4 IRC channel
-----------------

IRC can be an interesting alternative to mailing-lists.  There's an open
channel dedicated to Liquid War on freenode.net, you can access it on
<irc://irc.freenode.net/liquidwar> that is, channel '#liquidwar' on
irc.freenode.net.

2.2 Getting the game
====================

2.2.1 Download source
---------------------

Liquid War 6 can be found on:
   * <http://ftp.gnu.org/gnu/liquidwar6/>
   * <http://download.savannah.gnu.org/releases/liquidwar6/>
   * <http://www.ufoot.org/download/liquidwar/v6/>

   Downloading the latest file from this place, and compile it yourself
on your computer with a classical './configure && make && make install'
is the recommended way to install Liquid War 6.

2.2.2 Download binaries
-----------------------

Some binary packages might be available.  Your mileage may vary.

   GNU/Linux based systems are supported, through Debian
(http://www.debian.org/) '.deb' and Red Hat (http://www.redhat.com/)
'RPM' packages.  There is also a Microsoft Windows installer.

   However these binaries are not necessarly available for every single
version of the game.

2.2.3 GIT repository
--------------------

Latest work in progress versions can be obtained with GIT
(http://git-scm.com/).  Here's the typicall command which will fetch the
latest version:

     git clone git://git.sv.gnu.org/liquidwar6.git

   If you are behing a firewall and can't use the native GIT protocol,
you can rely on the (slower) http protocol:

     git clone http://git.sv.gnu.org/r/liquidwar6.git

   You can browse the code online, consult log summary, and in a general
manner "follow" the project on
<http://git.savannah.gnu.org/gitweb/?p=liquidwar6.git> and
<http://git.savannah.gnu.org/cgit/liquidwar6.git>.

   Beware, git does not contain all the files included in the official
source tarball.  For instance, the './configure' script is not present.
You need to run :
     autoreconf
     ./configure
     make
     make install
   The 'autoreconf' call is really mandatory the first time, 'autoconf'
is not enough.  You will also need all the prerequisites needed to build
the docs, generally speaking, getting the source from git requires more
tools to build the package than picking a ready-to-use tarball.

2.2.4 Daily snapshots
---------------------

Alternatively, you can download daily snapshots on
<http://www.ufoot.org/liquidwar/v6/snapshots/> These files used to be
built every day, now they are generated by Jenkins
(http://jenkins-ci.org/) whenever there's a source change (commit).  A
simple 'make' is done before generating source tarballs however a 'make
distcheck' is performed before generating binaries, therefore sometimes
you can have the source but no associated tarballs.

   Beware of revision numbers, snapshots can make you believe version
X.Y is out when it's only a release candidate at best, and most of the
time just a work-in-progress.

   Still, if you want bleeding edge versions, this is the way to go.

   Documentation is automatically updated as well, and available on
<http://www.ufoot.org/liquidwar/v6/doc/>.

2.2.5 Check integrity
---------------------

Most binary packages (at least '.deb' and 'RPM' GNU/Linux binaries)
should be signed using GnuPG (http://www.gnupg.org/).  The following
keys are used when generating upstream/vendor packages:

   * 1024D/FD409E94 2002-01-31 Christian Mauduit (U-Foot)
     <ufoot@ufoot.org>
     -----BEGIN PGP PUBLIC KEY BLOCK-----
     Version: GnuPG v1.4.12 (GNU/Linux)

     mQGiBDxZRPIRBACxPI8ZYEtkIGUliwLanAlZbIqVCI38d/SONo8MS3VUZkO82XRo
     EAoj4KwX39fbUM3knpLK6SijzxKef/7Mw0w3W7lnQ/NegqSelTxiHmJxEQmeLulk
     drP89CpXQPdir8ediZseR9/BAroiWgckDJK8YgMKsmBCjE62xfPrtxM2nwCghH0X
     JAT/iD2uP0FdLpQGbM1dCnMD/jM3OcWIqQ1uGO8gp/lKTb7Kv7vEFQX0waLaIWOk
     KJ45kx4guYuT7u4dVg1Y01PCbtnWTYJ9t1SW6GHhpNsdGybrw8izRk6zXE5TYFtN
     9LN0kYYx5V+/Szjl4z5JabdEAt2OXZ9/N8Pb4PYInmG1jRr5fl78IO4SC1Gy03vK
     9rL7A/9iXSGnN77/aNJ2qN3btTagwdLv4AYbk0ySneIpzKT9nmnM6MYs+seOwYeS
     8e7i/SPISqblS5G10WZ4o/j5te0jotT7QFZdT3diO2NuUQXqqXIvRNxBGVKfX7Sg
     TqvjZWlXMNAvH5KiuZ8vqgfEMqLS0hwjpJNVaZIPF4cifFgPFbQsQ2hyaXN0aWFu
     IE1hdWR1aXQgKFUtRm9vdCkgPHVmb290QHVmb290Lm9yZz6IVwQTEQIAFwUCPFlE
     8gULBwoDBAMVAwIDFgIBAheAAAoJEN4/K839QJ6Uk+YAnRuBRpn/rdD/JZNGHz0w
     bJaVon9eAJ0YEdl0agCwJaWjKeZGWJl/f8TZqYhXBBMRAgAXBQI8WUTzBQsHCgME
     AxUDAgMWAgECF4AACgkQ3j8rzf1AnpS+kgCeNl528f7waryDPBnEGJ0FjevrdNMA
     oIDB+UCj1U65teCEbA3sEPyfkndFuQENBDxZRPUQBAD/PoWU0T2R4p0Fft5WQvCE
     RqFSk+QZl0YXZCtwW59/v3ai0xEYzv193kjhojHqcDifoeHbO7bkEU5ZrbtwDt33
     ++/LZ4JqCi8wBXH2I+2msau/92Vn+WGZZf1fFRYJiputKyQrDnd05q41FvPI3knP
     FBIMV/eKu0twqgGkLfHntwADBQP+PE4YN1NU01bScHiwkz62E5Xf/MwgOkBPFJ+D
     L1o18xaUaNwrHSaI+nJc04de6QzxNrVfDdREwdjIm+M7CkK+ru4agmECyE3Ek3YL
     76dFkE9geeOZTQ9A6MY9u/D1h+QHODg1r2sNfqoMnsFaNWOLXtivjjH4XWMN6Qze
     N9H8UUqIRgQYEQIABgUCPFlE9QAKCRDePyvN/UCelJT4AJ94wSFLzyLxZLT29cBW
     xybTpyt/jQCZAXEQi6LWVEo5jt/99FWRwDVNHK4=
     =fcJV
     -----END PGP PUBLIC KEY BLOCK-----

   * 2048R/406FFCAB 2013-07-12 Jenkins Daemon (Christian Mauduit)
     <jenkins@ufoot.org>
     -----BEGIN PGP PUBLIC KEY BLOCK-----
     Version: GnuPG v1.4.12 (GNU/Linux)

     mQGiBDxZRPIRBACxPI8ZYEtkIGUliwLanAlZbIqVCI38d/SONo8MS3VUZkO82XRo
     EAoj4KwX39fbUM3knpLK6SijzxKef/7Mw0w3W7lnQ/NegqSelTxiHmJxEQmeLulk
     drP89CpXQPdir8ediZseR9/BAroiWgckDJK8YgMKsmBCjE62xfPrtxM2nwCghH0X
     JAT/iD2uP0FdLpQGbM1dCnMD/jM3OcWIqQ1uGO8gp/lKTb7Kv7vEFQX0waLaIWOk
     KJ45kx4guYuT7u4dVg1Y01PCbtnWTYJ9t1SW6GHhpNsdGybrw8izRk6zXE5TYFtN
     9LN0kYYx5V+/Szjl4z5JabdEAt2OXZ9/N8Pb4PYInmG1jRr5fl78IO4SC1Gy03vK
     9rL7A/9iXSGnN77/aNJ2qN3btTagwdLv4AYbk0ySneIpzKT9nmnM6MYs+seOwYeS
     8e7i/SPISqblS5G10WZ4o/j5te0jotT7QFZdT3diO2NuUQXqqXIvRNxBGVKfX7Sg
     TqvjZWlXMNAvH5KiuZ8vqgfEMqLS0hwjpJNVaZIPF4cifFgPFbQsQ2hyaXN0aWFu
     IE1hdWR1aXQgKFUtRm9vdCkgPHVmb290QHVmb290Lm9yZz6IVwQTEQIAFwUCPFlE
     8gULBwoDBAMVAwIDFgIBAheAAAoJEN4/K839QJ6Uk+YAnRuBRpn/rdD/JZNGHz0w
     bJaVon9eAJ0YEdl0agCwJaWjKeZGWJl/f8TZqYhXBBMRAgAXBQI8WUTzBQsHCgME
     AxUDAgMWAgECF4AACgkQ3j8rzf1AnpS+kgCeNl528f7waryDPBnEGJ0FjevrdNMA
     oIDB+UCj1U65teCEbA3sEPyfkndFuQENBDxZRPUQBAD/PoWU0T2R4p0Fft5WQvCE
     RqFSk+QZl0YXZCtwW59/v3ai0xEYzv193kjhojHqcDifoeHbO7bkEU5ZrbtwDt33
     ++/LZ4JqCi8wBXH2I+2msau/92Vn+WGZZf1fFRYJiputKyQrDnd05q41FvPI3knP
     FBIMV/eKu0twqgGkLfHntwADBQP+PE4YN1NU01bScHiwkz62E5Xf/MwgOkBPFJ+D
     L1o18xaUaNwrHSaI+nJc04de6QzxNrVfDdREwdjIm+M7CkK+ru4agmECyE3Ek3YL
     76dFkE9geeOZTQ9A6MY9u/D1h+QHODg1r2sNfqoMnsFaNWOLXtivjjH4XWMN6Qze
     N9H8UUqIRgQYEQIABgUCPFlE9QAKCRDePyvN/UCelJT4AJ94wSFLzyLxZLT29cBW
     xybTpyt/jQCZAXEQi6LWVEo5jt/99FWRwDVNHK4=
     =fcJV
     -----END PGP PUBLIC KEY BLOCK-----

2.3 Installation
================

This section covers installation from source.  Other ways of installing
the program are not described here.

2.3.1 Requirements
------------------

All these libraries are mandatory to compile the game.  Liquid War 6
won't compile, let alone run, without them.  Some of them could probably
be replaced by equivalent tools, but this would certainly require a
programming effort and some changes in Liquid War 6 source code.

   * GCC (http://www.gnu.org/software/make/).  Liquid War 6 does require
     the GNU C Compiler to build, while other compilers might be able to
     build the game, this is untested.

   * Gomp (http://gcc.gnu.org/projects/gomp/).  Liquid War 6 uses OpenMP
     '#pragma' directives, this should help the game run faster on SMP
     systems.

   * GNU Make (http://www.gnu.org/software/make/).  Liquid War 6 might
     and certainly does use GNU Make extensions.

   * GNU C library (http://www.gnu.org/software/libc/).  Sounds obvious,
     but you need a standard C library.  It happens that glibc has some
     rather usefull extensions (yes, as of 2006, some vendors continue
     to offer C libraries without 'snprintf'...)  and Liquid War 6 might
     use them.  In a general manner, Liquid War 6 is part of and
     designed for GNU. You might however manage to compile it with
     limited libc support, this is the case with mingw32 for instance
     but, do it at your own risk.

   * Perl (http://www.perl.com/).  Some Makefile commands require Perl.
     You don't need any Perl devel packages, and you can probably use
     any Perl 5.x version, since no fancy recent feature of Perl is
     used.  Just plain Perl.

   * Guile (http://www.gnu.org/software/guile/).  Possibly the most
     required library, since Liquid War 6 is a scheme program which uses
     a set of functions coded in standard C. You need at least Guile
     1.8.

   * GNU MP (http://gmplib.org/).  GMP is a free library for arbitrary
     precision arithmetic, required by Guile.

   * libgc (https://launchpad.net/libgc).  This is a a garbage collector
     library, recent versions of Guile might require this so in case
     your version of Guile requires it, then Liquid War 6 will need it
     too.

   * ltdl (http://www.gnu.org/software/libtool/).  This library, which
     comes with libtool, provides a portable alternative to 'dlopen' and
     'dlclose'.  Check that you have a '/usr/include/ltdl.h' file, or
     install the corresponding package.

   * zlib (http://www.zlib.net/).  Required by other libraries, but can
     also be used directly by Liquid War 6 to compress network messages
     for instance.

   * expat (http://www.libexpat.org/).  Used to read and write XML
     files, which contain constants and configuration data.

   * libpng (http://www.libpng.org/pub/png/libpng.html).  Liquid War 6
     uses libpng to read levels (maps), not to speak of other optional
     libraries (SDL and the rest) who need it themselves.

   * libjpeg (http://www.ijg.org/).  Maps can also be provided as jpeg
     files, so libjpeg is required as well.

   * SQLite 3 (http://www.sqlite.org).  Used to handle the list of
     available servers.

2.3.2 Optional libraries
------------------------

While all these libraries are theorically optional (the game will
successfully compile without them), you'll obviously need, for instance,
one graphics backend.  Otherwise, you'll simply have no display.  This
is not acceptable.  As of today, one can reasonnably consider all
SDL-related libraries are required.  The rest is truely optional.

   * libcunit (http://cunit.sourceforge.net/).  Provides (hopefully)
     more readable test output.  It's not strictly mandatory but still
     highly recommended.  Building without is just allowed in case some
     rare and bizarre platform would not have a libcunit port.

   * ncurses (http://www.gnu.org/software/ncurses/).  Required by
     readline, needs to be there otherwise readline might not be
     detected properly on some systems.

   * GNU readline
     (http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html).  Used to
     handle input on the console.  Console is not absolutely mandatory,
     but it's a must-have if you want to hack the game.  Console
     unavailable does not mean you won't get anything on stdout but, the
     interactive script shell just won't work.

   * GTK+ (http://www.gtk.org/).  Used to display error/critical
     messages, so that users who launch the game by clicking on a icon
     (that is, not from the console) are still visually informed of
     important messages.

   * Mesa (http://www.mesa3d.org/).  This library provides an API
     similar to OpenGL and enables 2-D and 3-D drawing.

   * SDL (http://www.libsdl.org/).  SDL is used to set up a working
     OpenGL environnement, and handle input (mouse and keyboard).

   * SDL_image (http://www.libsdl.org/projects/SDL_image/).  This SDL
     extension is used to read textures and other graphics from disk.

   * FreeType 2 (http://freetype.sourceforge.net/).  This library is
     required by SDL_ttf, to draw fonts.

   * SDL_ttf (http://www.libsdl.org/projects/SDL_ttf/).  This SDL
     extension is used to draw fonts.  It is UTF-8 enabled.

   * libcaca (http://caca.zoy.org/).  This library transforms bitmaps
     into ascii-art images, allowing an alternative style of display,
     TTY compatible.

   * libcsound (http://www.csounds.com/).  While this tool is not used
     yet, it is meant to be the final sound backend, as CSounds offers
     great power to the composer, enabling truely dynamically generated
     sound & music.  For now Liquid War 6 tries to detect csound 4 but
     as the mainstream stable release is now 5 an update is needed.  It
     will probably be updated/fixed (Liquid War 6 using csounds 5) some
     day, for now you can safely *not* install csound on your system and
     enjoy all the possibilities of the game.

   * SDL_mixer (http://www.libsdl.org/projects/SDL_mixer/).  This SDL
     extension is used to allow dynamic mixing of sounds, and it also
     provides a builtin 'OGG/Vorbis' file renderer.

   * libcURL (http://curl.haxx.se/libcurl/).  Used to handle HTTP
     requests, the idea being not to re-invent the wheel but use a
     robust standards-compliant generic library.

2.3.3 Optional tools
--------------------

Those tools are used upstream to maintain the game, you normally do not
need them to build the game "as is" but if you modify the source code
and hack the game, you might be interested in installing them.

   * Perl 5 (http://www.perl.org/).  Liquid War 6 uses Perl for many
     tedious task, including, but not limited to, parsing documentation.

   * GNU Indent (http://www.gnu.org/software/indent/).  Code is
     regularly indented using the script 'src/indent.sh' which calls
     'indent' automatically and recursively on the whole source tree.

   * md5sum (GNU core utilities)
     (http://www.gnu.org/software/coreutils/) This is used to stamp the
     source code and help tracking exact build versions.

   * Doxygen (http://www.stack.nl/~dimitri/doxygen/).  Used to generate
     documentation concerning C structs, more precisely, include the
     struct members documentation into the official texinfo manual.

   * xsltproc (http://xmlsoft.org/XSLT/xsltproc2.htm).  Used to
     post-process Doxygen output and transform it to texinfo.

   * dot (http://www.graphviz.org/).  Used to generate Doxygen call
     graphs.

   * Google Performance Tools
     (http://code.google.com/p/google-perftools/).  This tool is
     convenient to optimize the program and find out what parts of it
     take most of the CPU power to execute.

   * lcov (http://ltp.sourceforge.net/coverage/lcov.php).  Gives nice
     output about code coverage.

   * GNU global (http://www.ufoot.org/liquidwar/v6/doc/global/).  Shows
     global references through the code.

   * pmccabe (http://parisc-linux.org/~bame/pmccabe/).  Cyclomatic
     complexity, shows what part of the code are bloated.

   * Valgrind (http://www.valgrind.org/).  Usefull to track down memory
     leaks and many other programming errors.

2.3.4 Installing requirements using RPM/DEB packages
----------------------------------------------------

You might find it convenient not to install all the requirements from
source, but use your favorite GNU/Linux distribution packages.

   On an RPM based GNU/Linux system, a typical command (tested with
Fedora (http://www.fedoraproject.org/) 15 "Lovelock") could be:

     yum install \
     make gcc glibc glibc-devel binutils \
     libgomp \
     guile guile-devel gmp gmp-devel libgc1c2 libgc-dev \
     libtool libtool-ltdl libtool-ltdl-devel \
     zlib zlib-devel expat expat-devel \
     libpng libpng-devel libjpeg libjpeg-devel \
     sqlite sqlite-devel \
     ncurses ncurses-devel readline readline-devel \
     libGL libGL-devel libGLU libGLU-devel \
     SDL SDL-devel SDL_image SDL_image-devel \
     SDL_mixer SDL_mixer-devel \
     freetype freetype-devel SDL_ttf SDL_ttf-devel \
     libcaca libcaca-devel \
     libcurl libcurl-devel \
     gtk2-devel \
     perl lcov global valgrind graphviz gv ImageMagick \
     texinfo-tex \
     indent emacs doxygen libxml \
     CUnit CUnit-devel \
     rpm-build

   On a DEB package based GNU/Linux system this command (tested with
Debian (http://www.debian.org/) 6.0 "squeeze") would be:

     apt-get install \
     make autoconf automake \
     gcc libc6 libc6-dev binutils \
     libgomp1 \
     guile-2.0 guile-2.0-dev guile-2.0-libs libgmp10 libgmp3-dev \
     libtool libltdl7 libltdl-dev \
     zlib1g zlib1g-dev libexpat1 libexpat1-dev \
     libpng12-0 libpng12-dev libjpeg8 libjpeg-dev \
     libsqlite3-0 libsqlite3-dev \
     libncurses5 libncurses5-dev libreadline6 libreadline6-dev \
     libgl1-mesa-glx libgl1-mesa-dri libgl1-mesa-dev libglu1-mesa libglu1-mesa-dev \
     libgles2-mesa libgles2-mesa-dev \
     libsdl1.2debian libsdl1.2-dev libsdl-image1.2 libsdl-image1.2-dev \
     libsdl-mixer1.2 libsdl-mixer1.2-dev \
     libfreetype6 libfreetype6-dev libsdl-ttf2.0-0 libsdl-ttf2.0-dev \
     libcaca0 caca-utils libcaca-dev \
     libcurl4-gnutls-dev \
     libgtk2.0-dev \
     perl lcov global valgrind graphviz gv imagemagick \
     texinfo texlive-base texlive-generic-extra \
     texlive-fonts-recommended texlive-latex-extra \
     indent emacs doxygen xsltproc pmccabe \
     libcunit1-ncurses libcunit1-ncurses-dev \
     google-perftools libgoogle-perftools-dev \
     git git2cl \
     zip nsis \
     debhelper devscripts

   Note that those requirements really depend on the exact distribution
you have, package names may vary from one to another.

2.3.5 Compiling
---------------

Liquid War 6 uses GNU Automake (http://www.gnu.org/software/automake/),
Autoconf (http://www.gnu.org/software/autoconf/) and GNU Libtool
(http://www.gnu.org/software/libtool/).

   Once all the requirements are installed, run:

     ./configure
     make
     make install

   Liquid War 6 supports the standard './configure --prefix=/my/path'
option (in fact, it supports much more than that) so you can install the
game in any directory.  You do not need to be 'root' to install Liquid
War 6.

2.4 Extra maps
==============

2.4.1 The extra maps package
----------------------------

The main package contains some maps so that you can try out the game.
Still, an additionnal package, called 'extra-maps' or
'liquidwar6-extra-maps' is available, containing more maps.  It really
does contain many of them, including most Liquid War 3 and Liquid War 5
legacy maps, plus new Liquid War 6 maps.

2.4.2 Install extra maps on GNU/Linux and POSIX systems
-------------------------------------------------------

On GNU/Linux systems (and possibly any POSIX unixish system) running:

     ./configure
     make
     make install

   will install the extra maps on your system automatically, they will
then be available in the 'extra/' sub-directory when browsing maps.

   The './configure' script has a '--enable-liquidwar6' switch which
will try and find automatically if there's an existing 'liquidwar6'
binary in the path.  If there's such a binary, it will run it and ask
for its 'map-path' and use this value automatically.

2.4.3 Raw install of extra maps (all-platforms)
-----------------------------------------------

Another solution, which works on all platforms including Microsoft
Windows and Mac OS X but also works on GNU/Linux, is to simply unpack
the 'extra-maps' package (unzip or untar) in your custom map directory,
or in the system map directory.  There's nothing else to do to install
these maps but simply put them on your hard drive in the right
directory.

   Typically on an Microsoft Windows system, you would unpack the extra
maps in 'C:\Program Files\Liquid War 6\map\' (system directory) and on a
Mac OS X system you would unpack the extra maps in 'Liquid War
6.app/Contents/Resources/map/' (system directory) or
'$HOME/Library/Application Support/Liquid War 6/map' (user directory).
On a GNU/Linux or POSIX system you would unpack them in
'$HOME/.liquidwar6/map/' (user directory).

   Next time you run the game, the maps should be browsable.

   If you can't see them, run 'liquidwar6 --audit' and check that the
place where you unpacked the files is actually searched by the binary.

2.5 Troubleshooting
===================

2.5.1 Compilation problems
--------------------------

A quick survival guide:

   * Check that you have all dependencies installed.  Also check their
     version number.  Double-check that you have devel packages
     installed, not only run-time binaries.
   * Read carefully the output of './configure'.  Running './configure >
     configure.log 2> configure.err' does help.
   * Editing '/etc/ld.so.conf' and running 'ldconfig' as 'root' can help
     if some dependencies are installed in exotic places.
   * Check the values of the environment variables 'CFLAGS', 'LDFLAGS'
     and 'LD_LIBRARY_PATH'.
   * Try './configure --enable-allinone', this will disable some fancy
     but somewhat complicated dynamic '.so' file support, it can help if
     shared libraries are handled differently on your system than on a
     plain GNU/Linux box.

   If none of these help, consider reporting a bug, or search the
mailing-lists for help.

2.5.2 Check installation
------------------------

Here's a check-list to ensure that your installation is correct:
   * What was the output of 'make install'?  'make check'?
   * Is the 'liquidwar6' binary in your 'PATH' environment variable?  It
     might be in '/usr/games'.
   * Run 'liquidwar6 --pedigree'.  Look at the output.  Check the
     compilation date & time, the version number.
   * Run 'liquidwar6 --audit'.  What do these paths look like?  Are they
     absolute paths?  Do they exist?  What's there?  Normally, once the
     game is installed, all of them should exist, and be populated with
     sub-directories and files.
   * Run 'liquidwar6 --modules', to know which modules where compiled.
     You need at least one graphical module, for instance 'mod-gl1',
     else the game won't run.
   * Run 'liquidwar6 --host', this displays informations about the host
     system the binary has been built for.

2.5.3 Problems running the game
-------------------------------

Now, game looks correctly installed, but you have problems running it.

   * Run the game from a terminal, not from a Gnome or KDE launcher, you
     need to see the console output.
   * In the '$HOME/.liquidwar6/' directory, you'll find some files, the
     main log file 'log.csv' and maybe 'dump.txt' or 'backtrace.txt'.
     They might contain valuable information, read them.  Note that
     while 'log.csv' is overwritten each time you start the game,
     'dump.txt' or 'backtrace.txt' are conserved until a new problem
     arises.  So check the date of these files to be sure you're
     analyzing the right ones.  Note that byt default on Microsoft
     Windows '$HOME/.liquidwar6/' is replaced by 'C:\Documents and
     Settings\<username>\Liquid War 6' and on Mac OS X it is in
     '/Users/<username>/Library/Application Support/Liquid War 6/'.
   * Run 'liquidwar6 --defaults'.  This will reset all options to
     defaults.  You might need to run this when upgrading from a version
     to another, since some options might appear, disappear, or defaults
     values can change.
   * Run 'liquidwar6 --test'.  This should run a complete test suite,
     many functions in the game will be tested automatically, and errors
     reported.
   * Run 'liquidwar6 --show-script-file'.  Are you really running the
     right code?
   * Game segfaults: try 'make uninstall && make clean && make && make
     install'.  Many problems can come from using a wrong shared module.
     You can also launch the game with the '--trap-errors=false' switch,
     this will disable the custom popup window and allow you to get the
     real error.
   * Game (still) segfaults: try 'gdb liquidwar6'.  Type 'run
     --trap-errors=false' and watch output.
   * The dynamic library loader can sometimes have problemes, and does
     not always report explicit messages on 'stdout' or 'stderr'.  You
     can change this by modifying some environment variables: 'export
     LD_DEBUG=all'.  This is very verbose but does help finding bugs.
   * Consider compiling the game using './configure --enable-valgrind'
     and then run it using Valgrind (http://valgrind.org/).
   * Try 'find / -type d -a -name "liquidwar6*" 2> /dev/null' to ensure
     you don't have an old version of Liquid War 6 somewhere else...

2.6 Quick start
===============

2.6.1 Quick start
-----------------

Once the game is installed, run it, click on 'Quick start' with the
mouse, and control the red ''a'' cursor with the mouse, or keyboard,
both work.  Try and surround the green team, it's a stupid bot, you
should win ;)

   You army is formed by all the red pixels on the screen, they should
try and rejoin the cursor (the blinking ''a'' letter) using the shortest
path.  When red and green meet, they fight.  Try it, toy arround.

   The 'Quick start' button will always make you play red against a
green stupid bot, whatever other options you have set up.

   Todo...

2.7 Strategy tips
=================

2.8 User interface
==================

2.8.1 A reduced set of keys
---------------------------

Liquid War 6 can be controlled using a reduced set of keys.  This is to
make the game more portable and allow possible ports to platforms where
a full keyboard is not available.  Depending on the graphics backend,
exact mapping might change, they should hopefully be obvious and
intuitive.

   Those keys are:
   * 'up' : the arrow up key
   * 'down' : the down arrow key
   * 'left' : the left arrow key
   * 'right' : the right arrow key
   * 'enter' : the enter / return key
   * 'esc' : the escape key
   * 'ctrl' : the control key
   * 'alt' : the alt / meta key
   * 'pgup' : the page up key
   * 'pgdown' : the page down key

   Basically,

2.8.2 Combining mouse, keyboard and joysticks
---------------------------------------------

It's also possible to control the game with the mouse only, or with a
joystick.  By default the interface will trap all events and respond on
any of these possible devices.

Keyboard       Mouse          Joystick       Menu action    In-game
                                                            
---------------------------------------------------------------------------
'up'           mouse          stick          previous       move cursor
               pointer                       menu item      up
                                                            
'down'         mouse          stick          next menu      move cursor
               pointer                       item           down
                                                            
'left'         mouse          stick          change menu    move cursor
               pointer                       item value     left
                                                            
'right'        mouse          stick          change menu    move cursor
               pointer                       item value     right
                                                            
'enter'        left-click     button A       validate       validate
                                             menu           chat line
                                                            
'esc'          right-click    button B       back to        quit game
                                             previous       
                                             menu
'ctrl'         right-click    button C       N/A            fire
               or                                           
               double-click
               on any
               button
'alt'          middle-click   button D       N/A            alternate
               or                                           fire
               triple-click                                 
               on any
               button
'pgup'         wheel up       button E       previous       zoom in
                                             menu item      
'pgdown'       wheel down     button F       next menu      zoom out
                                             item           

   A final word about joystick buttons: there's no such thing as
standard joystick buttons, some will come with 'A,B,C,D', others will
have 'A,B,start,select,L,R', there's no way to know.  By default, the
game will use the buttons with the lowest indexes (returned by your
driver) for the most usefull functions.  Validate menu entries is the
most usefull action, zooming in and out the one you can live without.

2.8.3 Quit with F10
-------------------

There's also an (almost) hardcoded shortcut which will quit the game
immediately, or at least as quickly as possible, without any prompt or
warning.

   It is the 'F10' key.

   Think of this feature as the procastinator's "whoops, here comes my
boss!!!"  emergency function.

2.9 Solo game
=============

2.9.1 Current state
-------------------

As of today, Liquid War 6 is essentially a solo game since network is
not working.  It allows you to toy arround in arcade mode on any map you
wish.

   A real solo mode with campaign and goals to reach is planned, how it
will be implemented is yet to be defined.

2.9.2 Team profiles
-------------------

By default, teams behave differently, some of them move more rapidly,
some are more aggressive but vulnerable, some are more defensive but do
not attack as strong as others.  This aspect of the game is under active
tuning, things might be unfair by now, you can toy arround with the
various 'team-profile-...' options, any report is appreciated.

   Note that this is very different from Liquid War 5, and can give very
different gaming experiences, you can artificially set up arbitrary
strong bots, for instance.

   Here's a description of the default color settings:

   * 'blue': has a strong attack but is slow

   * 'cyan': has an extremely good defense but is slow

   * 'green': has a better defense than the average

   * 'lightblue': has an extremely strong attack but is very slow

   * 'magenta': is extremely fast but also very vulnerable

   * 'orange': is fast, but has a very weak attack

   * 'pink': has a very strong attack, but is also very vulnerable

   * 'purple': has a very good defense but a weak attack

   * 'red': moves faster than the average

   * 'yellow': has a strong attack

2.9.3 Weapons
-------------

Additionnally, when profiles are used, each team has two weapons, a
primary weapon and an alternate one.  Think of weapons as special
(usually nasty) tricks you can play on your opponents.

   Here's a description of available weapons:

   * 'atomic': nuclear explosion, all fighters arround your cursor are
     about to die

   * 'attract': all fighters from all teams are packed near your cursor

   * 'berzerk': super-strong attack for a limited time, crush your
     enemies

   * 'control': you take the control of all other teams while your
     cursor stays in place

   * 'crazy': all your opponents go crazy for some time, acting with no
     logic

   * 'disappear': you disappear for some time from the battlefield, to
     reappear later, somewhere else

   * 'escape': fighters placed as far as possible from cursor, magically
     escape from any grip

   * 'fix': all other teams are freezed, you can move but not attack
     them

   * 'invincible': no damage for a limited time, move untouched

   * 'kamikaze': you die along with the strongest team on the
     battlefield, requires at least 3 teams

   * 'mix': fighters exchange position, their properties being preserved

   * 'permutation': will exchange colors, randomly, requires at least 3
     teams (double edged weapon)

   * 'plague': general disease, all fighters mysteriously loose health

   * 'reverse': fighters continue to move normally, but attacks are done
     in reverse mode, backwards

   * 'rewind': make the battlefield be like it was a few seconds ago

   * 'scatter': every fighters of every team scattered in random places

   * 'shrink': reduces the number of fighters on the map

   * 'steal': steals some fighters to other teams

   * 'teleport': fighters placed as close as possible to cursor

   * 'turbo': move faster for a limited time

   Note that this is in progress, some of them are NOT IMPLEMENTED YET.

2.10 Network games
==================

2.10.1 Choose your "public url"
-------------------------------

Liquid War 6 needs to name your "node" (you can think as your server
instance of the game) and have a unique URL (address) to publish and
give to other nodes.

   If only one network adapter is attached to your computer and your
address IP is 'A.B.C.D' then by default the game will pick automatically
the address 'http://A.B.C.D:8056/' and it should work flawlessly.

   Problems can arise if you have a peculiar network configuration, if
you have multiple non-loopback network interfaces, if you use NAT to
protect yourself from intruders and/or if your context forces you to do
so.  In that case, Liquid War won't be able to guess a correct URL
automatically.  So you need to set it up manually either by editing the
'public-url' entry in the config file, changing environment variable
'LW6_PUBLIC_URL' or passing the '--public-url=http://<host>:<port>/'
argument when running the game.  Typically, if you are behind a firewall
which does NAT, use the firewall address.  The right address is the
address which, given to remote hosts, will allow them to connect on your
game instance.

2.10.2 Starting a node
----------------------

A node is started automatically when you run the game.  Even if you
don't start to play, node starts in the background and exchanges data
with other nodes, mostly to discover them and maintain its internal map
of existing nodes and games.

   So even without starting a network game, you should be able to point
a web browser on your node and see a web page describing it.  Your node
address is displayed on 'stdout' (console) when starting the game.  If
in doubt, try <http://localhost:8056/> which should work unless you
modified defaults settings.

   When you start a network game, the program simply changes your node
state from "idle" to "accepting connections".

2.10.3 Connecting to a node
---------------------------

The interface should show you the list of available nodes, just pick one
and try and connect to it.

   Note that once you're connected on a remote node, you're still acting
as an independant node, and other nodes might connect to your node as
well as to the other nodes.  In short, there's no real server or client,
everyone is a client for someone, and can act as a server.

   Nodes connected together form a "community", which can disband,
accept new nodes, and in a general manner has its own immaterial life,
the first node which created the game might disappear, game can continue
without it.

   This is why the main network module is called 'libp2p', this is a
reference to the term "peer to peer".

2.10.4 Communities
------------------

Once a node is connected to another one, they've started a "community".
Formally, a stand-alone node accepting for connection is already a
community, even if it has only one member, but the only really
interesting communities are those formed with several nodes.

   A community can't be reached through a given server, to connect to
one you just need to connect on one of its member nodes.  All nodes are
equivalent, there's no master, no root node, nodes collaborate to share
the same real-time information and maintaine an up-to-date game state.

   Of course, conflicts can arise, and in that case nodes need to agree
on an acceptable solution.  Normally, the program takes decisions
automatically (for instance, it could decide to "kick" a node out of the
community) so the player does not have to care about this, but this is
expected to be one of the most tricky (and passionating) part of Liquid
War 6 hacking.

2.10.5 Firewall settings
------------------------

By default, Liquid War 6 will communicate on port 8056, in both TCP and
UDP, and in both ways too (in/out).  It's possible to play with partial
connectivity, in extreme case, you can even play without direct internet
access, using only a mere web proxy.

   However, things will go faster and be much easier if the program can
use its default native protocol.

   Here's an example of a typicall iptables (http://www.netfilter.org/)
configuration which allows you to play the game full-featured.  It's
assumed that by default all packets are dropped, this configuration will
just open the necessary ports.

     # outgoing TCP on port 8056 (liquidwar6)
     iptables -A OUTPUT -p tcp --dport 8056 -m state --state NEW,ESTABLISHED -j ACCEPT
     iptables -A INPUT -p tcp --sport 8056 -m state --state ESTABLISHED -j ACCEPT
     # incoming TCP on port 8056 (liquidwar6)
     iptables -A INPUT -p tcp --dport 8056 -m state --state NEW,ESTABLISHED -j ACCEPT
     iptables -A OUTPUT -p tcp --sport 8056 -m state --state ESTABLISHED -j ACCEPT
     # outgoing UDP on port 8056 (liquidwar6)
     iptables -A OUTPUT -p udp --dport 8056 --sport 1024:65535 -j ACCEPT
     iptables -A INPUT -p udp --sport 8056 --dport 1024:65535 -j ACCEPT
     # incoming UDP on port 8056 (liquidwar6)
     iptables -A INPUT -p udp --dport 8056 --sport 1024:65535 -j ACCEPT
     iptables -A OUTPUT -p udp --sport 8056 --dport 1024:65535 -j ACCEPT

   If you can't change firewall settings and only have access to the web
through a web proxy, it can still be possible to play (with some
restrictions such as your node not being seen by others) if 'mod-http'
is available.  This in turn depends on wether libcurl
(http://curl.haxx.se/) support was activated when compiling the game.
To use the proxy, you can set the 'http_proxy' environment variable.
For detailed informations, please refer to libcurl doccumentation
(http://curl.haxx.se/docs/).

2.10.6 Is the game secure?
--------------------------

As stated in the license, the program comes with NO WARRANTY. Period.

   However, an important effort has been made so that it can reasonnably
be used online, exposed to various "common" attacks.

   As far as security is concerned, there are two different issues:
   * vulnerability to general security attacks, people typically trying
     to gain prililedged access on your computer, relying on a security
     flaw in the program.  A good firewall is a must-have, as you can
     never know for sure a program has no bugs.  Running Liquid War 6 as
     an unpriviledged user (certainly not "root") is also a good
     practice.
   * vulnerability to players "cheating" and sending malicious
     informations to fake their moves, scores, and/or modify
     informations concerning other players.  This is a very important
     point in Liquid War 6 since it has a multi-channel way of
     exchanging data (think of the web interface, you have no garantee
     of who the client is).

   Here's a list of various steps which have been taken to make the
program more secure:

   * a '--skip-network' option is here if you really do not want to be
     bothered by networking risks;
   * program has basic password support so that you can deny access to
     unknown players;
   * passwords are never sent in clear text over the network, only a
     hash (checksum) is sent;
   * no use of well-known buffer overflow friendly functions like
     'strcpy', equivalents such as 'strncpy' are used;
   * program never trusts what comes from network peers, when it wants
     to know something, it checks it out by itself, for instance, the
     node list is systematically verified by the local node before being
     used and/or published;
   * the built-in web server is not a general purpose web server which
     will end up revealing some of your private files, it can only serve
     game-related pages;
   * the very fact that the game has no central server makes it hard to
     attack it, because if someone wants to play "Oscar" annoying
     "Alice" and "Bob" he well need to fool all the nodes participating
     in a game, sending wrong informations to a single node won't have
     much effect.

   This being said, Liquid War 6 does not use any strong encryption
library to protect the data it sends.  All the checksum machinery might
be vulnerable to a brute-force and/or strong cryptographic attack, so in
theory it's possible to fool the program.

   In practise, if you want real privacy, play over a VPN (Virtual
Private Network).

2.11 Graphics
=============

2.11.1 Standard, high and low resolution
----------------------------------------

Liquid War 6 will try and pick up a default resolution when the game is
launched the first time.  It won't use your maximum screen resolution
but will instead list all available fullscreen modes, and pick up one
which is usually something like two thirds of the highest mode.  This is
to allow switching back and forth between fullscreen and windowed mode
using the same settings.  This automatically picked-up resolution really
depends on your hardware and driver.  It is called "standard" in the
graphics options menu.

   Then it is possible to automatically select the minimum and maximum
resolution your hardware allows in fullscreen mode.  These are called
"low" and "high" in the graphics options menu.  Just click on the button
that display the resolution, it will change and use the next setting.
In windowed mode, the game won't accept the highest available mode but
will instead use a percentage of it, defined by the
'--windowed-mode-limit' parameter.

   You might still be in a case where this is not enough.  For instance
your maximum resolution is 1600x1200, Liquid War 6 picks a default mode
of 1280x960 for you but for some reason you want to play in 800x600,
fullscreen.  In this case, simply switch to windowed mode, resize the
window with the mouse (the resolution button will show you the current
resolution) and just choose a resolution near 800x600.  It does not even
need to be exactly 800x600, 798x603 would probably fit.  Then when
switching back to fullscreen, you'll be in 800x600, the game will
automatically pick up the fullscreen mode which is closest to the
current windowed mode resolution.

2.11.2 Display rate
-------------------

By default the game will try and run at 60 frames per second.  Given the
nature of Liquid War 6, this is probably enough.  Higher values will
maybe give a slightly smoother display, but barely noticeable.

   You can activate the display of frames per seconds (aka "fps")
through the menu ("options -> system") or with the command line
("-display-fps").

   On a single processor system, reducing the number of frames per
second might allow the rest of the game run faster.  So if you notice
the game is really slow, in terms of "fighters move slowly" then you
might be happy reducing the display rate and therefore giving power back
to the other parts of the program.  On a dual-core (or more) or on a
multi-processor system, this is probably useless since the game is
threaded and has a dedicated thread for display purposes.  The command
line option to reduce the number of frames per second is '--target-fps'.

   Additionnally, the parameter '--gfx-cpu-usage' allows you to force
the display thread to "take a rest" and go idle for some time.  This is
advanced settings, most users won't touch this.

2.12 Sound & music
==================

2.12.1 Current status
---------------------

As of today, the game is capable of playing Ogg Vorbis
(http://www.vorbis.com/) audio files.  That's it.

2.12.2 The future
-----------------

In the long run, what is planned is to support Csound
(http://www.csounds.com/) which would allow very cool effects, such as
dynamically changing the music while the game is running, typically
following the action.  If there's a lot of fight, the music could
reflect this.

   For now this is only vaporware, just a nice idea among others,
nothing implmented yet.

2.13 Config file
================

The config file is a simple XML file.  It uses XML only to benefit
standard parsing tools, but it's not a structured XML file, in the sense
that the tree is so simple that all items are at the same level.  It is
just a simple key-value binding.

   This file is in '$HOME/.liquidwar6/config.xml' on GNU/Linux and POSIX
systems, in 'C:\Documents and Settings\<username>\Liquid War
6\config.xml' on Microsoft Windows and in
'/Users/<username>/Library/Application Support/Liquid War 6/config.xml'
on Mac OS X.

   You're free to edit it manually, but all parameters are changeable
with command line options.  The program will overwrite this file each
time it exits, so if you put comments in it, they will disappear.  The
advantage of this is that if you mispell something, or if for some
reason the game does not understand a value, then when rewriting the
file, it will show you it just did not get it.

   The file embeds the documentation for all its entries, it is
therefore rather verbose.  The documentation is the same you will find
online or by quering the game with the '--about' option, also the same
you would get reading this manual.

2.14 Logs
=========

Liquid War 6 uses 'stdout' to output important messages, and 'stderr' to
log warnings and errors.  It will also use syslog
(http://en.wikipedia.org/wiki/Syslog) if available.

   Additionnally, a verbose log is available in
'$HOME/.liquidwar6/log.csv' on GNU/Linux and POSIX systems, in
'C:\Documents and Settings\<username>\Liquid War 6\log.csv' on Microsoft
Windows and in '/Users/<username>/Library/Application Support/Liquid War
6/log.csv' on Mac OS X.

   You can read this using any spreadsheet software capable of reading
csv file.  It uses the tab ('\t') character as a separator.  It contains
valuable informations including version and most default values for the
game, and for each line logged, it says where in the code the log
function was called.  A must-have for debugging.

2.15 Report bugs
================

There are two ways to report bugs:

   * send a mail to <bug-liquidwar6@gnu.org>
     (mailto:bug-liquidwar6@gnu.org);
   * use the web-based Savannah bug tracker:
     <http://savannah.gnu.org/bugs/?func=additem&group=liquidwar6>.

   The latter (Savannah (http://savannah.gnu.org)) is much preferred,
because the mailing-list is bloated with spam...  It also offers a list
of bugs (http://savannah.gnu.org/bugs/?group=liquidwar6) which you
should read before submitting a new one.

3 Hacker's guide
****************

This hacker's guide is for anyone who is curious about the game, and
wants to know how it works.  It covers many aspects from simple map
creation to technical program internals.  A great effort has been done
in Liquid War 6 so that it should be much more hackable than previous
versions.  Any feedback is welcome.

3.1 Designing levels
====================

3.1.1 Why is level design so important?
---------------------------------------

As of Liquid War 5 (http://www.ufoot.org/liquidwar/v5), most levels have
been contributed by players.  While the maintainer of Liquid War 6 has
technical knowledge to develop the game, artistic talent and taste might
not be his domain of excellence 8-)

   Therefore contribution are truely welcomed when they take the form of
a new, original, fun and good looking level.  It's believed the levels
often make the game much more than its engine.  This is true for any
type of game, and Liquid War is no exception.

   So this section is here to help players understand how to hack
existing levels, and create new ones, in the hope that 1) they can enjoy
their own creations and 2) possibly share their work with others.

   Note that this manual might refer to levels and maps: they are just
two different names to describe the very same thing.  It's an alias.

3.1.2 Format overview
---------------------

Liquid War 6 stores level information in a plain directory.

   There is no such thing as an opaque '.dat' binary file.  The name of
the level is the name of the directory itself, and its elements are the
files contained in it.

   Files must follow a precise naming scheme.  For instance Liquid War 6
expects a 'map.png' file to be present in each map directory.

   All image files in a level use the Portable Network Graphics
(http://www.w3.org/Graphics/PNG/) or JPEG (http://www.jpeg.org/) format.
It is possible that in the long term, Liquid War 6 will be able to
handle levels as '.tar.gz' or '.zip' files.  In that case these files
will only be a compressed image of the actual level directory.

   See the './map/' directory of the source Liquid War 6 distribution to
see example of maps.

3.1.3 Resolution (map size)
---------------------------

Liquid War 6 does enforce a limit on map size.  This is not to frustrate
map designers and/or players, simply, it would be a lie to pretend the
game can handle arbitrary big maps.

   They might look great on your computer but will become unplayable
soon on an older machine.  And most of the time they don't look that
great, carefully crafted 1280×720 just looks awesome and can represent
a great level complexity.

   Here are the technical limits:

Type               Max width          Max height         Max surface
                                                         
----------------------------------------------------------------------------
Texture            3 000              2 000              6 000 000
                                                         
Logical map        1 500              1 000              1 000 000
                                                         

   The texture can be somewhat bigger than the logical map, this allows
for pretty levels while limiting the horsepower needed to move the
fighters and animate everything.  Note that you could technically feed
the game with a 'map.png' that is bigger than the logical map limit,
only it will be downscaled when being loaded.

   The texture limits are generous enough to accept a full-HD 1920x1080
image, or a 4/3 1600x1200 image, while the "one million pixels" logical
map limit is enough to store a 16/9 1280x720 map or a 4/3 1024x768.

   Keep in mind that the logical map ('map.png') will probably be scaled
whatsoever, even if it's within the absolute limits (the game adapts the
resolution to your computer speed) and your texture will rarely appear
in its native resolution, will probably be distorted, and so on.

3.1.4 Metadata
--------------

Older versions of Liquid War 6 used to load a plain 'README' file and
use this as metadata.  Title was take from map directory name.  This is
still supported, but it now also supports the addition of a
'metadata.xml' file in which you can describe your map.

   The following files can be defined:

   * 'title': map title, what will appear in the menus
   * 'author': map author
   * 'description': description of the map, to help players when
     browsing folders
   * 'license': map license (short version, just a simple one-liner,
     don't use lenghtly copyright notices here, the 'README' file would
     be the file to put long legal sections)

3.1.5 map.png
-------------

This is the only required file in a level.

   In fact, the existence of 'map.png' makes a directory a level.  When
checking wether a directory is a correct level, Liquid War 6 simply
tests the existence and validity of 'map.png'.

   This image is a simple black & white area, where white zones are the
background, the sea, the places where fighters can move, and black zones
are the foreground, the walls, the places where fighters can't go.

   This informations can be stored in a 2-color indexed file, or in a
grayscaled or even truecolor RGB file, but color information won't be
used.  Internally, Liquid War 6 will read the color of every point.  If
it is over 127 on a 0 to 255 scale, it will be considered as background,
if it is below 127, it will be considered as foreground.

3.1.6 layer2.png ... layer7.png
-------------------------------

Liquid War 6 can handle mutiple layer maps.  Think of a pile of maps,
one being on top of the other.  This allows you to create a volume, the
game considers every layer has two axis x and y, and the z axis is to
travel through layers.  First layer corresponds to z=0, second layer to
z=1, and so on.

   Here are the files you can use to define layers:
   * 'map.png' this one is on top, it's always defined (z=0)
   * 'layer2.png' (z=1)
   * 'layer3.png' (z=2)
   * 'layer4.png' (z=3)
   * 'layer5.png' (z=4)
   * 'layer6.png' (z=5)
   * 'layer7.png' (z=6)

   A 'layerX.png' file should be designed exactly like 'map.png'.  In
fact, 'map.png' could simply have been called 'layer1.png'.

   Up to 6 extra layers can be defined (from 'layer2.png' to
'layer7.png').  This is a hardcoded limit.  It allows you to define 7
different layers, including the top 'map.png' layer.  Keep in mind this
layer system is not real 3D, it's more a "2D and a half" model.  Adding
layers can considerably slow down the game, so it's wise to try and use
as few layers as possible.  Technically, 3 layers will allow you to
build bridges and tunnels, which is probably the most usefull
construction using layers.  Fighters can also have difficulties
navigating through layers so piling up layers in narrow "vertical"
z-axis based tunnels is probably not a great idea.

   The 'ufoot/concept/pass' map of the 'liquidwar6-extra-maps'
demonstrates basic layer usage.

3.1.7 texture.png, texture.jpeg and texture-alpha.jpeg
------------------------------------------------------

It is possible to define a texture for the map by putting a
'texture.png' or 'texture.jpeg' file.  It does not need to have the same
dimensions as the map itself.  Indeed, textures can be much more precise
than the actual logical map.

   There's no theorical limit on how big a texture can be, more
precisely, it can be much bigger than any hardware/driver maximum
texture size.  In practice, a too big texture will waste your video card
RAM, and slow everything down.  Sizes ranging from 640x480 to 1600x1200
are reasonable texture sizes.

   If you don't define this, the 'map.png' file will be used as the
texture, and also import colors from 'style.xml' if defined.

   Note that the shape of the texture defines the shape of the map, that
is, the ratio with which it will appear on the screen.

   The PNG alpha layer will be used for transparency.  But to save disk
space, it can be convienient to prefer the JPEG format, use
'texture.jpeg' instead of 'texture.png' and store the alpha layer in a
separated file, called 'texture-alpha.jpeg'.  This avoids handling heavy
PNG files, PNG compression not being performant on most textures.

   In 'texture-alpha.jpeg', black is considered opaque, and white is
transparent.  Different levels of gray correspond to different levels of
opacity.  Previous versions of the game used the other way of doing
things (black is transparent) because this is technically, the most
obvious way to do things.  Black is 0 and transparent is 0.  But for a
human "reader" of the map this does not make sense.  One generally
expects white to be the equivalent of "undrawn" or "blank", well, if
it's undecided, void, transparent, whatever, it's white.  When the Gimp
(http://www.gimp.org/) flattens an image, it becomes white, not black.

   So white is transparent.  Period.

3.1.8 glue.png and boost.png
----------------------------

If there's a 'glue.png' or 'boost.png' file in the map directory (you
can use one of them or both) then they will be interpreted as follow:

   * on areas where 'glue.png' and 'boost.png' are white, nothing
     special happens, fighters follow their default behavior
   * on areas where 'glue.png' is black, fighters will be slowed down.
     How slowish they will be depends on the 'glue-power' parameter.  If
     'glue-power' is 3 then fighters will move three times slower.
   * on areas where 'boost.png' is black, fighters will behave faster.
     How fast they will be depends on the 'boost-power' parameter.  If
     'boost-power' is 2 then fighters will move two times faster.
   * on areas where 'glue.png' or 'boost.png' are gray, they will be
     slowed down less or speeded up less depending on how dark the grey
     is.

   There can be, at the same place, some gray or black in both
'boost.png' and 'glue.png'.  How this will behave exactly is not really
clear at this stage, the recommendation is not to do this (it does not
really make sense anyway) but if you do it, game won't complain.

   It's also wise not to abuse of 'boost.png' for obviously, a map
filled with "boosted" zones at a X10 pace will require much more CPU
than the same map with no such setting.  This might fool the automatic
resampling algorithm and lead to maps that are unplayable.  The spirit
of 'boost.png' is just to make a few spots go faster.

   It's also important to note that behaving faster or slower means
moving faster or slower but also attacking faster or slower, and, in a
general manner doing any action with a different pace.

3.1.9 danger.png and medicine.png
---------------------------------

If there's a 'danger.png' or 'medicine.png' file in the map directory
(you can use one of them or both) then they will be interpreted as
follow:

   * on areas where 'danger.png' and 'medicine.png' are white, nothing
     special happens, fighters follow their default behavior
   * on areas where 'danger.png' is black, fighters die automatically,
     that is, they become black and loose health.  How dangerous these
     zones are depends on the 'danger-power' parameter.
   * on areas where 'medicine.png' is black, fighters regenerate faster,
     they become bright and shiny as if auto-healing.  How efficient
     this medicine is depends on the 'medicine-power' parameter.
   * on areas where 'danger.png' or 'medicine.png' are gray, well, it's
     in between, the "danger" and "medicine" effect will be proportional
     to the level of gray.

   There can be, at the same place, some gray or black in both
'medicine.png' and 'danger.png'.  How this will behave exactly is not
really clear at this stage, the recommendation is not to do this (it
does not really make sense anyway) but if you do it, game won't
complain.

3.1.10 one-way-<direction>.png
------------------------------

The four files:

   * 'one-way-north.png' (AKA "up")
   * 'one-way-east.png' (AKA "right")
   * 'one-way-south.png' (AKA "down")
   * 'one-way-west.png' (AKA "left")

   can be used to force the fighters to go in one given direction, on
some parts of the map.  If an area is black on one of this meta-layers,
then fighters will go in the given direction.  For instance, a black
zone in 'one-way-north' will make fighters go to the north (AKA "up"
direction) regardless of the cursor position.  The fact that this is a
one-way path is understood by fighters and they will take this in
account when choosing the shortest path to go somewhere.  You can
combine vertical and horizontal one-way informations, making diagonal
one-way paths.

3.1.11 cursor.png and cursor-color.png
--------------------------------------

By default, a simple cursor will be displayed, but you can use a custom
per-map cursor.  Cursors are defined by two 64x64 bitmaps:

   * 'cursor.png' is a PNG file, very likely to use transparency, which
     will be default be colorized according to the map colors.  You can
     draw it any color, only greyscale informations will be used.  You
     can keep the original colors if you really want to by setting
     'colorize-cursor' to false, but the default is to ignore the hue.
   * 'cursor-color.png' is another PNG file, very likely to use
     transparency too, which will always be colorized, replacing white
     by the team color, and black by the "dead" color, which by default
     is black and is usually a dark color.  This colorization is a way
     to recognize your cursor and know which team it belongs to.

   You can define only one of those bitmaps, if doing so, then the other
layer will be empty, and won't be filled with the default cursor data.
Note that additionnally, a little letter (single character) will be
displayed using the team color, so that's yet another way to identify
which teams the cursor belongs too.  The PNG files really need to be PNG
(JPEG won't work) and need to be 64x64, any other size will be ignored.

3.1.12 rules.xml
----------------

Whereas 'style.xml' is only about the appearance of the map, 'rules.xml'
allows the map designer to change pretty much any parameter.

   Ultimately, the player can still ignore these settings and overide
them with its own values, but the idea is: most game options are only
pertinent in a given context.  For instance, on some maps it's
interesting to move slowly, on some other it's interesting to move fast.
Some maps might be playable packed with fighters everywhere, some other
might be much more fun with almost nobody on them.

   The approach in Liquid War 5 (http://www.ufoot.org/liquidwar/v5) was
to make the options available, but let the player himself find the right
settings for the right map.  The consequence is that no one ever used
all those cryptic options in the advanced options menu, and probably 99%
of the players ended up playing with default settings.  This is not that
bad, but given the fact that changing a few parameters one can totally
transform the gameplay, it has decided been that in Liquid War 6, the
map designer suggests the right options that matches his map.

   This does not prevent the player from toying with options himself, he
can still do it.

   There's also one important point to note: all these options are
technically implemented as integer parameters.  We certainly do not want
any float here, since, and it is a Liquid War specific behavior, the
game must be 100,00% predictable and behave the same on every platform.
As there is nothing like exactness when speaking of floats, those are
forbidden here.  As for strings, we are dealing here with low-level
internals, and this section is not about telling a story.  They are
technical options only.  Booleans are implemented with the usual 'false
= 0' and 'true = 1' convention.  Note that other config files in Liquid
War 6 might rely on floats, strings, and booleans with conventionnal
'true' and 'false' values, but not this one.  'rules.xml' is special.

   This 'rules.xml' file is a direct image of the internal "rules"
structure, so it contains technical, sometimes not very user-friendly
parameters.  While hacking 'rules.xml' directly is a good way to test
things, most of the time, the other file 'hints.xml' contains more
high-level informations that do the job the right way.  A typicall
example is speed.

   *Note rules.xml reference: Map rules.xml.

3.1.13 hints.xml
----------------

This parameter is only used by the map loader.  The map itself contains
none of these parameters, they are only clues (hints, in fact..)  on
"how to load the map" which are passed to the loader.

   Let's take an example : speed.  This 'rules.xml' file has a (rather)
easy to use "speed" parameter, which will do all the job of finding the
right resolution for your map, the right "rounds-per-sec" and
"moves-per-round" parameters, in short, it will set many other
parameters to fit your needs.

   As far as the map designer is concerned, 'rules.xml' and 'hints.xml'
could have been merged (but so would have 'style.xml') but internally
they are very different: 'rules.xml' contains the real parameters, the
one used by the algorithm whereas 'hints.xml' contains only instructions
which are used once when loading the map and then disappear.  The core
algorithm has no idea of what was in 'hints.xml', once it's loaded.

   *Note hints.xml reference: Map hints.xml.

3.1.14 style.xml
----------------

This is a simple XML file defining various appearance parameters.  It
has absolutely no effect on gameplay.  These settings can ultimately be
overriden by the player, but the idea is that if the map designer thinks
this level looks better with this or that option, let him say it in this
file.

   *Note style.xml reference: Map style.xml.

3.1.15 teams.xml
----------------

In this file one can specify per-map team settings.  In short, this is
where you can say how many bots you want, which color, and so on.  This
can be on a per-map basis, so that each map has different customized
settings, some maps might be fun with only one bot, some other maps
might be fun packed with 8 opponents.

   Technically, 'teams.xml' will allow you to define up to 4 players and
9 bots.  This is an awfull lot considering there are only 10 colors.
Basically, it's OK to simply define:
   * 2 players ('player1' and 'player2')
   * 4 bots ('bot1' and 'bot2')
   It might also be a clever idea to just set up 'player2' and 'bot1'
being the same color, in case of a conflict the game will pick up
another color, but in practice those two entries often correspond to
"the second player, bot or human, coming on the battlefield".

   All in all, this represents 5 entries to set up (main player, other
player or first bot which can be the same, then 3 more bots), it's OK to
have the rest undefined or set to defaults.

   Note that this can also simply be unset, and in that case the game
defaults will apply, and the user will be able to change them, whereas
if you set these up, the player will somewhat force to used the map
settings.

   *Note teams.xml reference: Map teams.xml.

3.1.16 Resampling
-----------------

This is a very important point.  Liquid War almost *always* resamples
maps, unless you ask it not to do it.  This is not recommended, it is
believed in the general case, letting the internal algorithm make its
own decisions is better than trying to figure out oneself "which is the
best resolution".

   The reason is, the right resolution (we're talking here of the
logical resolution, how many fighters wide is the battlefield) often
depends on the speed and general ressources the of the computer the
program is running on.  The map designer does not have this information.
The program does.  It runs a bench at startup.  So this way it can
choose, at runtime, the resolution which fits best.

   The recommended way of doing things is not to try to be too picky
about 'rules.xml' parameters related to speed and also let the default
map size limits in 'hints.xml' to their defaults.  Do not use them
unless debugging stuff.  Then the program will resample the map so that
the player can play on it at a reasonnable speed.  If map is too big,
and it's often the case, then it will downsize it until there are
sufficiently few fighters so that the CPU can handle the job.  This, of
course, is not rocket science.  The bench calculation is a somewhat
brute-force approach of doing things.  Formally, we would have to run
the map for good to figure out what is the right speed.  Still, this
bench gives good approximations.

   Previous versions of the game relied heavily on 'fighter-scale' to
resample maps, but this is not the case anymore.  The 'fighter-scale' is
now a minor parameter which is used to upsize maps if they are too
small.  In 99.9% of the cases, the map is first upsized by
'fighter-scale' for this parameter is by default set low (1.0) then
downsized by 'bench-value' for real-life personnal computers can't
handle 1600x1200 maps in real-time.  Not yet.

   There are a bazillion options to control map size, including
'min-map-surface'.  They are here because it's important that,
ultimately, people can do whatever they want with the game.  But for map
design, this is another story.  Don't use them.  Rely on 'bench-value'
and just care about game speed.  This is achieved by changing the
"speed" parameter.

3.1.17 Music
------------

It is possible to store your own custom music file within the map
directory.  You can call it whatever you want (you can keep its original
name, which is something music authors usually appreciate, even if
there's no strong "attribution" clause on the license, it can be
considered fair use not to fiddle to much with the name) you just have
to place it in the same directory than the other files like 'map.png' or
'texture.jpeg'.

   The following formats are known to work with the default SDL_mixer
(http://www.libsdl.org/projects/SDL_mixer/) based 'mod_ogg' backend:
   * 'ogg' (Ogg Vorbis (http://www.vorbis.com/) files)
   * 'wav'
   * 'midi' (extensions '.mid' and '.midi' should both work)
   * 'mod', 's3m' and 'xm' files, AKA "modules".

   To be more precise, here's how things work:
   * step 1: the game tries to find the file 'music-file' (parameter
     taken from 'style.xml' or defined/overriden by player) in the
     current map directory; step 2: if not found, it will try every path
     in 'music-path' to find this file.  This includes the "system"
     music directory with musics that ship with the game, but also the
     './music' subfolder in the user directory; step 3: if still not
     found, it will try to play a random file, relying on 'music-filter'
     to ignore some files.

3.1.18 Experience ("exp")
-------------------------

In 'rules.xml' you can set a special parameter which is 'exp' and allows
you to tell "a player can't load this map if he doesn't have at least
'N' at his/her 'exp' rating".  Gaining 'exp' (stands for "experience")
isn't hard, you just need to win a level with 'exp=N' to gain 'exp=N+1'.

   By default, the player's 'exp' is 0 and levels default to 1, so this
means only levels with 'exp' set explicitely to 0 in 'rules.xml' might
be used.  Then player wins that level and is given access to all maps by
default, unless these are explicitely set with 'exp' greater than 1.

   In solo game, when a player wins a level, he's automatically
redirected to the map which is in the same directory and has exactly the
'exp' he just gain.  For instance, if you win a map with 'exp=5' then
you're chained to the first map (in alphabetical order) which has
'exp=6'.  By setting up the 'exp' parameter the right way, with a map
for each 'exp' level one can transform a simple map directory in a
scenario that player will automatically follow.

   Last, but not least, the game, at startup, only allows you to play
red, green, blue and yellow.  Other colors are unlocked as you progress
among levels.  Same things with weapons, there are "liberated"
continuously through the game.

   This mechanics allows the following behavior:
   * when game is launched first, only a small subset of maps are
     accessible
   * after you win one map (sort of quite easy) you gain access to the
     next level, plus many of the maps of the 'extra' package.
   * after each map you win, you're redirected to the next map, and
     regularly, you gain access to new colors/weapons

   As a final word, yes, it's possible to cheat, fool the exp system,
but it's believed this is moot and lame.

3.2 Translating
===============

3.2.1 Using gettext
-------------------

Liquid War 6 uses GNU gettext (http://www.gnu.org/software/gettext/) for
all its messages.  There's an online manual
(http://www.gnu.org/software/gettext/manual/gettext.html) about this
tool.  In practice, what you have to do as a translator is to edit the
'po/xx.po' file with 'xx' being your language / country code.  For
instance, to translate the game in French, one needs to edit 'po/fr.po'.

3.2.2 Formatted strings
-----------------------

This is very important, you might already be aware of it if you are
familiar with gettext, but still it's worth mentionning : when a string
contains special characters such as '%d' or '%s' (in a general manner,
anything with a '%' it's important that all translations contain exactly
the same number of '%d's and '%s's than the original.

   For instance:

     "foo has %d bars (%s)"

   can be translated to:

     "ziblug zdonc %d zuc - %s - tac"

   The number, order and type of '%' entries is preserved.  To learn
more about these formats, use 'info printf' or 'man 3 printf'.  In a
general manner, get informations about printf
(http://en.wikipedia.org/wiki/Printf).

   Additionnally, some strings are used by Scheme (Guile) code and not
by C code.  Thus, they don't use the standard C/printf convention.  In
these strings, what you must preserve and be aware of is the tilde
character '~'.  Very often you'll see '~a' in a string.  As with the
printf '%', you must preserve the number, order and type of those.
There is a complete online reference
(http://www.gnu.org/software/guile/manual/html_node/Formatted-Output.html)
about this way of formatting strings.

3.2.3 Partial translation
-------------------------

Liquid War 6 has thousands and thousands of messages which could
theorically be translated.  In practise it's counter-productive to spend
time to translate those, as the game is still evolving constantly, and
as most of these messages are technical messages which inform about rare
bugs and strange conditions.  All sort of informations which, while
valuable, are not intented for end-users and are more destinated to be
reported in bug reports.  To select only the interesting messages to
translate, the current gettext configuration only uses a reduced set of
files.

   * 'src/scriptpo.c' : the most important file.  It contains the
     definitions used by all the Guile code, this is where you'll find
     all the menu labels.
   * 'src/lib/sys/sys-log.c' : log messages and keywords.  These are not
     the log messages themselves, it only concerns the log engine.  One
     can for instance replace 'WARNING' by 'ATTENTION'.
   * 'src/lib/hlp/hlp-credits.c' : the credits, which are displayed at
     game startup in the splash screen.
   * 'src/lib/lw6-print.c' : contains some messages printed on the
     console.

   As a side note, the file 'src/lib/hlp/hlp-reference.c' contains all
the entries for the various configuration options, anything that can be
queried by 'liquidwar6 --about=<keyword>'.  This is several hundred
messages.  It might be interesting to translate them some day, but it's
obviously not a priority today.

3.3 Architecture
================

3.3.1 C + Guile
---------------

Technically, Liquid War 6 is a collection of C functions which are
exported to Guile.  The main binary embeds a Guile interpreter, which
will run a Guile script.  This script calls the exported C functions,
and glues them together.

   It should be possible to implement the game without using Guile at
all, using C code to make the various modules communicate together.
This might seem an easier way to go, not involving several languages.
However, using this script level is a good way to achieve several
important goals:

   * it's possible, at any time, to query the game about its internal
     state, dump objects, take actions.  That's what the console is
     about.  It's a bit like having an embedded debugger, it's really a
     very convenient tool to develop, make experiments and track
     problems.
   * many hacks can be done without recompiling anything at all.  Simply
     edit a few files with an editor, and your patch is running.  Once
     the binary base is set up, hacking scripts on top of it is (almost)
     a piece of cake.
   * forcing the program to use scripts to transfer informations from a
     module to another is a good way to avoid "spaghetti" code, when
     modules cross-use each other in an uncontrollable way.  Of course
     in some cases, modules communicate directly, especially when
     performance is important.  But for many tasks, it's just very
     comfortable and safe to have module A send orders to module B
     through a high-level script API.

   Having Guile to implement high-level stuff also decreases, to some
extent, the need for object-oriented features of C++.  The big picture
is : low level code that require speed, optimized data processing, is
written in C. Code which is more high level and requires abstraction is
written in scheme.

3.3.2 Threading and SMP
-----------------------

Liquid War 6 makes a heavy usage of threads.  Early versions of the game
did not have this feature but starting with 0.0.7beta, one can really
consider the game is heavily threaded.

   There's basically:
   * a thread to handle the main control flow.  This thread runs scheme
     code which Guile.  It's not the most CPU-greedy thread, but when
     it's stalled, there's no more interaction between the user and the
     program.
   * a thread to handle the display.  Depending on rendering options,
     this thread can consume lots of CPU cycle.  On a single
     processor/core system, it can be interesting to lower rendering
     options in order to gain speed on other aspects of the game.  On a
     quad-core system, it's probably useless, just play with all bells
     and whistles activated.
   * two threads to run the core algorithm.  One maintains the so-called
     reference state, the other being dedicated to the draft sate.  In a
     local game there's no draft state so only one of those two threads
     is used.  There's even a technical optimization which can be turned
     on and can theorically use even more threads and be efficient on
     very big maps but well, it's rather untested and still has to prove
     its real efficiency.
   * a thread to handle map loading.  This one is not active all the
     time, it's just here to keep a preemptive interface while loading
     complex maps.
   * network code can also fire threads, especially when connecting on
     remote systems.

   So globally, if you have an SMP system, the game will be happy with
it.  It will also run on a single processor, as the program uses POSIX
pthreads it's capable to run on any computer which has pthreads
implemented for it.

   But, and this is a strong limitation, without pthreads, the game
won't run.  At all.  Or at least, not unless it's almost completely
rewritten.

3.3.3 Internal libraries
------------------------

The C code is splitted into several internal libraries.  This allow
independant testing of various game modules.

   The main module, the most important one, is 'libker', (stands for
"kernel").  This is were the core algorithm is.  To some extent, the
rest of the code is just about how to provide this module with the right
data and environment.  Logically, if you profle the game, you should
find out that a great part of the CPU time is spent here.  Code here is
about spreading gradients, moving fighters and cursors.

   The 'libmap' module is here to handle maps, it contains the code to
manipulate maps in memory.  But it does not know how to load them from
disk.  This is the responsability of another module, 'libldr', which is
linked against libraries such as libpng
(http://www.libpng.org/pub/png/libpng.html) or libjpeg
(http://www.ijg.org/) and does the job of transforming those standard
formats into a usable in-memory structure.  The 'libgen' module also
works the same way, creating pseudo-random maps.  There's still a
another moduled involved in map handling, it's 'libtsk', whose job is to
load a level in the background.  It has a 2-steps asynchronous loading
system which allows the game to load maps while the user interface is
still responsive, and give a preview of the map as soon as possible,
when loading continues in the background, building optimizing structures
which are usefull when playing but not mandatory just to show the map.

   At the other end of the algorithm-chain, the 'libpil' module will
"pilot" things.  It's this module which will translate text readable
orders (typically adapted for network usage) into function calls.  It
has event lists, keeps them in the right order, and will also
permanently maintain three different states of the game.  A backup state
which can be used any time to go back in time and get the game in a
stable 100% sure state.  A reference state which is correct but ever
changing.  Basically backup plus all the orders received between backup
and reference gives reference.  And finally a draft state which is as up
to date as possible but might be wrong.  This is typically interesting
in network game, where we want to show something moving, something fast,
even if there's lag on the network and other computers fail to send
information in time.  In this case we display draft while still keeping
reference and updating it when we finally receive valid informations.
Backup would be used to send bootstrap information when people are
joining a new game, or to check up if things are going right.

   A special 'libbot' module is here to handle bot algorithms.  A bot is
just a simple 'move' function which takes a game state as an input, and
returns an 'x,y' position, just the way a mouse handler would.  How
complex a bot is "under the hood" depends on the type of bot.  Current
bots are really basic.  Additionnally, 'libsim' will run dummy fight
simulations to find out wether some team has a real advantage on another
one, speaking of team profiles depending on colors.

   The 'libgfx' module handles all the graphics stuff.  It is itself
splitted in several sub-modules, that is, it does not do anything but
load a module such as 'mod-gl1' which will actually contain the
implementation.  In an object-oriented language, it would be an abstract
class, an inteface.  The implementation does not need to be thread-safe.
It's better if it is, for theorically it could be possible to fire
Liquid War 6 with two display backends running at the same time on the
same game instance, but this code has yet to be written, and it's a rare
dual headed configuration which probably has no real-life usage.  If
only one graphics backend is activated at a time, the rest of the
implementation garantees there will never be two concurrent calls to a
function is this module.  It is the 'libdsp' ("display") which handles
this.  It fires a thread for rendering purposes, and sends information
to this thread, detecting automatically if it's necessary to acquire a
mutex and update rendering informations.  For the caller, this is
transparent, one just has to call an update function from time to time.
The module will even perform "dirty-reads" on a game state being
calculated, to render things in real time, as soon as possible.

   An experimental 'libvox' module is under design/development and
might, in the future, provide a real-time voxel renderer.  Still
pre-alpha stage.

   To ease up the implementation of different graphics backends, a
'libgui' module contains code which is meant to be used by any graphics
backend.  It's just a factorisation module, containing common code and
interfaces, related to displaying things.  This is where, for instance,
one can find a high level menu object.  In the same spirit, 'libmat'
contains generic math, vector and matrix code, which is commonly used in
3D interfaces.

   The 'libsnd' module handles sound.  It's also an abstract class, an
interface, which uses dynamic backends as implementations.

   The 'libnet' module is a wrapper over different network APIs, it
handles Winsock and POSIX sockets in a uniform manner.  The 'libcli' and
'libsrv' contain network client and server code, implementing the
various protocols in dynamically loadable sub-modules.  It's the role of
'libp2p' to glue this together, handle the list of available servers,
the message queue, verifying nobody is cheating, and so on.  All this
modules share information about current game state using code &
structures defined in 'libnod',use message utilities (format, parse)
defined in 'libmsg' and share code concerning connections in 'libcnx'.
Additionnally, 'libdat' provides facilities to store old network
messages and sort them.

   The 'libsys' module contains most system and convenience functions,
it handles logs, type conversions, timer, memory allocation, it's the
fundamental module every other module depends on.  It has a compation
'libglb' module with all the Gnulib
(http://www.gnu.org/software/gnulib/) shared code.

   The 'libhlp' is used to handle keywords and internal
self-documentation (this is what is used by '--list' and '--about'),
'libcfg' knows how to read and save config files, 'libcns' handles the
console, and 'libdyn' can load '.so' shared files dynamically.

   To glue all this, there are some Guile bindings with helper functions
available in 'libscm' which fills two needs, one being an easy way to
check if Guile linking is working correctly without requiring all other
modules to be available, and also performing automatic checks on some
actions such as registering or executing a function.

   Finally there are small modules like 'libimg' (to make screenshots of
the game) which have been separated because they required special
libraries to link with and/or did not really fit in existing modules for
dependencies reasons.

   So well, this is a lot of modules.  The list might move a bit, but
the big picture is here.  Each module is testable separately.

   Below is a Graphviz (http://www.graphviz.org/) diagram, which shows
the modules dependencies.

3.4 Memory structures
=====================

The most important memory structures in Liquid War 6 are:

   * map ('lw6map_level_t') : this contain the map immutable
     informations.  This is what resides in memory after a map has been
     loaded from the disk.  It contains all the various '.png' and
     '.jpeg' files stored as pixel arrays, resampled if need, and also
     contains the various map attributes.  Once this structure is ready,
     the game is capable of displaying the map on the screen, but it can
     not do anything with it yet.
   * game_struct ('lw6ker_game_struct_t') : this one contains the same
     informations as the previous structure, only the information has
     been post-treated so that it's ready for use by the core algorithm.
     It will, for instance, contain the famous mesh structure, which
     groups squares by packets of 1, 4, 16, 64 or more.  The reason it's
     been separated from the level is that operations such as creating
     the mesh might require a lot of time.  So to allow players to see
     the level while black magic is still running in the background, it
     was required to make a difference between what is required to view
     the map ("level") and what is required to play on it
     ("game_struct").
   * game_state ('lw6ker_game_state_t') : contains all the variable,
     ever changing game data.  This is where the position of fighters is
     stored, their health, and such things.  It is designed to be
     synchronizable by using mostly simple calls to 'memcpy'.  It
     heavily relies on the previous structures, the idea is that one can
     have several "game_state" plugged on a single "game_struct".

   All these structures are defined in the 'ker/ker.h' header.

3.5 100% predictable algorithm
==============================

The core Liquid War 6 algorithm is 100% predictable, that is to say,
given the same input, it will produce the same results, on any computer.
Previous versions of the game also had this property.  This is very
important for network games, since in a network only informations such
as "cursor A is at position x,y" are transmitted.  Every node maintains
its own internal game state, so it's very important that every node
comes with the same output given the same input.

   For this reason Liquid War 6 never uses floating point numbers for
its core algorithm, it uses fixed point numbers instead.  It also never
relies on a real "random" function but fakes random behavior by using
predictable pseudo-random sources, implementation independant, such as
checksums, or modulos.

   There are also some optimizations which are not possible because of
the predictability requirement, for instance one can not spread a
gradient and move the fighters in concurrent threads, or move fighters
from different teams in different threads.

   If you read the code, you'll find lots of checksums here and there, a
global checksum not being enough for you never know where the problem
happened.  The test suite uses those facilities to garantee that the
game will run the same on any platform.

   Not being able to rely on a predictable algorithm would require to
send whole game states on the network, and this is certainly way too
much data to transmit.  A moderate 200x200 map has a memory footprint of
possibly several megabytes, so serializing this and sending it to
multiple computers at a fast-paced rate is very hard, if possible at
all, even with a high bandwidth.  We're talking about Internet play
here.

3.6 Graphics backends
=====================

3.6.1 Modularity
----------------

Liquid War 6 has a modular architecture which allows the programmer (and
the player) to plug pretty much any rendering/graphics backend, provided
this one is...  developped.

   As of 2009 the only available backend was 'mod-gl1', it would display
the game using 3D acceleration, if available, through the SDL
(http://www.libsdl.org/) library, using its GL bindings.

   As of 2012, other backends are begin developped, the idea is that
each backend can provide the user with enough visual feedback to play,
and convey input informations to the core engine.

   The rest of the game is exactly the same, this means playing with
'mod-gl1' you can do exactly the same things than with 'mod-caca'.

3.6.2 List of backends
----------------------

   * mod-gl1

     Liquid War 6 has a modular architecture which allows the programmer
     (and the player) to plug pretty much any rendering/graphics
     backend, provided this one is...  developped.

     As of 2009 the only available backend is still 'mod-gl1', it will
     display the game using 3D acceleration, if available, through the
     SDL (http://www.libsdl.org/) library, using its GL bindings.

     Additionnally, versions available for Microsoft Windows and Mac OS
     X will probably never any other backends available.  For technical
     reasons, those platforms do not have the flexibility of GNU/Linux
     and do not allow graphical libraries to be loaded dynamically.  In
     practice, both of them require hacks that override the standard
     'main' function.  Microsoft Windows has its 'WinMain' instead, and
     Mac OS X is even more pedantic, requiring graphical functions to be
     executed in the main thread.  So 'mod-gl1' is just linked
     statically in those versions, and the modularity of the game is
     purely theorical on these platforms.

     This 'mod-gl1' module is really one of the key stones of Liquid War
     6, and if you want to change graphical things, it's definitely the
     place to hack on.  The source is in 'src/lib/gfx/mod-gl1'.

     The 'mod-gl1' backend requires "moderate" hardware, but it still
     does require hardware acceleration.  Pure software rendering
     through mesa (http://www.mesa3d.org/) for instance, won't be
     enough.

     So if you're running Xorg on GNU/Linux and there's a DRI driver for
     your card, the game should run fine.

     On the programmer side, the counterpart is that one should not rely
     on fancy OpenGL features.  Textures have a maximum size of 512x512
     for instance.  Of course some maps are bigger than this but this
     means that internally, 'mod-gl1' splits them into smaller tiles,
     and displays those tiles one by one.

     Inside the 'mod-gl1' backend, the 'src/lib/gfx/mod-gl1/gl-utils'
     directory contains lots of common structures, factorized functions
     which can (and should, if appliable) be used.

   * mod-gles2

     This is under development, the idea is to provide an alternative
     renderer based on OpenGL ES 2, which could be used on standard
     computers but also on mobile platforms.

     Work in progress, don't hold your breath.

   * mod-soft

     This is under development, the idea is to provide a very basic
     rendered which can be compiled pretty much anywhere as long as SDL
     is available, since it does use software rendering only.

     Work in progress, don't hold your breath.

   * mod-caca

     This is under heavy development, the idea is to provide a basic yet
     surprising alternative text-based renderer, using libcaca.

3.6.3 How to write a new backend
--------------------------------

The starting point for any hack are the files 'src/lib/gfx/gfx.h'.  This
is where the API is defined.

   Basically, the type 'lw6gfx_backend_t' contains all the required
callbacks.  You must provide an implementation for each function.

   Let's take an example, taken from 'mod-gl1'.  When calling
'lw6gfx_get_video_mode' and passing it a first argument which is a valid
'mod-gl1' backend, the function 'mod_gl1_utils_get_video_mode' will be
called.  How this is done is a little C casting wizardry.

   To understand how this works, read the files:

   * 'src/lib/gfx/gfx-api.c': contains all the functions which are part
     of the API and can be called elsewhere in the code.
   * 'src/lib/gfx/gfx-register.c': contains the code that allows a
     module to be loaded/unloaded at runtime.  Will act differently if
     the games is compile with the '--allinone' flag, but for the caller
     this is transparent, just create and destroy backend, period.
   * 'src/lib/gfx/mod-gl1/mod-gl1-backend.c': this is where the module
     actually binds its internal functions with the callbacks defined in
     the 'lw6gfx_backend_s' struct.  None of these internal functions
     should be called directly, code in 'libdsp' for instance should
     only refer to the 'lw6gfx_...' bindings.  Reading the code in
     'src/lib/gfx/gfx-test.c' shows how these functions can be called,
     and in which order.

   All the functions should be defined, but some of them are obviously
more important.  The two most critical functions are:

   * 'pump_events' This is used to process inputs.  The function should
     update a 'lw6gui_input_s' struct and return it to the caller.  How
     this done is really up to the backend, it happens that all SDL
     based backends ('mod-gl1', 'mod-gles2' and 'mod-soft') share the
     same code for this, but another backend could do this differently,
     there's no real need to use SDL.

     Only, the returned input should behave correctly when queried with
     function from 'libgui'.  As a consequence, one needs to have a look
     at 'libgui' to understand how input works.  A look at
     'src/lib/gfx/shared-sdl/shared-sdl-event.c' is a good example of
     this, as this file contains the implementation for SDL-based input.

     *Note libgfx reference: libgfx.  *Note libgui reference: libgui.

   * 'display' By far the most complicated function, this one is called
     on each display loop to render the game.  It's always used in the
     same thread, so need not be reentrant, and on some platforms (eg
     Mac OS X) it will even be called in the main thread (this can be of
     some importance regarding some libraries such as SDL).

     Still, beware, the 'game_state' object it uses can change on the
     fly while rendering.  In that case "changing" means that fighters
     can move and gradients be updated but the global structure won't
     change.  So any pointer on a fighter will still be valid after it's
     been obtained, but the renderer should not expect the game to be
     static.  In practice this is not really a problem.  If you are
     curious, you can look in 'libdsp' how and when this function is
     called.

     A very important parameter is 'mask', depending on its value, the
     backend should, or not, display the menu, or the map, or both, etc.
     The reference for this are the 'LW6GUI_DISPLAY_...' constants in
     'src/lib/gui/gui.h'.

     As a starting point, implementing menu display before anything else
     is probably the best bet, since without menus it's hard to do
     anything within the game.

     To test out a backend, one can either launch the full game using
     the "under development" backend, or launch the test suite by typing
     './liquidwar6gfx-test 1' in './src/lib/gfx'.

     *Note libdsp reference: libdsp.

3.7 Core algorithm
==================

3.7.1 Introduction
------------------

Since Liquid War 3 (http://ufoot.org/liquidwar/v5/techinfo/algorithm)
the algorithm to power Liquid War is pretty much unchanged, at least,
there has been no revolution, the basic principles remain the same.
This has been explained in Liquid War 5 doc
(http://ufoot.org/liquidwar/v5/techinfo/algorithm), but is repeated
here, along with the specific Liquid War 6 stuff.

   The very important things to remember are:
   * The algorithm is 100.00% predictable.  This means given the same
     input, it will give exactly the same output.  This is very
     important for the network games to work correctly, therefore, the
     algorithm does not ever use any call to 'rand' / 'random'
     functions, it also does not use any float value either, since
     different type of processors/contexts might give slightly different
     results because of rounding problems.
   * It's a two-pass algorithm, the first step is to calculate the
     distance from any point of the map to the closest cursor.  This
     step is always imperfect, the shortest path is never really found,
     the naive approach is to consider that if a place on the map is at
     distance 'N' of the cursor, then in the worst case, all adjacent
     places are at distance 'N+1'.  As of Liquid War 6, the
     corresponding code is in 'src/lib/ker/ker-spread.c'.  The second
     step is to move the fighters, make them act.  In Liquid War 6, the
     corresponding code is in 'src/lib/ker/ker-move.c'.  One can have a
     look at the code source for the function
     'lw6ker_game_state_do_round' in 'src/lib/ker/ker-gamestate.c' to
     see how these are called.

3.7.2 Level, game struct, game state and pilot
----------------------------------------------

Most of the algorithm code has something to do with the following types
(which are structs):

   * 'lw6map_level_t' defined in which is used to store the level data.
   * 'lw6ker_game_struct_t' defined in 'src/lib/map/map.h' which is used
     to store the memory data required by the algorithm, but which are
     immutable.  There's a difference between those data and the ones
     stored in the level struct.  For instance, those data are "private"
     since 'lw6ker_game_struct_t' is opaque, while everything is
     'lw6map_level_t' is "public".  Also, data in 'lw6ker_game_struct_t'
     might be highly redundant for performance issues and is optimized
     for speed while data in 'lw6map_level_t' is just plain data and
     won't change if the algorithm is updated.
   * 'lw6ker_game_state_t' defined in 'src/lib/ker/ker.h' which is used
     to store the level data required by the algorithm, and which
     changes during the game.  This is typically where an information
     such as "there's a red fighter in slot (3,23,1)" will be stored.
   * 'lw6pil_pilot_t' defined in 'src/lib/pil/pil.h' which is used to
     handle all the threading issues.  It keeps a track of 3 game
     states.  A "reference" state which is the state of the game
     considering all input has been received from the network, and is
     validated.  A "draft" state which might be anticipated and updated
     "as if the players we did not get input from did not move there
     cursors".  This can give the illusion that the game is running
     smoothly while in reality input from other players on the network
     is choppy.  In a local game, "draft" and "reference" are
     equivalent, since there's no doubt about what's on the network.
     And finally, a "backup" state which can be pulled in case of a
     serious flaw and is a good way to solve the "hey, someone untrusted
     is throwing garbage on the net".  One can always pull a backup.

   Most of the time, hacking on the algorithm, changing the gameplay,
does not require to touch anything but the code in 'src/lib/ker'.

   See *Note libmap::.  See *Note libker::.  See *Note libpil::.

3.7.3 Getting informations about where fighters are
---------------------------------------------------

One of the key functions is 'lw6ker_game_state_get_fighter_id', which
will return the id of a fighter at a given position.  Then its companion
function 'lw6ker_game_state_get_fighter_by_id' can be called, it will
return a 'lw6ker_fighter_t', which contains the real data.

   The type 'lw6ker_fighter_t' is not opaque and can be freely accessed
by the caller, which, typically, is a graphics backend trying to display
informations.  Try and grep for the string
"lw6ker_game_state_get_fighter_id" withing the 'src/lib/gfx' source tree
for examples.

   One thing that is very important when hacking on 'libker': you should
always leave the 'lw6ker_game_state_t' struct in a state that is
compatible with a correct usage of public "getters" in
'src/lib/ker/ker.h'.  The reason is that this code can be executed by
separate threads, more precisely, in "dirty read" mode, the rendering
thread will try and display a "game state" while this very "game state"
is being updated by another thread.

3.8 Compilation tips
====================

3.8.1 Advanced ./configure options
----------------------------------

In addition to all the common Autoconf
(http://www.gnu.org/software/autoconf/) switches such as '--prefix',
Liquid War 6 has some custom switches:

   * '--disable-console': allows you to turn on/off console support.
     Normally this is detected automatically but in case you really want
     to disable it on platforms which support it, you can.  This will
     cause the program no to link against 'libreadline', among other
     things.
   * '--disable-gtk': allows you to turn on/off gtk support.  Normally
     this is detected automatically but in case you really want to
     disable it on platforms which support it, you can.  This will cause
     the program not to link against GTK libs.
   * '--disable-cunit': allows you to turn on/off CUnit
     (http://cunit.sourceforge.net/) support.  Normally this is detected
     automatically but in case you really want to disable it on
     platforms which support it, you can.  This will cause the program
     not to link against CUnit libs.
   * '--enable-optimize': will turn on optimizations.  This will turn on
     compiler options such as '-fomit-frame-pointer' but also disable
     some code in the program.  Indeed, most of the advanced memory
     checking in the game - which ensures it does not leak - will be
     turned of.  This will certainly speed up things, however, it's not
     recommended to turn this on until program is not stable enough so
     that memory leaks and other problems can be declared 'impossible'.
     Turn this on if you really have some speed problem, otherwise it's
     safer to use the full-featured 'slow' version of the game.
   * '--enable-paranoid': will turn on very picky and pedantic checks in
     the code, try this when you suspect a serious memory bug, a race
     condition whatsoever, and want to track it down.  Useless for
     players.
   * '--enable-headless': will allow compilation without any graphics
     backend.  The game is unplayable in that state but one can still
     wish to compile what is compilable, for testing purposes.
   * '--enable-silent': will allow compilation without any sound
     backend.  The game won't play any music in that state but one can
     still wish to compile what is compilable, for testing purposes.
   * '--enable-allinone': will stuff all the internal libraries into one
     big executable.  Very convenient for profiling.  The major drawback
     is that you need to have all the optional libraries installed to
     compile all the optional modules.  Another side effect is that with
     this option there's no more dynamic loading of binary modules, so
     if your platform has a strange or buggy support for '.so' files,
     this option can help.
   * '--enable-fullstatic': will build a totally static binary, that is
     using the '--static' option for 'gcc' and the '-all-static' option
     for 'libtool'.  Currently broken, this option could in the future
     allow for building binaries that run pretty much everywhere,
     without requiring any dependency but a Kernel.
   * '--enable-gprof': will enable profiling informations.  This will
     activate '--enable-allinone', else you would only track the time
     spent in functions in the main 'liquidwar6' executable, and exclude
     lots of interesting code contained in dynamic libraries.
   * '--enable-instrument': will instrument functions for profiling.
     This will turn on the '-finstrument-functions' switch when
     compiling, so that the hooks '__cyg_profile_func_enter' and
     '__cyg_profile_func_exit' are called automatically.  Then you can
     link against tools like cprof (http://cprof.sourceforge.net/) or
     FunctionCheck (http://sourceforge.net/projects/fnccheck/).
   * '--enable-profiler': will enable Google Performance Tools
     (http://code.google.com/p/google-perftools/) support.  Basically,
     this means linking against 'libtcmalloc' and 'libprofiler'.  You
     could activate those by using 'LD_PRELOAD' or by using your own
     'LDFLAGS' but using this option will also make the game tell you if
     'CPUPROFILE' or 'HEAPPROFILE' are set when it starts.  The 'pprof
     -gv' output is very handy.  Note that on some systems 'pprof' is
     renamed 'google-pprof'.
   * '--enable-gcov': will enable coverage informations, to use with
     gcov (http://gcc.gnu.org/onlinedocs/gcc/Gcov.html) and lcov
     (http://ltp.sourceforge.net/coverage/lcov.php).  This is for
     developpers only.  It will activate '--enable-allinone', else there
     would be some link errors when opening dynamic libraries.  The
     obtained information is available online: coverage
     (http://www.ufoot.org/liquidwar/v6/doc/coverage/).  and GNU global
     (http://www.ufoot.org/liquidwar/v6/doc/global/).
   * '--enable-valgrind': will enable some 'CFLAGS' options which are
     suitable for the use of Valgrind (http://www.valgrind.org/), to
     track down memory leaks and other common programming errors.  Use
     for debugging only, usually together with '--enable-allinone'.

3.8.2 Debian packages
---------------------

Liquid War 6 does have a './debian' in both main and extra maps
packages, so it's "debianized".  To build the main '.deb' package, untar
the main source tarball, then:

make dist
cd pkg
cp ../liquidwar6-X.Y.Z.tar.gz . # X.Y.Z is the version
make deb

   Note that you have to copy the source tarball to './pkg' and move to
this directory before typing 'make deb'.  This is, among other things,
to simplify the main 'Makefile'.

   To build the extra maps '.deb' package, untar the extra maps tarball,
then:

make deb

3.8.3 Red Hat packages
----------------------

Liquid War 6 does have a '.spec' files in both main and extra maps
packages.  To build the main '.rpm' package, untar the main source
tarball, then:

make dist
cd pkg
cp ../liquidwar6-X.Y.Z.tar.gz . # X.Y.Z is the version
make rpm

   Note that you have to copy the source tarball to './pkg' and move to
this directory before typing 'make rpm'.  This is, among other things,
to simplify the main 'Makefile'.

   To build the extra maps '.rpm' package, untar the extra maps tarball,
then:

make rpm

3.8.4 Microsoft Windows msys/mingw32 port
-----------------------------------------

This section describes how to compile the game from source under
Microsoft Windows.  Note that players are encouraged to use a free
system such as GNU/Linux, which is the platform Liquid War 6 is being
hacked on by default.  If you encounter problems with this port, you'll
probably save time by installing a double-boot with GNU/Linux coexisting
with your previous Microsoft Windows install.

   Basically, Liquid War 6 requires MinGW (http://www.mingw.org/).  More
precisely, it requires MSYS (http://www.mingw.org/msys.shtml).  A
standard Cygwin (http://www.cygwin.com/) installation won't work,
because it is too UNIXish to allow third party libraries like SDL
(http://www.libsdl.org/) to compile natively.  You might argue that SDL
is available for Cygwin, but in reality, the Cygwin port of SDL is a
MinGW port.  Indeed, Cygwin brings all standard POSIX functions
including the use of 'main' instead of 'WinMain' and I suspect this is a
problem for graphical libraries like SDL which do require some sort of
direct access to the OS low-level functions.  Therefore, MinGW is more
adapted for it does not define all these functions, and allows any
library to hook on Microsoft Windows internals directly.  Point is then,
you also loose the cool effect of Cygwin which is to have a complete
glibc (http://www.gnu.org/software/libc) available, including network
functions like 'select' defined the POSIX way, and not the WinSock way.
If you ever ported code from POSIX sockets to WinSock 2, you know what I
mean.  Using MinGW is also embarassing for some libraries won't compile
easily, and for instance programs which heavily rely on a real 'TTY'
interface to work are usually hard to port.  This includes ncurses
(http://www.gnu.org/software/ncurses/) and GNU readline
(http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html).  Liquid War 6
tries to have workarrounds for all this, and in some cases the
workarround is simply that embarassing code is not compiled on Microsoft
Windows.  For this reason, some features are not available on this
platform.  Period.

   Now the reason you need MSYS and not only MinGW is that MSYS will
allow './configure' scripts to run, and this eases up the porting
process a lot.  MinGW and MSYS packages are downloadable on the
SourceForge MinGW download page
(http://sourceforge.net/project/showfiles.php?group_id=2435).
Alternatively, there is a mirror on ufoot.org
(http://www.ufoot.org/download/liquidwar/v6/mingw32/pkg/), but files
might be outdated.

   To compile Liquid War 6, first download and unzip all the following
files in the same directory, for instance 'C:\MSYS'.  If you do not have
any tool to handle '.tar.gz' and '.tar.bz2' files under Microsoft
Windows, which is likely to be the case when MSYS is not installed yet,
you can untar these on any GNU/Linux box, then upload the whole
directory to the target Windows host.

   * autoconf2.5-2.61-1-bin.tar.bz2
   * autoconf-4-1-bin.tar.bz2
   * autogen-5.9.2-MSYS-1.0.11-1-bin.tar.gz
   * autogen-5.9.2-MSYS-1.0.11-1-dev.tar.gz
   * autogen-5.9.2-MSYS-1.0.11-1-dll25.tar.gz
   * automake1.10-1.10-1-bin.tar.bz2
   * automake-3-1-bin.tar.bz2
   * bash-3.1-MSYS-1.0.11-1.tar.bz2
   * binutils-2.18.50-20080109-2.tar.gz
   * bison-2.3-MSYS-1.0.11-1.tar.bz2
   * coreutils-5.97-MSYS-1.0.11-snapshot.tar.bz2
   * crypt-1.1-1-MSYS-1.0.11-1.tar.bz2
   * csmake-3.81-MSYS-1.0.11-2.tar.bz2
   * cvs-1.11.22-MSYS-1.0.11-1-bin.tar.gz
   * diffutils-2.8.7-MSYS-1.0.11-1.tar.bz2
   * findutils-4.3-MSYS-1.0.11-1.tar.bz2
   * flex-2.5.33-MSYS-1.0.11-1.tar.bz2
   * gawk-3.1.5-MSYS-1.0.11-1.tar.bz2
   * gcc-core-3.4.5-20060117-3.tar.gz
   * gcc-g++-3.4.5-20060117-3.tar.gz
   * gcc-g77-3.4.5-20060117-3.tar.gz
   * gcc-objc-3.4.5-20060117-3.tar.gz
   * gdb-6.8-mingw-3.tar.bz2
   * gdbm-1.8.3-MSYS-1.0.11-1.tar.bz2
   * gettext-0.16.1-1-bin.tar.bz2
   * gettext-0.16.1-1-dll.tar.bz2
   * gettext-0.16.1-MSYS-1.0.11-1.tar.bz2
   * gettext-devel-0.16.1-MSYS-1.0.11-1.tar.bz2
   * inetutils-1.3.2-40-MSYS-1.0.11-2-bin.tar.gz
   * libiconv-1.11-1-bin.tar.bz2
   * libiconv-1.11-1-dll.tar.bz2
   * libiconv-1.11-MSYS-1.0.11-1.tar.bz2
   * libtool1.5-1.5.25a-1-bin.tar.bz2
   * libtool1.5-1.5.25a-1-dll.tar.bz2
   * libtool1.5-1.5.25a-20070701-MSYS-1.0.11-1.tar.bz2
   * lndir-6.8.1.0-MSYS-1.0.11-1.tar.bz2
   * lpr-1.0.1-MSYS.tar.gz
   * lzma-4.43-MSYS-1.0.11-1-bin.tar.gz
   * make-3.81-MSYS-1.0.11-2.tar.bz2
   * mingw-runtime-3.14.tar.gz
   * mingw-utils-0.3.tar.gz
   * minires-1.01-1-MSYS-1.0.11-1.tar.bz2
   * MSYS-1.0.11-20071204.tar.bz2
   * msysCORE-1.0.11-2007.01.19-1.tar.bz2
   * openssh-4.7p1-MSYS-1.0.11-1-bin.tar.gz
   * openssl-0.9.8g-1-MSYS-1.0.11-2-bin.tar.gz
   * openssl-0.9.8g-1-MSYS-1.0.11-2-dev.tar.gz
   * openssl-0.9.8g-1-MSYS-1.0.11-2-dll098.tar.gz
   * perl-5.6.1-MSYS-1.0.11-1.tar.bz2
   * perl-man-5.6.1-MSYS-1.0.11-1.tar.bz2
   * regex-0.12-MSYS-1.0.11-1.tar.bz2
   * tar-1.19.90-MSYS-1.0.11-1-bin.tar.gz
   * texinfo-4.11-MSYS-1.0.11-1.tar.bz2
   * vim-7.1-MSYS-1.0.11-1-bin.tar.gz
   * w32api-3.11.tar.gz
   * zlib-1.2.3-MSYS-1.0.11-1.tar.bz2

   This file list might contain file which are not absolutely mandatory
for Liquid War 6, for instance the Fortran 77 compiler is absolutely
useless, but installing it won't harm either.  Some packages might unzip
things the right way, but some do it in a subfolder.  You might need to
run commands like:

     cp -r coreutils*/* .
     rm -rf coreutils*

   Get rid of useless files:
     rm ._.DS_Store .DS_Store

   It's also mandatory to move everything that has been installed in
'/usr' or '/usr/local' to '/' since MSYS has some builtin wizardry which
maps '/usr' on '/'.  You need to do this if you don't unzip files from a
MinGW shell, which is obviously the case when you first install it.
Usefull command can be:

     mv usr/* .
     rmdir usr

   Next, 'libintl' is not correctly handled/detected by LW6, and can
raise an error like '"gcc.exe: C:/msys/local/lib/.libs/libintl.dll.a: No
such file or directory"' so one needs to copy some libraries in
'/usr/local/lib/.libs/':

     mkdir local/lib/.libs
     cp local/lib/libintl.* local/lib/.libs/

   Another step is to edit '/etc/profile' and add lines like:

     export CFLAGS="-g -I/usr/local/include"
     export LDFLAGS="-L/usr/local/lib"
     export GUILE_LOAD_PATH="C:\\MSYS\\local\\share\\guile\\1.8\\"

   Close and re-launch your msys shell (rxvt) so that these changes take
effect.  Check that those values are correctly set:

     env | grep FLAGS
     env | grep GUILE

   Finally, your MSYS environment is (hopefully...)  working.

   Now you need to compile the following programs, from source.  Files
are mirrored on ufoot.org
(http://www.ufoot.org/download/liquidwar/v6/mingw32/src/) for your
convenience, however these might be outdated.  Still, there are known to
work.  Proceed like if you were under a POSIX system.  Some packages use
the '--disable-rpath' swith, there are various reasons for which rpath
is an issue (http://wiki.debian.org/RpathIssue).  In the same manner,
'--disable-nls' when linking against 'libintl' or 'libiconv' was
painful.

   * pthreads-win32 (http://sourceware.org/pthreads-win32/), untar
     pthreads-w32-2-8-0-release.tar.gz then 'make clean GC; cp pthread.h
     sched.h /usr/local/include/; cp pthreadGC2.dll /usr/local/bin/; cp
     libpthreadGC2.a /usr/local/lib/'
   * GNU MP (http://gmplib.org/), untar 'gmp-4.2.2.tar.gz' then
     './configure && make && make install'
   * Guile (http://www.gnu.org/software/guile/), untar
     'guile-1.8.5.tar.gz'.  Edit 'libguile/guile.c' and insert '#undef
     SCM_IMPORT' just before '#include <libguile.h>'.  Edit
     './libguile/threads.c' and place 'struct timespec { long tv_sec;
     long tv_nsec; };' just before '#include "libguile/_scm.h"'.  Then
     './configure --disable-nls --disable-rpath
     --disable-error-on-warning --without-threads && make && make
     install'.  The 'GUILE_LOAD_PATH' value must be correctly set for
     'guile-config' to work.  For unknown reasons, running 'guile' can
     throw a stack overflow error.  Don't panic.  See bug 2007506 on
     SourceForge.net
     (https://sourceforge.net/tracker/?func=detail&atid=102435&aid=2007506&group_id=2435)
     for an explanation on why the Guile binary shipped with MSYS is not
     suitable for Liquid War 6.
   * expat (http://www.libexpat.org/), untar 'expat-2.0.1.tar.gz' then
     './configure && make && make install'
   * SQLite (http://www.sqlite.org/), untar
     'sqlite-amalgamation-3.5.9.tar.gz' then './configure && make &&
     make install'
   * libpng (http://www.libpng.org/pub/png/libpng.html), untar
     'libpng-1.2.29.tar.gz' then './configure && make && make install'
   * libjpeg (http://www.ijg.org/), untar 'jpegsrc.v6b.tar.gz' then
     './configure && make && make install && make install-lib'
   * libcURL (http://curl.haxx.se/libcurl/), untar 'curl-7.18.1.tar.gz'
     then './configure --without-ssl && make && make install'
   * FreeType 2 (http://freetype.sourceforge.net/), untar
     'freetype-2.3.5.tar.gz' then './configure && make && make install'
   * libogg (http://www.xiph.org/), untar 'libogg-1.1.3.tar.gz' then
     './configure && make && make install'
   * libvorbis (http://www.xiph.org/), untar 'libvorbis-1.2.0.tar.gz'
     then 'LDFLAGS="$LDFLAGS -logg" && ./configure && make && make
     install'
   * SDL (http://www.libsdl.org/), untar 'SDL-1.2.13.tar.gz' then
     './configure && make && make install'
   * SDL_image (http://www.libsdl.org/projects/SDL_image/), untar
     'SDL_image-1.2.6.tar.gz' then './configure && make && make install'
   * SDL_mixer (http://www.libsdl.org/projects/SDL_mixer/), untar
     'SDL_mixer-1.2.8.tar.gz' then './configure && make && make install'
   * SDL_ttf (http://www.libsdl.org/projects/SDL_ttf/), untar
     'SDL_ttf-2.0.9.tar.gz' then './configure && make && make install'

   For your convenience, a zip file containing a complete MSYS "Liquid
War 6 ready" environment is available.  It is simply the result of all
the operations described above.  Simply unzip
msys-for-liquidwar6-20080819.zip
(http://www.ufoot.org/download/liquidwar/v6/mingw32/msys-for-liquidwar6-20080819.zip)
(about 240 megs) in 'C:\MSYS\'.  All dependencies compiled in '/local'
have been generated using the command:
     cd /usr/local/src
     ./msys-for-liquidwar6-build.sh > ./msys-for-liquidwar6-build.log 2>&1
   Note that this script does't do everything, you'll still need to edit
Guile source code and patch it manually.

   It might even be possible to use this MSYS environment under Wine
(http://www.winehq.com/).  Simply unzip it under '$HOME/.wine/drive_c',
and run 'wine "$HOME/.wine/drive_c/windows/system32/cmd.exe" /c
"c:\\msys\\msys.bat"' and with luck, you'll get a working shell.  Note
that this might allow you to compile the game, but running it is another
story.  Consider this MSYS over Wine trick as a hack enabling the use of
free software only when compiling for Microsoft proprietary platform.
It is not a reasonnable way to run the game.  If running under a UNIXish
platform, or better, GNU, simply run native code.  Use the Windows
32-bit port only if you are jailed on a Microsoft system.

   Now, let's come to the real meat, untar the Liquid War 6 source
tarball, launch your MSYS shell, and:

     ./configure
     make
     make install

   Now the binary is in 'src/.libs/liquidwar6.exe' (beware,
'src/liquidwar6.exe' is only a wrapper).  This binary is an MSYS/MinGW
binary, so it read paths "à la" Microsoft, that is, it has no knowledge
of what '/usr' is, for instance.  It requires paths starting by 'C:\'.

3.8.5 Mac OS X port
-------------------

This is still experimental.  Basically, install MacPorts, and most
dependencies with, except for SDL which you compile from source.  The
idea is to compile SDL using the native OS X bindings (and not some
other GL files you could have in '/opt/local' installed by MacPorts),
then compile the game and other SDL dependencies against this SDL.

   The SDL_mixer library might need to be told to compile itself without
dynamic ogg support.  By default it seems that it tries to load
'libvorbisfile.dylib' at runtime, and it can fail.  To disable this
dynamic loading, use for instance :

/configure --prefix=/opt/extra --enable-music-ogg --disable-music-ogg-shared

   Also, it might seem obvious for Mac OS X users, but there are some
important issues related to compiling options and handling dynamic
libraries at runtime.
   * The command 'ldd' does not exist, run 'otool -L' instead.
   * The equivalent of 'LD_LIBRARY_PATH' is 'DYLD_LIBRARY_PATH'.
   * The extension for shared binaries is '.dylib' and not '.so'.
   * You might need to set the 'OBJCFLAGS' environment variable along
     with 'CFLAGS' because the Mac OS X port uses some Objective-C code.

   It is very important to have the right SDL flags when linking the
Liquid War 6 binaries.  For instance it could be:

-I/opt/extra/include -I/opt/local/include -Wl,-framework -Wl,CoreFoundation -I/opt/local/include -D_THREAD_SAFE -Wl,-framework -Wl,Cocoa -Wl,-framework -Wl,OpenGL -Wl,-framework -Wl,Cocoa

   The point is to have Cocoa and OpenGL support.  Depending on the way
you installed SDL, you might also need to include an SDL framework
support, this is mostly if you installed SDL from .dmg binary images,
and not from source with the command line.  A typical output of
'sdl-config --libs' is:

-L/opt/extra/lib -lSDLmain -lSDL -Wl,-framework,Cocoa

   Another important issue is to include 'SDL.h', which in turn includes
'SDLmain.h', in all the .c source files defining the standard 'main'
function.  This is done in liquidwar6 but should you try to link
yourself on liquidwar6 libraries and/or hack code, you must do this or
you'll get errors when running the game.  Such errors look like:

*** _NSAutoreleaseNoPool(): Object 0x420c90 of class NSCFNumber autoreleased with no pool in place - just leaking

   The reason is that SDL replaces your 'main' with its own version of
it.  One strong implication is that all the dynamic loading of SDL,
which works on sandard GNU/Linux boxes, won't work under Mac OS X, since
SDL hard codes itself by patching 'main' with '#define' C-preprocessor
commands.

   A '.dmg' file (disk image) containing a 'Liquid War 6.app' folder (OS
X application) is available for your convenience.  It might work or not.
In doubt, compile from source.  The complicated part about this package
(a "bundle" is OS X language) is that it needs to embed various
libraries which are typically installed in '/opt' by MacPorts on a
developper's machine.  So to build this package a heavy use of the
utilility 'install_name_tool' is required, normally all libraries needed
ship with the binary, remaining depedencies concern frameworks which
should be present on any working Mac OS X install.  Still, this is only
theory.  Needs to be widely tested.

   The layout of the bundle follows:
   * './Contents/Info.plist': metadata, bundle description file
   * './Contents/MacOS': contains the main binary 'liquidwar6' as well
     as all specific low-level libraries
   * './Contents/Resources/data': general game data, does not contain
     maps.
   * './Contents/Resources/music': music for the game.
   * './Contents/Resources/map': system maps, you can put your own maps
     (or "extra" maps) here if you want all users to share them.
   * './Contents/Resources/script': Liquid War 6 specific scripts, the
     scheme scripted part of the program.
   * './Contents/Resources/guile': common shared Guile scripts, part of
     Guile distribution.
   * './Contents/Resources/doc': documentation in HTML and PDF formats.

   Additionnally, the Mac OS X port uses
'/Users/<username>/Library/Application Support/Liquid War 6/' to store
configuration file, logs, etc.  It does not use '$HOME/.liquidwar6' like
the default UNIX port.

   The Mac OS X port also has a special behavior, in order to load some
libraries with dlopen (SDL_image does this with libpng and libjpeg) it
needs to set 'DYLD_FALLBACK_LIBARY_PATH' to a value that contains these
libraries.  This is typically in the bundle distributed on the disk
image.  On a developper's computer this problem does not appear for
those libs are often in places like:
   * '/usr/local/lib'
   * '/usr/X11/lib'
   * '/opt/local/lib'
   So the program sets 'DYLD_FALLBACK_LIBARY_PATH' (but not
'DYLD_LIBRARY_PATH' else it breaks internal OS X stuff which relies, for
instance, on libjpeg library that has the same name but different
contents) but it needs to do it before it is even run, else the various
'dyld' functions do not acknowledge the change.  That is, calling the C
function 'setenv()', even before 'dlopen()', has no effect.  So the
program calls 'exec()' to re-run itself with the right environment
variable.  This is why, on Mac OS X, there are two lines (exactly the
same ones) displaying the program description when it is started in a
terminal.

3.8.6 GP2X port
---------------

This is not working yet, but there are good hopes that some day, Liquid
War 6 can run on a GP2X console (http://www.gp2xwiz.co.kr/).  This
handled gaming device uses a Linux kernel (http://kernel.org) on an ARM
processor, does support most GNU (http://www.gnu.org/) packages through
cross-compilation, and has basic SDL (http://www.libsdl.org/) support.

   To compile Liquid War 6 for GP2X, you first need to set up a working
"toolchain".  It's suggested you do this on a working GNU/Linux box.
There are several solutions, the recommended one being Open2x
(http://www.open2x.org/).  Read the online documentation on how to
install Open2x
(http://wiki.gp2x.org/wiki/Installing_the_Open2x_toolchain).

   Basically, the following should work:

mkdir /opt/open2x # check that you can write here
svn co https://open2x.svn.sourceforge.net/svnroot/open2x/trunk/toolchain-new open2x-toolchain
./open2x-gp2x-apps.sh
cd open2x-toolchain

   Then, for your environment to be complete, you need to set up some
environment variables.  For instance:

export OPEN2X_SYSTEM_PREFIX=/opt/open2x/gcc-4.1.1-glibc-2.3.6/arm-open2x-linux
export GP2X_USER_PREFIX=$HOME/gp2x

export CC=${OPEN2X_SYSTEM_PREFIX}/bin/arm-open2x-linux-gcc
export CPP=${OPEN2X_SYSTEM_PREFIX}/bin/arm-open2x-linux-cpp
export CXX=${OPEN2X_SYSTEM_PREFIX}/bin/arm-open2x-linux-g++
export AS=${OPEN2X_SYSTEM_PREFIX}/bin/arm-open2x-linux-as

export CFLAGS=''-I${OPEN2X_PREFIX}/include -I${GP2X_USER_PREFIX}/include''
export CPPFLAGS=''-I${OPEN2X_PREFIX}/include -I${GP2X_USER_PREFIX}/include''
export CXXFLAGS=''-I${OPEN2X_PREFIX}/include -I${GP2X_USER_PREFIX}/include''
export LDFLAGS=''-L${OPEN2X_PREFIX}/lib -L${GP2X_USER_PREFIX}/lib''

export PATH=''${GP2X_USER_PREFIX}/bin:${OPEN2X_SYSTEM_PREFIX}/bin:$PATH''

   In this setting, there's a user '$HOME/gp2x' directory which will
contain all the Liquid War 6 related libraries while the '/opt/open2x'
remains untouched.

   Then you need to install the requirements.  All these packages need
to be cross-compiled.  To make things clear and non-ambiguous, even if
you have 'CC' set up in your environment variables, pass '--build' and
'--host' arguments to the './configure' script of all these packages.  A
typical command is:

./configure --build=i686-pc-linux-gnu --host=arm-open2x-linux --prefix=${GP2X_USER_PREFIX}

   Here's the list of the requirements:

   * SDL (http://www.libsdl.org/).  1.2.14 works zith the following
     settings: './configure --prefix=$GP2X_USER_PREFIX
     --build=x86_64-pc-linux-gnu --host=arm-open2x-linux
     --disable-pulseaudio --disable-video-directfb'
   * libtool (http://www.gnu.org/software/libtool/).  Install a 1.5.x
     version, and not 2.2.x.  For some reasons, 2.2.x is unusable, it
     keeps on complaining that lt_libltdl_LTX_preloaded_symbols is not
     defined
     (http://lists.cistron.nl/pipermail/freeradius-users/2009-September/msg00149.html).
     Apparently the bug has already been reported
     (http://www.archivum.info/bug-libtool@gnu.org/2009-01/00014/undefined_lt_ptr).
     For Liquid War 6 needs, 1.5.x is very fine, use 1.5.26 for
     instance, it works well.

   * GNU MP (http://gmplib.org/) (version 4.3.1 reported to work)

   * Guile (http://www.gnu.org/software/guile/) (version 1.8.7 reported
     to work).  You need to pass the '--witout-threads' switch to the
     './configure' script else it will try (and fail!)  to run a test
     program.  Liquid War 6 does not use Guile threads, it does use
     threads but uses them "directly" outside the Guile layer.

   * zlib (http://www.zlib.net/) (version 1.2.3 reported to work).  Do
     not use '--build' and '--host' for this one, they are unsupported.
     Package compiles fine anyway.

   * expat (http://www.libexpat.org/) (version 2.0.1 reported to work).

   * libpng (http://www.libpng.org/pub/png/libpng.html) (version 1.2.3
     reported to work).

   * libjpeg (http://www.ijg.org/) (version 7 reported to work).

   * SQLite 3 (http://www.sqlite.org) (version 3.6.18 reported to work).

   * libcURL (http://curl.haxx.se/libcurl/) (version 7.19.6 reported to
     work).

   Next, one needs to install a special version of SDL, which targets
the GP2X specifically.  This is not a generic SDL, and it does have
limitations, which are related to the GP2X peculiar hardware.  There are
installation instructions
(http://wiki.gp2x.org/wiki/How_to_install_the_SDL_libraries) about how
to do this.  The following should work:

cvs -d :pserver:anonymous@cvs.sourceforge.net:/cvsroot/open2x login # blank password
cvs -d :pserver:anonymous@cvs.sourceforge.net:/cvsroot/open2x co libs-gp2x

3.9 Coding guidelines
=====================

3.9.1 Project goals reminder
----------------------------

One of the purposes of Liquid War 6 is to make a cleaner implementation
of Liquid War than the previous one, namely Liquid War 5
(http://www.ufoot.org/liquidwar/v5).  While the latter has achieved the
practical goal of providing a playable implementation of the game, it
failed at providing an evolutive platform.  Network capabilities where
finally added to Liquid War 5 (http://www.ufoot.org/liquidwar/v5), but
anyone who played on Internet with someone a few hundreds of
milliseconds away would agree that it's far from being perfect.  The
main reason for this is that it is really had to hack on Liquid War 5
(http://www.ufoot.org/liquidwar/v5), especially when you are not the
core developper.  The core developper himself, even knowing all the
various hacks in the game, is very quickly lost when trying to implement
major changes.

   To put it short, Liquid War 5 (http://www.ufoot.org/liquidwar/v5) is
a global variable hell, a pile of hacks on top of a quick and dirty
implementation.  Still, it works.

   With Liquid War 6, the idea is to take the time to make something
stable, something nice which will enable developpers to implement the
cool features, and have fun along the way.  Of course, this is only a
dream, and in the (hopefully "very") long run, Liquid War 6 will also
end up as a big unmaintainable mess, like any real-life program, until
then, it should remain hackable.

3.9.2 Common sense
------------------

Here are a few guidelines which I think are common sense advice, but
they are still worth mentionning:

   * try and respect the GNU coding standards
     (http://www.gnu.org/prep/standards/);
   * absolutely no 'strcpy' or 'sprintf' anywhere in the code.  Nowhere.
     Use their equivalent 'strncpy' and 'snprintf' systematically, as
     they are part of the glibc and are an order of magnitude safer.
     Moreover, Liquid War 6 provides wrappers, such as
     'lw6sys_new_sprintf' which handles all the nasty dirty memory
     allocation stuff for you;
   * keep global variables for when there is something truely global,
     and even in that case try to fit them in clearly identified
     structures.

3.9.3 Unitary tests
-------------------

Each of the internal libraries in Liquid War has a "test" program
associated with it.  For instance 'liquidwar6sys-test' is associated to
'libliquidwar6sys', and its purpose is to test the features of this
library.

   While it is fairly easy to test out unitary functions which require
no peculiar context, testing high-level functions which requires files,
graphical and possibly network contexts to exist is obviously harder to
achieve.  There's no easy way to draw the line, but the idea is to put
in these test executables as many features as possible, to be sure that
what is tested in them is rock solid, bullet proof, and that one can
safely rely on it and trust that code when running it in a more complex
environnement.

   These test executables are also very good places to see a library API
in action, find code fragments, and make experiments.

3.9.4 Memory allocation
-----------------------

Liquid War 6 provides macros to allocate and free memory.  One should
use them systematically, except when trying to free something allocated
by another library, and in very special cases, mostly concerning low-low
level operations which are seldom hacked on.

   Usage of macros 'LW6SYS_MALLOC', 'LW6SYS_CALLOC' and 'LW6SYS_FREE' is
straightforward, read any random chunk of code, for instance
'./src/lib/sys/sys-test.c' to see them in action.  They are defined in
'sys/sys.h'.

   Once used, these macros will track every single call to 'malloc' and
'free', and if there's a difference, it will report it.  It will also
help you by showing what's in the non-freed memory area, at which line
of code it has been allocated, and when.  This is very usefull to track
down memory leaks.  Of course a debugger could tell you some of these
informations, but experience shows than when you encounter a memory bug,
it's very often impossible to reproduce it.  So you one wastes time
trying to reproduce the bug, whereas with this tool you have the
information reported just when the problem happens.

3.9.5 Private and public interfaces
-----------------------------------

Each library exports a public interface and hides its internal.  Since
Liquid War 6 uses standard C and no C++, there's no real standard way to
handle public/private features.  The convention used in Liquid War 6 is
to show internal structures as opaque pointers ('void *') whenever some
function needs to operate on a structure which has possibly private
fields.  This way the caller function has no way to access the
internals, and we are sure that no reference to any internal
implementation specific feature will appear.

   Here's a code excerpt from 'src/gfx/setup.c':
     void _lw6gfx_quit(_LW6GFX_CONTEXT *context) {
       /*
        * Implementation here.
        */
     [...]
     }

     void lw6gfx_quit(void *context) {
       _lw6gfx_quit((_LW6GFX_CONTEXT *) context);
     }

   The function '_lw6gfx_quit' (note the "_") is internal, declared in
'internal.h' whereas the function 'lw6gfx_quit' is public, and is
therefore exported in 'gfx.h'.

   This way, functions in the program using 'lw6gfx_quit' do not know
what is in the '_LW6GFX_CONTEXT' structure, and they need not know it.

   This does not mean it is not possible to have public structures, only
these structures must reflect some truely public, accessible and safe to
access structures.

3.9.6 Commit policy
-------------------

Basic rules :

   * commits should be as small as possible, yet leave the code in a
     consistent state.  The general idea is that big commits tend to
     make error tracking more complicated;
   * a commit should not leave the code in a state in which it does not
     compile and/or is consistent from a user point of view.  The
     general idea is to go step by step and break as little things as
     possible.
   * tests should be written along the way.  The project is not
     developped with a "test driven" method, still, it's a good practice
     to write the tests functions as soon as possible.

   To check that a commit does not break everything, a good practice is
to run a 'make check' before committing / submitting anything.

   Then, once it's within the main GIT repository, check the Jenkins
builds (http://www.ufoot.org/jenkins/job/liquidwar6/) to see if the
program still builds correctly.

3.9.7 Audit the code
--------------------

Liquid War 6 is regularly audited with automated tools.  You might need
to pass '--enable-gcov' to '--configure' if you want to use thes tools
yourself.  More precisely:

   * CUnit (http://cunit.sourceforge.net) is used for regression tests.
     It's used to provide hopefully standardized output when testing,
     and provide test statistics more easily.  It's a rule of thumb to
     try and write tests when new features and/or bug-fixes pour in.
   * lcov (http://ltp.sourceforge.net/coverage/lcov.php) is run, ideally
     with each release - but it's not garanteed, check the output date
     and time - and the output is available online on
     <http://www.ufoot.org/liquidwar/v6/doc/coverage/>.
   * GNU global (http://www.gnu.org/software/global/) is run too,
     ideally with each release - again, check the output date and time -
     and the output is available online on
     <http://www.ufoot.org/liquidwar/v6/doc/global/>.
   * pmccabe (http://parisc-linux.org/~bame/pmccabe/) reports cyclomatic
     complexity.  It shows where the code is too complex and should
     probably be rewritten.  Output is post-processed using pmccabe2html
     (http://www.gnu.org/software/gnulib/MODULES.html#module=pmccabe2html)
     from gnulib (http://www.gnu.org/software/gnulib/).  The output is
     available online on <http://www.ufoot.org/liquidwar/v6/doc/cyclo/>.
   * Valgrind (http://valgrind.org/) is run as well, it should report
     absolutely no leak on all the core sub-libraries, eg running
     'liquidwar6ker-test' or 'liquidwar6ker-pil'.  Bits of code which
     depend on other libraries are a different story, for some projects
     on which Liquid War 6 depends might, for some reason, raise
     warnings.  But as far as Liquid War 6 is concerned, the goal is
     simple: zero leak.
   * Liquid War 6 is referenced on Open HUB (http://www.openhub.net/).
     Visit <http://www.openhub.net/p/liquidwar6> to get time-based
     statistics and facts about the source code.

   Those tools certainly don't garantee the code is perfect, but they do
help improving the quality of the program.  If you hack, it's
recommended you give them a try.

3.10 Using the console
======================

The console can be activated by passing '--display-console' when
starting the game or by using the system options menu.

   When the console is activated, a 'lw6>' prompt should appear in the
terminal which launched the program.  If you started Liquid War 6 by
clicking on an icon, console probably won't work at all since 'stdout'
and 'stdin' won't be attached to anything.

   The console allows you to type arbitray Scheme/Guile code.

   Try, for instance:
     (+ 1 2)
     (display "foo\n")

   You can really break things with this console, it gives you a direct
access to all the program internals.  At least, all the values which are
accessible through the script interface, that is, many of them.

   You can call any internal C function which has been exported to
Guile, here are some examples:

     (c-lw6sys-timestamp)
     (c-lw6bot-get-backends)
     (c-lw6sys-sleep 2.0)
     (lw6-config-get-number "zoom")
     (lw6-config-set-number! "zoom" 0.9)
     (lw6-config-get-number "zoom")

   While syntax (and possibly other) errors will be trapped by the
interpreter, note that if you break things inside the game by, say,
changing some global value, or in a general manner cause an error
elsewhere in the code, the game will really raise a fatal error and
stop.  That's how you can "break things".

   Still, this console is a very powerfull tool, very usefull for
debugging but also for tweaking the game without restarting it and/or
navigating through the menu interface.

3.11 Advanced tweaking
======================

3.11.1 Hacking ressources
-------------------------

Liquid War 6 tries to have as few hardcoded data as possible.  So many
constants, and pretty much all the image files, are accessible in the
data directory.  You can know where it is by launching 'liquidwar6
--show-data-dir'.  If you look in this directory you'll find different
files, among them XML files.

   Let's take an example.  Try and find the file
'gfx/gl/hud/floating/gl-floating-const.xml'.  Edit the line with the
'clock-y1' entry.  Change the number after '"value"'.  Re-run the
program.  Play a game.  What happens?  Logically you should see that
"something" is not displayed at the same place than before.

   You could also modify the textures (JPEG and PNG files).  In a
general manner it's more cautious to keep them the same size but it
depends, sometimes other sizes will work as well.

   Many of these parameters are really too technical and obscure to have
their place in the main config file (which is already rather big).  Use
at your own risks, you can really break things touching this, but you
can also find out lots of things can be tuned.

3.11.2 Optimize for speed
-------------------------

Todo...

3.12 Writing modules
====================

Todo...

3.13 Use as a library
=====================

Todo...

3.14 Network protocol
=====================

This section describes how Liquid War 6 handles network messages.  Note
that for now this is purely theorical, more of a draft, a plan, it might
change before being implemented.

3.14.1 No server, no client, only nodes
---------------------------------------

Liquid War 6 does not really have the notion of server or client, any
instance of the program can act as both server and client, therefore we
use the term node.

   A node listens on a given port, in both TCP and UDP, and can connect
to other nodes on the same port.  The main identifier of a node is its
public url, which is typically of the form
'http://<ip-address>:<port>/'.  This url is very important for it is (or
at least should be) a unique identifier of the node over the network.

   Liquid War has 3 ways to communicate:
   * raw TCP, this is the LW6 protocol, the easiest to implement and
     debug, probably the most reliable one, but not always the fastest.
     This involves the two modules 'mod-tcp' and 'mod-tcpd'.
   * HTTP over TCP, this is a hack which allows the game to communicate
     through HTTP proxies for instance.  Additionnally, the fact any
     node is a web server enables peering with a simple web browser.
     Web server facility requires 'mod-httpd' and client part requires
     'mod-http' which might or not be available, depending on how the
     game was compiled.
   * raw UDP, this is another version of the LW6 protocol, this is in
     theory the fastest way to communicate, it requires 'mod-udp' and
     'mod-udpd' to work.  Using UDP only was not an option when
     conceiving Liquid War since it's interesting to have other
     solutions if, for instance, a firewall does not allow you to use
     UDP the way you want.

   On each of these channels, messages can be exchanged in two modes, an
"out of band" mode (AKA "oob"), and a regular message oriented, here we
speak of "connection".

3.14.2 Out of band messages
---------------------------

There are only 3 out of band messages:

   * 'PING': requests for a simple 'PONG http://server:port/' answer,
     this is just to check if a server is a valid server, and if the URL
     we used to connect on it is the correct one.
   * 'INFO': requests for a list of key/attributes pairs, which describe
     the node, telling for instance its version, its uptime, and so on.
   * 'LIST': requests for a list of other nodess this node is aware of.

   You can test out of band messages by simply connecting on your server
with a command like:
telnet localhost 8056

   At the telnet prompt, simply type:
INFO
   and press return, and you should have a description of your node.

   The complete syntax of OOB messages is:
<COMMAND> [password] [url]

   The 'password' and 'url' parameters are optionnal.  'password' can
contain either the plain text password or a checksum calculated from the
password which is, for security reasons, seeded with the public url of
the node we're connecting to, so that this password can't be re-used on
another node.  'url' is simply a clue we give to the other node to help
find us, the other node will automatically try to detect our IP address
and use standard LW6 port 8056, but if for some reason we use a
different setting, this is a good way to pass the hint.

   Here are examples of valid messages:

LIST
PING http://myhost.mydomain:1234/
INFO secret http://myhost.mydomain:1234/
LIST 12ab34cd

   If there's only one argument, the parser will first try and interpret
it as a URL. If it's not parseable that way, it will consider it's a
password.  The password, in turn, may be specified as clear text or as a
32-bit checksum.

   As far as OOB is concerned, TCP and UDP work almost the same, HTTP is
a bit different, the OOB commands are accessed through the following
URLs:
   * '/ping.txt'
   * '/info.txt'
   * '/list.txt'

   OOB messages are usually sent many times in redundant mode on the
network, as there's no tracking of them, sending them through multiple
channels ensures they make their way to the right place.

   The parser for these messages is located in 'src/lib/msg/msg-oob.c'.

3.14.3 Regular messages overview
--------------------------------

All messages that are non-OOB share a common syntax.  This is called the
"envelope" of messages.

   The general syntax is:

LW6 <VERSION> <PASSWORD_CHECKSUM> <PHYSICAL_TICKET_SIG> <LOGICAL_TICKET_SIG> <PHYSICAL_FROM_ID> <PHYSICAL_TO_ID> <LOGICAL_FROM_ID> <LOGICAL_TO_ID> <MSG>

   Here's an example:

LW6 0.1.3485 - 2d1dbed7 - 3003300330033003 2002200220022002 - - DATA 8 0 1 1000000035005 3003300330033003 SET 3001 11 1 1 0

   In this example, the messages carried is 'DATA 8 0 1 1000000035005
3003300330033003 SET 3001 11 1 1 0', the rest is part of the envelope
protocol.

   Here's what those fields mean:
   * 'LW6': should always be LW6, this is a marker to make sure we're
     speaking the right protocol.
   * '<VERSION>': the version of the program sending the message, the
     receiver of the message should check this version is compatible.
   * '<PASSWORD_CHECKSUM>': the password checksum, while a clear
     password should still be correctly interpreted, as for OOB
     messages, there's no reason to send the cleartext password, so the
     checksum is just fine.  Note that the checksum is short, and
     vulnerable to brute-force attacks.  If you want strong protection,
     the general advice is to tunnel your connections through SSL or
     TLS, use a VPN, LW6 won't implement "fortress mode", third party
     tools should do this much better.  If undefined, should be replaced
     by the dash character '-'.
   * '<PHYSICAL_TICKET_SIG>': a signature done by the sender, which is
     unique for the combination message+from+to.  This means two
     different messages will generate two differents signatures, but
     different senders and/or receivers will also change this, so it's
     not possible, unless one has the "ticket" to fake a message.  This
     is clearly not bullet-proof, and more specifically, brute-force
     attacks and/or network listening could break the protocol and/or
     reveal the ticket, still, this is a good way to make sure that if
     something is inconsistent, someone is trying to cheat.  As every
     node maintain its own game state, a cheater can "only" be a
     nuisance by sending wrong key presses, but in the long run it will
     be defeated by the fact that an attacker should intercept and
     modify all messages on all channels (tcp, udp, http ...)  and make
     sure the official, real informations, never makes its way to the
     right node.  This is quite hard to achieve, very likely, an
     inconsistency will be detected, nodes concerned should be
     disconnected, period.  When sending the first messages, ticket
     might not be exchanged yet, so there's no way to calculate this,
     during this period, 'ffffffff' is sent, and checksum errors are
     ignored.
   * '<LOGICAL_TICKET_SIG>': another signature, but this one concerns
     the physical sender/receiver.  If the physical sender is the
     logical sender, and the physical receiver is the logical receiver,
     that is, if physical and logical nodes are the same pair of nodes,
     then it need not be defined and can be replaced by the dash
     character '-'.  In fact, in that case, the physical and logical
     signatures are obviously the same.  However (not implemented yet)
     the protocol is designed so that nodes can act as messages
     forwarders, in that case they have no knowledge of the secret
     ticket to use, so this ticket is here to ensure message consistency
     for the final, real (logical) receiver of the message.
   * '<PHYSICAL_FROM_ID>': the id of the physical sender, the node that
     created the message.
   * '<PHYSICAL_TO_ID>': the id of the physical receiver, the node that
     should receive the message.
   * '<LOGICAL_FROM_ID>': the id of the logical sender, if it's the same
     than the physical sender, can be replaced by the dash character
     '-'.
   * '<LOGICAL_TO_ID>': the id of the logical receiver, if it's the same
     than the physical receiver, can be replaced by the dash character
     '-'.
   * '<MSG>': the message itself, it might in turn be separated by
     spaces, or whatever the message delimiter is.  It should not be too
     long, as it must be sendable on the network by UDP, so it must fit
     within the MTU (about 1.4 kb) with all the protocol (envelope)
     stuff before it.  In practice, it's cut into 1.2 kb parts by
     'libdat', the constant '_LW6DAT_ATOM_MAX_SIZE' is used to split big
     messages in smaller parts.

   It's implemented in 'src/lib/msg/msg-envelope.c'.

3.14.4 Regular control messages
-------------------------------

To establish a connection, maintain it, and do the OOB job, a set of
control message is used.  Those messages carry a bunch of informations
about who is sending them, in fact, they just contain the informations
that would otherwise be handled by out-of-band messages, but it's
convenient to have the information first-hand rather than relying on the
other protocol.

   The syntax is:
LW6 <VERSION> <PASSWORD_CHECKSUM> <PHYSICAL_TICKET_SIG> <LOGICAL_TICKET_SIG> <PHYSICAL_FROM_ID> <PHYSICAL_TO_ID> <LOGICAL_FROM_ID> <LOGICAL_TO_ID> <COMMAND> <PROGRAM> <VERSION> <CODENAME> <STAMP> <ID> <URL> <TITLE> <DESCRIPTION> <HAS_PASSWORD> <BENCH> <OPEN_RELAY> <UPTIME> <COMMUNITY_ID> <ROUND> <LEVEL> <REQUIRED_BENCH> <NB_COLORS> <MAX_NB_COLORS> <NB_CURSORS> <MAX_NB_CURSORS> <NB_NODES> <MAX_NB_NODES> <PEER_LIST> <COMMAND_ARGS>

   Example:
LW6 0.1.3485 - ffffffff - 1001100110011001 2002200220022002 - - HELLO liquidwar6 0.1.3485 "Davy Crockett" 3485 1001100110011001 http://localhost:8057/ cGF0 RHVtbXkgdGVzdCBub2RlIEE= 0 10 0 5 372057f45b3d2ba5 10005 "Default map" 5 4 10 4 26 1 12 ""

   The fields, starting from 'LW6' up to (and including)
'<LOGICAL_TO_ID>' are part of the envelope, described previously.

   The message fields are:
   * '<COMMAMD>': described below, the main command,
   * '<PROGRAM>': should be 'liquidwar6'
   * '<VERSION>': the version of the program.  Yes, this is also in the
     envelope, but one could think of instances relaying informations
     for other peers, in that case this could prove useful.
   * '<CODENAME>': the code name of the program.
   * '<STAMP>': the stamp, it's normally contained within the version,
     but this avoids parsing issues.
   * '<ID>': the node id (could be inferred from envelope, but repeated
     here).
   * '<URL>': the node url (could be inferred from envelope, but
     repeated here).
   * '<TITLE>': the readable title of the node, base64 encrypted.
   * '<DESCRIPTION>': the readable description of the node, base64
     encrypted.
   * '<HAS_PASSWORD>': wether it's protected by a password or not, 0 if
     not, 1 if protected.
   * '<BENCH>': the bench of the node, giving its CPU strength in an
     arbitrary unit.
   * '<OPEN_RELAY>': wether the node act as an open relay, 0 if not, 1
     if in relaying.
   * '<UPTIME>': node uptime, in seconds.
   * '<COMMUNITY_ID>': the community id, a unique id shared by all nodes
     connected to a game session.
   * '<ROUND>': the current round id.
   * '<REQUIRED_BENCH>': the minimum bench required to connect to this
     node (used to avoid slow nodes connecting to way-too-fast games).
   * '<NB_COLORS>': number of colors playing.
   * '<MAX_NB_COLORS>': maximum number of colors allowed on this node.
   * '<NB_CURSORS>': number of cursors playing.
   * '<MAX_NB_CURSORS>': maximum number of cursors allowed on this node.
   * '<NB_NODES>': number of nodes connected.
   * '<MAX_NB_NODES>': maximum number of nodes allowed on this node.
   * '<PEER_LIST>': list of peers connected to this node.
   * '<COMMAND_ARGS>': command-specific arguments

   Here are the different possibilities for the '<COMMAND>' field.

   * 'HELLO': is used when connecting, this should be the first message
     sent.  In itself, the message means pretty much noting, it just
     says "I'm here" which could be infered from any other message.  No
     command args.
   * 'TICKET <ticket>': is used to inform the caller of the ticket we
     use.  The ticket sent from A to B is ised by B to sign messages for
     A. A node typically sents a different ticket to all its peers so
     when sending the same message to A and C, B will typically use two
     different tickets, thus generating two different signatures, and if
     sending the exact same string to C, A generate yet another
     signature as it will have sent another ticket.  There's one
     optional argument, which is the ticket itself, a 64-bit hexa
     integer.
   * 'FOO <key> <serial>': is sent on a regular basis, it's really the
     replacement of the OOB 'PING' message, it will update the peer
     status and maintain consistent informations.  It has two arguments,
     the first one is 'key', a 32-bit hexa integer, which will, upon
     'BAR' message reception, used to figure out "OK, this is the 'BAR'
     message associated to this 'FOO' message I sent before".  The
     second one, 'serial', is used to inform the peer that, possibly,
     there are new messages to fetch from us.  The peer, in turn, might
     fire 'MISS' messages, but without this feature, peers could "fall
     asleep" and forget to pump messages, especially on non-reliable
     connections.
   * 'BAR <key> <serial>': is the response to 'FOO' which is received on
     a regular basis, it's really the replacement of the OOB 'PONG'
     message, it will update the peer status and maintain consistent
     informations.  It has two arguments, the first one is 'key', a
     32-bit hexa integer, which will, upon reception, ne matched against
     a corresponding 'FOO' messaged, used to figure out "OK, this is the
     'BAR' message associated to this 'FOO' message I sent before".  The
     second one, 'serial', is used to inform the peer that, possibly,
     there are new messages to fetch from us.  The peer, in turn, might
     fire 'MISS' messages, but without this feature, peers could "fall
     asleep" and forget to pump messages, especially on non-reliable
     connections.
   * 'JOIN <seq> <serial>': Used to join a game.  In fact, having said
     'HELLO' and exchanged 'FOO' and 'BAR' messages does not mean one
     has joined the game for real.  The reason for this is that those
     messages help establishing a stable communication channel, then one
     needs to come in with the right 'seq' and 'serial'.  There are
     basically two cases.  First case, 'seq' can be zero, in that case
     it means we're trying to connect on an existing server, which will
     in turn send a 'JOIN' message with a non-zero value, giving the
     current seq.  Second case, 'seq' is non-zero, in that case it means
     we're answering a connection request.  In both cases, 'serial' is a
     serial number other peers should use as a minimum limit, and never
     ask for messages with a 'serial' lower than that.
   * 'GOODBYE': symetric of 'HELLO', should be called on disconnection,
     however, the peers should handle the case when no 'GOODBYE' message
     is sent, this is just about being polite.  No command args.

   It's implemented in 'src/lib/msg/msg-cmd.c'.

3.14.5 Regular MISS messages
----------------------------

Todo...

3.14.6 Regular META messages
----------------------------

Todo...

3.14.7 Regular DATA messages
----------------------------

Todo...

3.14.8 Other raw technical stuff (WIP)
--------------------------------------

TCP messages:

LW6 [<passwd>] <version> <client-id>
<from-id> <to-id> <serial> <i> <n> <sig> MSG1
<from-id> <to-id> <serial> <i> <n> <sig> MSG2

   TCP oobs:

<return> # only works anonymous, same as INFO
INFO [<passwd>] [<public-url>]
LIST [<passwd>] [<public-url>]
PING [<passwd>] [<public-url>]

   UDP messages:

LW6 [<passwd>] <version> <client-id> <from-id> <to-id> <serial> <i> <n> <sig> MSG1
LW6 [<passwd>] <version> <client-id> <from-id> <to-id> <serial> <i> <n> <sig> MSG2

   UDP oobs:

INFO [<passwd>] [<public-url>]
LIST [<passwd>] [<public-url>]
PING [<passwd>] [<public-url>]

   HTTP messages:

   client id & password passed in HTTP headers

/lw6/version/<from-id>/<to-id>/<serial>/<i>/<n>/sig/MSG1
/lw6/version/<from-id>/<to-id>/<serial>/<i>/<n>/sig/MSG2

   HTTP public URLs:

/ -> index.html
/index.html
/favicon.ico
/screenshot.jpeg
/robots.txt
/gpl.txt
/info.txt
/list.txt
/ping.txt

   MSG syntax:

<round> <server-id> <command> <arg1> ... <argN>

   COMMAND examples:
2 1234abcd1234abcd REGISTER
3 1234abcd1234abcd ADD 5678 YELLOW
4 1234abcd1234abcd SET 5678 20 5
10 1234abcd1234abcd NOP
400 1234abcd1234abcd REMOVE 5678
1000 1234abcd1234abcd UNREGISTER

   Sig is a checksum on string:
<from-id> <to-id> <serial> <i> <n> MSG

3.15 Technical HOWTOs
=====================

3.15.1 Release check-list
-------------------------

Summary off all operations required for a release:

   * check the value of 'LW6MAP_RULES_DEFAULT_EXP' and default for
     '--skip-network', which might have been changed will developping.
   * in './src', run './indent.sh'.
   * in './doc', run './gdoc-update.sh', './doxygen-update.sh' and
     './perf-update.sh'.
   * edit 'NEWS' file, in both 'liquidwar6' and 'liquidwar6-extra-maps'.
     Check 'ChangeLog' is OK.
   * update the version history in 'doc/liquidwar6.texi'.
   * update 'debian/changelog' files in both main and extra maps
     packages.
   * run 'make distcheck'...  (at least!)
   * build 'RPM' package ('make -C pkg rpm'), check 'yum install'
     produces a working installation, also check the 'rpm -e' command to
     verify uninstalling is OK too.
   * build '.exe' main binary on Microsoft Windows then go back to
     GNU/Linux and build '.exe' installer ('make -C pkg installer'), go
     back to Microsoft Windows and test the installer (there are often
     problems at this stage because of missing libraries or other
     files...).
   * build '.dmg' Mac OS X disk image, check it works even when '/opt'
     and '/usr/local' or (re)moved, this is important, else execution
     might rely on binaries which are only on the development machine
     and do not ship with game.
   * upload files (doc on
     <http://savannah.gnu.org/maintenance/DownloadArea>), with a command
     like 'rsync --rsh=ssh --recursive --verbose --progress ./X.Y.Z/
     login@dl.sv.nongnu.org:/releases/liquidwar6/X.Y.Z/'.  Each file
     must have its '.sig' corresponding file.
   * update online docs with 'gendocs.sh', carefull, 'liquidwar6.html'
     is suppressed by this, need to re-create it from previous version
     and/or 'index.html' which is the same.
   * update 'index.html', 'liquidwar6.html' and 'liquidwar6.fr.html' so
     that they reflect the latest release.  Check download links are OK.
   * post news on <https://savannah.gnu.org/news/?group=liquidwar6>,
     <http://lists.gnu.org/mailman/listinfo/help-liquidwar6> and
     <http://lists.gnu.org/mailman/listinfo/info-liquidwar6>.
   * after everything did work, upload files on <ftp://ftp.gnu.org/>,
     for instance use 'gnupload --to ftp.gnu.org:liquidwar6
     liquidwar6-X.Y.Z.tar.gz'.

3.15.2 Add a new option
-----------------------

This describes how to add a new option to the game.

   * edit 'src/lib/def/def-list.txt'
   * in 'src/lib/def/def-update.py' run './def-update.py'.  This will
     automatically fill 'src/lib/def/def.h' and 'script/def.scm'.  In
     the code, you should always use 'LW6DEF_<OPTION>' in C and
     'lw6def-<option>' in scheme to refer to the option.  This does help
     avoiding typesetting errors.
   * add the entry to 'src/lib/hlp/hlp-list.c', choose a category for it
   * add the entry to 'src/lib/hlp/hlp-reference.c', give it a type,
     documentation string and default values if needed
   * to sort 'src/lib/def/def-list.txt' a common practice is to fill it
     with the output of 'liquidwar6 --list' once the program has been
     compiled and is aware of the new option.

   Unless this is done, program won't accept the option.

   Some options need more work, for instance:

   * Any option which is a command-line argument needs to be added to
     'src/lib/lw6-options.c'.
   * Any option which is related to the build system (to enable or
     disable some feature) must be referenced in 'src/lib/sys-build.c'
     and also 'src/lw6-funcssys.c' to be callable from scripts.
   * Any option which changes the map rules (any new rule...)  impacts
     the game checksums so these ones need to be updated in
     'src/lib/map/map-test.c', 'src/lib/ker/ker-test.c',
     'src/lib/pil/pil-test.c' and 'src/lib/pil/pil-suite.c'.

3.15.3 Add a new internal library
---------------------------------

This describes how to add a new 'libxyz' internal library:

   * create a new 'src/lib/xyz' directory.  The convention is to use 3
     letters names and prefix every global identifier with 'lw6xyz'.
   * copy 'Makefile.am', 'xyz.h', 'xyz-test.c' and 'xyz-testmain.c' from
     an existing internal library ('libnod' is a good source, it does
     not have complex dependencies).
   * edit 'Makefile.am' to fill requirements, make necessary adjustments
     to other files (many string replaces to make, both lowercase and
     uppercase).
   * add the entry in the 'SUBDIRS' and 'LW6_LIBS' sections of
     'src/lib/Makefile.am'
   * add the entry in the 'AC_CONFIG_FILES' of './configure.ac'.
   * run 'automake' and 'autoconf'.
   * edit 'src/lib/lw6-options.c' and add a call to 'lw6xyz_test()' for
     both "check" and "test" cases.
   * edit 'src/lib/lw6-test.c' and add a reference to the
     'lw6xzy_test()' function.
   * in every internal 'abc' library that depends on 'xyz', edit the
     'lw6abc_test' function so that it contains a reference to
     'lw6xzy_test'.
   * in every internal 'abc' library that depends on 'xyz/xyz.h', edit
     the 'abc/abc.h' header so that it includes 'xzy/xyz.h'.  Also edit
     'src/lib/liquidwar6.h.in'.
   * in every internal 'abc' library that depends on 'libxyz', add a
     reference to '../xyz/libxyz.la' inf the '_LDADD' section.
   * create a new 'src/lib/lw6-funcsxyz.c' file which declares Guile
     bindings for this lib, if needed
   * edit 'doc/gdoc-update.sh' and add the entry for 'xyz'.
   * edit 'doc/Makefile.am' and add 'xyz-gdoc.texi' in 'gdoc_TEXINFOS'.
   * edit 'doc/doxygen-update.sh' and add the entry for 'xyz'.
   * edit 'doc/Makefile.am' and add 'xyz-doxygen.texi' in
     'doxygen_TEXINFOS'.
   * edit 'doc/perf-update.sh' and add the entry for 'xyz'.
   * in './doc', run './gdoc-update.sh', './doxygen-update.sh' and
     './perf-update.sh'.
   * edit 'doc/doxygen/Makefile.am' and add the dependency on
     'src/lib/xyz/xyz.h'.
   * edit 'doc/liquidwar6.texi' to and a new node/section for this
     internal library.
   * edit 'doc/deps.dot' to update dependencies.
   * run './configure && make', fix code if needed.

3.15.4 Add a new module
-----------------------

This describes how to add a new 'mod-ab' module, for instance a new bot,
but gfx, snd, cli or srv backends should work pretty much the same:

   * add a new entry in 'src/lib/bot/Makefile.am'
   * create the subdir 'src/lib/bot/mod-ab', with its 'Makefile.am'
     (inspired from other existing modules)
   * add the entry in 'configure.ac' so that
     'src/lib/bot/mod-ab/Makefile' is generated.
   * edit 'doc/gdoc-update.sh' and add an entry for 'mod-ab'
   * edit 'doc/Makefile.am' and add 'mod-ab-gdoc.texi' in
     'gdoc_TEXINFOS'.
   * edit 'doc/doxygen-update.sh' and add an entry for 'mod-ab'
   * edit 'doc/Makefile.am' and add 'mod-ab-doxygen.texi' in
     'doxygen_TEXINFOS'.
   * type 'touch doc/mod-ab-gdoc.texi doc/mod-ab-doxygen.texi' else
     dependencies checking will fail.
   * in './doc', run './gdoc-update.sh' and './doxygen-update.sh'.
   * edit 'doc/liquidwar6.texi' to add a new node/section for this
     module.
   * edit 'doc/deps.dot' to update dependencies.
   * edit 'src/lib/bot/bot-test.c', change the value of
     'TEST_NB_BACKENDS' and modify the code so that the new 'ab' module
     is tested too.
   * edit 'src/lib/bot/bot-register.c', the code must updated pretty
     much in every place with the conditionnal 'LW6_ALLINONE', you need
     to add the new module.
   * run 'automake', 'autoconf', './configure' and 'make'.

3.16 Using GNU Arch
===================

3.16.1 About GNU Arch
---------------------

Since March, 4th 2010, Liquid War 6 uses GIT (http://git-scm.com/) to
handle source code, track changes, branches, and the rest.  It replaces
the GNU Arch (http://www.gnu.org/software/gnu-arch/) repository.  This
old repository contains all sources up to version 0.0.7beta, following
versions, including 0.0.8beta, must be retrieved from GIT.

   So the following informations only concern those who are interested
in previous versions of the game.  Anybody else - probably you - should
use GIT instead.

   *Note Using GIT::.

   Still, this quick Arch survival guide is kept in the documentation.

   Read the GNU Arch tutorial
(http://www.gnu.org/software/gnu-arch/tutorial/arch.html) to learn how
Arch works.  Note that there are many other source control managers
available, some of which provide functionnalities similar to GNU Arch /
tla.  GNU Arch has been chosen for Liquid War 6 because:
   * it is Free Software,
   * it is not limited to per-file commits like CVS, and supports atomic
     commits involving several files,
   * it is distributed,
   * it enables developpers to sign each of their contributions,
   * it was already available back in 2005.

3.16.2 Getting the latest version from the repository
-----------------------------------------------------

The repository for Liquid War 6 is accessible on
<http://arch.savannah.gnu.org/archives/liquidwar6>.  This is a read-only
access, but with the distributed nature of GNU Arch, it still allows you
to keep track of your own changes, and submit patches.  Accessing it in
read/write mode with sftp requires a Savannah account and special rights
on the Liquid War 6 project.

   Here are typicall commands one can use to get Liquid War 6 source
from the GNU Arch repository:

     tla register-archive http://arch.savannah.gnu.org/archives/liquidwar6
     tla get -A liquidwar6@sv.gnu.org liquidwar6--beta

   All the patches in the archive are signed with GnuPG
(http://www.gnupg.org/), so you can check their authenticity with my
public key (http://www.ufoot.org/ufoot.pub).

   You might need to edit your
'$HOME/.arch-params/signing/=default.check' file and put the following
text in it:
     tla-gpg-check gpg_command="gpg --verify-files -"

3.16.3 Setting up your own arch repository
------------------------------------------

This section is for those who want to hack the game and set up their own
repositories.  This will enable you to keep track of your patches,
package them, and help the core maintainer merging them in the main
repository.

   You can introduce yourself and create a repository by issuing
commands like:

   You can introduce yourself and create a repository by issuing
commands like:

     tla my-id me@home.net
     tla register-archive me@home.net--2008 /home/me/tla-archives

   Then, you can get create your own repository, with a command like:

     tla tag -S liquidwar6@sv.gnu.org/liquidwar6--beta--0.1 me@home.net--2008/liquidwar6--beta--0.4

   The idea is that you create, locally, a depot which has a name that
matches the name on savannah (http://arch.savannah.gnu.org) (this is for
convenience, you could technically give it any name...)  and indicate
that they represent, today, the same thing.

   You can get a working copy of your depot with the command:

     tla get me@home.net--2008/liquidwar6--beta--0.4

   This will create a complete source tree, which you are free to
modify, this is where you should hack.

3.16.4 Synchronizing your repository with upstream releases
-----------------------------------------------------------

To synchronize yourself with upstream developments, go into your copy
(the directory created by 'tla get') and type:

     tla star-merge liquidwar6@sv.gnu.org/liquidwar6--beta--0.1

   This will apply locally all the changes that happened since the last
synchronization.  Of course this is one way to work, you can decide to
cherry pick patches and such stuff, but for most dayly uses, a good'ol
'star-merge' is fine.

   Not that 'star-merge' will only apply patches on your working copy,
not on your repository.  The only way to actually commit the
modifications on the repository is to use the 'commit' command.

3.16.5 Submitting patches
-------------------------

When using Arch, you can of course still send patches created with
'diff', or even send updated files directly, the way you would without
revision control.

   But it can be more convenient to either
   * Send the patches stored in the depot ('/home/me/tla-archives' in
     our example).
   * Make patches using 'tla mkpatch'.

   Here's an example of an 'mkpatch' command, and which will compute the
differences between a previous 'liquidwar6--beta--0.4--patch-2' snapshot
and a not yet commited latest version:

     tla mkpatch {arch}/++pristine-trees/unlocked/liquidwar6/liquidwar6--beta/liquidwar6--beta--0.4/me@home.net--2006/liquidwar6--beta--0.4--patch-2 . my-patch

   This will create a 'my-patch' directory, which can be gzipped and
sent by mail.

3.16.6 Recover from broken lock
-------------------------------

Sometimes, when signing a patch, you might enter the wrong passphrase
several times, or you might press CTRL+D inadvertantly.  In that case,
tla will be in a half-broken state, telling you it can't acquire
revision lock...  A quick workarround for this is to go to the depot,
find the latest patch, and in this repository, create the following
folders:
     ++revision-lock/+contents
   Both are directories, note the two ++ and the single +.  the
'+contents' directory can be empty.  Once you've done this, try to
re-commit.

3.17 Using GIT
==============

3.17.1 About GIT
----------------

There's no CVS or Subversion (AKA "SVN") source depot for Liquid War 6.
Instead, a GIT (http://git-scm.com/) depot is used.  GIT has many
advantages over other source control managers (SCM), among them, it's
distributed, like GNU Arch (http://www.gnu.org/software/gnu-arch).

   You can find interesting informations on GIT here:
   * <http://git-scm.com/documentation>
   * <http://savannah.gnu.org/maintenance/UsingGit>
   * <http://savannah.gnu.org/git/?group=liquidwar6>

3.17.2 Getting the latest source
--------------------------------

Simply install git and run the following command:

     git clone git://git.sv.gnu.org/liquidwar6.git

   If you are behing a firewall and can't have direct TCP/IP access:

     git clone http://git.sv.gnu.org/r/liquidwar6.git

   Additionnally, source can be browsed online here:
<http://git.savannah.gnu.org/cgit/liquidwar6.git>

3.17.3 Developper access
------------------------

You need an ssh access on Savannah (http://savannah.gnu.org/) and
appropriate rights on the project, then you can type:

     git clone login@git.sv.gnu.org:/srv/git/liquidwar6.git

3.17.4 Submitting patches
-------------------------

If you have developper access to the project, then a simply 'git push'
will commit your changes.

   If not (that is, if you checked out anonymously using 'git clone
git://git.sv.gnu.org/liquidwar6.git' for instance, you can still submit
patches.  Follow these steps:
   * edit the code, make your patches, commit to your local GIT tree
   * run 'git format-patch -p origin' this command will generate
     '.patch' files, one for each of you commits, which you can send by
     email.  They can be easily integrated in the main source tree by
     using 'git apply <file.patch>'.

   Note that you can need to run 'git format-patch -p master' (with
'master' instead of 'origin') it not using a fresh checkout.  Also
consider adding the '--stdout' switch, eg 'git format-patch -p master
--stdout > my-changes.patch' if you're not using a fresh checkout.

3.18 Jenkins builds
===================

Liquid War 6 uses Jenkins (http://jenkins-ci.org/) for continuous
integration.

   Each time a commit is done on the main GIT source tree, a build is
triggered.  The list of builds, their status, is available on:

   * all Jenkins jobs on ufoot.org (http://www.ufoot.org/jenkins/).
   * liquidwar6 Jenkins job on ufoot.org
     (http://www.ufoot.org/jenkins/job/liquidwar6/).

   It's interesting, among other things, to look at the log produced
when the game is built, as it contains the test suite output, and can
provide usefull informations of what is supposed to happen when the game
is built correctly, and what happens when things go wrong.

4 Reference
***********

This chapter is a technical reference.  Most of its content is
self-generated by the program itself.  That is to say, most if its
content is already available to you if you have the game installed.
Running 'liquidwar6 --list' and 'liquidwar6 --about=<keyword>' is very
likely to give you the very same informations, the advantage being that
you'll be sure the information is up-to-date and corresponds to the
exact version of the program you have.  However, publishing this in a
reader-friendly way is convenient, plus it enables web search engines to
harvest the content.

4.1 Basic options
=================

4.1.1 about
-----------

 -- Command-line option: '--about=<value>'
     Type: string

     Will allow you to get informations about a given keyword.  Let's
     say that, for instance, you want informations about the keyword
     'map-path'.  Simply run 'liquidwar6 -about=map-path'.  Note that
     this internal self-documentation system can describe command line
     switches as well as XML config file parameters or environment
     variables, and even some Guile script functions.  The '-list'
     command line switch will give you the list of all available
     keywords.

4.1.2 audit
-----------

 -- Command-line option: '--audit'
     Display all path values, defaults and current settings.  This
     output is very usefull to track down problems such as missing
     directories, broken installations.  If you get an error message
     that suggests some file is missing, then give this option a try.

4.1.3 copyright
---------------

 -- Command-line option: '--copyright'
     Returns the copyright notice for the program.

4.1.4 credits
-------------

 -- Command-line option: '--credits'
     Gives hopefully extensive information on who contributed to the
     game.

4.1.5 debug
-----------

 -- Command-line option: '--debug'
     Enables debug mode.  This will turn on maximum log information, and
     display everything on stderr, even messages which are normally only
     stored in the log file.

4.1.6 defaults
--------------

 -- Command-line option: '--defaults'
     Clears the config file and run the game with default settings.  Use
     this if you suspect you have broken something by tweaking user
     settings, or when upgrading the game to a new version.

4.1.7 help
----------

 -- Command-line option: '--help'
     Returns a short help for the program.

4.1.8 host
----------

 -- Command-line option: '--host'
     Display all known system host properties, including os and cpu
     informations.

4.1.9 list
----------

 -- Command-line option: '--list'
     Returns the list of all keywords which can be queried for
     information.  This includes command-line options, environment
     variables, and so on.  This is the companion option of '-about'.
     Results obtained with '-list' can be passed to '-about'.

4.1.10 modules
--------------

 -- Command-line option: '--modules'
     Tells which modules have been enabled when the game was compiled.
     It's still possible to add or remove modules afterwards, but this
     option allows you to know how things were at first.

4.1.11 pedigree
---------------

 -- Command-line option: '--pedigree'
     Display all build values, these are general constants which can
     help debugging, tracing what binary you are running, and so on.
     It's a good idea to take a look at the output of 'pedigree' if you
     have problems running the game.

4.1.12 test
-----------

 -- Command-line option: '--test'
     Runs a (hopefully) complete test suite which will call most
     internal Liquid War 6 functions and check out wether they work, in
     a simple context, without any game interference.  Usefull for
     troubleshooting.

4.1.13 version
--------------

 -- Command-line option: '--version'
     Returns the version of the program, as defined by the GNU Coding
     Standards.

4.2 Doc options
===============

4.2.1 example-hints-xml
-----------------------

 -- Command-line option: '--example-hints-xml'
     Dumps on stdout an example hints.xml file.  Such a file is normally
     shipped with the game.  It is indeed generated using this command.

4.2.2 example-rules-xml
-----------------------

 -- Command-line option: '--example-rules-xml'
     Dumps on stdout an example options.xml file.  Such a file is
     normally shipped with the game.  It is indeed generated using this
     command.

4.2.3 example-style-xml
-----------------------

 -- Command-line option: '--example-style-xml'
     Dumps on stdout an example style.xml file.  Such a file is normally
     shipped with the game.  It is indeed generated using this command.

4.2.4 example-teams-xml
-----------------------

 -- Command-line option: '--example-teams-xml'
     Dumps on stdout an example teams.xml file.  Such a file is normally
     shipped with the game.  It is indeed generated using this command.

4.2.5 list-advanced
-------------------

 -- Command-line option: '--list-advanced'
     List advanced options which can be used for fine-tuning the game.

4.2.6 list-aliases
------------------

 -- Command-line option: '--list-aliases'
     List the keyword aliases.  These are here for convenience.

4.2.7 list-doc
--------------

 -- Command-line option: '--list-doc'
     List documentation-related command line options.  These commands
     allow you to list all the keywords related to a given domain.

4.2.8 list-funcs
----------------

 -- Command-line option: '--list-funcs'
     List the C-functions which are exported to Guile, thus usable in
     scripts.

4.2.9 list-graphics
-------------------

 -- Command-line option: '--list-graphics'
     List graphics options (resolution, fullscreen...).

4.2.10 list-hooks
-----------------

 -- Command-line option: '--list-hooks'
     List user-modifiable hooks.

4.2.11 list-input
-----------------

 -- Command-line option: '--list-input'
     List input (AKA controls) related options.  Use these to change
     keyboard, joystick and mouse settingds.

4.2.12 list-map
---------------

 -- Command-line option: '--list-map'
     List map-related entries, excluding rules.xml, hints.xml and
     style.xml entries.

4.2.13 list-map-hints
---------------------

 -- Command-line option: '--list-map-hints'
     List 'hints.xml' entries.  These parameters enable you to modify
     the behavior of the map loader.

4.2.14 list-map-rules
---------------------

 -- Command-line option: '--list-map-rules'
     List 'options.xml' entries.  These parameters enable you to modify
     the gameplay.

4.2.15 list-map-style
---------------------

 -- Command-line option: '--list-map-style'
     List 'style.xml' entries.  These parameters enable you to modify
     the aspect of the game.

4.2.16 list-map-teams
---------------------

 -- Command-line option: '--list-map-teams'
     List 'teams.xml' entries.  These parameters enable you to specify
     which teams should play on the map.

4.2.17 list-network
-------------------

 -- Command-line option: '--list-network'
     List network options.

4.2.18 list-path
----------------

 -- Command-line option: '--list-path'
     List parameters which allow you to override the defaults of the
     game, and force the game your own file paths and directories.

4.2.19 list-players
-------------------

 -- Command-line option: '--list-players'
     List player-related entries, that is to say 'who plays'.

4.2.20 list-quick
-----------------

 -- Command-line option: '--list-quick'
     List quick help entries, this includes the GNU standard options and
     a few troubleshooting tools.

4.2.21 list-show
----------------

 -- Command-line option: '--list-show'
     List command-line options which begin with '-show-...'.  These will
     display on the console many internal parameters.  Usefull when
     debugging.

4.2.22 list-sound
-----------------

 -- Command-line option: '--list-sound'
     List sound options (volume...).

4.2.23 list-team-colors
-----------------------

 -- Command-line option: '--list-team-colors'
     List the team colors, there should be 10 of them

4.2.24 list-weapons
-------------------

 -- Command-line option: '--list-weapons'
     List the available weapons.

4.3 Show options
================

4.3.1 show-build-abs-srcdir
---------------------------

 -- Command-line option: '--show-build-abs-srcdir'
     Shows the top source directory on the machine where the binary was
     compiled, as an absolute path.

4.3.2 show-build-bin-id
-----------------------

 -- Command-line option: '--show-build-bin-id'
     Shows the internal 'bin-id' value.  This value does not mean
     anything in itself but it's supposed to change each time you
     compile the game.

4.3.3 show-build-bugs-url
-------------------------

 -- Command-line option: '--show-build-bugs-url'
     Shows the URL to make bug reports.

4.3.4 show-build-cflags
-----------------------

 -- Command-line option: '--show-build-cflags'
     Shows what value you should put in 'CFLAGS' (environment variable)
     if you want to compile programs that use Liquid War 6 as a library,
     and include 'liquidwar6.h'.

4.3.5 show-build-codename
-------------------------

 -- Command-line option: '--show-build-codename'
     Shows the codename associated with this version, generally the name
     of someone famous who is war-related (a general, an emperor...).

4.3.6 show-build-configure-args
-------------------------------

 -- Command-line option: '--show-build-configure-args'
     Shows the arguments that have been passed to the GNU Autoconf
     './configure' script when building the program.  This can be very
     usefull if you want to know how the program has been built.

4.3.7 show-build-copyright
--------------------------

 -- Command-line option: '--show-build-copyright'
     Shows a very short copyright notice.

4.3.8 show-build-datadir
------------------------

 -- Command-line option: '--show-build-datadir'
     Shows the 'datadir' value as passed to the GNU Autoconf
     './configure' script when compiling the program.  Default is
     '/usr/local/share'.  This is the generic, non Liquid War 6 specific
     data directory.  Liquid War 6 related data is stored elsewhere
     (usually in a sub-directory) see the 'data-dir' switch for more
     information.  'datadir' is not 'data-dir'.  That's the point.

4.3.9 show-build-date
---------------------

 -- Command-line option: '--show-build-date'
     Shows the date when the binary was compiled.

4.3.10 show-build-docdir
------------------------

 -- Command-line option: '--show-build-docdir'
     Shows the 'docdir' value as passed to the GNU Autoconf
     './configure' script when compiling the program.  Default is
     '/usr/local/share/doc/liquidwar6'.

4.3.11 show-build-enable-allinone
---------------------------------

 -- Command-line option: '--show-build-enable-allinone'
     Shows wether the 'allinone' option has been chosen when building
     the game.  This depends on parameters passed to './configure'.

4.3.12 show-build-enable-console
--------------------------------

 -- Command-line option: '--show-build-enable-console'
     Shows wether the console has been enabled when building the game.
     This depends on parameters passed to './configure' and also on the
     presence of ncurses and readline.

4.3.13 show-build-enable-fullstatic
-----------------------------------

 -- Command-line option: '--show-build-enable-fullstatic'
     Shows wether the 'fullstatic' option has been chosen when building
     the game.  This depends on parameters passed to './configure'.

4.3.14 show-build-enable-gcov
-----------------------------

 -- Command-line option: '--show-build-enable-gcov'
     Shows wether the game was build with suitable informations for
     gcov.  This depends on parameters passed to './configure'.

4.3.15 show-build-enable-gprof
------------------------------

 -- Command-line option: '--show-build-enable-gprof'
     Shows wether the game was build with suitable informations for
     gprof.  This depends on parameters passed to './configure'.

4.3.16 show-build-enable-gtk
----------------------------

 -- Command-line option: '--show-build-enable-gtk'
     Shows wether GTK+ support has been enabled when building the game.
     This depends on parameters passed to './configure' and also on the
     presence of GTK+ headers and libs.  It uses pkg-config to detect
     it.

4.3.17 show-build-enable-instrument
-----------------------------------

 -- Command-line option: '--show-build-enable-instrument'
     Shows wether the game was build with the '-finstrument-functions'
     GCC switch.  This depends on parameters passed to './configure'.

4.3.18 show-build-enable-mod-caca
---------------------------------

 -- Command-line option: '--show-build-enable-mod-caca'
     Shows wether the mod-caca graphical backend has been enabled when
     building the game.  This depends on parameters passed to
     './configure' and also on the presence of libcaca related
     libraries.

4.3.19 show-build-enable-mod-csound
-----------------------------------

 -- Command-line option: '--show-build-enable-mod-csound'
     Shows wether the mod-csound audio backend has been enabled when
     building the game.  This depends on parameters passed to
     './configure' and also on the presence of the csound library.

4.3.20 show-build-enable-mod-gl1
--------------------------------

 -- Command-line option: '--show-build-enable-mod-gl1'
     Shows wether the mod-gl1 graphical backend has been enabled when
     building the game.  This depends on parameters passed to
     './configure' and also on the presence of SDL and OpenGL related
     libraries.

4.3.21 show-build-enable-mod-gles2
----------------------------------

 -- Command-line option: '--show-build-enable-mod-gles2'
     Shows wether the mod-gles2 graphical backend has been enabled when
     building the game.  This depends on parameters passed to
     './configure' and also on the presence of SDL and OpenGL ES related
     libraries.

4.3.22 show-build-enable-mod-http
---------------------------------

 -- Command-line option: '--show-build-enable-mod-http'
     Shows wether the mod-http network backend has been enabled when
     building the game.  This depends on parameters passed to
     './configure' and also on the presence of libCurl.

4.3.23 show-build-enable-mod-ogg
--------------------------------

 -- Command-line option: '--show-build-enable-mod-ogg'
     Shows wether the mod-ogg audio backend has been enabled when
     building the game.  This depends on parameters passed to
     './configure' and also on the presence of SDL and related
     libraries.

4.3.24 show-build-enable-mod-soft
---------------------------------

 -- Command-line option: '--show-build-enable-mod-soft'
     Shows wether the mod-soft graphical backend has been enabled when
     building the game.  This depends on parameters passed to
     './configure' and also on the presence of SDL related libraries.

4.3.25 show-build-enable-openmp
-------------------------------

 -- Command-line option: '--show-build-enable-openmp'
     Shows wether the program was built with OpenMP support.  This
     depends on parameters passed to './configure'.

4.3.26 show-build-enable-optimize
---------------------------------

 -- Command-line option: '--show-build-enable-optimize'
     Shows wether the 'optimize' option has been chosen when building
     the game.  This depends on parameters passed to './configure'.

4.3.27 show-build-enable-paranoid
---------------------------------

 -- Command-line option: '--show-build-enable-paranoid'
     Shows wether the game was build with paranoid memory management.
     This is for debugging purposes, the default already includes some
     controls, with turned it's really...  paranoid.

4.3.28 show-build-enable-profiler
---------------------------------

 -- Command-line option: '--show-build-enable-profiler'
     Shows wether the game was build with Google Profiler support.  This
     depends on parameters passed to './configure'.

4.3.29 show-build-enable-valgrind
---------------------------------

 -- Command-line option: '--show-build-enable-valgrind'
     Shows wether the game was build with valgrind later use in mind.
     This depends on parameters passed to './configure'.

4.3.30 show-build-endianness
----------------------------

 -- Command-line option: '--show-build-endianness'
     Returns the endianness.  'little' corresponds to x86-like systems,
     'big' to ppc-like systems.

4.3.31 show-build-gcc-version
-----------------------------

 -- Command-line option: '--show-build-gcc-version'
     Returns the version of the GNU C compiler which was used to compile
     the program.

4.3.32 show-build-gnu
---------------------

 -- Command-line option: '--show-build-gnu'
     Returns 1 (true) if host OS is a GNU system, or at least has been
     considered as such when compiling, 0 (false) if not.

4.3.33 show-build-gp2x
----------------------

 -- Command-line option: '--show-build-gp2x'
     Returns 1 (true) if host is a GP2X, 0 (false) if not.

4.3.34 show-build-home-url
--------------------------

 -- Command-line option: '--show-build-home-url'
     Shows the URL of the program, its homepage.

4.3.35 show-build-host-cpu
--------------------------

 -- Command-line option: '--show-build-host-cpu'
     Shows the host CPU, as defined by 'host_cpu' in GNU Autoconf.

4.3.36 show-build-host-os
-------------------------

 -- Command-line option: '--show-build-host-os'
     Shows the host OS, as defined by 'host_os' in GNU Autoconf.

4.3.37 show-build-hostname
--------------------------

 -- Command-line option: '--show-build-hostname'
     Shows the name of the host where the binary was compiled.

4.3.38 show-build-includedir
----------------------------

 -- Command-line option: '--show-build-includedir'
     Shows the 'includedir' value as passed to the GNU Autoconf
     './configure' script when compiling the program.  Default is
     '/usr/local/include'.

4.3.39 show-build-ldflags
-------------------------

 -- Command-line option: '--show-build-ldflags'
     Shows what value you should put in 'LDFLAGS' (environment variable)
     if you want to link programs against libliquidwar6.

4.3.40 show-build-libdir
------------------------

 -- Command-line option: '--show-build-libdir'
     Shows the 'libdir' value as passed to the GNU Autoconf
     './configure' script when compiling the program.  Default is
     '/usr/local/lib'.  This is the generic, non Liquid War 6 specific
     library directory.  Dedicated Liquid War 6 modules are stored
     elsewhere (usually in a sub-directory) see the 'mod-dir' switch for
     more information.

4.3.41 show-build-license
-------------------------

 -- Command-line option: '--show-build-license'
     Shows the license of the program (GNU GPL v3 or later).

4.3.42 show-build-localedir
---------------------------

 -- Command-line option: '--show-build-localedir'
     Shows the 'localedir' value as passed to the GNU Autoconf
     './configure' script when compiling the program.  Default is
     '/usr/local/share/locale'.

4.3.43 show-build-mac-os-x
--------------------------

 -- Command-line option: '--show-build-mac-os-x'
     Returns 1 (true) if host OS is Mac OS X, 0 (false) if not.

4.3.44 show-build-md5sum
------------------------

 -- Command-line option: '--show-build-md5sum'
     Shows the MD5 checksum, which has been calculated from the C source
     files.  Complementary with 'show-build-stamp'.

4.3.45 show-build-ms-windows
----------------------------

 -- Command-line option: '--show-build-ms-windows'
     Returns 1 (true) if host OS is Microsoft Windows, 0 (false) if not.

4.3.46 show-build-package-id
----------------------------

 -- Command-line option: '--show-build-package-id'
     Shows the package tarname with its version, that is,
     'liquidwar6-<version>

4.3.47 show-build-package-name
------------------------------

 -- Command-line option: '--show-build-package-name'
     Shows the package name, that is, 'Liquid War 6'.

4.3.48 show-build-package-string
--------------------------------

 -- Command-line option: '--show-build-package-string'
     Shows the package string, that is, 'Liquid War 6 <version>

4.3.49 show-build-package-tarname
---------------------------------

 -- Command-line option: '--show-build-package-tarname'
     Shows the package tarname, that is, liquidwar6.

4.3.50 show-build-pointer-size
------------------------------

 -- Command-line option: '--show-build-pointer-size'
     Returns the pointer size, in bytes.  Should be 4 on 32-bit systems
     and 8 on 64-bit systems.

4.3.51 show-build-prefix
------------------------

 -- Command-line option: '--show-build-prefix'
     Shows the 'prefix' value as passed to the GNU Autoconf
     './configure' script when compiling the program.  Default is
     '/usr/local'.

4.3.52 show-build-stamp
-----------------------

 -- Command-line option: '--show-build-stamp'
     Shows the build stamp.  A very usefull value, more precise than the
     version to track down binaries.  It is incremented each time the
     core C code is updated.  It won't reflect all the programs for it
     does not take scripts in account, but if you are running a
     work-in-progress version, it might be very convenient to use this
     to know what your are running exactly.  It's also used as the
     revision number (the third number afer MAJOR.MINOR).

4.3.53 show-build-time
----------------------

 -- Command-line option: '--show-build-time'
     Shows the time when the binary was compiled.

4.3.54 show-build-top-srcdir
----------------------------

 -- Command-line option: '--show-build-top-srcdir'
     Shows the top source directory on the machine where the binary was
     compiled, as a (possibly) relative path.

4.3.55 show-build-unix
----------------------

 -- Command-line option: '--show-build-unix'
     Returns 1 (true) if host OS is a UNIX system, or at least has been
     considered as such when compiling, 0 (false) if not.

4.3.56 show-build-version
-------------------------

 -- Command-line option: '--show-build-version'
     Shows the version.  Note that this is different from the standard
     GNU 'version' command line option which shows a complete message
     with a short copyright notice.  This one will just return the
     version, without the package tarname or anything else.

4.3.57 show-build-version-base
------------------------------

 -- Command-line option: '--show-build-version-base'
     Shows the version base.  This is basically MAJOR.MINOR and
     determines the level of compatibility of the program.  Two programs
     with the same base version should be able to communicate on the
     network, share data files and even binary modules if on the same
     platform.

4.3.58 show-build-version-major
-------------------------------

 -- Command-line option: '--show-build-version-major'
     Shows the major version number.  This is just used to differenciate
     alpha/beta releases (using 0) from stable releases (using 6).

4.3.59 show-build-version-minor
-------------------------------

 -- Command-line option: '--show-build-version-minor'
     Shows the minor version number.  This is manually increased at each
     significant, public release of the game.

4.3.60 show-build-x86
---------------------

 -- Command-line option: '--show-build-x86'
     Tells wether the CPU belongs to the x86 family.

4.3.61 show-config-file
-----------------------

 -- Command-line option: '--show-config-file'
     Shows the config file path.  Default is
     '$HOME/.liquidwar6/config.xml'.

4.3.62 show-cwd
---------------

 -- Command-line option: '--show-cwd'
     Shows the current working directory, the value that the pwd command
     would return.

4.3.63 show-data-dir
--------------------

 -- Command-line option: '--show-data-dir'
     Shows the data directory path.  This is where the games searches
     for most of its data,the most important exception being maps, which
     are stored elsewhere.  Default is
     '/usr/local/share/liquidwar6-<version>/data'.

4.3.64 show-default-config-file
-------------------------------

 -- Command-line option: '--show-default-config-file'
     Shows the default config file path.  Default is
     '$HOME/.liquidwar6/config.xml'.

4.3.65 show-default-data-dir
----------------------------

 -- Command-line option: '--show-default-data-dir'
     Shows the default data directory path.  This is where the games
     searches for most of its data,the most important exception being
     maps, which are stored elsewhere.  Default is
     '/usr/local/share/liquidwar6-<version>/data'.

4.3.66 show-default-log-file
----------------------------

 -- Command-line option: '--show-default-log-file'
     Shows the default log file path.  Default is
     '$HOME/.liquidwar6/log.csv'.

4.3.67 show-default-map-dir
---------------------------

 -- Command-line option: '--show-default-map-dir'
     Shows the default map directory.  This is where builtin maps are
     stored.  Default is '/usr/local/share/liquidwar6-<version>/map'.

4.3.68 show-default-map-path
----------------------------

 -- Command-line option: '--show-default-map-path'
     Shows the default map search path.  This is where the game searches
     for maps.  It's the combination of command-line arguments and
     builtin paths.  Might return more directories than the one
     specified in a single 'map-path=dir1:dir2' argument.

4.3.69 show-default-mod-dir
---------------------------

 -- Command-line option: '--show-default-mod-dir'
     Shows the default module directory path.  This is where all
     dynamically loaded modules are stored.  Default is
     '/usr/local/lib/liquidwar6-<version>'.

4.3.70 show-default-music-dir
-----------------------------

 -- Command-line option: '--show-default-music-dir'
     Shows the default music directory.  This is where builtin musics
     are stored.  Default is
     '/usr/local/share/liquidwar6-<version>/music'.

4.3.71 show-default-music-path
------------------------------

 -- Command-line option: '--show-default-music-path'
     Shows the default music search path.  This is where the game
     searches for musics.  It's the combination of command-line
     arguments and builtin paths.  Might return more directories than
     the one specified in a single 'music-path=dir1:dir2' argument.

4.3.72 show-default-prefix
--------------------------

 -- Command-line option: '--show-default-prefix'
     Shows the default prefix used.  This should logically be the value
     passed to the GNU Autoconf ./configure script when building the
     game.  Most other path are deduced from this one.  Default is
     '/usr/local'.

4.3.73 show-default-script-file
-------------------------------

 -- Command-line option: '--show-default-script-file'
     Shows the default main script file path.  This file is very
     important, since the program is more or less a hudge scheme
     interpreter, and this file is the file loaded by Guile.  In short,
     it is the main program.  Default is
     '/usr/local/share/liquidwar6-<version>/script/liquidwar6.scm'.

4.3.74 show-default-user-dir
----------------------------

 -- Command-line option: '--show-default-user-dir'
     Shows the default user directory path.  This is where run-time
     data, config files, log files, are stored.  Default is
     '$HOME/.liquidwar6/'.

4.3.75 show-log-file
--------------------

 -- Command-line option: '--show-log-file'
     Shows the log file path.  Default is '$HOME/.liquidwar6/log.csv'.

4.3.76 show-map-dir
-------------------

 -- Command-line option: '--show-map-dir'
     Shows the map directory.  This is where builtin maps are stored.
     Default is '/usr/local/share/liquidwar6-<version>/map'.

4.3.77 show-map-path
--------------------

 -- Command-line option: '--show-map-path'
     Shows the map search path.  This is where the game searches for
     maps.  It's the combination of command-line arguments and builtin
     paths.  Might return more directories than the one specified in a
     single 'map-path=dir1:dir2' argument.

4.3.78 show-mod-dir
-------------------

 -- Command-line option: '--show-mod-dir'
     Shows the module directory path.  This is where all dynamically
     loaded modules are stored.  Default is
     '/usr/local/lib/liquidwar6-<version>'.

4.3.79 show-music-dir
---------------------

 -- Command-line option: '--show-music-dir'
     Shows the music directory.  This is where builtin maps are stored.
     Default is '/usr/local/share/liquidwar6-<version>/music'.

4.3.80 show-music-path
----------------------

 -- Command-line option: '--show-music-path'
     Shows the music search path.  This is where the game searches for
     musics.  It's the combination of command-line arguments and builtin
     paths.  Might return more directories than the one specified in a
     single 'music-path=dir1:dir2' argument.

4.3.81 show-prefix
------------------

 -- Command-line option: '--show-prefix'
     Shows the prefix used.  This should logically be the value passed
     to the GNU Autoconf ./configure script when building the game.
     Most other path are deduced from this one.  Default is
     '/usr/local'.

4.3.82 show-run-dir
-------------------

 -- Command-line option: '--show-run-dir'
     Shows the run directory, usually the path where the binary is.  It
     depends on how and where the program is launched.  It is guessed
     from the argc/argv values at runtime.

4.3.83 show-script-file
-----------------------

 -- Command-line option: '--show-script-file'
     Shows the main script file path.  This file is very important,
     since the program is more or less a hudge scheme interpreter, and
     this file is the file loaded by Guile.  In short, it is the main
     program.  Default is
     '/usr/local/share/liquidwar6-<version>/script/liquidwar6.scm'.

4.3.84 show-user-dir
--------------------

 -- Command-line option: '--show-user-dir'
     Shows the user directory path.  This is where run-time data, config
     files, log files, are stored.  Default is '$HOME/.liquidwar6/'.

4.4 Path options
================

4.4.1 config-file
-----------------

 -- Command-line option: '--config-file'
     Type: string

     Default value: $HOME/.liquidwar6/config.xml

     Set the config file path.  This enables you to use whatever config
     file you like, keeping all other informations in the same place.

4.4.2 data-dir
--------------

 -- Command-line option: '--data-dir'
     Type: string

     Default value: /usr/local/share/liquidwar6-<version>/data

     Set the data directory.  By changing ths value you'll be able to
     use an alternative data directory.

4.4.3 log-file
--------------

 -- Command-line option: '--log-file=<value>'
 -- Environment variable: 'LW6_LOG_FILE'
 -- XML key: 'log-file'
     Type: string

     Default value: $HOME/.liquidwar6/log.csv

     Set the log file path.  This enables you to use whatever log file
     you like, keeping all other informations in the same place.

4.4.4 map-dir
-------------

 -- Command-line option: '--map-dir'
     Type: string

     Default value: /usr/local/share/liquidwar6-<version>/map

     Set the map directory path.  By changing this value you'll be able
     to play with your own maps in your own directory.  Note that there
     are other ways to achieve that, but using this option will work.
     However, a side effect is that you might not see builtin maps
     anymore.

4.4.5 map-path
--------------

 -- Command-line option: '--map-path=<value>'
 -- Environment variable: 'LW6_MAP_PATH'
 -- XML key: 'map-path'
     Type: string

     Default value:
     $HOME/.liquidwar6/map:/usr/local/share/liquidwar6-<version>/map

     Set the map search path.  By changing this value you'll be able to
     play with your own maps in your own directory.  This is different
     from 'map-dir', since it includes 'map-dir', plus it adds a number
     of other search paths.  Unlike most other parameters, the values
     given from the command-line, from the environment variables, or
     from the config file, are not overwritten, but appended.  That is
     to say if you specify a 'map-path' with the command-line argument
     'map-path=path', but also define the 'LW6_MAP_PATH' value and
     finally edit 'config.xml' to change the 'map-path' entry in it,
     you'll end up with the game searching for maps in all these
     directories.  Additionnally, 'map-dir' and '<user-dir>/map' will
     always be in the list.  Any given value can itself include several
     pathes, separated by the path separator.  This separator is ':' on
     GNU/Linux, and ';' on Microsoft Windows.  For instance, on a
     GNU/Linux box, you could use the command-line argument
     'map-path=/foo/bar/map:/home/user/map/:/map'.

4.4.6 mod-dir
-------------

 -- Command-line option: '--mod-dir'
     Type: string

     Default value: /usr/local/lib/liquidwar6-<version>

     Set the module directory path.  By changing this you will load
     dynamic shared libraries (game specific modules such as the
     graphical backend) from an alternative place.  Use this at your own
     risks, for there can always be a binary incompatibility.  You've
     been warned.

4.4.7 music-dir
---------------

 -- Command-line option: '--music-dir=<value>'
 -- Environment variable: 'LW6_MUSIC_DIR'
 -- XML key: 'music-dir'
     Type: string

     Default value: /usr/local/share/liquidwar6-<version>/music

     Set the music directory path.  By changing this value you'll be
     able to use your own musics in your own directory.  Note that there
     are other ways to achieve that, but using this option will work.
     The major side effect is that using this option, you really replace
     the existing builtin musics by your own.  If you simply want to add
     musics you can store them in $HOME/.liquidwar6/music or in the map
     directory itself.

4.4.8 music-path
----------------

 -- Command-line option: '--music-path=<value>'
 -- Environment variable: 'LW6_MUSIC_PATH'
 -- XML key: 'music-path'
     Type: string

     Default value:
     $HOME/.liquidwar6/music:/usr/local/share/liquidwar6-<version>/music

     Set the music search path.  By changing this value you'll be able
     to play with your own musics in your own directory.  This is
     different from 'music-dir', since it includes 'music-dir', plus it
     adds a number of other search paths.  Unlike most other parameters,
     the values given from the command-line, from the environment
     variables, or from the config file, are not overwritten, but
     appended.  That is to say if you specify a 'music-path' with the
     command-line argument 'music-path=path', but also define the
     'LW6_MUSIC_PATH' value and finally edit 'config.xml' to change the
     'music-path' entry in it, you'll end up with the game searching for
     musics in all these directories.  Additionnally, 'music-dir' and
     '<user-dir>/music' will always be in the list.  Any given value can
     itself include several pathes, separated by the path separator.
     This separator is ':' on GNU/Linux, and ';' on Microsoft Windows.
     For instance, on a GNU/Linux box, you could use the command-line
     argument 'music-path=/foo/bar/music:/home/user/music/:/music'.

4.4.9 prefix
------------

 -- Command-line option: '--prefix'
     Type: string

     Default value: /usr/local

     Override the prefix value given to the GNU Autoconf ./configure
     script when building the game.  Not all path will be changed, some
     of them might remain the same, for instance message translations
     (localedir).  But most game-specific data including maps, graphics,
     sounds, will be searched according to the new given parameter.

4.4.10 script-file
------------------

 -- Command-line option: '--script-file'
     Type: string

     Default value:
     /usr/local/share/liquidwar6-<version>/script/liquidwar6.scm

     Set the main script file path.  This file is very important, since
     the program is more or less a hudge scheme interpreter, and this
     file is the file loaded by Guile.  In short, it is the main
     program.

4.4.11 user-dir
---------------

 -- Command-line option: '--user-dir=<value>'
 -- Environment variable: 'LW6_USER_DIR'
 -- XML key: 'user-dir'
     Type: string

     Default value: $HOME/.liquidwar6

     Set the user directory path.  This is where run-time data, config
     files, log files, are stored.  If you override this value, other
     parameters such as where the config and log files reside, will
     change.

4.5 Players options
===================

4.5.1 player1-control
---------------------

 -- Command-line option: '--player1-control=<value>'
 -- Environment variable: 'LW6_PLAYER1_CONTROL'
 -- XML key: 'player1-control'
     Type: string

     Default value: mouse

     Control for the first player, must be mouse, keyboard, joystick1,
     joystick2 or custom.

4.5.2 player1-name
------------------

 -- Command-line option: '--player1-name=<value>'
 -- Environment variable: 'LW6_PLAYER1_NAME'
 -- XML key: 'player1-name'
     Type: string

     Default value: <username>

     Name of the first player, the player used by default.  A default
     value is provided, you can of course, change it at will.

4.5.3 player1-status
--------------------

 -- Command-line option: '--player1-status=<value>'
 -- Environment variable: 'LW6_PLAYER1_STATUS'
 -- XML key: 'player1-status'
     Type: boolean

     Default value: true

     Status of the first player, true if player is activated, false if
     idle.

4.5.4 player2-control
---------------------

 -- Command-line option: '--player2-control=<value>'
 -- Environment variable: 'LW6_PLAYER2_CONTROL'
 -- XML key: 'player2-control'
     Type: string

     Default value: keyboard

     Control for the second player, must be mouse, keyboard, joystick1,
     joystick2 or custom.

4.5.5 player2-name
------------------

 -- Command-line option: '--player2-name=<value>'
 -- Environment variable: 'LW6_PLAYER2_NAME'
 -- XML key: 'player2-name'
     Type: string

     Default value: player2-<hostname>

     Name of the second player.  A default value is provided, you'll
     certainly want to change it.

4.5.6 player2-status
--------------------

 -- Command-line option: '--player2-status=<value>'
 -- Environment variable: 'LW6_PLAYER2_STATUS'
 -- XML key: 'player2-status'
     Type: boolean

     Default value: true

     Status of the second player, true if player is activated, false if
     idle.

4.5.7 player3-control
---------------------

 -- Command-line option: '--player3-control=<value>'
 -- Environment variable: 'LW6_PLAYER3_CONTROL'
 -- XML key: 'player3-control'
     Type: string

     Default value: joystick1

     Control for the third player, must be mouse, keyboard, joystick1,
     joystick2 or custom.

4.5.8 player3-name
------------------

 -- Command-line option: '--player3-name=<value>'
 -- Environment variable: 'LW6_PLAYER3_NAME'
 -- XML key: 'player3-name'
     Type: string

     Default value: player3-<hostname>

     Name of the third player.  A default value is provided, you'll
     certainly want to change it.

4.5.9 player3-status
--------------------

 -- Command-line option: '--player3-status=<value>'
 -- Environment variable: 'LW6_PLAYER3_STATUS'
 -- XML key: 'player3-status'
     Type: boolean

     Default value: false

     Status of the third player, true if player is activated, false if
     idle.

4.5.10 player4-control
----------------------

 -- Command-line option: '--player4-control=<value>'
 -- Environment variable: 'LW6_PLAYER4_CONTROL'
 -- XML key: 'player4-control'
     Type: string

     Default value: joystick2

     Control for the fourth player, must be mouse, keyboard, joystick1,
     joystick2 or custom.

4.5.11 player4-name
-------------------

 -- Command-line option: '--player4-name=<value>'
 -- Environment variable: 'LW6_PLAYER4_NAME'
 -- XML key: 'player4-name'
     Type: string

     Default value: player4-<hostname>

     Name of the fourth player.  A default value is provided, you'll
     certainly want to change it.

4.5.12 player4-status
---------------------

 -- Command-line option: '--player4-status=<value>'
 -- Environment variable: 'LW6_PLAYER4_STATUS'
 -- XML key: 'player4-status'
     Type: boolean

     Default value: false

     Status of the fourth player, true if player is activated, false if
     idle.

4.6 Input options
=================

4.6.1 auto-release-delay
------------------------

 -- Command-line option: '--auto-release-delay=<value>'
 -- Environment variable: 'LW6_AUTO_RELEASE_DELAY'
 -- XML key: 'auto-release-delay'
     Type: integer

     Default value: 250

     Time, in milliseconds, before which a key is automatically
     released.  This might or might not be used by the graphics backend,
     it's typically used by backends which don't always handle key
     releases events the right way, that is, don't fire them.  Libcaca
     is a good example of such a case.

4.6.2 click-to-focus
--------------------

 -- Command-line option: '--click-to-focus=<value>'
 -- Environment variable: 'LW6_CLICK_TO_FOCUS'
 -- XML key: 'click-to-focus'
     Type: boolean

     Default value: false

     If set to true, you'll need to click with the mouse to select a
     menuitem or move the cursor in the game.  If not, some actions will
     be taken automatically without the need to click.

4.6.3 cursor-sensitivity
------------------------

 -- Command-line option: '--cursor-sensitivity=<value>'
 -- Environment variable: 'LW6_CURSOR_SENSITIVITY'
 -- XML key: 'cursor-sensitivity'
     Type: float

     Default value: 1.0

     Keyboard and joystick sensitivity while moving the cursor.  1.0 is
     the default, 0.1 is slow, 10 is reponsive.  This is used for moving
     the cursor during the game only, the option has no impact on menu
     navigation.

4.6.4 custom-alt
----------------

 -- Command-line option: '--custom-alt=<value>'
 -- Environment variable: 'LW6_CUSTOM_ALT'
 -- XML key: 'custom-alt'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 110) ; SDLK_n

     Guile custom code associated to the ALT key equivalent.

4.6.5 custom-ctrl
-----------------

 -- Command-line option: '--custom-ctrl=<value>'
 -- Environment variable: 'LW6_CUSTOM_CTRL'
 -- XML key: 'custom-ctrl'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 98) ; SDLK_b

     Guile custom code associated to the CTRL key equivalent.

4.6.6 custom-down
-----------------

 -- Command-line option: '--custom-down=<value>'
 -- Environment variable: 'LW6_CUSTOM_DOWN'
 -- XML key: 'custom-down'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 100) ; SDLK_d

     Guile custom code associated to the DOWN key equivalent.

4.6.7 custom-enter
------------------

 -- Command-line option: '--custom-enter=<value>'
 -- Environment variable: 'LW6_CUSTOM_ENTER'
 -- XML key: 'custom-enter'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 103) ; SDLK_g

     Guile custom code associated to the ENTER key equivalent.

4.6.8 custom-esc
----------------

 -- Command-line option: '--custom-esc=<value>'
 -- Environment variable: 'LW6_CUSTOM_ESC'
 -- XML key: 'custom-esc'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 102) ; SDLK_f

     Guile custom code associated to the ESC key equivalent.

4.6.9 custom-left
-----------------

 -- Command-line option: '--custom-left=<value>'
 -- Environment variable: 'LW6_CUSTOM_LEFT'
 -- XML key: 'custom-left'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 99) ; SDLK_c

     Guile custom code associated to the LEFT key equivalent.

4.6.10 custom-pgdown
--------------------

 -- Command-line option: '--custom-pgdown=<value>'
 -- Environment variable: 'LW6_CUSTOM_PGDOWN'
 -- XML key: 'custom-pgdown'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 115) ; SDLK_s

     Guile custom code associated to the PGDOWN key equivalent.

4.6.11 custom-pgup
------------------

 -- Command-line option: '--custom-pgup=<value>'
 -- Environment variable: 'LW6_CUSTOM_PGUP'
 -- XML key: 'custom-pgup'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 119) ; SDLK_w

     Guile custom code associated to the PGUP key equivalent.

4.6.12 custom-right
-------------------

 -- Command-line option: '--custom-right=<value>'
 -- Environment variable: 'LW6_CUSTOM_RIGHT'
 -- XML key: 'custom-right'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 118) ; SDLK_v

     Guile custom code associated to the RIGHT key equivalent.

4.6.13 custom-up
----------------

 -- Command-line option: '--custom-up=<value>'
 -- Environment variable: 'LW6_CUSTOM_UP'
 -- XML key: 'custom-up'
     Type: string

     Default value: (c-lw6gui-keyboard-is-pressed 101) ; SDLK_e

     Custom keycode to be used as the UP key equivalent.

4.6.14 double-click-delay
-------------------------

 -- Command-line option: '--double-click-delay=<value>'
 -- Environment variable: 'LW6_DOUBLE_CLICK_DELAY'
 -- XML key: 'double-click-delay'
     Type: integer

     Default value: 333

     Time, in milliseconds, determining wether two consecutive clicks
     make a double-click or not.

4.6.15 max-cursor-speed
-----------------------

 -- Command-line option: '--max-cursor-speed=<value>'
 -- Environment variable: 'LW6_MAX_CURSOR_SPEED'
 -- XML key: 'max-cursor-speed'
     Type: float

     Default value: 10.0

     Maximum cursor speed when cursor is controlled with keyboard or
     joystick joystick 1.  Consider using cursor-sensitivity too.

4.6.16 mouse-sensitivity
------------------------

 -- Command-line option: '--mouse-sensitivity=<value>'
 -- Environment variable: 'LW6_MOUSE_SENSITIVITY'
 -- XML key: 'mouse-sensitivity'
     Type: float

     Default value: 1.0

     Mouse sensitivity, 1.0 is the default, 0.1 is slow, 10 is
     reponsive.  This is used for moving the cursor during the game
     only, the option has no impact on menu navigation.

4.6.17 repeat-delay
-------------------

 -- Command-line option: '--repeat-delay=<value>'
 -- Environment variable: 'LW6_REPEAT_DELAY'
 -- XML key: 'repeat-delay'
     Type: integer

     Default value: 500

     Time, in milliseconds, before key repeat will start, use 0 to
     disable.

4.6.18 repeat-interval
----------------------

 -- Command-line option: '--repeat-interval=<value>'
 -- Environment variable: 'LW6_REPEAT_INTERVAL'
 -- XML key: 'repeat-interval'
     Type: integer

     Default value: 100

     Time, in milliseconds, between two repeats, once repeat has
     started, use 0 to disable.

4.6.19 use-double-click
-----------------------

 -- Command-line option: '--use-double-click=<value>'
 -- Environment variable: 'LW6_USE_DOUBLE_CLICK'
 -- XML key: 'use-double-click'
     Type: boolean

     Default value: false

     Wether to use double-click feature, mostly usefull if running on a
     system that has only one button (such as a tablet-PC or anything
     with a tactile screen), if your mouse has three buttons, disabling
     this might avoid some confusion.  Basically, if enabled,
     double-click is equivalent to right-click (fire) and triple-click
     is equivalent to middle-click (alternate fire).

4.6.20 use-esc-button
---------------------

 -- Command-line option: '--use-esc-button=<value>'
 -- Environment variable: 'LW6_USE_ESC_BUTTON'
 -- XML key: 'use-esc-button'
     Type: boolean

     Default value: true

     Decides wether to display an 'esc' (escape) button in the
     interface.  This is usefull for people who control the game with
     the mouse only, and have a single buttons, or on a touchscreen.

4.6.21 zoom-step
----------------

 -- Command-line option: '--zoom-step=<value>'
 -- Environment variable: 'LW6_ZOOM_STEP'
 -- XML key: 'zoom-step'
     Type: float

     Default value: 1.1

     A value, strictly greater than 1, which will be used when zooming.
     The greater it is, the more sensible the zoom is.

4.6.22 zoom-stick-delay
-----------------------

 -- Command-line option: '--zoom-stick-delay=<value>'
 -- Environment variable: 'LW6_ZOOM_STICK_DELAY'
 -- XML key: 'zoom-stick-delay'
     Type: float

     Default value: 1000

     How long, in msec, the zoom will stick to its default value.

4.7 Graphics options
====================

4.7.1 capture
-------------

 -- Command-line option: '--capture=<value>'
 -- Environment variable: 'LW6_CAPTURE'
 -- XML key: 'capture'
     Type: boolean

     Default value: false

     Enables capture mode, in which a BMP file is dumped on the disk (in
     your user directory, search for a 'capture' sub-directory).

4.7.2 fullscreen
----------------

 -- Command-line option: '--fullscreen=<value>'
 -- Environment variable: 'LW6_FULLSCREEN'
 -- XML key: 'fullscreen'
     Type: boolean

     Default value: false

     Force the game to fun fullscreen.  Note that the graphics backend
     might ignore this hint.

4.7.3 gfx-backend
-----------------

 -- Command-line option: '--gfx-backend=<value>'
 -- Environment variable: 'LW6_GFX_BACKEND'
 -- XML key: 'gfx-backend'
     Type: string

     Default value: gl1

     Sets the graphics backend AKA 'gfx' to use.  For now the only
     reasonnable choice is 'gl1' and will use an OpenGL v1 / SDL
     3D-accelerated driver.

4.7.4 gfx-quality
-----------------

 -- Command-line option: '--gfx-quality=<value>'
 -- Environment variable: 'LW6_GFX_QUALITY'
 -- XML key: 'gfx-quality'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Sets the overall quality of the graphics backend.  Depending on the
     backend, this can mean different things.  For instance for the 'gl'
     backend, this can change texture filtering (nearest, linear,
     bilinear...).  This is not the same as 'pixelize' which is a
     per-map option and emulates an old school appearance.

4.7.5 height
------------

 -- Command-line option: '--height=<value>'
 -- Environment variable: 'LW6_HEIGHT'
 -- XML key: 'height'
     Type: integer

     Default value: -1

     Run the game with the given screen height.Note that the graphics
     backend might ignore this hint.  Use with its companion option
     'width'.  A negative value will force the use of a default value.

4.7.6 width
-----------

 -- Command-line option: '--width=<value>'
 -- Environment variable: 'LW6_WIDTH'
 -- XML key: 'width'
     Type: integer

     Default value: -1

     Run the game with the given screen width.  Note that the graphics
     backend might ignore this hint.  Use with its companion option
     'height'.A negative value will force the use of a default value.

4.7.7 windowed-mode-limit
-------------------------

 -- Command-line option: '--windowed-mode-limit=<value>'
 -- Environment variable: 'LW6_WINDOWED_MODE_LIMIT'
 -- XML key: 'windowed-mode-limit'
     Type: float

     Default value: 0.95

     When switching back from fullscreen mode to windowed mode, if we're
     in maximum resolution, then this coefficient will be applied before
     resizing the window.  The idea is that (obviously) a windowed mode
     is prefered when a little smaller that totally fullscreen.  So set
     this to a value just below 1.0.

4.8 Sound options
=================

4.8.1 ambiance-exclude
----------------------

 -- Command-line option: '--ambiance-exclude=<value>'
 -- Environment variable: 'LW6_AMBIANCE_EXCLUDE'
 -- XML key: 'ambiance-exclude'
     Type: string

     Default value:

     If this string is present in a music file name, this file won't be
     played during the menus, it will be excluded from the list.

4.8.2 ambiance-file
-------------------

 -- Command-line option: '--ambiance-file=<value>'
 -- Environment variable: 'LW6_AMBIANCE_FILE'
 -- XML key: 'ambiance-file'
     Type: string

     Default value:

     A music file which will be used to be played during the menus.  If
     not found, game will fallback on random files.

4.8.3 ambiance-filter
---------------------

 -- Command-line option: '--ambiance-filter=<value>'
 -- Environment variable: 'LW6_AMBIANCE_FILTER'
 -- XML key: 'ambiance-filter'
     Type: string

     Default value: Chadburn

     A music filter, used to select the files which are played while
     navigating in the menus.  It works like 'music-filter' except this
     one is not related to a peculiar map.  This is not a complex
     regex-enabled filter, just a plain string search.  Even the '*'
     wildcard won't work.

4.8.4 fx-volume
---------------

 -- Command-line option: '--fx-volume=<value>'
 -- Environment variable: 'LW6_FX_VOLUME'
 -- XML key: 'fx-volume'
     Type: float

     Default value: 0.3 Min value: 0 Max value: 1

     Set the sound effects volume.  This is a floating point value.  0
     is mute.  Maximum value is 1.

4.8.5 music-volume
------------------

 -- Command-line option: '--music-volume=<value>'
 -- Environment variable: 'LW6_MUSIC_VOLUME'
 -- XML key: 'music-volume'
     Type: float

     Default value: 0.6 Min value: 0 Max value: 1

     Set the music volume.This is a floating point value.  0 is mute.
     Maximum value is 1.

4.8.6 snd-backend
-----------------

 -- Command-line option: '--snd-backend=<value>'
 -- Environment variable: 'LW6_SND_BACKEND'
 -- XML key: 'snd-backend'
     Type: string

     Default value: ogg

     Sets the sound backend AKA 'snd' to use.  Can be 'ogg' or 'csound'
     but only 'ogg' will produce sound in the current release.

4.8.7 water-volume
------------------

 -- Command-line option: '--water-volume=<value>'
 -- Environment variable: 'LW6_WATER_VOLUME'
 -- XML key: 'water-volume'
     Type: float

     Default value: 0.2 Min value: 0 Max value: 1

     Set the volume for water sounds.  This is a floating point value.
     0 is mute.  Maximum value is 1.

4.9 Network options
===================

4.9.1 bind-ip
-------------

 -- Command-line option: '--bind-ip=<value>'
 -- Environment variable: 'LW6_BIND_IP'
 -- XML key: 'bind-ip'
     Type: string

     Default value: 0.0.0.0

     The IP address to bind on when listening to network messages.  You
     can use this to specifically use a given network interface, the
     default will listen on any available interface.

4.9.2 bind-port
---------------

 -- Command-line option: '--bind-port=<value>'
 -- Environment variable: 'LW6_BIND_PORT'
 -- XML key: 'bind-port'
     Type: integer

     Default value: 8056 Min value: 1 Max value: 65535

     The IP port to bind on when listening to network messages.  The
     default should work out of the box, and will ease up the discovery
     process.  That is, if you use your own settings, automatic
     detection of your server by other servers might not work so well.

4.9.3 broadcast
---------------

 -- Command-line option: '--broadcast=<value>'
 -- Environment variable: 'LW6_BROADCAST'
 -- XML key: 'broadcast'
     Type: boolean

     Default value: true

     Allows the program to send broadcast messages on the network.  It
     can be usefull to disable those if you don't use UDP node discovery
     and/or if there's a sysadmin arround who does not enjoy permanent
     broadcasts on his LAN.

4.9.4 cli-backends
------------------

 -- Command-line option: '--cli-backends=<value>'
 -- Environment variable: 'LW6_CLI_BACKENDS'
 -- XML key: 'cli-backends'
     Type: string

     Default value: tcp,udp,http

     The client backends to use.  Most of the time the default is fine,
     change it only if you specifically want to disactivate some
     protocol, or if you want to activate a custom-made client backend.
     It's a comma separated list.

4.9.5 known-nodes
-----------------

 -- Command-line option: '--known-nodes=<value>'
 -- Environment variable: 'LW6_KNOWN_NODES'
 -- XML key: 'known-nodes'
     Type: string

     Default value: http://ufoot.org:8056/,http://ufoot.hd.free.fr:8056/

     List of known nodes, nodes which the program will try to contact
     first to get the list of other nodes.  This is mostly usefull when
     program is launched for the first time, after this it should keep
     an up-to-date list of known servers in its internal database and
     automatically reconnect to them next time it starts.  You might
     want to change this if you really want to connect to a given server
     which is not publically listed.  The list is comma separated.

4.9.6 node-description
----------------------

 -- Command-line option: '--node-description=<value>'
 -- Environment variable: 'LW6_NODE_DESCRIPTION'
 -- XML key: 'node-description'
     Type: string

     Default value: No description.

     The description of your node, that is a text that describes your
     server.  This will typically appear when pointing a web client on
     the public server URL, it is for general information, so if there's
     something special about your server, say it here.

4.9.7 node-title
----------------

 -- Command-line option: '--node-title=<value>'
 -- Environment variable: 'LW6_NODE_TITLE'
 -- XML key: 'node-title'
     Type: string

     Default value:

     The title of your node, that is the name which will be displayed
     when listing servers.  This is different from player name, for
     there can be several players on a single computer.  By default this
     will be set to hostname.

4.9.8 password
--------------

 -- Command-line option: '--password=<value>'
 -- Environment variable: 'LW6_PASSWORD'
 -- XML key: 'password'
     Type: string

     Default value:

     The password to use for network games.  Do not use a valuable
     password, as this is stored as clear text on your hard drive.
     Still, the game will only send a hash/checksum of the password on
     the network so eavesdropper won't be able to read it.  They can see
     the hash/checksum and use it if clever, but they can't guess the
     real password.  A blank password means anyone can join your games
     when you act like a server.

4.9.9 public-url
----------------

 -- Command-line option: '--public-url=<value>'
 -- Environment variable: 'LW6_PUBLIC_URL'
 -- XML key: 'public-url'
     Type: string

     Default value:

     The public URL of your server.  By default the game will pick up
     one for you.  In fact, the clients discovering your server should
     guess the public URL, probably http://<your-ip>:<your-port>/ but
     you might need to use your own settings if you are using NAT or an
     Apache reverse-proxy to rewrite HTTP requests.

4.9.10 skip-network
-------------------

 -- Command-line option: '--skip-network=<value>'
 -- Environment variable: 'LW6_SKIP_NETWORK'
 -- XML key: 'skip-network'
     Type: boolean

     Default value: false

     If set, then game won't do anything network related.  No listen, no
     connect, no nothing.  You are playing locally.

4.9.11 srv-backends
-------------------

 -- Command-line option: '--srv-backends=<value>'
 -- Environment variable: 'LW6_SRV_BACKENDS'
 -- XML key: 'srv-backends'
     Type: string

     Default value: tcpd,udpd,httpd

     The server backends to use.  Most of the time the default is fine,
     change it only if you specifically want to disactivate some
     protocol, or if you want to activate a custom-made server backend.
     It's a comma separated list.

4.10 Map parameters
===================

4.10.1 chosen-map
-----------------

 -- Command-line option: '--chosen-map=<value>'
 -- Environment variable: 'LW6_CHOSEN_MAP'
 -- XML key: 'chosen-map'
     Type: string

     Default value: subflower

     The last map chosen by the player, locally.  This is the map which
     will be used for a quick-start game, a local game, or a game
     started as a server.

4.10.2 force
------------

 -- Command-line option: '--force=<value>'
 -- Environment variable: 'LW6_FORCE'
 -- XML key: 'force'
     Type: string

     Default value: respawn-team,color-conflict-mode

     A comma separated list of options which should be ignored when
     reading map XML files.  For instance, if this contains
     'rounds-per-sec,moves-per-round' then whatever values were defined
     for this in 'rules.xml', then game will ignore them and use the
     user's values, stored in 'config.xml', running the game at the
     requested speed.  This ultimately allows the player to control
     everything despite the values set by the map designer.

4.10.3 use-cursor-texture
-------------------------

 -- Command-line option: '--use-cursor-texture=<value>'
 -- Environment variable: 'LW6_USE_CURSOR_TEXTURE'
 -- XML key: 'use-cursor-texture'
     Type: boolean

     Default value: true

     Defines wether the cursor textures should be used.  If unset, then
     the default builtin cursor texture will be used instead of the map
     specific one.

4.10.4 use-hints-xml
--------------------

 -- Command-line option: '--use-hints-xml=<value>'
 -- Environment variable: 'LW6_USE_HINTS_XML'
 -- XML key: 'use-hints-xml'
     Type: boolean

     Default value: true

     If set, then hints will be picked up from the map defined
     hints.xml, if it exists.  This is the default.

4.10.5 use-music-file
---------------------

 -- Command-line option: '--use-music-file=<value>'
 -- Environment variable: 'LW6_USE_MUSIC_FILE'
 -- XML key: 'use-music-file'
     Type: boolean

     Default value: true

     If set, then the program will use the 'music-file' attribute to
     choose the music to play.  If unset, then a random builtin music
     will be picked up, regardless of what is specified in 'music-file'.

4.10.6 use-rules-xml
--------------------

 -- Command-line option: '--use-rules-xml=<value>'
 -- Environment variable: 'LW6_USE_RULES_XML'
 -- XML key: 'use-rules-xml'
     Type: boolean

     Default value: true

     If set, then rules will be picked up from the map defined
     rules.xml, if it exists.  This is the default.  Use force-time and
     force-size to override this and use user-defined values anyway.

4.10.7 use-style-xml
--------------------

 -- Command-line option: '--use-style-xml=<value>'
 -- Environment variable: 'LW6_USE_STYLE_XML'
 -- XML key: 'use-style-xml'
     Type: boolean

     Default value: true

     If set, then style will be picked up from the map defined
     style.xml, if it exists.  This is the default.  Use force-time and
     force-background to override this and use user-defined values
     anyway.

4.10.8 use-teams-xml
--------------------

 -- Command-line option: '--use-teams-xml=<value>'
 -- Environment variable: 'LW6_USE_TEAMS_XML'
 -- XML key: 'use-teams-xml'
     Type: boolean

     Default value: true

     If set, then teams will be picked up from the map defined
     teams.xml, if it exists.  This is the default.  Use force-time and
     force-background to override this and use user-defined values
     anyway.

4.10.9 use-texture
------------------

 -- Command-line option: '--use-texture=<value>'
 -- Environment variable: 'LW6_USE_TEXTURE'
 -- XML key: 'use-texture'
     Type: boolean

     Default value: true

     Defines wether the map texture should be used.  Of course if
     there's no map texture, the texture...  won't be used.  But if
     there is one, this parameter will force the game to ignore it and
     play with solid colors.  This probably won't look as nice as the
     textured map in most cases, but some players might find it more
     readable and confortable to play when throwing eye candy away.

4.11 Map rules.xml
==================

4.11.1 boost-power
------------------

 -- Command-line option: '--boost-power=<value>'
 -- Environment variable: 'LW6_BOOST_POWER'
 -- XML key: 'boost-power'
     Type: integer

     Default value: 3 Min value: 1 Max value: 10

     Defines how fast and powerfull the boost is.  That is, if on
     'boost.png' it's pitch black and this parameter is set to 3, then
     fighters will move and act 3 times than what they would do
     normally.

4.11.2 color-conflict-mode
--------------------------

 -- Command-line option: '--color-conflict-mode=<value>'
 -- Environment variable: 'LW6_COLOR_CONFLICT_MODE'
 -- XML key: 'color-conflict-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     How to handle color conflicts, that is, when a player requests a
     color, but this color is already used, what should be done?  If 0,
     wether a color already exists won't affect the color of a new
     cursor.  If 1, then two players on the same computer will be
     allowed to share the same color/team, but if another computer is
     already playing with a color, any new computer will need to use
     another team.  If 2, then it's impossible for a new cursor to use a
     pre-existing color, any new cursor will require a new color, if
     that color is already used, a new color will be picked randomly.

4.11.3 cursor-pot-init
----------------------

 -- Command-line option: '--cursor-pot-init=<value>'
 -- Environment variable: 'LW6_CURSOR_POT_INIT'
 -- XML key: 'cursor-pot-init'
     Type: integer

     Default value: 100000 Min value: 5000 Max value: 500000

     Defines the cursor potential at startup.  Not really any reason to
     change it.  Theorically, there could be maps where the default
     value doesn't fit, but none has been seen yet.

4.11.4 danger-power
-------------------

 -- Command-line option: '--danger-power=<value>'
 -- Environment variable: 'LW6_DANGER_POWER'
 -- XML key: 'danger-power'
     Type: integer

     Default value: 200 Min value: 0 Max value: 10000

     Defines how dangerous are the black zones defined in 'danger.png'.
     The value is used to decrease the fighter health at each move, so
     you should compare its value to something like 'fighter-attack'.
     Being on a dangerous zone is a bit like being attacked by an
     invisible and unknown ennemy.

4.11.5 exp
----------

 -- Command-line option: '--exp=<value>'
 -- Environment variable: 'LW6_EXP'
 -- XML key: 'exp'
     Type: integer

     Default value: 1 Min value: 0 Max value: 99

     Level of experience (AKA exp) required to play the current level.
     If this level is validated (that is, won) then player will be
     granted with a level of exp+1 and be able to play all the next
     levels.  An exp of 0 means the level is playable by a pure
     beginner.

4.11.6 fighter-attack
---------------------

 -- Command-line option: '--fighter-attack=<value>'
 -- Environment variable: 'LW6_FIGHTER_ATTACK'
 -- XML key: 'fighter-attack'
     Type: integer

     Default value: 500 Min value: 1 Max value: 10000

     Defines how hard fighters will attack others, that is, in one
     attack, how many life-points the attacked fighter will loose.
     Increasing this will cause your opponents to melt faster when you
     attack them.  With a low value, it will take ages to take on your
     opponents.  Different styles of game.  Can radically change the
     gameplay.

4.11.7 fighter-defense
----------------------

 -- Command-line option: '--fighter-defense=<value>'
 -- Environment variable: 'LW6_FIGHTER_DEFENSE'
 -- XML key: 'fighter-defense'
     Type: integer

     Default value: 50 Min value: 0 Max value: 10000

     Defines how fast fighters will regenerate after an attack.  When
     this parameter is set low, an attacked fighter, which is very dark
     and almost dead will take a very long time to regain energy.  If
     the parameter is set high, it can almost instantaneously regain
     energy.

4.11.8 fighter-new-health
-------------------------

 -- Command-line option: '--fighter-new-health=<value>'
 -- Environment variable: 'LW6_FIGHTER_NEW_HEALTH'
 -- XML key: 'fighter-new-health'
     Type: integer

     Default value: 5000 Min value: 1 Max value: 10000

     Defines how healthy fighters will be when they appear on the map.
     This can be either at the beginning of the game of when a fighter
     changes team.  Setting this low will allow battefields to switch
     from one side to another very fast, for freshly gained fighters
     will be feeble and very likely to return to their original camp.
     To calibrate this parameter, keep in mind that the absolute maximum
     health a fighter can have is always 10000 (ten-thousands).

4.11.9 fighter-regenerate
-------------------------

 -- Command-line option: '--fighter-regenerate=<value>'
 -- Environment variable: 'LW6_FIGHTER_REGENERATE'
 -- XML key: 'fighter-regenerate'
     Type: integer

     Default value: 5 Min value: 0 Max value: 10000

     Defines at which speed fighters will self-regenerate, without even
     begin packed together.  This will allow lone fighters to regenerate
     a bit by hiding somewhere in the map.  This is typically a low
     value, might even be 0.

4.11.10 frags-fade-out
----------------------

 -- Command-line option: '--frags-fade-out=<value>'
 -- Environment variable: 'LW6_FRAGS_FADE_OUT'
 -- XML key: 'frags-fade-out'
     Type: integer

     Default value: 100 Min value: 10 Max value: 100

     When a player looses (in deathmatch mode) all player points will be
     multiplicated by this percentage, for instance if it's 90 and
     player had 50 points, then player will only have 45 points, then
     points corresponding to the new death will be added/substrated to
     its total.  This is to avoid players with thousands of points in
     advance, and keep everyone in the race.  A low value will minimize
     the importance of game start.  This is only used in modes where
     frags are distributed in a proportional way.

4.11.11 frags-mode
------------------

 -- Command-line option: '--frags-mode=<value>'
 -- Environment variable: 'LW6_FRAGS_MODE'
 -- XML key: 'frags-mode'
     Type: integer

     Default value: 2 Min value: 0 Max value: 3

     Defines how points are calculated in deathmatch mode, 0 is old
     school simple mode.  1 is in a mode in which 1 point is attributed
     to every winner, and looser looses all the corresponding points
     (total is always 0).  2 isproportional mode, with a total of 0 kept
     constant, that is, loosers loose as many points as attributed to
     winners.  3 is a mode in which at each death, winners are
     attributed a number of points proportional to their fighters, and
     loosers scores remain untouched.

4.11.12 frags-to-distribute
---------------------------

 -- Command-line option: '--frags-to-distribute=<value>'
 -- Environment variable: 'LW6_FRAGS_TO_DISTRIBUTE'
 -- XML key: 'frags-to-distribute'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines how many points will be distributed when in deathmatch
     mode.  When a player looses, this amont of points will be
     substracted to its total, and the same amount of points will be
     distributed to other live players, proportionnally to how many
     fighters they have on the battlefield.

4.11.13 glue-power
------------------

 -- Command-line option: '--glue-power=<value>'
 -- Environment variable: 'LW6_GLUE_POWER'
 -- XML key: 'glue-power'
     Type: integer

     Default value: 20 Min value: 1 Max value: 100

     Defines how sticky and powerfull the glue is.  That is, if on
     'glue.png' it's pitch black and this parameter is set to 3, then
     fighters will take 3 steps to do what would normally take only one
     step.

4.11.14 highest-team-color-allowed
----------------------------------

 -- Command-line option: '--highest-team-color-allowed=<value>'
 -- Environment variable: 'LW6_HIGHEST_TEAM_COLOR_ALLOWED'
 -- XML key: 'highest-team-color-allowed'
     Type: integer

     Default value: 9 Min value: 3 Max value: 9

     Id of the greatest/highest color one can use.  Normally, you can
     leave this untouched, the program will automatically fit this
     according to your exp.  Setting an artificially low value will just
     cause normally available colors to disappear, setting it to a high
     value does nothing, if you still don't have access to some colors,
     you still don't, period.

4.11.15 highest-weapon-allowed
------------------------------

 -- Command-line option: '--highest-weapon-allowed=<value>'
 -- Environment variable: 'LW6_HIGHEST_WEAPON_ALLOWED'
 -- XML key: 'highest-weapon-allowed'
     Type: integer

     Default value: 19 Min value: 7 Max value: 19

     Id of the greatest/highest weapon one can use.  Normally, you can
     leave this untouched, the program will automatically fit this
     according to your exp.  Setting an artificially low value will just
     cause normally available weapons to disappear, setting it to a high
     value does nothing, if you still don't have access to some weapons,
     you still don't, period.

4.11.16 max-cursor-pot
----------------------

 -- Command-line option: '--max-cursor-pot=<value>'
 -- Environment variable: 'LW6_MAX_CURSOR_POT'
 -- XML key: 'max-cursor-pot'
     Type: integer

     Default value: 1000000 Min value: 50000 Max value: 5000000

     Defines the maximum cursor potential.  Not really any reason to
     change it.  Any high value should produce the same results.  Low
     values might reveal algorithm bugs and inconsistencies.

4.11.17 max-cursor-pot-offset
-----------------------------

 -- Command-line option: '--max-cursor-pot-offset=<value>'
 -- Environment variable: 'LW6_MAX_CURSOR_POT_OFFSET'
 -- XML key: 'max-cursor-pot-offset'
     Type: integer

     Default value: 100 Min value: 1 Max value: 10000

     Defines the maximum cursor potential offset.  The idea is that in
     some cases, the potential of a cursor can increase in burst mode,
     for instance to make this cursor more important than others, so
     that fighters rally to it, neglecting other cursors (talking about
     a multi-cursor controlled team).  This parameter is here to limit
     this burst effect and avoid bugs.

4.11.18 max-nb-cursors
----------------------

 -- Command-line option: '--max-nb-cursors=<value>'
 -- Environment variable: 'LW6_MAX_NB_CURSORS'
 -- XML key: 'max-nb-cursors'
     Type: integer

     Default value: 26 Min value: 2 Max value: 26

     Defines the maximum number of cursors who can enter the game.
     Really makes sense in network games.  Default value is 26, the
     maximum.

4.11.19 max-nb-nodes
--------------------

 -- Command-line option: '--max-nb-nodes=<value>'
 -- Environment variable: 'LW6_MAX_NB_NODES'
 -- XML key: 'max-nb-nodes'
     Type: integer

     Default value: 12 Min value: 2 Max value: 15

     Defines the maximum number of servers who can enter the game.
     Really makes sense in network games.  Default value is 10, and
     should fit in most cases.  Can be raised up to 26.

4.11.20 max-nb-teams
--------------------

 -- Command-line option: '--max-nb-teams=<value>'
 -- Environment variable: 'LW6_MAX_NB_TEAMS'
 -- XML key: 'max-nb-teams'
     Type: integer

     Default value: 10 Min value: 2 Max value: 10

     Defines the maximum number of teams who can enter the game.  Really
     makes sense in network games.  Default value is 10, the maximum.

4.11.21 max-round-delta
-----------------------

 -- Command-line option: '--max-round-delta=<value>'
 -- Environment variable: 'LW6_MAX_ROUND_DELTA'
 -- XML key: 'max-round-delta'
     Type: integer

     Default value: 1000 Min value: 1 Max value: 10000

     This is the companion value of 'round-delta'.  Will put an absolute
     limit to the delta, which (what did you think?)  is of course
     incremented in some cases by the core algorithm.  If in doubt,
     don't touch.

4.11.22 max-zone-size
---------------------

 -- Command-line option: '--max-zone-size=<value>'
 -- Environment variable: 'LW6_MAX_ZONE_SIZE'
 -- XML key: 'max-zone-size'
     Type: integer

     Default value: 8 Min value: 1 Max value: 64

     Defines the maximum zone size, which is an internal and rather
     technical parameter.  The idea is that to optimize things, Liquid
     War 6 divides the battlefield in squares, where it can, and tries
     to make these squares as big as possible, the idea being that
     everywhere in this square, fighters follow the same intructions.
     Just a technical optimization.  The problem is that setting it too
     high will reveal the optimization and its tradeoffs to the player,
     who will see the fighter behave strangely, following invisible
     paths.  Plus, it's ugly.  Depending on your tastes (speed,
     look'n'feel) you'll prefer something nice or something fast.  Note
     that anyways passed a certain value, this does not optimize
     anything anymore.  In doubt, don't touch it.

4.11.23 medicine-power
----------------------

 -- Command-line option: '--medicine-power=<value>'
 -- Environment variable: 'LW6_MEDICINE_POWER'
 -- XML key: 'medicine-power'
     Type: integer

     Default value: 100 Min value: 0 Max value: 10000

     Defines how fast fighter will automatically regenerate on black
     zones defined in 'medicine.png'.  The value is used to decrease the
     fighter health at each move, so you should compare its value to
     something like 'fighter-defense'.  Being on a medicined zone is a
     bit like being defended by an invisible and unknown friend.

4.11.24 moves-per-round
-----------------------

 -- Command-line option: '--moves-per-round=<value>'
 -- Environment variable: 'LW6_MOVES_PER_ROUND'
 -- XML key: 'moves-per-round'
     Type: integer

     Default value: 2 Min value: 1 Max value: 50

     Defines how many times fighters move per round.  Increasing this
     will just make fighters move faster, but won't change anything for
     the rest, that is keyboard and mouse responsivity, and network
     traffic will stay the same.  Multiplying the number of moves per
     round by the number of rounds per second will give the number of
     moves per second, which is, in fact, how fast fighters move on the
     screen.

4.11.25 nb-attack-tries
-----------------------

 -- Command-line option: '--nb-attack-tries=<value>'
 -- Environment variable: 'LW6_NB_ATTACK_TRIES'
 -- XML key: 'nb-attack-tries'
     Type: integer

     Default value: 3 Min value: 1 Max value: 7

     Defines how many tries a fighter will do before giving-up attacking
     and choosing another behvior (defense).  By tries we mean: how many
     directions it will try.  Going North?  Going North-West?  Setting
     this to a low value will make fighters somewhat less aggressive.
     This idea is that they'll prefer to switch to the next option, that
     is, defense/regeneration, if there's no opponent right in front of
     them.

4.11.26 nb-defense-tries
------------------------

 -- Command-line option: '--nb-defense-tries=<value>'
 -- Environment variable: 'LW6_NB_DEFENSE_TRIES'
 -- XML key: 'nb-defense-tries'
     Type: integer

     Default value: 1 Min value: 1 Max value: 7

     Defines how many tries a fighter will do before giving-up attacking
     and choosing another behavior (do nothing).  By tries we mean: how
     many directions it will try.  Going North?  Going North-West?
     Setting this to a low value, you'll need a very compact pack of
     fighters for regeneration to operate, else fighters will hang
     arround unhealthy.

4.11.27 nb-move-tries
---------------------

 -- Command-line option: '--nb-move-tries=<value>'
 -- Environment variable: 'LW6_NB_MOVE_TRIES'
 -- XML key: 'nb-move-tries'
     Type: integer

     Default value: 5 Min value: 3 Max value: 7

     Defines how many tries a fighter will do before giving-up moving
     and choosing another behvior (attack or defense).  By tries we
     mean: how many directions it will try.  Going North?  Going
     North-West?  Setting this to a low value, your fighters will look
     very stubborn and always try to move in one direction, neglecting
     the fact that they could dodge.  This can lead to queues of
     fighters and other strange behaviors.  On the other hand, setting
     it too high will cause fighter to always avoid the enemy, and
     groups of fighters will just pass each other without any fight.
     Matter of taste.

4.11.28 respawn-delay
---------------------

 -- Command-line option: '--respawn-delay=<value>'
 -- Environment variable: 'LW6_RESPAWN_DELAY'
 -- XML key: 'respawn-delay'
     Type: integer

     Default value: 3 Min value: 0 Max value: 30

     Delay, in seconds, after which teams reappear on the battlefield,
     when in deathmatch mode.  0 means team right away.

4.11.29 respawn-position-mode
-----------------------------

 -- Command-line option: '--respawn-position-mode=<value>'
 -- Environment variable: 'LW6_RESPAWN_POSITION_MODE'
 -- XML key: 'respawn-position-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Defines how teams are set up on the map when respawning.  0 means
     teams respect the pre-defined start positions.  1 means that a
     random position will be picked, among the existing positions.  That
     is, red could take green's place.  2 means total randomness, teams
     can appear anywhere.

4.11.30 respawn-team
--------------------

 -- Command-line option: '--respawn-team=<value>'
 -- Environment variable: 'LW6_RESPAWN_TEAM'
 -- XML key: 'respawn-team'
     Type: integer

     Default value: 1 Min value: 0 Max value: 1

     Defines what to do when a team dies.  If set to 0, team disappears
     forever, if set to 1, team reappears automatically with fresh
     fighters.  It's a deathmatch mode, where the winner is not the one
     who stays alive the longest time, since it makes no real sens in
     this case, but the one who has died less often than others.

4.11.31 round-delta
-------------------

 -- Command-line option: '--round-delta=<value>'
 -- Environment variable: 'LW6_ROUND_DELTA'
 -- XML key: 'round-delta'
     Type: integer

     Default value: 1 Min value: 0 Max value: 100

     Conditions by how much the cursor potential will be incremented
     each time gradient is spreaded.  Sounds cryptic?  It is.  The idea
     is that at each time you move your cursor of 1 pixel, theorically,
     you'll need in the worst case to move of 1 more pixel to reach any
     point on the map.  Of course this is not true but this is the
     default asumption, and gradient spread will fix that.  Only in
     Liquid War 6 this is not even the worst case, for you can control
     your cursor with the mouse and cross walls.  Whenever you cross a
     wall, you might have done a great distance from the fighters' point
     of view, if the map is a maze.  Thus this parameter, which corrects
     things, experience shows it does give acceptable results to
     increase the cursor potential by more than one at each turn.  Toy
     arround with this if you find fighters take wrong paths on some
     given map.  If in doubt, don't touch.

4.11.32 rounds-per-sec
----------------------

 -- Command-line option: '--rounds-per-sec=<value>'
 -- Environment variable: 'LW6_ROUNDS_PER_SEC'
 -- XML key: 'rounds-per-sec'
     Type: integer

     Default value: 50 Min value: 1 Max value: 200

     Defines the overall speed of the game.  All other settings being
     equal, raising this value will cause the game to behave faster.
     Everything will be faster, except probably the display since your
     computer will calculate more game positions in a given time and
     spend more CPU time.  It will also increase network traffic.
     Values between 10 and 50 really make sense.

4.11.33 side-attack-factor
--------------------------

 -- Command-line option: '--side-attack-factor=<value>'
 -- Environment variable: 'LW6_SIDE_ATTACK_FACTOR'
 -- XML key: 'side-attack-factor'
     Type: integer

     Default value: 20 Min value: 0 Max value: 100

     Defines how hard fighters will attack sideways.  It's an algorithm
     trick, fighters attack by default the opponent right in front, but
     if there's no fighter there, they will still try to attack someone
     else, maybe sideways.  But doing this their attack is not as
     strong.  This parameter enables you to tune this.  This is a
     percentage.

4.11.34 side-defense-factor
---------------------------

 -- Command-line option: '--side-defense-factor=<value>'
 -- Environment variable: 'LW6_SIDE_DEFENSE_FACTOR'
 -- XML key: 'side-defense-factor'
     Type: integer

     Default value: 20 Min value: 0 Max value: 100

     Defines how fast fighters will regenerate, when being side by side
     instead of being right in front of the other.  This is a
     percentage.

4.11.35 single-army-size
------------------------

 -- Command-line option: '--single-army-size=<value>'
 -- Environment variable: 'LW6_SINGLE_ARMY_SIZE'
 -- XML key: 'single-army-size'
     Type: integer

     Default value: 30 Min value: 1 Max value: 95

     Defines the proportion of the whole available space, which will be
     occupied by an army at the beginning of the game.  You can either
     imagine playing with almost empty maps, or play very crowded with
     almost no space left.  This is a percentage, but will be multiplied
     by itself to get the actual surface.  That is, 50 means 50%*50%,
     that is, a square of 1/2 the size of a square map, so it represents
     25% (1/4) of the total surface.

4.11.36 spread-mode
-------------------

 -- Command-line option: '--spread-mode=<value>'
 -- Environment variable: 'LW6_SPREAD_MODE'
 -- XML key: 'spread-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     If set to 1, then gradient spread will be slower but gain in terms
     of homogeneity and consistency.  You could consider setting this to
     0 on very very big maps to save CPU cycles, else the default should
     work fine.

4.11.37 spread-thread
---------------------

 -- Command-line option: '--spread-thread=<value>'
 -- Environment variable: 'LW6_SPREAD_THREAD'
 -- XML key: 'spread-thread'
     Type: integer

     Default value: 0 Min value: 0 Max value: 1

     If set to 1, the core algorithm with fire a separate thread to
     spread the gradient.  By default this is turned off (set to 0).
     Consider this as an experimental feature, the program is already
     rather heavily threaded, turning this on will probably not offer
     any significant performance gain, even on SMP systems.  This might
     change in the future.

4.11.38 spreads-per-round
-------------------------

 -- Command-line option: '--spreads-per-round=<value>'
 -- Environment variable: 'LW6_SPREADS_PER_ROUND'
 -- XML key: 'spreads-per-round'
     Type: integer

     Default value: 5 Min value: 1 Max value: 100

     Defines how many times the gradient is spread per round.  Gradient
     spread is a very Liquid War 6 specific feature, just remember that
     the more often you do it, the more accurately fighters will move.
     That is, you will be sure they really take the shortest path.
     Usually this does not have much effect, the default value should
     fit in most cases, but you might want to decrease it on very simple
     maps where the gradient is obvious, or increase it on complex maps
     where you want fighters to be real smart.

4.11.39 start-blue-x
--------------------

 -- Command-line option: '--start-blue-x=<value>'
 -- Environment variable: 'LW6_START_BLUE_X'
 -- XML key: 'start-blue-x'
     Type: integer

     Default value: 90 Min value: 0 Max value: 100

     X start position for the blue team.  This is a percentage of map
     width, value between 0 and 100.

4.11.40 start-blue-y
--------------------

 -- Command-line option: '--start-blue-y=<value>'
 -- Environment variable: 'LW6_START_BLUE_Y'
 -- XML key: 'start-blue-y'
     Type: integer

     Default value: 10 Min value: 0 Max value: 100

     Y start position for the blue team.  This is a percentage of map
     height, value between 0 and 100.

4.11.41 start-cyan-x
--------------------

 -- Command-line option: '--start-cyan-x=<value>'
 -- Environment variable: 'LW6_START_CYAN_X'
 -- XML key: 'start-cyan-x'
     Type: integer

     Default value: 35 Min value: 0 Max value: 100

     X start position for the cyan team.  This is a percentage of map
     width, value between 0 and 100.

4.11.42 start-cyan-y
--------------------

 -- Command-line option: '--start-cyan-y=<value>'
 -- Environment variable: 'LW6_START_CYAN_Y'
 -- XML key: 'start-cyan-y'
     Type: integer

     Default value: 10 Min value: 0 Max value: 100

     Y start position for the cyan team.  This is a percentage of map
     height, value between 0 and 100.

4.11.43 start-green-x
---------------------

 -- Command-line option: '--start-green-x=<value>'
 -- Environment variable: 'LW6_START_GREEN_X'
 -- XML key: 'start-green-x'
     Type: integer

     Default value: 90 Min value: 0 Max value: 100

     X start position for the green team.  This is a percentage of map
     width, value between 0 and 100.

4.11.44 start-green-y
---------------------

 -- Command-line option: '--start-green-y=<value>'
 -- Environment variable: 'LW6_START_GREEN_Y'
 -- XML key: 'start-green-y'
     Type: integer

     Default value: 90 Min value: 0 Max value: 100

     Y start position for the green team.  This is a percentage of map
     height, value between 0 and 100.

4.11.45 start-lightblue-x
-------------------------

 -- Command-line option: '--start-lightblue-x=<value>'
 -- Environment variable: 'LW6_START_LIGHTBLUE_X'
 -- XML key: 'start-lightblue-x'
     Type: integer

     Default value: 35 Min value: 0 Max value: 100

     X start position for the lightblue team.  This is a percentage of
     map width, value between 0 and 100.

4.11.46 start-lightblue-y
-------------------------

 -- Command-line option: '--start-lightblue-y=<value>'
 -- Environment variable: 'LW6_START_LIGHTBLUE_Y'
 -- XML key: 'start-lightblue-y'
     Type: integer

     Default value: 90 Min value: 0 Max value: 100

     Y start position for the lightblue team.  This is a percentage of
     map height, value between 0 and 100.

4.11.47 start-magenta-x
-----------------------

 -- Command-line option: '--start-magenta-x=<value>'
 -- Environment variable: 'LW6_START_MAGENTA_X'
 -- XML key: 'start-magenta-x'
     Type: integer

     Default value: 65 Min value: 0 Max value: 100

     X start position for the magenta team.  This is a percentage of map
     width, value between 0 and 100.

4.11.48 start-magenta-y
-----------------------

 -- Command-line option: '--start-magenta-y=<value>'
 -- Environment variable: 'LW6_START_MAGENTA_Y'
 -- XML key: 'start-magenta-y'
     Type: integer

     Default value: 90 Min value: 0 Max value: 100

     Y start position for the magenta team.  This is a percentage of map
     height, value between 0 and 100.

4.11.49 start-orange-x
----------------------

 -- Command-line option: '--start-orange-x=<value>'
 -- Environment variable: 'LW6_START_ORANGE_X'
 -- XML key: 'start-orange-x'
     Type: integer

     Default value: 65 Min value: 0 Max value: 100

     X start position for the orange team.  This is a percentage of map
     width, value between 0 and 100.

4.11.50 start-orange-y
----------------------

 -- Command-line option: '--start-orange-y=<value>'
 -- Environment variable: 'LW6_START_ORANGE_Y'
 -- XML key: 'start-orange-y'
     Type: integer

     Default value: 10 Min value: 0 Max value: 100

     Y start position for the orange team.  This is a percentage of map
     height, value between 0 and 100.

4.11.51 start-pink-x
--------------------

 -- Command-line option: '--start-pink-x=<value>'
 -- Environment variable: 'LW6_START_PINK_X'
 -- XML key: 'start-pink-x'
     Type: integer

     Default value: 10 Min value: 0 Max value: 100

     X start position for the pink team.  This is a percentage of map
     width, value between 0 and 100.

4.11.52 start-pink-y
--------------------

 -- Command-line option: '--start-pink-y=<value>'
 -- Environment variable: 'LW6_START_PINK_Y'
 -- XML key: 'start-pink-y'
     Type: integer

     Default value: 50 Min value: 0 Max value: 100

     Y start position for the pink team.  This is a percentage of map
     height, value between 0 and 100.

4.11.53 start-position-mode
---------------------------

 -- Command-line option: '--start-position-mode=<value>'
 -- Environment variable: 'LW6_START_POSITION_MODE'
 -- XML key: 'start-position-mode'
     Type: integer

     Default value: 0 Min value: 0 Max value: 2

     Defines how teams are set up on the map at game startup.  0 means
     teams respect the pre-defined start positions.  1 means that a
     random position will be picked, among the existing positions.  That
     is, red could take green's place.  2 means total randomness, teams
     can appear anywhere.

4.11.54 start-purple-x
----------------------

 -- Command-line option: '--start-purple-x=<value>'
 -- Environment variable: 'LW6_START_PURPLE_X'
 -- XML key: 'start-purple-x'
     Type: integer

     Default value: 90 Min value: 0 Max value: 100

     X start position for the purple team.  This is a percentage of map
     width, value between 0 and 100.

4.11.55 start-purple-y
----------------------

 -- Command-line option: '--start-purple-y=<value>'
 -- Environment variable: 'LW6_START_PURPLE_Y'
 -- XML key: 'start-purple-y'
     Type: integer

     Default value: 50 Min value: 0 Max value: 100

     Y start position for the purple team.  This is a percentage of map
     height, value between 0 and 100.

4.11.56 start-red-x
-------------------

 -- Command-line option: '--start-red-x=<value>'
 -- Environment variable: 'LW6_START_RED_X'
 -- XML key: 'start-red-x'
     Type: integer

     Default value: 10 Min value: 0 Max value: 100

     X start position for the red team.  This is a percentage of map
     width, value between 0 and 100.

4.11.57 start-red-y
-------------------

 -- Command-line option: '--start-red-y=<value>'
 -- Environment variable: 'LW6_START_RED_Y'
 -- XML key: 'start-red-y'
     Type: integer

     Default value: 10 Min value: 0 Max value: 100

     Y start position for the red team.  This is a percentage of map
     height, value between 0 and 100.

4.11.58 start-yellow-x
----------------------

 -- Command-line option: '--start-yellow-x=<value>'
 -- Environment variable: 'LW6_START_YELLOW_X'
 -- XML key: 'start-yellow-x'
     Type: integer

     Default value: 10 Min value: 0 Max value: 100

     X start position for the yellow team.  This is a percentage of map
     width, value between 0 and 100.

4.11.59 start-yellow-y
----------------------

 -- Command-line option: '--start-yellow-y=<value>'
 -- Environment variable: 'LW6_START_YELLOW_Y'
 -- XML key: 'start-yellow-y'
     Type: integer

     Default value: 90 Min value: 0 Max value: 100

     Y start position for the yellow team.  This is a percentage of map
     height, value between 0 and 100.

4.11.60 team-profile-blue-aggressive
------------------------------------

 -- Command-line option: '--team-profile-blue-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_BLUE_AGGRESSIVE'
 -- XML key: 'team-profile-blue-aggressive'
     Type: integer

     Default value: 150 Min value: 5 Max value: 2000

     Defines how aggressive the blue team is.  This is a percentage, if
     set to 200 then team will attack twice as much as any other team
     with the default value.  Setting this to a high value clearly
     advantages this team.

4.11.61 team-profile-blue-fast
------------------------------

 -- Command-line option: '--team-profile-blue-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_BLUE_FAST'
 -- XML key: 'team-profile-blue-fast'
     Type: integer

     Default value: 50 Min value: 5 Max value: 2000

     Changes the speed of the blue team.  This is a percentage, if set
     to 50, then team will move twice slower than other teams with the
     default parameter.  Setting this high is very likely to advantage
     the team.

4.11.62 team-profile-blue-handicap
----------------------------------

 -- Command-line option: '--team-profile-blue-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_BLUE_HANDICAP'
 -- XML key: 'team-profile-blue-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the blue team.

4.11.63 team-profile-blue-mobile
--------------------------------

 -- Command-line option: '--team-profile-blue-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_BLUE_MOBILE'
 -- XML key: 'team-profile-blue-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the blue team.  If set to a high
     value team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.64 team-profile-blue-vulnerable
------------------------------------

 -- Command-line option: '--team-profile-blue-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_BLUE_VULNERABLE'
 -- XML key: 'team-profile-blue-vulnerable'
     Type: integer

     Default value: 60 Min value: 5 Max value: 2000

     Defines how vulnerable the blue team is.  This is a percentage, if
     set to 200 then team will be attacked twice as much as any other
     team with the default value.  Setting this to a high value clearly
     disadvantages this team.

4.11.65 team-profile-blue-weapon-alternate-id
---------------------------------------------

 -- Command-line option:
          '--team-profile-blue-weapon-alternate-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_BLUE_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-blue-weapon-alternate-id'
     Type: integer

     Default value: 8 Min value: 0 Max value: 19

     Id of the default alternate weapon for the blue team, see the
     documentation about weapons to know what these ids mean.

4.11.66 team-profile-blue-weapon-id
-----------------------------------

 -- Command-line option: '--team-profile-blue-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_BLUE_WEAPON_ID'
 -- XML key: 'team-profile-blue-weapon-id'
     Type: integer

     Default value: 14 Min value: 0 Max value: 19

     Id of the default weapon for the blue team, see the documentation
     about weapons to know what these ids mean.

4.11.67 team-profile-blue-weapon-mode
-------------------------------------

 -- Command-line option: '--team-profile-blue-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_BLUE_WEAPON_MODE'
 -- XML key: 'team-profile-blue-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for blue team.  0 means there's no weapon, 1 means one
     weapon per team, defined by the weapon-id parameter, 2 means random
     weapon.

4.11.68 team-profile-cyan-aggressive
------------------------------------

 -- Command-line option: '--team-profile-cyan-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_CYAN_AGGRESSIVE'
 -- XML key: 'team-profile-cyan-aggressive'
     Type: integer

     Default value: 44 Min value: 5 Max value: 2000

     Defines how aggressive the cyan team is.  This is a percentage, if
     set to 200 then team will attack twice as much as any other team
     with the default value.  Setting this to a high value clearly
     advantages this team.

4.11.69 team-profile-cyan-fast
------------------------------

 -- Command-line option: '--team-profile-cyan-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_CYAN_FAST'
 -- XML key: 'team-profile-cyan-fast'
     Type: integer

     Default value: 40 Min value: 5 Max value: 2000

     Changes the speed of the cyan team.  This is a percentage, if set
     to 50, then team will move twice slower than other teams with the
     default parameter.  Setting this high is very likely to advantage
     the team.

4.11.70 team-profile-cyan-handicap
----------------------------------

 -- Command-line option: '--team-profile-cyan-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_CYAN_HANDICAP'
 -- XML key: 'team-profile-cyan-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the cyan team.

4.11.71 team-profile-cyan-mobile
--------------------------------

 -- Command-line option: '--team-profile-cyan-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_CYAN_MOBILE'
 -- XML key: 'team-profile-cyan-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the cyan team.  If set to a high
     value team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.72 team-profile-cyan-vulnerable
------------------------------------

 -- Command-line option: '--team-profile-cyan-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_CYAN_VULNERABLE'
 -- XML key: 'team-profile-cyan-vulnerable'
     Type: integer

     Default value: 12 Min value: 5 Max value: 2000

     Defines how vulnerable the cyan team is.  This is a percentage, if
     set to 200 then team will be attacked twice as much as any other
     team with the default value.  Setting this to a high value clearly
     disadvantages this team.

4.11.73 team-profile-cyan-weapon-alternate-id
---------------------------------------------

 -- Command-line option:
          '--team-profile-cyan-weapon-alternate-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_CYAN_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-cyan-weapon-alternate-id'
     Type: integer

     Default value: 12 Min value: 0 Max value: 19

     Id of the default alternate weapon for the cyan team, see the
     documentation about weapons to know what these ids mean.

4.11.74 team-profile-cyan-weapon-id
-----------------------------------

 -- Command-line option: '--team-profile-cyan-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_CYAN_WEAPON_ID'
 -- XML key: 'team-profile-cyan-weapon-id'
     Type: integer

     Default value: 3 Min value: 0 Max value: 19

     Id of the default weapon for the cyan team, see the documentation
     about weapons to know what these ids mean.

4.11.75 team-profile-cyan-weapon-mode
-------------------------------------

 -- Command-line option: '--team-profile-cyan-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_CYAN_WEAPON_MODE'
 -- XML key: 'team-profile-cyan-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for cyan team.  0 means there's no weapon, 1 means one
     weapon per team, defined by the weapon-id parameter, 2 means random
     weapon.

4.11.76 team-profile-green-aggressive
-------------------------------------

 -- Command-line option: '--team-profile-green-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_GREEN_AGGRESSIVE'
 -- XML key: 'team-profile-green-aggressive'
     Type: integer

     Default value: 70 Min value: 5 Max value: 2000

     Defines how aggressive the green team is.  This is a percentage, if
     set to 200 then team will attack twice as much as any other team
     with the default value.  Setting this to a high value clearly
     advantages this team.

4.11.77 team-profile-green-fast
-------------------------------

 -- Command-line option: '--team-profile-green-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_GREEN_FAST'
 -- XML key: 'team-profile-green-fast'
     Type: integer

     Default value: 70 Min value: 5 Max value: 2000

     Changes the speed of the green team.  This is a percentage, if set
     to 50, then team will move twice slower than other teams with the
     default parameter.  Setting this high is very likely to advantage
     the team.

4.11.78 team-profile-green-handicap
-----------------------------------

 -- Command-line option: '--team-profile-green-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_GREEN_HANDICAP'
 -- XML key: 'team-profile-green-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the green team.

4.11.79 team-profile-green-mobile
---------------------------------

 -- Command-line option: '--team-profile-green-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_GREEN_MOBILE'
 -- XML key: 'team-profile-green-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the green team.  If set to a high
     value team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.80 team-profile-green-vulnerable
-------------------------------------

 -- Command-line option: '--team-profile-green-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_GREEN_VULNERABLE'
 -- XML key: 'team-profile-green-vulnerable'
     Type: integer

     Default value: 30 Min value: 5 Max value: 2000

     Defines how vulnerable the green team is.  This is a percentage, if
     set to 200 then team will be attacked twice as much as any other
     team with the default value.  Setting this to a high value clearly
     disadvantages this team.

4.11.81 team-profile-green-weapon-alternate-id
----------------------------------------------

 -- Command-line option:
          '--team-profile-green-weapon-alternate-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_GREEN_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-green-weapon-alternate-id'
     Type: integer

     Default value: 7 Min value: 0 Max value: 19

     Id of the default alternate weapon for the green team, see the
     documentation about weapons to know what these ids mean.

4.11.82 team-profile-green-weapon-id
------------------------------------

 -- Command-line option: '--team-profile-green-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_GREEN_WEAPON_ID'
 -- XML key: 'team-profile-green-weapon-id'
     Type: integer

     Default value: 13 Min value: 0 Max value: 19

     Id of the default weapon for the green team, see the documentation
     about weapons to know what these ids mean.

4.11.83 team-profile-green-weapon-mode
--------------------------------------

 -- Command-line option: '--team-profile-green-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_GREEN_WEAPON_MODE'
 -- XML key: 'team-profile-green-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for green team.  0 means there's no weapon, 1 means one
     weapon per team, defined by the weapon-id parameter, 2 means random
     weapon.

4.11.84 team-profile-lightblue-aggressive
-----------------------------------------

 -- Command-line option: '--team-profile-lightblue-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_LIGHTBLUE_AGGRESSIVE'
 -- XML key: 'team-profile-lightblue-aggressive'
     Type: integer

     Default value: 200 Min value: 5 Max value: 2000

     Defines how aggressive the lightblue team is.  This is a
     percentage, if set to 200 then team will attack twice as much as
     any other team with the default value.  Setting this to a high
     value clearly advantages this team.

4.11.85 team-profile-lightblue-fast
-----------------------------------

 -- Command-line option: '--team-profile-lightblue-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_LIGHTBLUE_FAST'
 -- XML key: 'team-profile-lightblue-fast'
     Type: integer

     Default value: 20 Min value: 5 Max value: 2000

     Changes the speed of the lightblue team.  This is a percentage, if
     set to 50, then team will move twice slower than other teams with
     the default parameter.  Setting this high is very likely to
     advantage the team.

4.11.86 team-profile-lightblue-handicap
---------------------------------------

 -- Command-line option: '--team-profile-lightblue-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_LIGHTBLUE_HANDICAP'
 -- XML key: 'team-profile-lightblue-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the lightblue team.

4.11.87 team-profile-lightblue-mobile
-------------------------------------

 -- Command-line option: '--team-profile-lightblue-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_LIGHTBLUE_MOBILE'
 -- XML key: 'team-profile-lightblue-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the lightblue team.  If set to a high
     value team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.88 team-profile-lightblue-vulnerable
-----------------------------------------

 -- Command-line option: '--team-profile-lightblue-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_LIGHTBLUE_VULNERABLE'
 -- XML key: 'team-profile-lightblue-vulnerable'
     Type: integer

     Default value: 8 Min value: 5 Max value: 2000

     Defines how vulnerable the lightblue team is.  This is a
     percentage, if set to 200 then team will be attacked twice as much
     as any other team with the default value.  Setting this to a high
     value clearly disadvantages this team.

4.11.89 team-profile-lightblue-weapon-alternate-id
--------------------------------------------------

 -- Command-line option:
          '--team-profile-lightblue-weapon-alternate-id=<value>'
 -- Environment variable:
          'LW6_TEAM_PROFILE_LIGHTBLUE_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-lightblue-weapon-alternate-id'
     Type: integer

     Default value: 17 Min value: 0 Max value: 19

     Id of the default alternate weapon for the lightblue team, see the
     documentation about weapons to know what these ids mean.

4.11.90 team-profile-lightblue-weapon-id
----------------------------------------

 -- Command-line option: '--team-profile-lightblue-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_LIGHTBLUE_WEAPON_ID'
 -- XML key: 'team-profile-lightblue-weapon-id'
     Type: integer

     Default value: 4 Min value: 0 Max value: 19

     Id of the default weapon for the lightblue team, see the
     documentation about weapons to know what these ids mean.

4.11.91 team-profile-lightblue-weapon-mode
------------------------------------------

 -- Command-line option: '--team-profile-lightblue-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_LIGHTBLUE_WEAPON_MODE'
 -- XML key: 'team-profile-lightblue-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for lightblue team.  0 means there's no weapon, 1 means
     one weapon per team, defined by the weapon-id parameter, 2 means
     random weapon.

4.11.92 team-profile-magenta-aggressive
---------------------------------------

 -- Command-line option: '--team-profile-magenta-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_MAGENTA_AGGRESSIVE'
 -- XML key: 'team-profile-magenta-aggressive'
     Type: integer

     Default value: 192 Min value: 5 Max value: 2000

     Defines how aggressive the magenta team is.  This is a percentage,
     if set to 200 then team will attack twice as much as any other team
     with the default value.  Setting this to a high value clearly
     advantages this team.

4.11.93 team-profile-magenta-fast
---------------------------------

 -- Command-line option: '--team-profile-magenta-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_MAGENTA_FAST'
 -- XML key: 'team-profile-magenta-fast'
     Type: integer

     Default value: 320 Min value: 5 Max value: 2000

     Changes the speed of the magenta team.  This is a percentage, if
     set to 50, then team will move twice slower than other teams with
     the default parameter.  Setting this high is very likely to
     advantage the team.

4.11.94 team-profile-magenta-handicap
-------------------------------------

 -- Command-line option: '--team-profile-magenta-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_MAGENTA_HANDICAP'
 -- XML key: 'team-profile-magenta-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the magenta team.

4.11.95 team-profile-magenta-mobile
-----------------------------------

 -- Command-line option: '--team-profile-magenta-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_MAGENTA_MOBILE'
 -- XML key: 'team-profile-magenta-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the magenta team.  If set to a high
     value team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.96 team-profile-magenta-vulnerable
---------------------------------------

 -- Command-line option: '--team-profile-magenta-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_MAGENTA_VULNERABLE'
 -- XML key: 'team-profile-magenta-vulnerable'
     Type: integer

     Default value: 1920 Min value: 5 Max value: 2000

     Defines how vulnerable the magenta team is.  This is a percentage,
     if set to 200 then team will be attacked twice as much as any other
     team with the default value.  Setting this to a high value clearly
     disadvantages this team.

4.11.97 team-profile-magenta-weapon-alternate-id
------------------------------------------------

 -- Command-line option:
          '--team-profile-magenta-weapon-alternate-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_MAGENTA_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-magenta-weapon-alternate-id'
     Type: integer

     Default value: 15 Min value: 0 Max value: 19

     Id of the default alternate weapon for the magenta team, see the
     documentation about weapons to know what these ids mean.

4.11.98 team-profile-magenta-weapon-id
--------------------------------------

 -- Command-line option: '--team-profile-magenta-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_MAGENTA_WEAPON_ID'
 -- XML key: 'team-profile-magenta-weapon-id'
     Type: integer

     Default value: 6 Min value: 0 Max value: 19

     Id of the default weapon for the magenta team, see the
     documentation about weapons to know what these ids mean.

4.11.99 team-profile-magenta-weapon-mode
----------------------------------------

 -- Command-line option: '--team-profile-magenta-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_MAGENTA_WEAPON_MODE'
 -- XML key: 'team-profile-magenta-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for magenta team.  0 means there's no weapon, 1 means
     one weapon per team, defined by the weapon-id parameter, 2 means
     random weapon.

4.11.100 team-profile-orange-aggressive
---------------------------------------

 -- Command-line option: '--team-profile-orange-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_ORANGE_AGGRESSIVE'
 -- XML key: 'team-profile-orange-aggressive'
     Type: integer

     Default value: 48 Min value: 5 Max value: 2000

     Defines how aggressive the orange team is.  This is a percentage,
     if set to 200 then team will attack twice as much as any other team
     with the default value.  Setting this to a high value clearly
     advantages this team.

4.11.101 team-profile-orange-fast
---------------------------------

 -- Command-line option: '--team-profile-orange-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_ORANGE_FAST'
 -- XML key: 'team-profile-orange-fast'
     Type: integer

     Default value: 160 Min value: 5 Max value: 2000

     Changes the speed of the orange team.  This is a percentage, if set
     to 50, then team will move twice slower than other teams with the
     default parameter.  Setting this high is very likely to advantage
     the team.

4.11.102 team-profile-orange-handicap
-------------------------------------

 -- Command-line option: '--team-profile-orange-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_ORANGE_HANDICAP'
 -- XML key: 'team-profile-orange-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the orange team.

4.11.103 team-profile-orange-mobile
-----------------------------------

 -- Command-line option: '--team-profile-orange-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_ORANGE_MOBILE'
 -- XML key: 'team-profile-orange-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the orange team.  If set to a high
     value team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.104 team-profile-orange-vulnerable
---------------------------------------

 -- Command-line option: '--team-profile-orange-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_ORANGE_VULNERABLE'
 -- XML key: 'team-profile-orange-vulnerable'
     Type: integer

     Default value: 144 Min value: 5 Max value: 2000

     Defines how vulnerable the orange team is.  This is a percentage,
     if set to 200 then team will be attacked twice as much as any other
     team with the default value.  Setting this to a high value clearly
     disadvantages this team.

4.11.105 team-profile-orange-weapon-alternate-id
------------------------------------------------

 -- Command-line option:
          '--team-profile-orange-weapon-alternate-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_ORANGE_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-orange-weapon-alternate-id'
     Type: integer

     Default value: 16 Min value: 0 Max value: 19

     Id of the default alternate weapon for the orange team, see the
     documentation about weapons to know what these ids mean.

4.11.106 team-profile-orange-weapon-id
--------------------------------------

 -- Command-line option: '--team-profile-orange-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_ORANGE_WEAPON_ID'
 -- XML key: 'team-profile-orange-weapon-id'
     Type: integer

     Default value: 0 Min value: 0 Max value: 19

     Id of the default weapon for the orange team, see the documentation
     about weapons to know what these ids mean.

4.11.107 team-profile-orange-weapon-mode
----------------------------------------

 -- Command-line option: '--team-profile-orange-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_ORANGE_WEAPON_MODE'
 -- XML key: 'team-profile-orange-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for orange team.  0 means there's no weapon, 1 means
     one weapon per team, defined by the weapon-id parameter, 2 means
     random weapon.

4.11.108 team-profile-pink-aggressive
-------------------------------------

 -- Command-line option: '--team-profile-pink-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PINK_AGGRESSIVE'
 -- XML key: 'team-profile-pink-aggressive'
     Type: integer

     Default value: 640 Min value: 5 Max value: 2000

     Defines how aggressive the pink team is.  This is a percentage, if
     set to 200 then team will attack twice as much as any other team
     with the default value.  Setting this to a high value clearly
     advantages this team.

4.11.109 team-profile-pink-fast
-------------------------------

 -- Command-line option: '--team-profile-pink-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PINK_FAST'
 -- XML key: 'team-profile-pink-fast'
     Type: integer

     Default value: 80 Min value: 5 Max value: 2000

     Changes the speed of the pink team.  This is a percentage, if set
     to 50, then team will move twice slower than other teams with the
     default parameter.  Setting this high is very likely to advantage
     the team.

4.11.110 team-profile-pink-handicap
-----------------------------------

 -- Command-line option: '--team-profile-pink-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PINK_HANDICAP'
 -- XML key: 'team-profile-pink-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the pink team.

4.11.111 team-profile-pink-mobile
---------------------------------

 -- Command-line option: '--team-profile-pink-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PINK_MOBILE'
 -- XML key: 'team-profile-pink-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the pink team.  If set to a high
     value team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.112 team-profile-pink-vulnerable
-------------------------------------

 -- Command-line option: '--team-profile-pink-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PINK_VULNERABLE'
 -- XML key: 'team-profile-pink-vulnerable'
     Type: integer

     Default value: 640 Min value: 5 Max value: 2000

     Defines how vulnerable the pink team is.  This is a percentage, if
     set to 200 then team will be attacked twice as much as any other
     team with the default value.  Setting this to a high value clearly
     disadvantages this team.

4.11.113 team-profile-pink-weapon-alternate-id
----------------------------------------------

 -- Command-line option:
          '--team-profile-pink-weapon-alternate-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PINK_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-pink-weapon-alternate-id'
     Type: integer

     Default value: 19 Min value: 0 Max value: 19

     Id of the default alternate weapon for the pink team, see the
     documentation about weapons to know what these ids mean.

4.11.114 team-profile-pink-weapon-id
------------------------------------

 -- Command-line option: '--team-profile-pink-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PINK_WEAPON_ID'
 -- XML key: 'team-profile-pink-weapon-id'
     Type: integer

     Default value: 1 Min value: 0 Max value: 19

     Id of the default weapon for the pink team, see the documentation
     about weapons to know what these ids mean.

4.11.115 team-profile-pink-weapon-mode
--------------------------------------

 -- Command-line option: '--team-profile-pink-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PINK_WEAPON_MODE'
 -- XML key: 'team-profile-pink-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for pink team.  0 means there's no weapon, 1 means one
     weapon per team, defined by the weapon-id parameter, 2 means random
     weapon.

4.11.116 team-profile-purple-aggressive
---------------------------------------

 -- Command-line option: '--team-profile-purple-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PURPLE_AGGRESSIVE'
 -- XML key: 'team-profile-purple-aggressive'
     Type: integer

     Default value: 32 Min value: 5 Max value: 2000

     Defines how aggressive the purple team is.  This is a percentage,
     if set to 200 then team will attack twice as much as any other team
     with the default value.  Setting this to a high value clearly
     advantages this team.

4.11.117 team-profile-purple-fast
---------------------------------

 -- Command-line option: '--team-profile-purple-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PURPLE_FAST'
 -- XML key: 'team-profile-purple-fast'
     Type: integer

     Default value: 80 Min value: 5 Max value: 2000

     Changes the speed of the purple team.  This is a percentage, if set
     to 50, then team will move twice slower than other teams with the
     default parameter.  Setting this high is very likely to advantage
     the team.

4.11.118 team-profile-purple-handicap
-------------------------------------

 -- Command-line option: '--team-profile-purple-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PURPLE_HANDICAP'
 -- XML key: 'team-profile-purple-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the purple team.

4.11.119 team-profile-purple-mobile
-----------------------------------

 -- Command-line option: '--team-profile-purple-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PURPLE_MOBILE'
 -- XML key: 'team-profile-purple-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the purple team.  If set to a high
     value team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.120 team-profile-purple-vulnerable
---------------------------------------

 -- Command-line option: '--team-profile-purple-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PURPLE_VULNERABLE'
 -- XML key: 'team-profile-purple-vulnerable'
     Type: integer

     Default value: 16 Min value: 5 Max value: 2000

     Defines how vulnerable the purple team is.  This is a percentage,
     if set to 200 then team will be attacked twice as much as any other
     team with the default value.  Setting this to a high value clearly
     disadvantages this team.

4.11.121 team-profile-purple-weapon-alternate-id
------------------------------------------------

 -- Command-line option:
          '--team-profile-purple-weapon-alternate-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PURPLE_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-purple-weapon-alternate-id'
     Type: integer

     Default value: 18 Min value: 0 Max value: 19

     Id of the default alternate weapon for the purple team, see the
     documentation about weapons to know what these ids mean.

4.11.122 team-profile-purple-weapon-id
--------------------------------------

 -- Command-line option: '--team-profile-purple-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PURPLE_WEAPON_ID'
 -- XML key: 'team-profile-purple-weapon-id'
     Type: integer

     Default value: 11 Min value: 0 Max value: 19

     Id of the default weapon for the purple team, see the documentation
     about weapons to know what these ids mean.

4.11.123 team-profile-purple-weapon-mode
----------------------------------------

 -- Command-line option: '--team-profile-purple-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_PURPLE_WEAPON_MODE'
 -- XML key: 'team-profile-purple-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for purple team.  0 means there's no weapon, 1 means
     one weapon per team, defined by the weapon-id parameter, 2 means
     random weapon.

4.11.124 team-profile-red-aggressive
------------------------------------

 -- Command-line option: '--team-profile-red-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_RED_AGGRESSIVE'
 -- XML key: 'team-profile-red-aggressive'
     Type: integer

     Default value: 220 Min value: 5 Max value: 2000

     Defines how aggressive the red team is.  This is a percentage, if
     set to 200 then team will attack twice as much as any other team
     with the default value.  Setting this to a high value clearly
     advantages this team.

4.11.125 team-profile-red-fast
------------------------------

 -- Command-line option: '--team-profile-red-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_RED_FAST'
 -- XML key: 'team-profile-red-fast'
     Type: integer

     Default value: 160 Min value: 5 Max value: 2000

     Changes the speed of the red team.  This is a percentage, if set to
     50, then team will move twice slower than other teams with the
     default parameter.  Setting this high is very likely to advantage
     the team.

4.11.126 team-profile-red-handicap
----------------------------------

 -- Command-line option: '--team-profile-red-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_RED_HANDICAP'
 -- XML key: 'team-profile-red-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the red team.

4.11.127 team-profile-red-mobile
--------------------------------

 -- Command-line option: '--team-profile-red-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_RED_MOBILE'
 -- XML key: 'team-profile-red-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the red team.  If set to a high value
     team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.128 team-profile-red-vulnerable
------------------------------------

 -- Command-line option: '--team-profile-red-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_RED_VULNERABLE'
 -- XML key: 'team-profile-red-vulnerable'
     Type: integer

     Default value: 110 Min value: 5 Max value: 2000

     Defines how vulnerable the red team is.  This is a percentage, if
     set to 200 then team will be attacked twice as much as any other
     team with the default value.  Setting this to a high value clearly
     disadvantages this team.

4.11.129 team-profile-red-weapon-alternate-id
---------------------------------------------

 -- Command-line option:
          '--team-profile-red-weapon-alternate-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_RED_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-red-weapon-alternate-id'
     Type: integer

     Default value: 2 Min value: 0 Max value: 19

     Id of the default alternate weapon for the red team, see the
     documentation about weapons to know what these ids mean.

4.11.130 team-profile-red-weapon-id
-----------------------------------

 -- Command-line option: '--team-profile-red-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_RED_WEAPON_ID'
 -- XML key: 'team-profile-red-weapon-id'
     Type: integer

     Default value: 10 Min value: 0 Max value: 19

     Id of the default weapon for the red team, see the documentation
     about weapons to know what these ids mean.

4.11.131 team-profile-red-weapon-mode
-------------------------------------

 -- Command-line option: '--team-profile-red-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_RED_WEAPON_MODE'
 -- XML key: 'team-profile-red-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for red team.  0 means there's no weapon, 1 means one
     weapon per team, defined by the weapon-id parameter, 2 means random
     weapon.

4.11.132 team-profile-yellow-aggressive
---------------------------------------

 -- Command-line option: '--team-profile-yellow-aggressive=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_YELLOW_AGGRESSIVE'
 -- XML key: 'team-profile-yellow-aggressive'
     Type: integer

     Default value: 200 Min value: 5 Max value: 2000

     Defines how aggressive the yellow team is.  This is a percentage,
     if set to 200 then team will attack twice as much as any other team
     with the default value.  Setting this to a high value clearly
     advantages this team.

4.11.133 team-profile-yellow-fast
---------------------------------

 -- Command-line option: '--team-profile-yellow-fast=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_YELLOW_FAST'
 -- XML key: 'team-profile-yellow-fast'
     Type: integer

     Default value: 70 Min value: 5 Max value: 2000

     Changes the speed of the yellow team.  This is a percentage, if set
     to 50, then team will move twice slower than other teams with the
     default parameter.  Setting this high is very likely to advantage
     the team.

4.11.134 team-profile-yellow-handicap
-------------------------------------

 -- Command-line option: '--team-profile-yellow-handicap=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_YELLOW_HANDICAP'
 -- XML key: 'team-profile-yellow-handicap'
     Type: integer

     Default value: 100 Min value: 10 Max value: 1000

     Defines the handicap for the yellow team.

4.11.135 team-profile-yellow-mobile
-----------------------------------

 -- Command-line option: '--team-profile-yellow-mobile=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_YELLOW_MOBILE'
 -- XML key: 'team-profile-yellow-mobile'
     Type: integer

     Default value: 0 Min value: -3 Max value: 3

     Increases (or decreases if negative) the number of
     move/attack/defense tries for the yellow team.  If set to a high
     value team will appear more mobile and do more things, but it won't
     change its cruising speed.  It's not obvious to tell wether this is
     an advantage or not, but it clearly changes the behavior.

4.11.136 team-profile-yellow-vulnerable
---------------------------------------

 -- Command-line option: '--team-profile-yellow-vulnerable=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_YELLOW_VULNERABLE'
 -- XML key: 'team-profile-yellow-vulnerable'
     Type: integer

     Default value: 90 Min value: 5 Max value: 2000

     Defines how vulnerable the yellow team is.  This is a percentage,
     if set to 200 then team will be attacked twice as much as any other
     team with the default value.  Setting this to a high value clearly
     disadvantages this team.

4.11.137 team-profile-yellow-weapon-alternate-id
------------------------------------------------

 -- Command-line option:
          '--team-profile-yellow-weapon-alternate-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_YELLOW_WEAPON_ALTERNATE_ID'
 -- XML key: 'team-profile-yellow-weapon-alternate-id'
     Type: integer

     Default value: 9 Min value: 0 Max value: 19

     Id of the default alternate weapon for the yellow team, see the
     documentation about weapons to know what these ids mean.

4.11.138 team-profile-yellow-weapon-id
--------------------------------------

 -- Command-line option: '--team-profile-yellow-weapon-id=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_YELLOW_WEAPON_ID'
 -- XML key: 'team-profile-yellow-weapon-id'
     Type: integer

     Default value: 5 Min value: 0 Max value: 19

     Id of the default weapon for the yellow team, see the documentation
     about weapons to know what these ids mean.

4.11.139 team-profile-yellow-weapon-mode
----------------------------------------

 -- Command-line option: '--team-profile-yellow-weapon-mode=<value>'
 -- Environment variable: 'LW6_TEAM_PROFILE_YELLOW_WEAPON_MODE'
 -- XML key: 'team-profile-yellow-weapon-mode'
     Type: integer

     Default value: 1 Min value: 0 Max value: 2

     Weapon mode for yellow team.  0 means there's no weapon, 1 means
     one weapon per team, defined by the weapon-id parameter, 2 means
     random weapon.

4.11.140 total-armies-size
--------------------------

 -- Command-line option: '--total-armies-size=<value>'
 -- Environment variable: 'LW6_TOTAL_ARMIES_SIZE'
 -- XML key: 'total-armies-size'
     Type: integer

     Default value: 60 Min value: 1 Max value: 95

     Defines the proportion of the whole available space, which can be
     occupied by all the armies present together.  Setting this low,
     whenever a new team arrives on the map, fighters might be stolen to
     other teams, otherwise the ame would get too crowded.  This allows
     you to play with reasonnably enough fighters with 2 players, while
     still allowing interesting gameplay with many players.  This is a
     percentage, but will be multiplied by itself to get the actual
     surface.  That is, 50 means 50%*50%, that is, a square of 1/2 the
     size of a square map, so it represents 25% (1/4) of the total
     surface.

4.11.141 total-time
-------------------

 -- Command-line option: '--total-time=<value>'
 -- Environment variable: 'LW6_TOTAL_TIME'
 -- XML key: 'total-time'
     Type: integer

     Default value: 900 Min value: 10 Max value: 864000

     Defines the maximum time of the game, in seconds.  Note that in
     some cases, the game can end much earlier if some player has
     managed to win before the bell rings.  Also, technically, this
     value will be translated into rounds and moves, and the game engine
     will wait until enough rounds and moves have been played.  So if
     the computer is too slow and the desired speed is not reached, then
     the game will last for a longer time.

4.11.142 use-team-profiles
--------------------------

 -- Command-line option: '--use-team-profiles=<value>'
 -- Environment variable: 'LW6_USE_TEAM_PROFILES'
 -- XML key: 'use-team-profiles'
     Type: integer

     Default value: 1 Min value: 0 Max value: 1

     If set, then all the team-profile-...  values will be taken in
     account.  This enables a mode in which teams behave differently
     according to their colors.  If you disable this, then all teams
     will behave the same, which is more fair, but might not be as fun.

4.11.143 vertical-move
----------------------

 -- Command-line option: '--vertical-move=<value>'
 -- Environment variable: 'LW6_VERTICAL_MOVE'
 -- XML key: 'vertical-move'
     Type: integer

     Default value: 1 Min value: 0 Max value: 7

     Defines when to process a vertical move (along the Z 'depth' axis).
     If set to 0, fighters never spontaneously move along this axis.  If
     set to 1, it will be tried just after the first move failed.  If
     set to 2, it will be tried just after the second move failed.  And
     so on.

4.11.144 weapon-charge-delay
----------------------------

 -- Command-line option: '--weapon-charge-delay=<value>'
 -- Environment variable: 'LW6_WEAPON_CHARGE_DELAY'
 -- XML key: 'weapon-charge-delay'
     Type: integer

     Default value: 30 Min value: 1 Max value: 600

     How long it will take for weapons to charge and be usable, by
     default.  Unit is seconds.

4.11.145 weapon-charge-max
--------------------------

 -- Command-line option: '--weapon-charge-max=<value>'
 -- Environment variable: 'LW6_WEAPON_CHARGE_MAX'
 -- XML key: 'weapon-charge-max'
     Type: integer

     Default value: 200 Min value: 100 Max value: 1000

     Maximum (percentage) of charge intensity that one have.  For
     instance, if this is 400, then if you wait four times more than
     required before firing, then you weapon will have four times its
     default power, but if you wait five times more it will still be
     four times more powerfull, it's just the limit after which it's
     useless to charge.

4.11.146 weapon-duration
------------------------

 -- Command-line option: '--weapon-duration=<value>'
 -- Environment variable: 'LW6_WEAPON_DURATION'
 -- XML key: 'weapon-duration'
     Type: integer

     Default value: 3 Min value: 1 Max value: 60

     How long all weapons (for which duration makes sense) will last.
     Unit is seconds.

4.11.147 weapon-tune-berzerk-power
----------------------------------

 -- Command-line option: '--weapon-tune-berzerk-power=<value>'
 -- Environment variable: 'LW6_WEAPON_TUNE_BERZERK_POWER'
 -- XML key: 'weapon-tune-berzerk-power'
     Type: integer

     Default value: 3 Min value: 1 Max value: 100

     Use to specifiy how strong berzerk mode is, if set to 3, then
     attacks will be 3 times as efficient in berzerk mode.

4.11.148 weapon-tune-turbo-power
--------------------------------

 -- Command-line option: '--weapon-tune-turbo-power=<value>'
 -- Environment variable: 'LW6_WEAPON_TUNE_TURBO_POWER'
 -- XML key: 'weapon-tune-turbo-power'
     Type: integer

     Default value: 3 Min value: 1 Max value: 10

     Defines how fast fighters move in turbo mode, if set to 3, then
     fighters move and act 3 times as fast.

4.11.149 x-polarity
-------------------

 -- Command-line option: '--x-polarity=<value>'
 -- Environment variable: 'LW6_X_POLARITY'
 -- XML key: 'x-polarity'
     Type: integer

     Default value: 0 Min value: -1 Max value: 1

     Defines how the map will be wrapped on the X (horizontal) axis.  If
     set to 0, nothing is wrapped.  If set to 1, the right and left
     borders are connected, any fighter can disappear on the right
     border and reappear on the left border, for instance.  If set to
     -1, it will be wrapped but also inversed, that is on a 320x240 map,
     a fighter disappearing on the left border at position (0,60) will
     reapper on the right border at position (319,180).  You can combine
     it with 'y-polarity'.

4.11.150 y-polarity
-------------------

 -- Command-line option: '--y-polarity=<value>'
 -- Environment variable: 'LW6_Y_POLARITY'
 -- XML key: 'y-polarity'
     Type: integer

     Default value: 0 Min value: -1 Max value: 1

     Defines how the map will be wrapped on the Y (vertical) axis.  If
     set to 0, nothing is wrapped.  If set to 1, the top and bottom
     borders are connected, any fighter can disappear on the top border
     and reappear on the bottom border, for instance.  If set to -1, it
     will be wrapped but also inversed, that is on a 320x240 map, a
     fighter disappearing on the bottom border at position (40,239) will
     reapper on the top border at position (280,0).  You can combine it
     with 'x-polarity'.

4.11.151 z-polarity
-------------------

 -- Command-line option: '--z-polarity=<value>'
 -- Environment variable: 'LW6_Z_POLARITY'
 -- XML key: 'z-polarity'
     Type: integer

     Default value: 0 Min value: 0 Max value: 1

     Defines how the map will be wrapped on the Z (deep) axis.  If set
     to 0, nothing is wrapped.  If set to 1, when using a 4 layer map,
     for instance, fighters on layer 1 will be able to go directly to
     layer 4 even if layers 2 and 3 are filled with walls.  A value of
     -1 is forbidden, this is not like x and y axis, it does not really
     make sense.  Consider this an advanced setting which might save a
     layer in some tricky cases, the default value of 0 should fit in
     most cases.

4.12 Map hints.xml
==================

4.12.1 background-color-auto
----------------------------

 -- Command-line option: '--background-color-auto=<value>'
 -- Environment variable: 'LW6_BACKGROUND_COLOR_AUTO'
 -- XML key: 'background-color-auto'
     Type: boolean

     Default value: true

     Defines wether hud colors will be set automatically from base and
     alternate colors.  This is a time saver to keep map designers from
     requiring to redefined every single color in the game.  You only
     need to set color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg.  Then hud_color_frame_bg, hud_color_frame_fg,
     hud_color_text_bg and hud_color_text_fg will be automatically set.

4.12.2 downsize-using-bench-value
---------------------------------

 -- Command-line option: '--downsize-using-bench-value=<value>'
 -- Environment variable: 'LW6_DOWNSIZE_USING_BENCH_VALUE'
 -- XML key: 'downsize-using-bench-value'
     Type: boolean

     Default value: true

     If set, then the game will automatically downsize a map according
     to the 'bench-value' parameter.  Downsizing means: a 1600x1200 maps
     becomes 200x150, for instance.  Downsizing causes fighters to be
     bigger because map resolution is lower.  This will avoid running
     the game on a too big map, with your computer not being able to
     handle it at the required speed.

4.12.3 downsize-using-fighter-scale
-----------------------------------

 -- Command-line option: '--downsize-using-fighter-scale=<value>'
 -- Environment variable: 'LW6_DOWNSIZE_USING_FIGHTER_SCALE'
 -- XML key: 'downsize-using-fighter-scale'
     Type: boolean

     Default value: false

     If set, then the game will automatically downsize a map according
     to the 'fighter-scale' parameter.  Downsizing means: a 1600x1200
     maps becomes 200x150, for instance.  Downsizing causes fighters to
     be bigger because map resolution is lower.  This can be usefull if
     you don't want fighters to be too small.

4.12.4 fighter-scale
--------------------

 -- Command-line option: '--fighter-scale=<value>'
 -- Environment variable: 'LW6_FIGHTER_SCALE'
 -- XML key: 'fighter-scale'
     Type: float

     Default value: 1.0

     Defines how wide (in pixels) fighters must be.  This parameter is
     very important and will largely condition the number of fighters on
     the map.  It is used when loading the map.  If it is, for instance,
     set to 1, there will be exactly a fighter per pixel on the screen.
     That is, if you play 640x480 on an empty map, the maximum fighters
     you could have is about 300000.  The idea is that by changing the
     resolution, you also define the density of the map.  In pratice,
     this is done in the hope that someone with a slow computer will
     pick up a low resolution and therefore play small levels.
     Conversely, someone with a brand new computer with powerfull CPU &
     GPU will use great resolutions and be happy with many fighters on
     the map.  Still, changing the resolution after loading the map will
     not affet the number of fighters.  Same for network games, the
     first player, who loads the map, defines its properties according
     to its own settings.

4.12.5 guess-colors
-------------------

 -- Command-line option: '--guess-colors=<value>'
 -- Environment variable: 'LW6_GUESS_COLORS'
 -- XML key: 'guess-colors'
     Type: boolean

     Default value: true

     Defines wether colors should be set automatically from texture
     colors.  If set to true, then the program will try to pick up
     colors automatically from the texture, and will override the values
     of the color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg parameters.  How these colors are picked up
     can't be garanteed, so if the map does not have strong contrast or
     if there can be any form of ambiguity, it's safe to set this to
     false and define one's own colors.

4.12.6 guess-moves-per-sec
--------------------------

 -- Command-line option: '--guess-moves-per-sec=<value>'
 -- Environment variable: 'LW6_GUESS_MOVES_PER_SEC'
 -- XML key: 'guess-moves-per-sec'
     Type: boolean

     Default value: true

     If set, then loader will use 'time-to-cross-level' to guess the
     game speed parameters.

4.12.7 hud-color-auto
---------------------

 -- Command-line option: '--hud-color-auto=<value>'
 -- Environment variable: 'LW6_HUD_COLOR_AUTO'
 -- XML key: 'hud-color-auto'
     Type: boolean

     Default value: true

     Defines wether hud colors will be set automatically from base and
     alternate colors.  This is a time saver to keep map designers from
     requiring to redefined every single color in the game.  You only
     need to set color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg.  Then hud_color_frame_bg, hud_color_frame_fg,
     hud_color_text_bg and hud_color_text_fg will be automatically set.

4.12.8 max-map-height
---------------------

 -- Command-line option: '--max-map-height=<value>'
 -- Environment variable: 'LW6_MAX_MAP_HEIGHT'
 -- XML key: 'max-map-height'
     Type: integer

     Default value: 1000

     Allows you to give a maximum map height.  When designing a map you
     might wonder: this is dumb I'm conceiving this map I know its
     height, why should I limit it?  Now think of the play who plays on
     a old slowish computer with a tiny screen.  He might redefine this
     himself, and does not necessarly wishes to fire Gimp to rescale the
     map.

4.12.9 max-map-surface
----------------------

 -- Command-line option: '--max-map-surface=<value>'
 -- Environment variable: 'LW6_MAX_MAP_SURFACE'
 -- XML key: 'max-map-surface'
     Type: integer

     Default value: 1000000

     Allows you to give a maximum map surface.  Map surface is simply
     (width * height).  This parameter is just here to save you the
     hassle of defining both 'max-map-width' and 'max-map-height' in a
     consistent manner.

4.12.10 max-map-width
---------------------

 -- Command-line option: '--max-map-width=<value>'
 -- Environment variable: 'LW6_MAX_MAP_WIDTH'
 -- XML key: 'max-map-width'
     Type: integer

     Default value: 1500

     Allows you to give a maximum map width.  When designing a map you
     might wonder: this is dumb I'm conceiving this map I know its
     width, why should I limit it?  Now think of the play who plays on a
     old slowish computer with a tiny screen.  He might redefine this
     himself, and does not necessarly wishes to fire Gimp to rescale the
     map.

4.12.11 menu-color-auto
-----------------------

 -- Command-line option: '--menu-color-auto=<value>'
 -- Environment variable: 'LW6_MENU_COLOR_AUTO'
 -- XML key: 'menu-color-auto'
     Type: boolean

     Default value: true

     Defines wether menu colors will be set automatically from base and
     alternate colors.  This is a time saver to keep map designers from
     requiring to redefined every single color in the game.  You only
     need to set color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg.  Then menu_color_default_bg,
     menu_color_default_fg, menu_color_selected_bg,
     menu_color_selected_fg, menu_color_disabled_bg and
     menu_color_disabled_fg will be automatically set.

4.12.12 min-map-height
----------------------

 -- Command-line option: '--min-map-height=<value>'
 -- Environment variable: 'LW6_MIN_MAP_HEIGHT'
 -- XML key: 'min-map-height'
     Type: integer

     Default value: 30

     Allows you to give a minimum map height.  When designing a map you
     might wonder: this is dumb I'm conceiving this map I know its
     height, why should I limit it?  Now think of the player who decided
     to play with highly-defined maps because he has a super calculator
     and a hudge screen.  He might redefine this himself, and does not
     necessarly wishes to fire Gimp to rescale the map.

4.12.13 min-map-surface
-----------------------

 -- Command-line option: '--min-map-surface=<value>'
 -- Environment variable: 'LW6_MIN_MAP_SURFACE'
 -- XML key: 'min-map-surface'
     Type: integer

     Default value: 3600

     Allows you to give a minimum map surface.  Map surface is simply
     (width * height).  This parameter is just here to save you the
     hassle of defining both 'min-map-width' and 'min-map-height' in a
     consistent manner.

4.12.14 min-map-width
---------------------

 -- Command-line option: '--min-map-width=<value>'
 -- Environment variable: 'LW6_MIN_MAP_WIDTH'
 -- XML key: 'min-map-width'
     Type: integer

     Default value: 40

     Allows you to give a minimum map width.  When designing a map you
     might wonder: this is dumb I'm conceiving this map I know its
     width, why should I limit it?  Now think of the player who decided
     to play with highly-defined maps because he has a super calculator
     and a hudge screen.  He might redefine this himself, and does not
     necessarly wishes to fire Gimp to rescale the map.

4.12.15 resample
----------------

 -- Command-line option: '--resample=<value>'
 -- Environment variable: 'LW6_RESAMPLE'
 -- XML key: 'resample'
     Type: boolean

     Default value: true

     If set to true, maps will always be resampled to a size which
     depends on your screen resolution, zoom factor, and the rest.  If
     false, maps will be set at the exact resolution of map.png.

4.12.16 speed
-------------

 -- Command-line option: '--speed=<value>'
 -- Environment variable: 'LW6_SPEED'
 -- XML key: 'speed'
     Type: float

     Default value: 1.0

     This parameter is the main parameter on which game speed depends.
     The map loader will garantee, by downscaling the map, that to cross
     the level (by crossing the level we mean, for instance, going from
     top-left corner to bottom-right corner in a straight line) a
     fighter will take a constant amount of time.  Under the hood, the
     loader might of course rescale the map but it will also change game
     speed so that, at the end, fighters take a constant time to cross
     the level.  This is, indeed, the most important thing, players do
     not care much if internally there are X or Y moves per second, the
     global game experience depends on how fast fighter movement looks
     on the screen.  The default settings corresponds roughly to one
     second to cross the level.  If you set this to 2.0, it will go
     twice faster.

4.12.17 system-color-auto
-------------------------

 -- Command-line option: '--system-color-auto=<value>'
 -- Environment variable: 'LW6_SYSTEM_COLOR_AUTO'
 -- XML key: 'system-color-auto'
     Type: boolean

     Default value: true

     Defines wether system colors will be set automatically from base
     and alternate colors.  This is a time saver to keep map designers
     from requiring to redefined every single color in the game.  You
     only need to set color-base-bg, color-base-fg, color-alternate-bg
     and color-alternate-fg.  Then system_color_bg and system_color_fg
     will be automatically set.

4.12.18 upsize-using-bench-value
--------------------------------

 -- Command-line option: '--upsize-using-bench-value=<value>'
 -- Environment variable: 'LW6_UPSIZE_USING_BENCH_VALUE'
 -- XML key: 'upsize-using-bench-value'
     Type: boolean

     Default value: false

     If set, then the game will automatically upsize a map according to
     the 'fighter-scale' parameter.  Upsizing means: a 160x120 maps
     becomes 400x300, for instance.  Upsizing causes fighters to be
     smaller because map resolution is higher.  This will avoid useless
     pixelish 'jumbo fighters' look when your computer is powerfull
     enough to do better.

4.12.19 upsize-using-fighter-scale
----------------------------------

 -- Command-line option: '--upsize-using-fighter-scale=<value>'
 -- Environment variable: 'LW6_UPSIZE_USING_FIGHTER_SCALE'
 -- XML key: 'upsize-using-fighter-scale'
     Type: boolean

     Default value: true

     If set, then the game will automatically upsize a map according to
     the 'fighter-scale' parameter.  Upsizing means: a 160x120 maps
     becomes 400x300, for instance.  Upsizing causes fighters to be
     smaller because map resolution is higher.  This can be usefull if
     you don't want fighters to be too big.

4.12.20 view-color-auto
-----------------------

 -- Command-line option: '--view-color-auto=<value>'
 -- Environment variable: 'LW6_VIEW_COLOR_AUTO'
 -- XML key: 'view-color-auto'
     Type: boolean

     Default value: true

     Defines wether view colors will be set automatically from base and
     alternate colors.  This is a time saver to keep map designers from
     requiring to redefined every single color in the game.  You only
     need to set color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg.  Then view_color_cursor_bg,
     view_color_cursor_fg, view_color_map_bg and view_color_map_fg will
     be automatically set.

4.12.21 wall-grease
-------------------

 -- Command-line option: '--wall-grease=<value>'
 -- Environment variable: 'LW6_WALL_GREASE'
 -- XML key: 'wall-grease'
     Type: integer

     Default value: 0 Min value: -5 Max value: 5

     This parameter allows you to make walls (AKA map foreground)
     thicker, or thiner, when map is loaded.  Indeed, when map are
     resampled, and especially when they are downscaled, some walls may
     disappear, or some passages may be blocked.  The loader can't
     automatically figure out wether it's more important to keep an
     existing wall or to keep an open passage for fighters.  This
     parameter helps doing so, if you set it to a low value, level will
     be less greasy, and many passages might open themselves.  On the
     contrary, if grease is at a high level, then a thin line of almost
     isolated pixels might become a thick wall.  There's no real
     garantee your wall or passage will always be present, but it's a
     same bet to assume on a 'tunnel-like' level one needs to set grease
     to a low value, and on a 'wide open' level with few walls one needs
     to set grease to a high value.

4.13 Map style.xml
==================

4.13.1 animation-density
------------------------

 -- Command-line option: '--animation-density=<value>'
 -- Environment variable: 'LW6_ANIMATION_DENSITY'
 -- XML key: 'animation-density'
     Type: float

     Default value: 1.0 Min value: 0 Max value: 10

     Density of the background animation, that is, for instance, if the
     background animation is about displaying bubbles, using a high
     value will display many bubbles.  A value of 1.0 corresponds to the
     default setting.

4.13.2 animation-speed
----------------------

 -- Command-line option: '--animation-speed=<value>'
 -- Environment variable: 'LW6_ANIMATION_SPEED'
 -- XML key: 'animation-speed'
     Type: float

     Default value: 1.0 Min value: 0 Max value: 10

     Speed of the background animation, that is, for instance, if the
     background animation is about displaying bubbles, using a high
     value will cause bubbles to move very fast.  A value of 1.0
     corresponds to the default setting.

4.13.3 background-color-root-bg
-------------------------------

 -- Command-line option: '--background-color-root-bg=<value>'
 -- Environment variable: 'LW6_BACKGROUND_COLOR_ROOT_BG'
 -- XML key: 'background-color-root-bg'
     Type: color

     Default value: #000000

     Defines the main background color.  This is, for instance, the
     color which will be used to clear the screen before drawing thing.
     Will be automatically guessed from the map texture if color-auto is
     set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.4 background-color-root-fg
-------------------------------

 -- Command-line option: '--background-color-root-fg=<value>'
 -- Environment variable: 'LW6_BACKGROUND_COLOR_ROOT_FG'
 -- XML key: 'background-color-root-fg'
     Type: color

     Default value: #cccccc

     Defines a color which will be used together with color-base-bg to
     compose the background.  It can be wise to have a minimum contrast
     between this color and color-base-bg, but it is not mandatory,
     especially if other colors are manually redefined.  Will be
     automatically guessed from the map texture if color-auto is set.
     Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.5 background-color-stuff-bg
--------------------------------

 -- Command-line option: '--background-color-stuff-bg=<value>'
 -- Environment variable: 'LW6_BACKGROUND_COLOR_STUFF_BG'
 -- XML key: 'background-color-stuff-bg'
     Type: color

     Default value: #333333

     Defines a color which will be used together with color-alternate-fg
     to draw things (animations, sprites, text, whatever) in the
     background.  It should be different enough from color-alternate-fg
     so that one can really distinguish these colors.  Will be
     automatically guessed from the map texture if color-auto is set.
     Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.6 background-color-stuff-fg
--------------------------------

 -- Command-line option: '--background-color-stuff-fg=<value>'
 -- Environment variable: 'LW6_BACKGROUND_COLOR_STUFF_FG'
 -- XML key: 'background-color-stuff-fg'
     Type: color

     Default value: #ffffff

     Defines a color which will be used to draw things (animations,
     sprites, text, whatever) in the background.  It should be different
     enough from color-alternate-bg so that one can really distinguish
     these colors.  Think of this as the sprite, the text, the
     whatever-needs-to-be-seen-uses-this color.  Will be automatically
     guessed from the map texture if color-auto is set.  Can be #RGB,
     #RGBA, #RRGGBB or #RRGGBBAA.

4.13.7 background-style
-----------------------

 -- Command-line option: '--background-style=<value>'
 -- Environment variable: 'LW6_BACKGROUND_STYLE'
 -- XML key: 'background-style'
     Type: string

     Default value: bubbles

     The background defines, of course, what is displayed at the
     background, but it also conditions the colors used for other items,
     such as the menus for instance.  The possible values are 'void' and
     'bubbles'.

4.13.8 blink-cursor
-------------------

 -- Command-line option: '--blink-cursor=<value>'
 -- Environment variable: 'LW6_BLINK_CURSOR'
 -- XML key: 'blink-cursor'
     Type: boolean

     Default value: false

     If set, then cursor will blink, allowing you to see what's under
     the cursor.  It's just a matter of taste, you might to always have
     your cursor displayed, or prefer to have it disappear from time to
     time so that you can see the action below

4.13.9 color-alternate-bg
-------------------------

 -- Command-line option: '--color-alternate-bg=<value>'
 -- Environment variable: 'LW6_COLOR_ALTERNATE_BG'
 -- XML key: 'color-alternate-bg'
     Type: color

     Default value: #333333

     Defines the alternate color, more precisely, its bg (background)
     part.  Colors are always defined by a bg/fg pair.  Most colors in
     the game can be deduced from this one, usually to color a map you
     only need to define color-base-bg, color-base-fg,
     color-alternate-bg and color-alternate-fg.

4.13.10 color-alternate-fg
--------------------------

 -- Command-line option: '--color-alternate-fg=<value>'
 -- Environment variable: 'LW6_COLOR_ALTERNATE_FG'
 -- XML key: 'color-alternate-fg'
     Type: color

     Default value: #ffffff

     Defines the alternate color, more precisely, its fg (foreground)
     part.  Colors are always defined by a bg/fg pair.  Most colors in
     the game can be deduced from this one, usually to color a map you
     only need to define color-base-bg, color-base-fg,
     color-alternate-bg and color-alternate-fg.

4.13.11 color-base-bg
---------------------

 -- Command-line option: '--color-base-bg=<value>'
 -- Environment variable: 'LW6_COLOR_BASE_BG'
 -- XML key: 'color-base-bg'
     Type: color

     Default value: #000000

     Defines the base color, more precisely, its bg (background) part.
     Colors are always defined by a bg/fg pair.  Most colors in the game
     can be deduced from this one, usually to color a map you only need
     to define color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg.

4.13.12 color-base-fg
---------------------

 -- Command-line option: '--color-base-fg=<value>'
 -- Environment variable: 'LW6_COLOR_BASE_FG'
 -- XML key: 'color-base-fg'
     Type: color

     Default value: #cccccc

     Defines the base color, more precisely, its fg (foreground) part.
     Colors are always defined by a bg/fg pair.  Most colors in the game
     can be deduced from this one, usually to color a map you only need
     to define color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg.

4.13.13 colorize
----------------

 -- Command-line option: '--colorize=<value>'
 -- Environment variable: 'LW6_COLORIZE'
 -- XML key: 'colorize'
     Type: boolean

     Default value: true

     If set, then all background drawings including textures will use
     the background colors.  This means, for instance, that if
     background colors are set automatically by color-auto from the map
     texture, then the background will adopt the same range of colors
     than the map itself.  In short, the background will mimic the map.

4.13.14 colorize-cursor
-----------------------

 -- Command-line option: '--colorize-cursor=<value>'
 -- Environment variable: 'LW6_COLORIZE_CURSOR'
 -- XML key: 'colorize-cursor'
     Type: boolean

     Default value: true

     If set, then all cursors will use the automatic guessed colors, or
     the specified colors, but basically they won't be displayed using
     their native colors.  This can be usefull for you can wish to use a
     generic non-colored texture for your cursor and let it be colorized
     automatically so that it's accorded to the level.

4.13.15 cursor-size
-------------------

 -- Command-line option: '--cursor-size=<value>'
 -- Environment variable: 'LW6_CURSOR_SIZE'
 -- XML key: 'cursor-size'
     Type: float

     Default value: 1.0 Min value: 0 Max value: 10

     Size of the cursors on the map.  1 is the default, setting it to a
     higher value will make cursors bigger, a lower value will make them
     smaller.

4.13.16 hidden-layer-alpha
--------------------------

 -- Command-line option: '--hidden-layer-alpha=<value>'
 -- Environment variable: 'LW6_HIDDEN_LAYER_ALPHA'
 -- XML key: 'hidden-layer-alpha'
     Type: float

     Default value: 0.1 Min value: 0 Max value: 1

     Whenever players are supposed to be hidden behind a wall, for
     instance if they are in layer 2 and layer 1 is filled with walls,
     it's still possible to see them, but with a low alpha value (almost
     transparent).  This parameter allows you to trick this value, 0
     will make these players absolutely invisible, 1 will make them
     totally opaque, like if they were on layer 1.

4.13.17 hud-color-frame-bg
--------------------------

 -- Command-line option: '--hud-color-frame-bg=<value>'
 -- Environment variable: 'LW6_HUD_COLOR_FRAME_BG'
 -- XML key: 'hud-color-frame-bg'
     Type: color

     Default value: #000000

     Defines the background color for the hud frame.  Ignored if
     hud-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.18 hud-color-frame-fg
--------------------------

 -- Command-line option: '--hud-color-frame-fg=<value>'
 -- Environment variable: 'LW6_HUD_COLOR_FRAME_FG'
 -- XML key: 'hud-color-frame-fg'
     Type: color

     Default value: #cccccc

     Defines the foreground color for the hud frame.  Ignored if
     hud-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.19 hud-color-text-bg
-------------------------

 -- Command-line option: '--hud-color-text-bg=<value>'
 -- Environment variable: 'LW6_HUD_COLOR_TEXT_BG'
 -- XML key: 'hud-color-text-bg'
     Type: color

     Default value: #333333

     Defines the background color for hud text.  Ignored if
     hud-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.20 hud-color-text-fg
-------------------------

 -- Command-line option: '--hud-color-text-fg=<value>'
 -- Environment variable: 'LW6_HUD_COLOR_TEXT_FG'
 -- XML key: 'hud-color-text-fg'
     Type: color

     Default value: #ffffff

     Defines the foreground color for hud text.  Ignored if
     hud-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.21 hud-style
-----------------

 -- Command-line option: '--hud-style=<value>'
 -- Environment variable: 'LW6_HUD_STYLE'
 -- XML key: 'hud-style'
     Type: string

     Default value: floating

     The hud is where informations about the game are displayed.  This
     means, who is winning, are other status-like informations.
     Possible values include 'floating' and 'tactical'.

4.13.22 keep-ratio
------------------

 -- Command-line option: '--keep-ratio=<value>'
 -- Environment variable: 'LW6_KEEP_RATIO'
 -- XML key: 'keep-ratio'
     Type: boolean

     Default value: true

     Defines wether the map should keep its ratio, or if it should be
     stretched to fill the shape of your screen.

4.13.23 menu-color-default-bg
-----------------------------

 -- Command-line option: '--menu-color-default-bg=<value>'
 -- Environment variable: 'LW6_MENU_COLOR_DEFAULT_BG'
 -- XML key: 'menu-color-default-bg'
     Type: color

     Default value: #333333

     Defines the default background color for menus.  Ignored if
     menu-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.24 menu-color-default-fg
-----------------------------

 -- Command-line option: '--menu-color-default-fg=<value>'
 -- Environment variable: 'LW6_MENU_COLOR_DEFAULT_FG'
 -- XML key: 'menu-color-default-fg'
     Type: color

     Default value: #ffffff

     Defines the default foreground color for menus.  In fact, this is
     the main color for menu text, the color used to draw letters in
     menus.  Ignored if menu-color-auto is set.  Can be #RGB, #RGBA,
     #RRGGBB or #RRGGBBAA.

4.13.25 menu-color-disabled-bg
------------------------------

 -- Command-line option: '--menu-color-disabled-bg=<value>'
 -- Environment variable: 'LW6_MENU_COLOR_DISABLED_BG'
 -- XML key: 'menu-color-disabled-bg'
     Type: color

     Default value: #000000

     Defines the background color for a disabled menu item.  Ignored if
     menu-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.26 menu-color-disabled-fg
------------------------------

 -- Command-line option: '--menu-color-disabled-fg=<value>'
 -- Environment variable: 'LW6_MENU_COLOR_DISABLED_FG'
 -- XML key: 'menu-color-disabled-fg'
     Type: color

     Default value: #cccccc

     Defines the foreground color for a disabled menu item.  Ignored if
     menu-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.27 menu-color-selected-bg
------------------------------

 -- Command-line option: '--menu-color-selected-bg=<value>'
 -- Environment variable: 'LW6_MENU_COLOR_SELECTED_BG'
 -- XML key: 'menu-color-selected-bg'
     Type: color

     Default value: #ffffff

     Defines the background color for a selected menu item.  Ignored if
     menu-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.28 menu-color-selected-fg
------------------------------

 -- Command-line option: '--menu-color-selected-fg=<value>'
 -- Environment variable: 'LW6_MENU_COLOR_SELECTED_FG'
 -- XML key: 'menu-color-selected-fg'
     Type: color

     Default value: #333333

     Defines the foreground color for a selected menu item.  Ignored if
     menu-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.29 menu-style
------------------

 -- Command-line option: '--menu-style=<value>'
 -- Environment variable: 'LW6_MENU_STYLE'
 -- XML key: 'menu-style'
     Type: string

     Default value: cylinder

     The menu style is simply the name of the engine used to power the
     menu system.  The only possible value, for now, is 'cylinder'.

4.13.30 music-exclude
---------------------

 -- Command-line option: '--music-exclude=<value>'
 -- Environment variable: 'LW6_MUSIC_EXCLUDE'
 -- XML key: 'music-exclude'
     Type: string

     Default value: Chadburn

     If this string is found in a music file name, it will be excluded
     from the list when playing in random mode.

4.13.31 music-file
------------------

 -- Command-line option: '--music-file=<value>'
 -- Environment variable: 'LW6_MUSIC_FILE'
 -- XML key: 'music-file'
     Type: string

     Default value:

     Allows you to play a custom music file (typically your own ogg
     music) and override default game music.  If file does not exist,
     game will use its internal music.  The file will be searched for in
     the current 'music-path' but also in the current map directory.  No
     absolute or even relative path are allowed, only a plain filename
     with no slash or backslash.  Avoid special characters at all cost.

4.13.32 music-filter
--------------------

 -- Command-line option: '--music-filter=<value>'
 -- Environment variable: 'LW6_MUSIC_FILTER'
 -- XML key: 'music-filter'
     Type: string

     Default value:

     A music filter, used when files are played randomly.  This is not a
     complex regex-enabled filter, just a plain string search.  Even the
     '*' wildcard won't work.  If you want precise control on what music
     file to play, please consider reorganizing your files and/or use
     the 'music-file' parameter.

4.13.33 pixelize
----------------

 -- Command-line option: '--pixelize=<value>'
 -- Environment variable: 'LW6_PIXELIZE'
 -- XML key: 'pixelize'
     Type: boolean

     Default value: false

     Depending on the renderer capabilities, will try to pixelize some
     parts of the game.  This can be used to emulate the old LW5
     appearance.

4.13.34 system-color-bg
-----------------------

 -- Command-line option: '--system-color-bg=<value>'
 -- Environment variable: 'LW6_SYSTEM_COLOR_BG'
 -- XML key: 'system-color-bg'
     Type: color

     Default value: #333333

     Defines the system background color, used when displaying system
     info, such as the number of frames per second.  Can be #RGB, #RGBA,
     #RRGGBB or #RRGGBBAA.

4.13.35 system-color-fg
-----------------------

 -- Command-line option: '--system-color-fg=<value>'
 -- Environment variable: 'LW6_SYSTEM_COLOR_FG'
 -- XML key: 'system-color-fg'
     Type: color

     Default value: #ffffff

     Defines the system foreground color, used when displaying system
     info, such as the number of frames per second.  This will typically
     be text color.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.36 team-color-blue
-----------------------

 -- Command-line option: '--team-color-blue=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_BLUE'
 -- XML key: 'team-color-blue'
     Type: color

     Default value: #0000ff

     Defines the color for the blue team.  Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.37 team-color-cyan
-----------------------

 -- Command-line option: '--team-color-cyan=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_CYAN'
 -- XML key: 'team-color-cyan'
     Type: color

     Default value: #00ffff

     Defines the color for the cyan team.  Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.38 team-color-dead
-----------------------

 -- Command-line option: '--team-color-dead=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_DEAD'
 -- XML key: 'team-color-dead'
     Type: color

     Default value: #000000

     Defines the color for the teams when they are dead.  By default it
     is black, this means when a team is weak it becomes black.  Syntax
     is HTML-like, #RGB or #RRGGBB.

4.13.39 team-color-green
------------------------

 -- Command-line option: '--team-color-green=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_GREEN'
 -- XML key: 'team-color-green'
     Type: color

     Default value: #00ff00

     Defines the color for the green team.  Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.40 team-color-lightblue
----------------------------

 -- Command-line option: '--team-color-lightblue=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_LIGHTBLUE'
 -- XML key: 'team-color-lightblue'
     Type: color

     Default value: #88bbff

     Defines the color for the light blue team.  Syntax is HTML-like,
     #RGB or #RRGGBB.

4.13.41 team-color-magenta
--------------------------

 -- Command-line option: '--team-color-magenta=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_MAGENTA'
 -- XML key: 'team-color-magenta'
     Type: color

     Default value: #ff00ff

     Defines the color for the magenta team.  Syntax is HTML-like, #RGB
     or #RRGGBB.

4.13.42 team-color-orange
-------------------------

 -- Command-line option: '--team-color-orange=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_ORANGE'
 -- XML key: 'team-color-orange'
     Type: color

     Default value: #ff8800

     Defines the color for the orange team.  Syntax is HTML-like, #RGB
     or #RRGGBB.

4.13.43 team-color-pink
-----------------------

 -- Command-line option: '--team-color-pink=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_PINK'
 -- XML key: 'team-color-pink'
     Type: color

     Default value: #ff88bb

     Defines the color for the pink team.  Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.44 team-color-purple
-------------------------

 -- Command-line option: '--team-color-purple=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_PURPLE'
 -- XML key: 'team-color-purple'
     Type: color

     Default value: #bb88ff

     Defines the color for the purple team.  Syntax is HTML-like, #RGB
     or #RRGGBB.

4.13.45 team-color-red
----------------------

 -- Command-line option: '--team-color-red=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_RED'
 -- XML key: 'team-color-red'
     Type: color

     Default value: #ff0000

     Defines the color for the red team.  Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.46 team-color-yellow
-------------------------

 -- Command-line option: '--team-color-yellow=<value>'
 -- Environment variable: 'LW6_TEAM_COLOR_YELLOW'
 -- XML key: 'team-color-yellow'
     Type: color

     Default value: #ffff00

     Defines the color for the yellow team.  Syntax is HTML-like, #RGB
     or #RRGGBB.

4.13.47 view-color-cursor-bg
----------------------------

 -- Command-line option: '--view-color-cursor-bg=<value>'
 -- Environment variable: 'LW6_VIEW_COLOR_CURSOR_BG'
 -- XML key: 'view-color-cursor-bg'
     Type: color

     Default value: #333333

     Defines the background cursor color.  Will typically be used to
     draw the shape of the cursor.  Ignored if view-color-auto is set.
     Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.48 view-color-cursor-fg
----------------------------

 -- Command-line option: '--view-color-cursor-fg=<value>'
 -- Environment variable: 'LW6_VIEW_COLOR_CURSOR_FG'
 -- XML key: 'view-color-cursor-fg'
     Type: color

     Default value: #ffffff

     Defines the foreground cursor color.  Will typically be used to
     draw text in the cursor.  Ignored if view-color-auto is set.  Can
     be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.49 view-color-map-bg
-------------------------

 -- Command-line option: '--view-color-map-bg=<value>'
 -- Environment variable: 'LW6_VIEW_COLOR_MAP_BG'
 -- XML key: 'view-color-map-bg'
     Type: color

     Default value: #000000

     Defines the background map color.  If there's no map texture
     defined or if use-texture is false, this is the color of the places
     where armies will go.  Ignored if view-color-auto is set.  Can be
     #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.50 view-color-map-fg
-------------------------

 -- Command-line option: '--view-color-map-fg=<value>'
 -- Environment variable: 'LW6_VIEW_COLOR_MAP_FG'
 -- XML key: 'view-color-map-fg'
     Type: color

     Default value: #cccccc

     Defines the foreground map color.  If there's no map texture
     defined or if use-texture is false, this is the color of walls,
     what armies can't go through.  Ignored if view-color-auto is set.
     Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.51 view-style
------------------

 -- Command-line option: '--view-style=<value>'
 -- Environment variable: 'LW6_VIEW_STYLE'
 -- XML key: 'view-style'
     Type: string

     Default value: flat

     The view style conditions which renderer is used for the map, the
     area where fighters are displayed.  This is not the graphics
     backend.  Indeed, the graphics backend defines which technical tool
     one uses (which library) one runs, wether this parameter says what
     kind of rendering one wants.

4.13.52 waves
-------------

 -- Command-line option: '--waves=<value>'
 -- Environment variable: 'LW6_WAVES'
 -- XML key: 'waves'
     Type: boolean

     Default value: true

     Activates the wave effect, that's to say level appears to be under
     water when playing.

4.13.53 x-wrap
--------------

 -- Command-line option: '--x-wrap=<value>'
 -- Environment variable: 'LW6_X_WRAP'
 -- XML key: 'x-wrap'
     Type: boolean

     Default value: true

     Defines wether the map should be wrapped on the x axis.  This is
     the companion of 'x-polarity', if no polarity is defined, map can't
     be wrapped, but in some cases, one might wish to have a map with
     polarity but without wrapping if, for instance, textures do not
     tile nicely.

4.13.54 y-wrap
--------------

 -- Command-line option: '--y-wrap=<value>'
 -- Environment variable: 'LW6_Y_WRAP'
 -- XML key: 'y-wrap'
     Type: boolean

     Default value: true

     Defines wether the map should be wrapped on the y axis.  This is
     the companion of 'y-polarity', if no polarity is defined, map can't
     be wrapped, but in some cases, one might wish to have a map with
     polarity but without wrapping if, for instance, textures do not
     tile nicely.

4.13.55 zoom
------------

 -- Command-line option: '--zoom=<value>'
 -- Environment variable: 'LW6_ZOOM'
 -- XML key: 'zoom'
     Type: float

     Default value: 1.0

     Defines the map zoom.  If lower than 1.0, map will occupy only a
     fraction of the screen, if greater than 1.0, some areas will be
     outside the screen, and the player will need to scroll through it.

4.13.56 zoom-max
----------------

 -- Command-line option: '--zoom-max=<value>'
 -- Environment variable: 'LW6_ZOOM_MAX'
 -- XML key: 'zoom-max'
     Type: float

     Default value: 30.0

     Defines the max map zoom.  If set to a high value, you'll be able
     to dynamically view the map with hudge fighters, seeing only a
     fraction of the level.

4.13.57 zoom-min
----------------

 -- Command-line option: '--zoom-min=<value>'
 -- Environment variable: 'LW6_ZOOM_MIN'
 -- XML key: 'zoom-min'
     Type: float

     Default value: 0.3

     Defines the min map zoom.  If set to a low value, you'll be able to
     dynamically view a very small, reduced map.

4.14 Map teams.xml
==================

4.14.1 bot-iq
-------------

 -- Command-line option: '--bot-iq=<value>'
 -- Environment variable: 'LW6_BOT_IQ'
 -- XML key: 'bot-iq'
     Type: integer

     Default value: 100 Min value: 0 Max value: 200

     The IQ (intelligence quotient) of bots.  Typically, a value of 100
     will make the bot behave normally, performing at its best.  A value
     of 0 will just make it act the worst way it can.  Values over 100
     probably won't change anything compared to 100, but this truely
     depends on which bot backend you're running.

4.14.2 bot-speed
----------------

 -- Command-line option: '--bot-speed=<value>'
 -- Environment variable: 'LW6_BOT_SPEED'
 -- XML key: 'bot-speed'
     Type: float

     Default value: 1.0f

     The speed of bots, 1 means normal speed, higher value will speed it
     up, lower will slow it down.  Note that this only has an impact on
     bot engines, not on the game speed itself.

4.14.3 bot1-ai
--------------

 -- Command-line option: '--bot1-ai=<value>'
 -- Environment variable: 'LW6_BOT1_AI'
 -- XML key: 'bot1-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 1.

4.14.4 bot1-color
-----------------

 -- Command-line option: '--bot1-color=<value>'
 -- Environment variable: 'LW6_BOT1_COLOR'
 -- XML key: 'bot1-color'
     Type: string

     Default value: green

     Color for bot number 1.

4.14.5 bot2-ai
--------------

 -- Command-line option: '--bot2-ai=<value>'
 -- Environment variable: 'LW6_BOT2_AI'
 -- XML key: 'bot2-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 2.

4.14.6 bot2-color
-----------------

 -- Command-line option: '--bot2-color=<value>'
 -- Environment variable: 'LW6_BOT2_COLOR'
 -- XML key: 'bot2-color'
     Type: string

     Default value: blue

     Color for bot number 2.

4.14.7 bot3-ai
--------------

 -- Command-line option: '--bot3-ai=<value>'
 -- Environment variable: 'LW6_BOT3_AI'
 -- XML key: 'bot3-ai'
     Type: string

     Default value: random

     AI engine for bot number 3.

4.14.8 bot3-color
-----------------

 -- Command-line option: '--bot3-color=<value>'
 -- Environment variable: 'LW6_BOT3_COLOR'
 -- XML key: 'bot3-color'
     Type: string

     Default value: yellow

     Color for bot number 3.

4.14.9 bot4-ai
--------------

 -- Command-line option: '--bot4-ai=<value>'
 -- Environment variable: 'LW6_BOT4_AI'
 -- XML key: 'bot4-ai'
     Type: string

     Default value: follow

     AI engine for bot number 4.

4.14.10 bot4-color
------------------

 -- Command-line option: '--bot4-color=<value>'
 -- Environment variable: 'LW6_BOT4_COLOR'
 -- XML key: 'bot4-color'
     Type: string

     Default value: cyan

     Color for bot number 4.

4.14.11 bot5-ai
---------------

 -- Command-line option: '--bot5-ai=<value>'
 -- Environment variable: 'LW6_BOT5_AI'
 -- XML key: 'bot5-ai'
     Type: string

     Default value: random

     AI engine for bot number 5.

4.14.12 bot5-color
------------------

 -- Command-line option: '--bot5-color=<value>'
 -- Environment variable: 'LW6_BOT5_COLOR'
 -- XML key: 'bot5-color'
     Type: string

     Default value: magenta

     Color for bot number 5.

4.14.13 bot6-ai
---------------

 -- Command-line option: '--bot6-ai=<value>'
 -- Environment variable: 'LW6_BOT6_AI'
 -- XML key: 'bot6-ai'
     Type: string

     Default value: follow

     AI engine for bot number 6.

4.14.14 bot6-color
------------------

 -- Command-line option: '--bot6-color=<value>'
 -- Environment variable: 'LW6_BOT6_COLOR'
 -- XML key: 'bot6-color'
     Type: string

     Default value: orange

     Color for bot number 6.

4.14.15 bot7-ai
---------------

 -- Command-line option: '--bot7-ai=<value>'
 -- Environment variable: 'LW6_BOT7_AI'
 -- XML key: 'bot7-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 7.

4.14.16 bot7-color
------------------

 -- Command-line option: '--bot7-color=<value>'
 -- Environment variable: 'LW6_BOT7_COLOR'
 -- XML key: 'bot7-color'
     Type: string

     Default value: lightblue

     Color for bot number 7.

4.14.17 bot8-ai
---------------

 -- Command-line option: '--bot8-ai=<value>'
 -- Environment variable: 'LW6_BOT8_AI'
 -- XML key: 'bot8-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 8.

4.14.18 bot8-color
------------------

 -- Command-line option: '--bot8-color=<value>'
 -- Environment variable: 'LW6_BOT8_COLOR'
 -- XML key: 'bot8-color'
     Type: string

     Default value: purple

     Color for bot number 8.

4.14.19 bot9-ai
---------------

 -- Command-line option: '--bot9-ai=<value>'
 -- Environment variable: 'LW6_BOT9_AI'
 -- XML key: 'bot9-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 9.

4.14.20 bot9-color
------------------

 -- Command-line option: '--bot9-color=<value>'
 -- Environment variable: 'LW6_BOT9_COLOR'
 -- XML key: 'bot9-color'
     Type: string

     Default value: pink

     Color for bot number 9.

4.14.21 nb-bots
---------------

 -- Command-line option: '--nb-bots=<value>'
 -- Environment variable: 'LW6_NB_BOTS'
 -- XML key: 'nb-bots'
     Type: integer

     Default value: 2 Min value: 0 Max value: 9

     Number of bots on the map.  0 means no bots, if set to 1 the the
     bot1-...  settings will be used, if set to 2 then bot1-...  and
     bot2-...  will be used, and so on.

4.14.22 player1-color
---------------------

 -- Command-line option: '--player1-color=<value>'
 -- Environment variable: 'LW6_PLAYER1_COLOR'
 -- XML key: 'player1-color'
     Type: string

     Default value: red

     Color of the first player, must be red, green, blue, yellow, cyan,
     magenta, orange, lightblue, purple or pink

4.14.23 player2-color
---------------------

 -- Command-line option: '--player2-color=<value>'
 -- Environment variable: 'LW6_PLAYER2_COLOR'
 -- XML key: 'player2-color'
     Type: string

     Default value: green

     Color of the second player, must be red, green, blue, yellow, cyan,
     magenta, orange, lightblue, purple or pink

4.14.24 player3-color
---------------------

 -- Command-line option: '--player3-color=<value>'
 -- Environment variable: 'LW6_PLAYER3_COLOR'
 -- XML key: 'player3-color'
     Type: string

     Default value: blue

     Color of the third player, must be red, green, blue, yellow, cyan,
     magenta, orange, lightblue, purple or pink

4.14.25 player4-color
---------------------

 -- Command-line option: '--player4-color=<value>'
 -- Environment variable: 'LW6_PLAYER4_COLOR'
 -- XML key: 'player4-color'
     Type: string

     Default value: yellow

     Color of the fourth player, must be red, green, blue, yellow, cyan,
     magenta, orange, lightblue, purple or pink

4.15 Advanced settings
======================

4.15.1 base64-decode
--------------------

 -- Command-line option: '--base64-decode'
     If specified, program will take stdin and base64 decode it to
     stdout.  This is for testing purpose (for network messages for
     instance).  Will decode in standard base64 encoding using
     characters + and / but also the url-compliant version using - and
     /, see RFC 4648 for details.

4.15.2 base64-encode
--------------------

 -- Command-line option: '--base64-encode'
     If specified, program will take stdin and base64 encode it to
     stdout.  This is for testing purpose (for network messages for
     instance).  Will *not* use standard base64 encoding using
     characters + and / but - and _ instead to be url-compliant, see RFC
     4648 for details.

4.15.3 bench
------------

 -- Command-line option: '--bench'
     Runs a benchmarking test which will report an approximative
     performance estimation of the game on your computer.  The result is
     in an arbitrary unit, but it is logarithmic, and works the way the
     audio decibels do.  That is, 30 is 10 times greater than 20.  10 is
     supposed to be a reference of a computer that can reasonnably run
     the game.  So if you get 40, you are 1000 times powerfull enough.
     Negative values can technically show up on very slow computers.

4.15.4 bench-value
------------------

 -- Command-line option: '--bench-value=<value>'
 -- Environment variable: 'LW6_BENCH_VALUE'
 -- XML key: 'bench-value'
     Type: integer

     Default value: LW6LDR_DEFAULT_BENCH_VALUE

     Contains the current bench value of the computer running the game.
     This is used internally to choose the right map settings.  You can
     override this value and use your own but...  use at your own risk.
     Pretending you have a faster computer than what you really have can
     lead to confusion.

4.15.5 bin-id
-------------

 -- Command-line option: '--bin-id=<value>'
 -- Environment variable: 'LW6_BIN_ID'
 -- XML key: 'bin-id'
     Type: integer

     Default value: 0

     The internal 'bin-id' value.  Note that this is not necessarly
     equal to the value returned by 'show-build-bin-id'.  When they are
     different, it is assumed this is because of a software upgrade.

4.15.6 check
------------

 -- Command-line option: '--check'
     Running the game with '-check' is almost like running '-test', the
     difference is that '-check' will not run tests which involve
     graphics or sound backends, so it's adapted to pure console mode.
     This can be usefull for automated checks on a build farm, or if you
     want to check things in a headless (pure console) environment.

4.15.7 commands-per-sec
-----------------------

 -- Command-line option: '--commands-per-sec=<value>'
 -- Environment variable: 'LW6_COMMANDS_PER_SEC'
 -- XML key: 'commands-per-sec'
     Type: integer

     Default value: 10 Min value: 1 Max value: 1000

     Defines the number of commands per second.  When a command is
     generated, orders are actually sent to the game engine, for
     instance, 'this cursor moved there'.  So this option will affect
     game responsiveness, setting this to a high value will make the
     game more responsive but consume bandwidth on network games.

4.15.8 cunit
------------

 -- Command-line option: '--cunit'
     Running the game with '-cunit' is almost like running '-test', the
     difference is that '-cunit' will use CUnit interactive interface,
     allowing the user to cherry-pick some tests, and avoid running the
     whole suite just for one test.  This can be usefull for debugging,
     when individual test binaries are not available.

4.15.9 daemon
-------------

 -- Command-line option: '--daemon'
     Start the game in daemon mode, this is typically used with the
     server mode, if you want the process to be detached from the
     console and executed in the background.

4.15.10 debug-layer-id
----------------------

 -- Command-line option: '--debug-layer-id=<value>'
 -- Environment variable: 'LW6_DEBUG_LAYER_ID'
 -- XML key: 'debug-layer-id'
     Type: integer

     Default value: 0 Min value: 0 Max value: 6

     A team id which will be used for debugging purposes, for instance
     when displaying gradient.

4.15.11 debug-team-id
---------------------

 -- Command-line option: '--debug-team-id=<value>'
 -- Environment variable: 'LW6_DEBUG_TEAM_ID'
 -- XML key: 'debug-team-id'
     Type: integer

     Default value: 0 Min value: 0 Max value: 9

     A team id which will be used for debugging purposes, for instance
     when displaying gradient.

4.15.12 demo
------------

 -- Command-line option: '--demo'
     Start the game in demo mode.  2 bots play against each other
     forever.

4.15.13 dialog-timeout
----------------------

 -- Command-line option: '--dialog-timeout=<value>'
 -- Environment variable: 'LW6_DIALOG_TIMEOUT'
 -- XML key: 'dialog-timeout'
     Type: integer

     Default value: 3600 Min value: 0 Max value: 86400

     Timeout, in seconds, after which a dialog will automatically be
     closed, wether user clicked on it or not.  Mostly used for testing,
     to avoid program being stall on a visual prompt.  0 will simply
     disable this feature and wait forever.  Note that some platforms
     might not support this.  Interfaces using Gtk do support it.

4.15.14 dirty-read
------------------

 -- Command-line option: '--dirty-read=<value>'
 -- Environment variable: 'LW6_DIRTY_READ'
 -- XML key: 'dirty-read'
     Type: integer

     Default value: 2 Min value: 0 Max value: 2

     How to handle dirty reads and locks when displaying stuff.  If set
     to 0, there will be no dirty reads at all, a lock (mutex) will be
     set whenever it's needed.  If set to 1, display might be done with
     inconsistent data, however the data itself won't be modified while
     displaying.  If set to 2, displayed data can (and will) be modified
     while the rendering thread is running.

4.15.15 display-background
--------------------------

 -- Command-line option: '--display-background=<value>'
 -- Environment variable: 'LW6_DISPLAY_BACKGROUND'
 -- XML key: 'display-background'
     Type: boolean

     Default value: true

     Decides wether the background animation/image should be displayed
     at all.

4.15.16 display-console
-----------------------

 -- Command-line option: '--display-console=<value>'
 -- Environment variable: 'LW6_DISPLAY_CONSOLE'
 -- XML key: 'display-console'
     Type: boolean

     Default value: false

     Defines wether the interactive system console must be displayed.
     Note that console support must have been enabled at compilation
     time.  It might not be available on your computer, for instance if
     you are running a system such as Microsoft Windows.

4.15.17 display-cursors
-----------------------

 -- Command-line option: '--display-cursors=<value>'
 -- Environment variable: 'LW6_DISPLAY_CURSORS'
 -- XML key: 'display-cursors'
     Type: boolean

     Default value: true

     Debugging option which can be set to 'false' to disable the display
     of cursors when playing.

4.15.18 display-debug-gradient
------------------------------

 -- Command-line option: '--display-debug-gradient=<value>'
 -- Environment variable: 'LW6_DISPLAY_DEBUG_GRADIENT'
 -- XML key: 'display-debug-gradient'
     Type: boolean

     Default value: false

     Set this to 'true' to display the gradient, this is usefull to
     debug the core algorithm or understand how it works.

4.15.19 display-debug-zones
---------------------------

 -- Command-line option: '--display-debug-zones=<value>'
 -- Environment variable: 'LW6_DISPLAY_DEBUG_ZONES'
 -- XML key: 'display-debug-zones'
     Type: boolean

     Default value: false

     Set this to 'true' to display the zones, this is usefull to debug
     the core algorithm or understand how it works.

4.15.20 display-fighters
------------------------

 -- Command-line option: '--display-fighters=<value>'
 -- Environment variable: 'LW6_DISPLAY_FIGHTERS'
 -- XML key: 'display-fighters'
     Type: boolean

     Default value: true

     Debugging option which can be set to 'false' to disable the display
     of fighters when playing.

4.15.21 display-fps
-------------------

 -- Command-line option: '--display-fps=<value>'
 -- Environment variable: 'LW6_DISPLAY_FPS'
 -- XML key: 'display-fps'
     Type: boolean

     Default value: false

     Set this to 'true' to display the number of frames per second.
     When this gets too low...  play a smaller map, buy a new computer
     or contribute and hack Liquid War 6 so that it runs faster!

4.15.22 display-hud
-------------------

 -- Command-line option: '--display-hud=<value>'
 -- Environment variable: 'LW6_DISPLAY_HUD'
 -- XML key: 'display-hud'
     Type: boolean

     Default value: true

     Decides wether the hud (informations while playing) should be
     displayed.

4.15.23 display-log
-------------------

 -- Command-line option: '--display-log=<value>'
 -- Environment variable: 'LW6_DISPLAY_LOG'
 -- XML key: 'display-log'
     Type: boolean

     Default value: true

     Set this to 'false' to disable the display of error messages on the
     screen.  Mote that you can miss valuable informations.

4.15.24 display-map
-------------------

 -- Command-line option: '--display-map=<value>'
 -- Environment variable: 'LW6_DISPLAY_MAP'
 -- XML key: 'display-map'
     Type: boolean

     Default value: true

     Debugging option which can be set to 'false' to disable map (level)
     display when playing.

4.15.25 display-menu
--------------------

 -- Command-line option: '--display-menu=<value>'
 -- Environment variable: 'LW6_DISPLAY_MENU'
 -- XML key: 'display-menu'
     Type: boolean

     Default value: true

     Debugging option which can be set to 'false' to disable the display
     of menus.

4.15.26 display-meta
--------------------

 -- Command-line option: '--display-meta=<value>'
 -- Environment variable: 'LW6_DISPLAY_META'
 -- XML key: 'display-meta'
     Type: boolean

     Default value: true

     Set to 'false' to disable the display of meta information, this
     includes the help, tootips and breadcrumbs in menus.

4.15.27 display-mouse
---------------------

 -- Command-line option: '--display-mouse=<value>'
 -- Environment variable: 'LW6_DISPLAY_MOUSE'
 -- XML key: 'display-mouse'
     Type: boolean

     Default value: true

     Set this to 'false' to always hide the mouse pointer.

4.15.28 display-mps
-------------------

 -- Command-line option: '--display-mps=<value>'
 -- Environment variable: 'LW6_DISPLAY_MPS'
 -- XML key: 'display-mps'
     Type: boolean

     Default value: false

     Set this to 'true' to display the number of moves per second.  In
     theory the game should maintain this constant but in practise it
     can get low if your computer is too slow or too busy.

4.15.29 display-preview
-----------------------

 -- Command-line option: '--display-preview=<value>'
 -- Environment variable: 'LW6_DISPLAY_PREVIEW'
 -- XML key: 'display-preview'
     Type: boolean

     Default value: true

     Decides wether a map preview should be displayed when choosing a
     level.

4.15.30 display-progress
------------------------

 -- Command-line option: '--display-progress=<value>'
 -- Environment variable: 'LW6_DISPLAY_PROGRESS'
 -- XML key: 'display-progress'
     Type: boolean

     Default value: true

     Decides wether a progress bar should be displayed when a long
     operation is realized as a background task.

4.15.31 display-score
---------------------

 -- Command-line option: '--display-score=<value>'
 -- Environment variable: 'LW6_DISPLAY_SCORE'
 -- XML key: 'display-score'
     Type: boolean

     Default value: true

     Decides wether the score screen should be displayed.

4.15.32 display-splash
----------------------

 -- Command-line option: '--display-splash=<value>'
 -- Environment variable: 'LW6_DISPLAY_SPLASH'
 -- XML key: 'display-splash'
     Type: boolean

     Default value: true

     Set this to 'false' to disable the display of the splash screen at
     game startup.

4.15.33 display-url
-------------------

 -- Command-line option: '--display-url=<value>'
 -- Environment variable: 'LW6_DISPLAY_URL'
 -- XML key: 'display-url'
     Type: boolean

     Default value: false

     Set this to 'true' to display the URL (homepage) of the game.  This
     is mostly used when doing screenshots, so that generated images
     contain a link to the homepage.

4.15.34 executed-again
----------------------

 -- Command-line option: '--executed-again=<value>'
 -- Environment variable: 'LW6_EXECUTED_AGAIN'
 -- XML key: 'executed-again'
     Type: boolean

     Default value: false

     This environment variable/keyword is used to detect wether the
     program has been launched by itself with an internal execv call.
     This is used as a workarround to set some environment variables
     (DYLD_LIBRARY_PATH on Mac OS X for instance) before the program is
     run, as sometimes using setenv() inside the program does not work.

4.15.35 gfx-cpu-usage
---------------------

 -- Command-line option: '--gfx-cpu-usage=<value>'
 -- Environment variable: 'LW6_GFX_CPU_USAGE'
 -- XML key: 'gfx-cpu-usage'
     Type: float

     Default value: 0.75 Min value: 0 Max value: 1

     Percentage of the CPU which will be used by the display thread.
     It's wise to leave some time to other threads to execute.  The OS
     does it naturally, but setting this helps the whole process by
     explicitely pausing (sleep call) the display thread.  You could
     change this to a low value if you have lagging games but smooth
     display.

4.15.36 gfx-debug
-----------------

 -- Command-line option: '--gfx-debug=<value>'
 -- Environment variable: 'LW6_GFX_DEBUG'
 -- XML key: 'gfx-debug'
     Type: boolean

     Default value: false

     Enables dedicated graphics debugging tools.  This is different from
     'debug' mode which is global, this one is really graphics specific.

4.15.37 io-per-sec
------------------

 -- Command-line option: '--io-per-sec=<value>'
 -- Environment variable: 'LW6_IO_PER_SEC'
 -- XML key: 'io-per-sec'
     Type: integer

     Default value: 20 Min value: 1 Max value: 1000

     Defines the number of calls to input/output functions per second.
     This can affect speed of menus but also cursors, but won't change
     the speed of the game itself.  It's a cosmectic, comfort option.

4.15.38 jpeg-quality
--------------------

 -- Command-line option: '--jpeg-quality=<value>'
 -- Environment variable: 'LW6_JPEG_QUALITY'
 -- XML key: 'jpeg-quality'
     Type: integer

     Default value: 85 Min value: 0 Max value: 85

     Quality used by libjpeg when creating screenshot images.  The same
     value you would give to Gimp before exporting an image as a JPEG.

4.15.39 loader-sleep
--------------------

 -- Command-line option: '--loader-sleep=<value>'
 -- Environment variable: 'LW6_LOADER_SLEEP'
 -- XML key: 'loader-sleep'
     Type: float

     Default value: 0.5

     Defines how long the loader thread should wait between two polls.
     Default value should fit in most cases.

4.15.40 local-bench-delta
-------------------------

 -- Command-line option: '--local-bench-delta=<value>'
 -- Environment variable: 'LW6_LOCAL_BENCH_DELTA'
 -- XML key: 'local-bench-delta'
     Type: integer

     Default value: 0 Min value: -70 Max value: 20

     A value which is added to bench before starting a local game.  This
     is typically zero or negative, as adding to bench is like
     pretending your computer is faster than it really is.

4.15.41 log-level
-----------------

 -- Command-line option: '--log-level=<value>'
 -- Environment variable: 'LW6_LOG_LEVEL'
 -- XML key: 'log-level'
     Type: integer

     Default value: 3 Min value: 0 Max value: 4

     Defines the log level, that is, how verbose the program will be
     regarding logs and console output.  0 (ERROR) is the minimum, only
     errors are reported.  1 (WARNING) means errors + warnings.  2
     (NOTICE) displays most important messages.  3 (INFO) is the
     default, the log file will contain all messages but debug stuff.  4
     (DEBUG) logs everything, including debug informations.

4.15.42 log-timeout
-------------------

 -- Command-line option: '--log-timeout=<value>'
 -- Environment variable: 'LW6_LOG_TIMEOUT'
 -- XML key: 'log-timeout'
     Type: integer

     Default value: 5000

     Delay, in msec, for which a log message will stay displayed on the
     screen.

4.15.43 magic-number
--------------------

 -- Command-line option: '--magic-number=<value>'
 -- Environment variable: 'LW6_MAGIC_NUMBER'
 -- XML key: 'magic-number'
     Type: integer

     Default value: LW6LDR_DEFAULT_MAGIC_NUMBER

     This 'magic' number probably requires an explanation.  It's used to
     estimate how big a map can be built.  The calculus is very
     approximative, basically
     bench_value*magic_number=total_fighters_on_map*rounds_per_sec*moves_per_round
     with total_fighters_on_map depending on various parameters such as
     map size but also how many fighters are on the map.  The map loader
     will try and adjust the map size so that it is just big enough not
     to saturate your CPU while being as high-res as possible.  The
     magic number in itself has no real meaning, the higher it gets, the
     more optimized it means the game is.  Normally you shouldn't change
     this but if you find the map resizing is too agressively
     pessimistic, or if for some reason bench returns bogus values, you
     can modify it.

4.15.44 max-local-bench-value
-----------------------------

 -- Command-line option: '--max-local-bench-value=<value>'
 -- Environment variable: 'LW6_MAX_LOCAL_BENCH_VALUE'
 -- XML key: 'max-local-bench-value'
     Type: integer

     Default value: LW6LDR_DEFAULT_MAX_LOCAL_BENCH_VALUE

     Even if your computer is very fast, this parameter will be used to
     tame the optimism of the test, and do not load maps in very high
     detail.  It's believed at some point, it's best to keep your extra
     power to deal with unordinary situations rather than waste it on
     useless details.  Game should be fun with that setting, but if you
     really want to use your shiny CPU at its maximum, raise this.

4.15.45 max-network-bench-value
-------------------------------

 -- Command-line option: '--max-network-bench-value=<value>'
 -- Environment variable: 'LW6_MAX_NETWORK_BENCH_VALUE'
 -- XML key: 'max-network-bench-value'
     Type: integer

     Default value: LW6LDR_DEFAULT_MAX_NETWORK_BENCH_VALUE

     On network games, we need to be sure everyone can play in correct
     conditions, therefore maps won't be loaded with more details than
     this, by default.  You're free to increase this parameter but it
     can cause your games to be unjoignable by some people.

4.15.46 memory-bazooka-eraser
-----------------------------

 -- Command-line option: '--memory-bazooka-eraser=<value>'
 -- Environment variable: 'LW6_MEMORY_BAZOOKA_ERASER'
 -- XML key: 'memory-bazooka-eraser'
     Type: boolean

     Default value: true

     The memory eraser is a tool which will systematically fill
     allocated memory with 'M', and overwrite all allocated bytes with
     'F' before freeing memory.  It will even handle realloc calls.
     This is usefull to track bugs.  Indeed, with this option enabled,
     freshly allocated memory will never contain zeroes unless one calls
     calloc, and if you ever free some memory zone before being done
     with it, it will be filled with junk and therefore not be usable.
     The memory bazooka must be big enough if you want this feature to
     actually work.

4.15.47 memory-bazooka-size
---------------------------

 -- Command-line option: '--memory-bazooka-size=<value>'
 -- Environment variable: 'LW6_MEMORY_BAZOOKA_SIZE'
 -- XML key: 'memory-bazooka-size'
     Type: integer

     Default value: 99991

     The memory bazooka is a brute-force tool, conceived after a full
     night spent tracking some memory leak.  The idea is to keep a track
     of all allocated pointers, when the data was allocated (timestamp),
     where in the code (file, line), and even point out what data there
     is in that place.  A memory bazooka report at the end of the game
     will just show what's left.  There should be nothing.  This
     parameter is here to avoid wasting CPU cycles on a feature which is
     very debug-oriented and does not really make sense for the casual
     user.  Set it to 0 for best performance, something like 100 might
     just be helpfull, but 1000000 is the right way to seriously debug
     code.

4.15.48 net-log
---------------

 -- Command-line option: '--net-log=<value>'
 -- Environment variable: 'LW6_NET_LOG'
 -- XML key: 'net-log'
     Type: boolean

     Default value: false

     Activates network log, that is, logs everything sent/received over
     the network, except data which is sent through a third party
     library such as libCurl.  This is mostly for debugging purpose, it
     can lead to rather big log files.

4.15.49 net-per-sec
-------------------

 -- Command-line option: '--net-per-sec=<value>'
 -- Environment variable: 'LW6_NET_PER_SEC'
 -- XML key: 'net-per-sec'
     Type: integer

     Default value: 500 Min value: 1 Max value: 1000

     Defines the number of calls to network functions per second.  This
     can technically change the network transfers speed, the higher the
     number, the faster it should be, but at the same time it can
     technically be more CPU greedy.

4.15.50 network-bench-delta
---------------------------

 -- Command-line option: '--network-bench-delta=<value>'
 -- Environment variable: 'LW6_NETWORK_BENCH_DELTA'
 -- XML key: 'network-bench-delta'
     Type: integer

     Default value: -5 Min value: -70 Max value: 20

     A value which is added to bench before starting a network game.
     This is typically a negative value, lower than the one added to
     local game.  This is because network games can be more CPU greedy.

4.15.51 network-reliability
---------------------------

 -- Command-line option: '--network-reliability=<value>'
 -- Environment variable: 'LW6_NETWORK_RELIABILITY'
 -- XML key: 'network-reliability'
     Type: integer

     Default value: 1000 Min value: 1 Max value: 1000000000

     The program assumes network is non-reliable, however the problem
     with those assumptions is that when you test, network is always
     reliable, even with non-garanteed protocols like UDP. This option
     will force the program to actually ignore some calls to send or
     recv functions, simulating a network disfunction.  This is to
     ensure the internal mecanisms correcting network problems do work
     for good, on daily regular use.  It's not possible to set it to a
     perfect behavior, never dropping any packet, however using the
     default settings you probably won't even notice the performance
     drop induced by having to fix problems.  The highest the number is,
     the most reliable network will look, the algorithm is simply to
     drop one message out of X.

4.15.52 open-relay
------------------

 -- Command-line option: '--open-relay=<value>'
 -- Environment variable: 'LW6_OPEN_RELAY'
 -- XML key: 'open-relay'
     Type: boolean

     Default value: false

     Enables forwarding of abritrary network messages.  If open relay is
     forbidden, the game will only forward messages when physical sender
     and logical sender are the same.  This is to say if messages come
     from A for C and is sent by A to B, B will forward it to C. But if
     message comes from X to C and is sent by A to B, then B won't
     forward it.  In practice, it means without open relay, messages can
     only be forwarded once.

4.15.53 pilot-lag
-----------------

 -- Command-line option: '--pilot-lag=<value>'
 -- Environment variable: 'LW6_PILOT_LAG'
 -- XML key: 'pilot-lag'
     Type: integer

     Default value: 10

     Maximum lag, in rounds, until the game engine is slowed down.  This
     will typically be usefull if your computer is too slow for the map
     resolution and the game speed you set up.

4.15.54 quick-start
-------------------

 -- Command-line option: '--quick-start'
     Start the game just like if the player had requested a quick start,
     without showing any menu.

4.15.55 reset
-------------

 -- Command-line option: '--reset'
     Clears the config file so that the game will run with defaults next
     time.  The idea is to get rid of traces of previous executions.
     The difference with '-defaults' is that '-reset' does not run the
     game, while '-defaults' does.

4.15.56 reset-config-on-upgrade
-------------------------------

 -- Command-line option: '--reset-config-on-upgrade=<value>'
 -- Environment variable: 'LW6_RESET_CONFIG_ON_UPGRADE'
 -- XML key: 'reset-config-on-upgrade'
     Type: boolean

     Default value: true

     If set, then a reset (config file set to defaults) is run every
     time you upgrade the game.

4.15.57 screenshots-per-min
---------------------------

 -- Command-line option: '--screenshots-per-min=<value>'
 -- Environment variable: 'LW6_SCREENSHOTS_PER_MIN'
 -- XML key: 'screenshots-per-min'
     Type: integer

     Default value: 12

     Defines the number of screenshots / node info per minute.  This can
     a quite costly operation, but still it must not be too low else
     screenshots are too outdated.

4.15.58 server
--------------

 -- Command-line option: '--server'
     Start the game in server mode, without requiring any graphics
     backend.  Server mode is usefull if you just want to start a
     network node without hosting any real game on it.  It can be used
     to list existing nodes and sessions or as a bounce server in case
     some clients can't contact each other because firewalled.  If you
     only want to start a server game on your computer, don't use this
     option, just start the game normally and start a game server by
     clicking on the GUI buttons.

4.15.59 simulate-basic
----------------------

 -- Command-line option: '--simulate-basic'
     Simulates some fights using the basic colors red, green, yellow and
     blue.  Will output on the console a percentage based on scores
     obtained by the teams.  This is typically for map designers and/or
     people who want to fiddle with team profiles, if some team is
     really stronger than another one, it should appear in these
     percentages.

4.15.60 simulate-full
---------------------

 -- Command-line option: '--simulate-full'
     Simulates some fights using all available colors.  This can be very
     long, it will run approximatively 1000 games consecutively, you can
     look in the log file to see the progress.  Will output on the
     console a percentage based on scores obtained by the teams.  This
     is typically for map designers and/or people who want to fiddle
     with team profiles, if some team is really stronger than another
     one, it should appear in these percentages.

4.15.61 target-fps
------------------

 -- Command-line option: '--target-fps=<value>'
 -- Environment variable: 'LW6_TARGET_FPS'
 -- XML key: 'target-fps'
     Type: integer

     Default value: 60 Min value: 1 Max value: 1000

     Defines how many frames will be displayed per second.  Of course
     this is a maximum value, if your hardware can't keep up with this
     value, display will just be slow, no matter what value you define
     here.  Note that you might really wish to have something rather low
     here, to keep network and 'logic' function responsiveness.  Passed
     60 frames per second, speed is really only for visual comfort, as
     Liquid War 6 is now so fast-paced that it requires 200 frames/sec
     to outperform opponents.

4.15.62 trap-errors
-------------------

 -- Command-line option: '--trap-errors=<value>'
 -- Environment variable: 'LW6_TRAP_ERRORS'
 -- XML key: 'trap-errors'
     Type: boolean

     Default value: false

     If set to true, will trap segmentation fault and floating point
     errors, and display messages about those in a custom box instead of
     the default one

4.15.63 trojan
--------------

 -- Command-line option: '--trojan=<value>'
 -- Environment variable: 'LW6_TROJAN'
 -- XML key: 'trojan'
     Type: boolean

     Default value: false

     Make the program act like a (stupid) trojan horse, trying to fake
     messages, sending various inconsistent informations.  This is to
     check the normal version of the program is able to detect such a
     fake and kick it out of the game.  It's of no use for regular
     players, be sure to unset this if you want to play for good.

4.15.64 z-decode
----------------

 -- Command-line option: '--z-decode'
     If specified, program will take stdin and z-decode it to stdout.
     This is for testing purpose (for network messages for instance).
     Z-decoding, here means verifying there a Z at the beginning, base64
     decode and pass the content through Zlib inflating.  I content is
     not Z-prefixed, will be returned as is.

4.15.65 z-encode
----------------

 -- Command-line option: '--z-encode'
     If specified, program will take stdin and z-encode it to stdout.
     This is for testing purpose (for network messages for instance).
     Z-encoding, here means passing the message through Zlib deflating
     then base64 encoding and prefix it with a Z.

4.16 C to Guile
===============

4.16.1 c-gettext
----------------

 -- C function exported to Guile: 'c-gettext'
     Calls GNU gettext to convert string in current locale.  Note that
     '_' (plain underscode) is exported as well, so that code can be
     written using '_' as a function.

4.16.2 c-lw6-exit
-----------------

 -- C function exported to Guile: 'c-lw6-exit'
     Wrapper on lw6_exit.

4.16.3 c-lw6-get-ret
--------------------

 -- C function exported to Guile: 'c-lw6-get-ret'
     Wrapper on lw6_get_ret.

4.16.4 c-lw6-release
--------------------

 -- C function exported to Guile: 'c-lw6-release'
     Wrapper on lw6_release.

4.16.5 c-lw6-set-ret
--------------------

 -- C function exported to Guile: 'c-lw6-set-ret'
     Wrapper on lw6_set_ret.

4.16.6 c-lw6bot-get-backends
----------------------------

 -- C function exported to Guile: 'c-lw6bot-get-backends'
     Wrapper on lw6bot_get_backends.

4.16.7 c-lw6bot-new
-------------------

 -- C function exported to Guile: 'c-lw6bot-new'
     Wrapper on lw6bot_new.

4.16.8 c-lw6bot-next-move
-------------------------

 -- C function exported to Guile: 'c-lw6bot-next-move'
     Wrapper on lw6bot_next_move.

4.16.9 c-lw6cfg-defaults
------------------------

 -- C function exported to Guile: 'c-lw6cfg-defaults'
     Wrapper on lw6cfg_defaults.

4.16.10 c-lw6cfg-get-option
---------------------------

 -- C function exported to Guile: 'c-lw6cfg-get-option'
     Wrapper on lw6cfg_get_option.

4.16.11 c-lw6cfg-init
---------------------

 -- C function exported to Guile: 'c-lw6cfg-init'
     Wrapper on lw6cfg_init.

4.16.12 c-lw6cfg-load
---------------------

 -- C function exported to Guile: 'c-lw6cfg-load'
     Wrapper on lw6cfg_load.

4.16.13 c-lw6cfg-option-exists
------------------------------

 -- C function exported to Guile: 'c-lw6cfg-option-exists'
     Wrapper on lw6cfg_option_exists.

4.16.14 c-lw6cfg-quit
---------------------

 -- C function exported to Guile: 'c-lw6cfg-quit'
     Wrapper on lw6cfg_quit.

4.16.15 c-lw6cfg-save
---------------------

 -- C function exported to Guile: 'c-lw6cfg-save'
     Wrapper on lw6cfg_save.

4.16.16 c-lw6cfg-set-option
---------------------------

 -- C function exported to Guile: 'c-lw6cfg-set-option'
     Wrapper on lw6cfg_set_option.

4.16.17 c-lw6cfg-unified-get-log-file
-------------------------------------

 -- C function exported to Guile: 'c-lw6cfg-unified-get-log-file'
     Wrapper on lw6cfg_unified_get_log_file.

4.16.18 c-lw6cfg-unified-get-map-path
-------------------------------------

 -- C function exported to Guile: 'c-lw6cfg-unified-get-map-path'
     Wrapper on lw6cfg_unified_get_map_path.

4.16.19 c-lw6cfg-unified-get-music-path
---------------------------------------

 -- C function exported to Guile: 'c-lw6cfg-unified-get-music-path'
     Wrapper on lw6cfg_unified_get_music_path.

4.16.20 c-lw6cfg-unified-get-user-dir
-------------------------------------

 -- C function exported to Guile: 'c-lw6cfg-unified-get-user-dir'
     Wrapper on lw6cfg_unified_get_user_dir.

4.16.21 c-lw6cli-get-backends
-----------------------------

 -- C function exported to Guile: 'c-lw6cli-get-backends'
     Wrapper on lw6cli_get_backends.

4.16.22 c-lw6cns-console-support
--------------------------------

 -- C function exported to Guile: 'c-lw6cns-console-support'
     Wrapper on lw6cns_console_support.

4.16.23 c-lw6cns-init
---------------------

 -- C function exported to Guile: 'c-lw6cns-init'
     Wrapper on lw6cns_init.

4.16.24 c-lw6cns-poll
---------------------

 -- C function exported to Guile: 'c-lw6cns-poll'
     Wrapper on lw6cns_poll.

4.16.25 c-lw6cns-quit
---------------------

 -- C function exported to Guile: 'c-lw6cns-quit'
     Wrapper on lw6cns_quit.

4.16.26 c-lw6cns-term-support
-----------------------------

 -- C function exported to Guile: 'c-lw6cns-term-support'
     Wrapper on lw6cns_term_support.

4.16.27 c-lw6dsp-get-average-fps
--------------------------------

 -- C function exported to Guile: 'c-lw6dsp-get-average-fps'
     Wrapper on lw6dsp_get_average_fps.

4.16.28 c-lw6dsp-get-fullscreen-modes
-------------------------------------

 -- C function exported to Guile: 'c-lw6dsp-get-fullscreen-modes'
     Wrapper on lw6dsp_get_fullscreen_modes.

4.16.29 c-lw6dsp-get-instant-fps
--------------------------------

 -- C function exported to Guile: 'c-lw6dsp-get-instant-fps'
     Wrapper on lw6dsp_get_instant_fps.

4.16.30 c-lw6dsp-get-last-frame-rendering-time
----------------------------------------------

 -- C function exported to Guile:
          'c-lw6dsp-get-last-frame-rendering-time'
     Wrapper on lw6dsp_get_last_frame_rendering_time.

4.16.31 c-lw6dsp-get-nb-frames
------------------------------

 -- C function exported to Guile: 'c-lw6dsp-get-nb-frames'
     Wrapper on lw6dsp_get_nb_frames.

4.16.32 c-lw6dsp-get-video-mode
-------------------------------

 -- C function exported to Guile: 'c-lw6dsp-get-video-mode'
     Wrapper on lw6dsp_get_video_mode.

4.16.33 c-lw6dsp-new
--------------------

 -- C function exported to Guile: 'c-lw6dsp-new'
     Wrapper on lw6dsp_new.

4.16.34 c-lw6dsp-release
------------------------

 -- C function exported to Guile: 'c-lw6dsp-release'
     Wrapper on lw6dsp_release.

4.16.35 c-lw6dsp-update
-----------------------

 -- C function exported to Guile: 'c-lw6dsp-update'
     Wrapper on lw6dsp_update.

4.16.36 c-lw6gen-create-from-seed
---------------------------------

 -- C function exported to Guile: 'c-lw6gen-create-from-seed'
     Wrapper on lw6gen_create_from_seed.

4.16.37 c-lw6gen-seed-new
-------------------------

 -- C function exported to Guile: 'c-lw6gen-seed-new'
     Wrapper on lw6gen_seed_new.

4.16.38 c-lw6gen-seed-normalize
-------------------------------

 -- C function exported to Guile: 'c-lw6gen-seed-normalize'
     Wrapper on lw6gen_seed_normalize.

4.16.39 c-lw6gfx-get-backends
-----------------------------

 -- C function exported to Guile: 'c-lw6gfx-get-backends'
     Wrapper on lw6gfx_get_backends.

4.16.40 c-lw6gui-default-look
-----------------------------

 -- C function exported to Guile: 'c-lw6gui-default-look'
     Wrapper on lw6gui_default_look.

4.16.41 c-lw6gui-input-reset
----------------------------

 -- C function exported to Guile: 'c-lw6gui-input-reset'
     Wrapper on lw6gui_input_reset.

4.16.42 c-lw6gui-joystick1-get-move-pad
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-get-move-pad'
     Wrapper on lw6gui_joystick1_get_move_pad.

4.16.43 c-lw6gui-joystick1-pop-button-a
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-button-a'
     Wrapper on lw6gui_joystick1_pop_button_a.

4.16.44 c-lw6gui-joystick1-pop-button-b
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-button-b'
     Wrapper on lw6gui_joystick1_pop_button_b.

4.16.45 c-lw6gui-joystick1-pop-button-c
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-button-c'
     Wrapper on lw6gui_joystick1_pop_button_c.

4.16.46 c-lw6gui-joystick1-pop-button-d
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-button-d'
     Wrapper on lw6gui_joystick1_pop_button_d.

4.16.47 c-lw6gui-joystick1-pop-button-e
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-button-e'
     Wrapper on lw6gui_joystick1_pop_button_e.

4.16.48 c-lw6gui-joystick1-pop-button-f
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-button-f'
     Wrapper on lw6gui_joystick1_pop_button_f.

4.16.49 c-lw6gui-joystick1-pop-pad-down
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-pad-down'
     Wrapper on lw6gui_joystick1_pop_pad_down.

4.16.50 c-lw6gui-joystick1-pop-pad-left
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-pad-left'
     Wrapper on lw6gui_joystick1_pop_pad_left.

4.16.51 c-lw6gui-joystick1-pop-pad-right
----------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-pad-right'
     Wrapper on lw6gui_joystick1_pop_pad_right.

4.16.52 c-lw6gui-joystick1-pop-pad-up
-------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick1-pop-pad-up'
     Wrapper on lw6gui_joystick1_pop_pad_up.

4.16.53 c-lw6gui-joystick2-get-move-pad
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-get-move-pad'
     Wrapper on lw6gui_joystick2_get_move_pad.

4.16.54 c-lw6gui-joystick2-pop-button-a
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-button-a'
     Wrapper on lw6gui_joystick2_pop_button_a.

4.16.55 c-lw6gui-joystick2-pop-button-b
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-button-b'
     Wrapper on lw6gui_joystick2_pop_button_b.

4.16.56 c-lw6gui-joystick2-pop-button-c
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-button-c'
     Wrapper on lw6gui_joystick2_pop_button_c.

4.16.57 c-lw6gui-joystick2-pop-button-d
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-button-d'
     Wrapper on lw6gui_joystick2_pop_button_d.

4.16.58 c-lw6gui-joystick2-pop-button-e
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-button-e'
     Wrapper on lw6gui_joystick2_pop_button_e.

4.16.59 c-lw6gui-joystick2-pop-button-f
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-button-f'
     Wrapper on lw6gui_joystick2_pop_button_f.

4.16.60 c-lw6gui-joystick2-pop-pad-down
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-pad-down'
     Wrapper on lw6gui_joystick2_pop_pad_down.

4.16.61 c-lw6gui-joystick2-pop-pad-left
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-pad-left'
     Wrapper on lw6gui_joystick2_pop_pad_left.

4.16.62 c-lw6gui-joystick2-pop-pad-right
----------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-pad-right'
     Wrapper on lw6gui_joystick2_pop_pad_right.

4.16.63 c-lw6gui-joystick2-pop-pad-up
-------------------------------------

 -- C function exported to Guile: 'c-lw6gui-joystick2-pop-pad-up'
     Wrapper on lw6gui_joystick2_pop_pad_up.

4.16.64 c-lw6gui-keyboard-get-move-pad
--------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-get-move-pad'
     Wrapper on lw6gui_keyboard_get_move_pad.

4.16.65 c-lw6gui-keyboard-is-pressed
------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-is-pressed'
     Wrapper on lw6gui_keyboard_is_pressed.

4.16.66 c-lw6gui-keyboard-pop-arrow-down
----------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-arrow-down'
     Wrapper on lw6gui_keyboard_pop_arrow_down.

4.16.67 c-lw6gui-keyboard-pop-arrow-left
----------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-arrow-left'
     Wrapper on lw6gui_keyboard_pop_arrow_left.

4.16.68 c-lw6gui-keyboard-pop-arrow-right
-----------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-arrow-right'
     Wrapper on lw6gui_keyboard_pop_arrow_right.

4.16.69 c-lw6gui-keyboard-pop-arrow-up
--------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-arrow-up'
     Wrapper on lw6gui_keyboard_pop_arrow_up.

4.16.70 c-lw6gui-keyboard-pop-key-alt
-------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-key-alt'
     Wrapper on lw6gui_keyboard_pop_key_alt.

4.16.71 c-lw6gui-keyboard-pop-key-ctrl
--------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-key-ctrl'
     Wrapper on lw6gui_keyboard_pop_key_ctrl.

4.16.72 c-lw6gui-keyboard-pop-key-enter
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-key-enter'
     Wrapper on lw6gui_keyboard_pop_key_enter.

4.16.73 c-lw6gui-keyboard-pop-key-esc
-------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-key-esc'
     Wrapper on lw6gui_keyboard_pop_key_esc.

4.16.74 c-lw6gui-keyboard-pop-key-pgdown
----------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-key-pgdown'
     Wrapper on lw6gui_keyboard_pop_key_pgdown.

4.16.75 c-lw6gui-keyboard-pop-key-pgup
--------------------------------------

 -- C function exported to Guile: 'c-lw6gui-keyboard-pop-key-pgup'
     Wrapper on lw6gui_keyboard_pop_key_pgup.

4.16.76 c-lw6gui-look-get
-------------------------

 -- C function exported to Guile: 'c-lw6gui-look-get'
     Wrapper on lw6gui_look_get.

4.16.77 c-lw6gui-look-set
-------------------------

 -- C function exported to Guile: 'c-lw6gui-look-set'
     Wrapper on lw6gui_look_set.

4.16.78 c-lw6gui-look-zoom-in
-----------------------------

 -- C function exported to Guile: 'c-lw6gui-look-zoom-in'
     Wrapper on lw6gui_look_zoom_in.

4.16.79 c-lw6gui-look-zoom-out
------------------------------

 -- C function exported to Guile: 'c-lw6gui-look-zoom-out'
     Wrapper on lw6gui_look_zoom_out.

4.16.80 c-lw6gui-menu-append
----------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-append'
     Wrapper on lw6gui_menu_append.

4.16.81 c-lw6gui-menu-close-popup
---------------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-close-popup'
     Wrapper on lw6gui_menu_close_popup.

4.16.82 c-lw6gui-menu-enable-esc
--------------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-enable-esc'
     Wrapper on lw6gui_menu_enable_esc.

4.16.83 c-lw6gui-menu-has-popup
-------------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-has-popup'
     Wrapper on lw6gui_menu_has_popup.

4.16.84 c-lw6gui-menu-new
-------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-new'
     Wrapper on lw6gui_menu_new.

4.16.85 c-lw6gui-menu-remove
----------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-remove'
     Wrapper on lw6gui_menu_remove.

4.16.86 c-lw6gui-menu-remove-all
--------------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-remove-all'
     Wrapper on lw6gui_menu_remove_all.

4.16.87 c-lw6gui-menu-scroll-down
---------------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-scroll-down'
     Wrapper on lw6gui_menu_scroll_down.

4.16.88 c-lw6gui-menu-scroll-up
-------------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-scroll-up'
     Wrapper on lw6gui_menu_scroll_up.

4.16.89 c-lw6gui-menu-select
----------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-select'
     Wrapper on lw6gui_menu_select.

4.16.90 c-lw6gui-menu-select-esc
--------------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-select-esc'
     Wrapper on lw6gui_menu_select_esc.

4.16.91 c-lw6gui-menu-set-breadcrumbs
-------------------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-set-breadcrumbs'
     Wrapper on lw6gui_menu_set_breadcrumbs.

4.16.92 c-lw6gui-menu-sync
--------------------------

 -- C function exported to Guile: 'c-lw6gui-menu-sync'
     Wrapper on lw6gui_menu_sync.

4.16.93 c-lw6gui-mouse-get-state
--------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-get-state'
     Wrapper on lw6gui_mouse_get_state.

4.16.94 c-lw6gui-mouse-poll-move
--------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-poll-move'
     Wrapper on lw6gui_mouse_poll_move.

4.16.95 c-lw6gui-mouse-pop-button-left
--------------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-pop-button-left'
     Wrapper on lw6gui_mouse_pop_button_left.

4.16.96 c-lw6gui-mouse-pop-button-middle
----------------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-pop-button-middle'
     Wrapper on lw6gui_mouse_pop_button_middle.

4.16.97 c-lw6gui-mouse-pop-button-right
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-pop-button-right'
     Wrapper on lw6gui_mouse_pop_button_right.

4.16.98 c-lw6gui-mouse-pop-double-click
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-pop-double-click'
     Wrapper on lw6gui_mouse_pop_double_click.

4.16.99 c-lw6gui-mouse-pop-simple-click
---------------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-pop-simple-click'
     Wrapper on lw6gui_mouse_pop_simple_click.

4.16.100 c-lw6gui-mouse-pop-triple-click
----------------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-pop-triple-click'
     Wrapper on lw6gui_mouse_pop_triple_click.

4.16.101 c-lw6gui-mouse-pop-wheel-down
--------------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-pop-wheel-down'
     Wrapper on lw6gui_mouse_pop_wheel_down.

4.16.102 c-lw6gui-mouse-pop-wheel-up
------------------------------------

 -- C function exported to Guile: 'c-lw6gui-mouse-pop-wheel-up'
     Wrapper on lw6gui_mouse_pop_wheel_up.

4.16.103 c-lw6hlp-about
-----------------------

 -- C function exported to Guile: 'c-lw6hlp-about'
     Wrapper on lw6hlp_about.

4.16.104 c-lw6hlp-get-default-value
-----------------------------------

 -- C function exported to Guile: 'c-lw6hlp-get-default-value'
     Wrapper on lw6hlp_get_default_value.

4.16.105 c-lw6hlp-list
----------------------

 -- C function exported to Guile: 'c-lw6hlp-list'
     Wrapper on lw6hlp_list.

4.16.106 c-lw6hlp-list-advanced
-------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-advanced'
     Wrapper on lw6hlp_list_advanced.

4.16.107 c-lw6hlp-list-aliases
------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-aliases'
     Wrapper on lw6hlp_list_aliases.

4.16.108 c-lw6hlp-list-doc
--------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-doc'
     Wrapper on lw6hlp_list_doc.

4.16.109 c-lw6hlp-list-funcs
----------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-funcs'
     Wrapper on lw6hlp_list_funcs.

4.16.110 c-lw6hlp-list-graphics
-------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-graphics'
     Wrapper on lw6hlp_list_graphics.

4.16.111 c-lw6hlp-list-hooks
----------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-hooks'
     Wrapper on lw6hlp_list_hooks.

4.16.112 c-lw6hlp-list-input
----------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-input'
     Wrapper on lw6hlp_list_input.

4.16.113 c-lw6hlp-list-map
--------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-map'
     Wrapper on lw6hlp_list_map.

4.16.114 c-lw6hlp-list-map-hints
--------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-map-hints'
     Wrapper on lw6hlp_list_map_hints.

4.16.115 c-lw6hlp-list-map-rules
--------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-map-rules'
     Wrapper on lw6hlp_list_map_rules.

4.16.116 c-lw6hlp-list-map-style
--------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-map-style'
     Wrapper on lw6hlp_list_map_style.

4.16.117 c-lw6hlp-list-map-teams
--------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-map-teams'
     Wrapper on lw6hlp_list_map_teams.

4.16.118 c-lw6hlp-list-network
------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-network'
     Wrapper on lw6hlp_list_network.

4.16.119 c-lw6hlp-list-path
---------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-path'
     Wrapper on lw6hlp_list_path.

4.16.120 c-lw6hlp-list-players
------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-players'
     Wrapper on lw6hlp_list_players.

4.16.121 c-lw6hlp-list-quick
----------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-quick'
     Wrapper on lw6hlp_list_quick.

4.16.122 c-lw6hlp-list-show
---------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-show'
     Wrapper on lw6hlp_list_show.

4.16.123 c-lw6hlp-list-sound
----------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-sound'
     Wrapper on lw6hlp_list_sound.

4.16.124 c-lw6hlp-list-team-colors
----------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-team-colors'
     Wrapper on lw6hlp_list_team_colors.

4.16.125 c-lw6hlp-list-weapons
------------------------------

 -- C function exported to Guile: 'c-lw6hlp-list-weapons'
     Wrapper on lw6hlp_list_weapons.

4.16.126 c-lw6img-screenshot
----------------------------

 -- C function exported to Guile: 'c-lw6img-screenshot'
     Wrapper on lw6img_screenshot.

4.16.127 c-lw6ker-add-cursor
----------------------------

 -- C function exported to Guile: 'c-lw6ker-add-cursor'
     Wrapper on lw6ker_add_cursor.

4.16.128 c-lw6ker-build-game-state
----------------------------------

 -- C function exported to Guile: 'c-lw6ker-build-game-state'
     Wrapper on lw6ker_build_game_state.

4.16.129 c-lw6ker-build-game-struct
-----------------------------------

 -- C function exported to Guile: 'c-lw6ker-build-game-struct'
     Wrapper on lw6ker_build_game_struct.

4.16.130 c-lw6ker-cursor-exists
-------------------------------

 -- C function exported to Guile: 'c-lw6ker-cursor-exists'
     Wrapper on lw6ker_cursor_exists.

4.16.131 c-lw6ker-did-cursor-win
--------------------------------

 -- C function exported to Guile: 'c-lw6ker-did-cursor-win'
     Wrapper on lw6ker_did_cursor_win.

4.16.132 c-lw6ker-do-round
--------------------------

 -- C function exported to Guile: 'c-lw6ker-do-round'
     Wrapper on lw6ker_do_round.

4.16.133 c-lw6ker-dup-game-state
--------------------------------

 -- C function exported to Guile: 'c-lw6ker-dup-game-state'
     Wrapper on lw6ker_dup_game_state.

4.16.134 c-lw6ker-game-state-checksum
-------------------------------------

 -- C function exported to Guile: 'c-lw6ker-game-state-checksum'
     Wrapper on lw6ker_game_state_checksum.

4.16.135 c-lw6ker-game-struct-checksum
--------------------------------------

 -- C function exported to Guile: 'c-lw6ker-game-struct-checksum'
     Wrapper on lw6ker_game_struct_checksum.

4.16.136 c-lw6ker-get-cursor
----------------------------

 -- C function exported to Guile: 'c-lw6ker-get-cursor'
     Wrapper on lw6ker_get_cursor.

4.16.137 c-lw6ker-get-moves
---------------------------

 -- C function exported to Guile: 'c-lw6ker-get-moves'
     Wrapper on lw6ker_get_moves.

4.16.138 c-lw6ker-get-nb-colors
-------------------------------

 -- C function exported to Guile: 'c-lw6ker-get-nb-colors'
     Wrapper on lw6ker_game_state_get_nb_colors.

4.16.139 c-lw6ker-get-nb-cursors
--------------------------------

 -- C function exported to Guile: 'c-lw6ker-get-nb-cursors'
     Wrapper on lw6ker_game_state_get_nb_cursors.

4.16.140 c-lw6ker-get-nb-nodes
------------------------------

 -- C function exported to Guile: 'c-lw6ker-get-nb-nodes'
     Wrapper on lw6ker_game_state_get_nb_nodes.

4.16.141 c-lw6ker-get-rounds
----------------------------

 -- C function exported to Guile: 'c-lw6ker-get-rounds'
     Wrapper on lw6ker_get_rounds.

4.16.142 c-lw6ker-get-spreads
-----------------------------

 -- C function exported to Guile: 'c-lw6ker-get-spreads'
     Wrapper on lw6ker_get_spreads.

4.16.143 c-lw6ker-is-over
-------------------------

 -- C function exported to Guile: 'c-lw6ker-is-over'
     Wrapper on lw6ker_is_over.

4.16.144 c-lw6ker-node-exists
-----------------------------

 -- C function exported to Guile: 'c-lw6ker-node-exists'
     Wrapper on lw6ker_node_exists.

4.16.145 c-lw6ker-register-node
-------------------------------

 -- C function exported to Guile: 'c-lw6ker-register-node'
     Wrapper on lw6ker_register_node.

4.16.146 c-lw6ker-remove-cursor
-------------------------------

 -- C function exported to Guile: 'c-lw6ker-remove-cursor'
     Wrapper on lw6ker_remove_cursor.

4.16.147 c-lw6ker-set-cursor
----------------------------

 -- C function exported to Guile: 'c-lw6ker-set-cursor'
     Wrapper on lw6ker_set_cursor.

4.16.148 c-lw6ker-sync-game-state
---------------------------------

 -- C function exported to Guile: 'c-lw6ker-sync-game-state'
     Wrapper on lw6ker_sync_game_state.

4.16.149 c-lw6ker-unregister-node
---------------------------------

 -- C function exported to Guile: 'c-lw6ker-unregister-node'
     Wrapper on lw6ker_unregister_node.

4.16.150 c-lw6ldr-chain-entry
-----------------------------

 -- C function exported to Guile: 'c-lw6ldr-chain-entry'
     Wrapper on lw6ldr_chain_entry.

4.16.151 c-lw6ldr-exp-validate
------------------------------

 -- C function exported to Guile: 'c-lw6ldr-exp-validate'
     Wrapper on lw6ldr_exp_validate.

4.16.152 c-lw6ldr-get-entries
-----------------------------

 -- C function exported to Guile: 'c-lw6ldr-get-entries'
     Wrapper on lw6ldr_get_entries.

4.16.153 c-lw6ldr-hints-get-default
-----------------------------------

 -- C function exported to Guile: 'c-lw6ldr-hints-get-default'
     Wrapper on lw6ldr_hints_get_default.

4.16.154 c-lw6ldr-print-examples
--------------------------------

 -- C function exported to Guile: 'c-lw6ldr-print-examples'
     Wrapper on lw6ldr_print_examples.

4.16.155 c-lw6ldr-read
----------------------

 -- C function exported to Guile: 'c-lw6ldr-read'
     Wrapper on lw6ldr_read.

4.16.156 c-lw6ldr-read-relative
-------------------------------

 -- C function exported to Guile: 'c-lw6ldr-read-relative'
     Wrapper on lw6ldr_read_relative.

4.16.157 c-lw6map-exp-get-unlocked-team-color
---------------------------------------------

 -- C function exported to Guile: 'c-lw6map-exp-get-unlocked-team-color'
     Wrapper on lw6map_exp_get_unlocked_team_color.

4.16.158 c-lw6map-exp-get-unlocked-weapon
-----------------------------------------

 -- C function exported to Guile: 'c-lw6map-exp-get-unlocked-weapon'
     Wrapper on lw6map_exp_get_unlocked_weapon.

4.16.159 c-lw6map-exp-is-team-color-allowed
-------------------------------------------

 -- C function exported to Guile: 'c-lw6map-exp-is-team-color-allowed'
     Wrapper on lw6map_exp_is_team_color_allowed.

4.16.160 c-lw6map-exp-is-weapon-allowed
---------------------------------------

 -- C function exported to Guile: 'c-lw6map-exp-is-weapon-allowed'
     Wrapper on lw6map_exp_is_weapon_allowed.

4.16.161 c-lw6map-get-look
--------------------------

 -- C function exported to Guile: 'c-lw6map-get-look'
     Wrapper on lw6map_get_look.

4.16.162 c-lw6map-get-max-nb-colors
-----------------------------------

 -- C function exported to Guile: 'c-lw6map-get-max-nb-colors'
     Wrapper on lw6map_get_max_nb_colors.

4.16.163 c-lw6map-get-max-nb-cursors
------------------------------------

 -- C function exported to Guile: 'c-lw6map-get-max-nb-cursors'
     Wrapper on lw6map_get_max_nb_cursors.

4.16.164 c-lw6map-get-max-nb-nodes
----------------------------------

 -- C function exported to Guile: 'c-lw6map-get-max-nb-nodes'
     Wrapper on lw6map_get_max_nb_nodes.

4.16.165 c-lw6map-get-music-dir
-------------------------------

 -- C function exported to Guile: 'c-lw6map-get-music-dir'
     Wrapper on lw6map_get_music_dir.

4.16.166 c-lw6map-get-title
---------------------------

 -- C function exported to Guile: 'c-lw6map-get-title'
     Wrapper on lw6map_get_title.

4.16.167 c-lw6map-param-get
---------------------------

 -- C function exported to Guile: 'c-lw6map-param-get'
     Wrapper on lw6map_param_get.

4.16.168 c-lw6map-rules-get-default
-----------------------------------

 -- C function exported to Guile: 'c-lw6map-rules-get-default'
     Wrapper on lw6map_rules_get_default.

4.16.169 c-lw6map-rules-get-int
-------------------------------

 -- C function exported to Guile: 'c-lw6map-rules-get-int'
     Wrapper on lw6map_rules_get_int.

4.16.170 c-lw6map-rules-get-max
-------------------------------

 -- C function exported to Guile: 'c-lw6map-rules-get-max'
     Wrapper on lw6map_rules_get_max.

4.16.171 c-lw6map-rules-get-min
-------------------------------

 -- C function exported to Guile: 'c-lw6map-rules-get-min'
     Wrapper on lw6map_rules_get_min.

4.16.172 c-lw6map-style-get-default
-----------------------------------

 -- C function exported to Guile: 'c-lw6map-style-get-default'
     Wrapper on lw6map_style_get_default.

4.16.173 c-lw6map-team-color-index-to-key
-----------------------------------------

 -- C function exported to Guile: 'c-lw6map-team-color-index-to-key'
     Wrapper on lw6map_team_color_index_to_key.

4.16.174 c-lw6map-team-color-index-to-label
-------------------------------------------

 -- C function exported to Guile: 'c-lw6map-team-color-index-to-label'
     Wrapper on lw6map_team_color_index_to_label.

4.16.175 c-lw6map-team-color-key-to-index
-----------------------------------------

 -- C function exported to Guile: 'c-lw6map-team-color-key-to-index'
     Wrapper on lw6map_team_color_key_to_index.

4.16.176 c-lw6map-team-color-list
---------------------------------

 -- C function exported to Guile: 'c-lw6map-team-color-list'
     Wrapper on lw6map_team_color_list.

4.16.177 c-lw6map-teams-get-default
-----------------------------------

 -- C function exported to Guile: 'c-lw6map-teams-get-default'
     Wrapper on lw6map_teams_get_default.

4.16.178 c-lw6map-weapon-index-to-key
-------------------------------------

 -- C function exported to Guile: 'c-lw6map-weapon-index-to-key'
     Wrapper on lw6map_weapon_index_to_key.

4.16.179 c-lw6map-weapon-index-to-label
---------------------------------------

 -- C function exported to Guile: 'c-lw6map-weapon-index-to-label'
     Wrapper on lw6map_weapon_index_to_label.

4.16.180 c-lw6map-weapon-key-to-index
-------------------------------------

 -- C function exported to Guile: 'c-lw6map-weapon-key-to-index'
     Wrapper on lw6map_weapon_key_to_index.

4.16.181 c-lw6map-weapon-list
-----------------------------

 -- C function exported to Guile: 'c-lw6map-weapon-list'
     Wrapper on lw6map_weapon_list.

4.16.182 c-lw6net-init
----------------------

 -- C function exported to Guile: 'c-lw6net-init'
     Wrapper on lw6net_init.

4.16.183 c-lw6net-quit
----------------------

 -- C function exported to Guile: 'c-lw6net-quit'
     Wrapper on lw6net_quit.

4.16.184 c-lw6p2p-db-default-name
---------------------------------

 -- C function exported to Guile: 'c-lw6p2p-db-default-name'
     Wrapper on lw6p2p_db_default_name.

4.16.185 c-lw6p2p-db-new
------------------------

 -- C function exported to Guile: 'c-lw6p2p-db-new'
     Wrapper on lw6p2p_db_new.

4.16.186 c-lw6p2p-db-reset
--------------------------

 -- C function exported to Guile: 'c-lw6p2p-db-reset'
     Wrapper on lw6p2p_db_reset.

4.16.187 c-lw6p2p-node-calibrate
--------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-calibrate'
     Wrapper on lw6p2p_node_calibrate.

4.16.188 c-lw6p2p-node-client-join
----------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-client-join'
     Wrapper on lw6p2p_node_client_join.

4.16.189 c-lw6p2p-node-close
----------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-close'
     Wrapper on lw6p2p_node_close.

4.16.190 c-lw6p2p-node-disconnect
---------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-disconnect'
     Wrapper on lw6p2p_node_disconnect.

4.16.191 c-lw6p2p-node-get-entries
----------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-entries'
     Wrapper on lw6p2p_node_get_entries.

4.16.192 c-lw6p2p-node-get-id
-----------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-id'
     Wrapper on lw6p2p_node_get_id.

4.16.193 c-lw6p2p-node-get-local-seq-0
--------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-local-seq-0'
     Wrapper on lw6p2p_node_get_local_seq_0.

4.16.194 c-lw6p2p-node-get-local-seq-last
-----------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-local-seq-last'
     Wrapper on lw6p2p_node_get_local_seq_last.

4.16.195 c-lw6p2p-node-get-next-draft-msg
-----------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-next-draft-msg'
     Wrapper on lw6p2p_node_get_next_draft_msg.

4.16.196 c-lw6p2p-node-get-next-reference-msg
---------------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-next-reference-msg'
     Wrapper on lw6p2p_node_get_next_reference_msg.

4.16.197 c-lw6p2p-node-get-seq-draft
------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-seq-draft'
     Wrapper on lw6p2p_node_get_seq_draft.

4.16.198 c-lw6p2p-node-get-seq-max
----------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-seq-max'
     Wrapper on lw6p2p_node_get_seq_max.

4.16.199 c-lw6p2p-node-get-seq-min
----------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-seq-min'
     Wrapper on lw6p2p_node_get_seq_min.

4.16.200 c-lw6p2p-node-get-seq-reference
----------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-get-seq-reference'
     Wrapper on lw6p2p_node_get_seq_reference.

4.16.201 c-lw6p2p-node-is-dump-needed
-------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-is-dump-needed'
     Wrapper on lw6p2p_node_is_dump_needed.

4.16.202 c-lw6p2p-node-is-peer-connected
----------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-is-peer-connected'
     Wrapper on lw6p2p_node_is_peer_connected.

4.16.203 c-lw6p2p-node-is-peer-registered
-----------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-is-peer-registered'
     Wrapper on lw6p2p_node_is_peer_registered.

4.16.204 c-lw6p2p-node-is-seed-needed
-------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-is-seed-needed'
     Wrapper on lw6p2p_node_is_seed_needed.

4.16.205 c-lw6p2p-node-new
--------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-new'
     Wrapper on lw6p2p_node_new.

4.16.206 c-lw6p2p-node-poll
---------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-poll'
     Wrapper on lw6p2p_node_poll.

4.16.207 c-lw6p2p-node-put-local-msg
------------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-put-local-msg'
     Wrapper on lw6p2p_node_put_local_msg.

4.16.208 c-lw6p2p-node-refresh-peer
-----------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-refresh-peer'
     Wrapper on lw6p2p_node_refresh_peer.

4.16.209 c-lw6p2p-node-server-start
-----------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-server-start'
     Wrapper on lw6p2p_node_server_start.

4.16.210 c-lw6p2p-node-update-info
----------------------------------

 -- C function exported to Guile: 'c-lw6p2p-node-update-info'
     Wrapper on lw6p2p_node_update_info.

4.16.211 c-lw6pil-bench
-----------------------

 -- C function exported to Guile: 'c-lw6pil-bench'
     Wrapper on lw6pil_bench.

4.16.212 c-lw6pil-build-pilot
-----------------------------

 -- C function exported to Guile: 'c-lw6pil-build-pilot'
     Wrapper on lw6pil_build_pilot.

4.16.213 c-lw6pil-calibrate
---------------------------

 -- C function exported to Guile: 'c-lw6pil-calibrate'
     Wrapper on lw6pil_calibrate.

4.16.214 c-lw6pil-commit
------------------------

 -- C function exported to Guile: 'c-lw6pil-commit'
     Wrapper on lw6pil_commit.

4.16.215 c-lw6pil-did-cursor-win
--------------------------------

 -- C function exported to Guile: 'c-lw6pil-did-cursor-win'
     Wrapper on lw6pil_did_cursor_win.

4.16.216 c-lw6pil-dump-command-generate
---------------------------------------

 -- C function exported to Guile: 'c-lw6pil-dump-command-generate'
     Wrapper on lw6pil_dump_command_generate.

4.16.217 c-lw6pil-execute-command
---------------------------------

 -- C function exported to Guile: 'c-lw6pil-execute-command'
     Wrapper on lw6pil_execute_command.

4.16.218 c-lw6pil-fix-coords
----------------------------

 -- C function exported to Guile: 'c-lw6pil-fix-coords'
     Wrapper on lw6pil_coords_fix.

4.16.219 c-lw6pil-fix-coords-x10
--------------------------------

 -- C function exported to Guile: 'c-lw6pil-fix-coords-x10'
     Wrapper on lw6pil_coords_fix_x10.

4.16.220 c-lw6pil-get-last-commit-seq
-------------------------------------

 -- C function exported to Guile: 'c-lw6pil-get-last-commit-seq'
     Wrapper on lw6pil_get_last_commit_seq.

4.16.221 c-lw6pil-get-looser
----------------------------

 -- C function exported to Guile: 'c-lw6pil-get-looser'
     Wrapper on lw6pil_get_looser.

4.16.222 c-lw6pil-get-max-seq
-----------------------------

 -- C function exported to Guile: 'c-lw6pil-get-max-seq'
     Wrapper on lw6pil_get_max_seq.

4.16.223 c-lw6pil-get-next-seq
------------------------------

 -- C function exported to Guile: 'c-lw6pil-get-next-seq'
     Wrapper on lw6pil_get_next_seq.

4.16.224 c-lw6pil-get-reference-current-seq
-------------------------------------------

 -- C function exported to Guile: 'c-lw6pil-get-reference-current-seq'
     Wrapper on lw6pil_get_reference_current_seq.

4.16.225 c-lw6pil-get-reference-target-seq
------------------------------------------

 -- C function exported to Guile: 'c-lw6pil-get-reference-target-seq'
     Wrapper on lw6pil_get_reference_target_seq.

4.16.226 c-lw6pil-get-round-0
-----------------------------

 -- C function exported to Guile: 'c-lw6pil-get-round-0'
     Wrapper on lw6pil_get_round_0.

4.16.227 c-lw6pil-get-seq-0
---------------------------

 -- C function exported to Guile: 'c-lw6pil-get-seq-0'
     Wrapper on lw6pil_get_seq_0.

4.16.228 c-lw6pil-get-winner
----------------------------

 -- C function exported to Guile: 'c-lw6pil-get-winner'
     Wrapper on lw6pil_get_winner.

4.16.229 c-lw6pil-is-over
-------------------------

 -- C function exported to Guile: 'c-lw6pil-is-over'
     Wrapper on lw6pil_is_over.

4.16.230 c-lw6pil-local-command
-------------------------------

 -- C function exported to Guile: 'c-lw6pil-local-command'
     Wrapper on lw6pil_local_command.

4.16.231 c-lw6pil-local-cursors-set-main
----------------------------------------

 -- C function exported to Guile: 'c-lw6pil-local-cursors-set-main'
     Wrapper on lw6pil_local_cursors_set_main.

4.16.232 c-lw6pil-local-cursors-set-mouse-controlled
----------------------------------------------------

 -- C function exported to Guile:
          'c-lw6pil-local-cursors-set-mouse-controlled'
     Wrapper on lw6pil_local_cursors_set_mouse_controlled.

4.16.233 c-lw6pil-make-backup
-----------------------------

 -- C function exported to Guile: 'c-lw6pil-make-backup'
     Wrapper on lw6pil_make_backup.

4.16.234 c-lw6pil-poll-dump
---------------------------

 -- C function exported to Guile: 'c-lw6pil-poll-dump'
     Wrapper on lw6pil_poll_dump.

4.16.235 c-lw6pil-round2seq
---------------------------

 -- C function exported to Guile: 'c-lw6pil-round2seq'
     Wrapper on lw6pil_round2seq.

4.16.236 c-lw6pil-seed-command-generate
---------------------------------------

 -- C function exported to Guile: 'c-lw6pil-seed-command-generate'
     Wrapper on lw6pil_seed_command_generate.

4.16.237 c-lw6pil-send-command
------------------------------

 -- C function exported to Guile: 'c-lw6pil-send-command'
     Wrapper on lw6pil_send_command.

4.16.238 c-lw6pil-seq-random-0
------------------------------

 -- C function exported to Guile: 'c-lw6pil-seq-random-0'
     Wrapper on lw6pil_seq_random_0.

4.16.239 c-lw6pil-seq2round
---------------------------

 -- C function exported to Guile: 'c-lw6pil-seq2round'
     Wrapper on lw6pil_seq2round.

4.16.240 c-lw6pil-slow-down
---------------------------

 -- C function exported to Guile: 'c-lw6pil-slow-down'
     Wrapper on lw6pil_slow_down.

4.16.241 c-lw6pil-speed-up
--------------------------

 -- C function exported to Guile: 'c-lw6pil-speed-up'
     Wrapper on lw6pil_speed_up.

4.16.242 c-lw6pil-suite-get-checkpoint
--------------------------------------

 -- C function exported to Guile: 'c-lw6pil-suite-get-checkpoint'
     Wrapper on lw6pil_suite_get_checkpoint.

4.16.243 c-lw6pil-suite-get-commands-by-node-index
--------------------------------------------------

 -- C function exported to Guile:
          'c-lw6pil-suite-get-commands-by-node-index'
     Wrapper on lw6pil_suite_get_command_by_node_index, returns the list
     of all steps.

4.16.244 c-lw6pil-suite-get-commands-by-stage
---------------------------------------------

 -- C function exported to Guile: 'c-lw6pil-suite-get-commands-by-stage'
     Wrapper on lw6pil_suite_get_command_by_stage, returns the list of
     all steps.

4.16.245 c-lw6pil-suite-get-node-id
-----------------------------------

 -- C function exported to Guile: 'c-lw6pil-suite-get-node-id'
     Wrapper on lw6pil_suite_get_node_id.

4.16.246 c-lw6pil-suite-get-seq-0
---------------------------------

 -- C function exported to Guile: 'c-lw6pil-suite-get-seq-0'
     Wrapper on lw6pil_suite_get_seq_0.

4.16.247 c-lw6pil-suite-init
----------------------------

 -- C function exported to Guile: 'c-lw6pil-suite-init'
     Wrapper on lw6pil_suite_init.

4.16.248 c-lw6pil-sync-from-backup
----------------------------------

 -- C function exported to Guile: 'c-lw6pil-sync-from-backup'
     Wrapper on lw6pil_sync_from_backup.

4.16.249 c-lw6pil-sync-from-draft
---------------------------------

 -- C function exported to Guile: 'c-lw6pil-sync-from-draft'
     Wrapper on lw6pil_sync_from_draft.

4.16.250 c-lw6pil-sync-from-reference
-------------------------------------

 -- C function exported to Guile: 'c-lw6pil-sync-from-reference'
     Wrapper on lw6pil_sync_from_reference.

4.16.251 c-lw6snd-get-backends
------------------------------

 -- C function exported to Guile: 'c-lw6snd-get-backends'
     Wrapper on lw6snd_get_backends.

4.16.252 c-lw6snd-is-music-file
-------------------------------

 -- C function exported to Guile: 'c-lw6snd-is-music-file'
     Wrapper on lw6snd_is_music_file.

4.16.253 c-lw6snd-new
---------------------

 -- C function exported to Guile: 'c-lw6snd-new'
     Wrapper on lw6snd_new.

4.16.254 c-lw6snd-play-fx
-------------------------

 -- C function exported to Guile: 'c-lw6snd-play-fx'
     Wrapper on lw6snd_play_fx.

4.16.255 c-lw6snd-play-music-file
---------------------------------

 -- C function exported to Guile: 'c-lw6snd-play-music-file'
     Wrapper on lw6snd_play_music_file.

4.16.256 c-lw6snd-play-music-random
-----------------------------------

 -- C function exported to Guile: 'c-lw6snd-play-music-random'
     Wrapper on lw6snd_play_music_random.

4.16.257 c-lw6snd-poll
----------------------

 -- C function exported to Guile: 'c-lw6snd-poll'
     Wrapper on lw6snd_poll.

4.16.258 c-lw6snd-release
-------------------------

 -- C function exported to Guile: 'c-lw6snd-release'
     Wrapper on lw6snd_release.

4.16.259 c-lw6snd-set-fx-volume
-------------------------------

 -- C function exported to Guile: 'c-lw6snd-set-fx-volume'
     Wrapper on lw6snd_set_fx_volume.

4.16.260 c-lw6snd-set-music-volume
----------------------------------

 -- C function exported to Guile: 'c-lw6snd-set-music-volume'
     Wrapper on lw6snd_set_music_volume.

4.16.261 c-lw6snd-set-water-volume
----------------------------------

 -- C function exported to Guile: 'c-lw6snd-set-water-volume'
     Wrapper on lw6snd_set_water_volume.

4.16.262 c-lw6snd-stop-music
----------------------------

 -- C function exported to Guile: 'c-lw6snd-stop-music'
     Wrapper on lw6snd_stop_music.

4.16.263 c-lw6srv-get-backends
------------------------------

 -- C function exported to Guile: 'c-lw6srv-get-backends'
     Wrapper on lw6srv_get_backends.

4.16.264 c-lw6sys-build-get-abs-srcdir
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-abs-srcdir'
     Wrapper on lw6sys_build_get_abs_srcdir.

4.16.265 c-lw6sys-build-get-bin-id
----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-bin-id'
     Wrapper on lw6sys_build_get_bin_id.

4.16.266 c-lw6sys-build-get-bugs-url
------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-bugs-url'
     Wrapper on lw6sys_build_get_bugs_url.

4.16.267 c-lw6sys-build-get-cflags
----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-cflags'
     Wrapper on lw6sys_build_get_cflags.

4.16.268 c-lw6sys-build-get-codename
------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-codename'
     Wrapper on lw6sys_build_get_codename.

4.16.269 c-lw6sys-build-get-configure-args
------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-configure-args'
     Wrapper on lw6sys_build_get_configure_args.

4.16.270 c-lw6sys-build-get-copyright
-------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-copyright'
     Wrapper on lw6sys_build_get_copyright.

4.16.271 c-lw6sys-build-get-datadir
-----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-datadir'
     Wrapper on lw6sys_build_get_datadir.

4.16.272 c-lw6sys-build-get-date
--------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-date'
     Wrapper on lw6sys_build_get_date.

4.16.273 c-lw6sys-build-get-docdir
----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-docdir'
     Wrapper on lw6sys_build_get_docdir.

4.16.274 c-lw6sys-build-get-enable-allinone
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-allinone'
     Wrapper on lw6sys_build_get_enable_allinone.

4.16.275 c-lw6sys-build-get-enable-console
------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-console'
     Wrapper on lw6sys_build_get_enable_console.

4.16.276 c-lw6sys-build-get-enable-fullstatic
---------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-fullstatic'
     Wrapper on lw6sys_build_get_enable_fullstatic.

4.16.277 c-lw6sys-build-get-enable-gcov
---------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-gcov'
     Wrapper on lw6sys_build_get_enable_gcov.

4.16.278 c-lw6sys-build-get-enable-gprof
----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-gprof'
     Wrapper on lw6sys_build_get_enable_gprof.

4.16.279 c-lw6sys-build-get-enable-gtk
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-gtk'
     Wrapper on lw6sys_build_get_enable_gtk.

4.16.280 c-lw6sys-build-get-enable-instrument
---------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-instrument'
     Wrapper on lw6sys_build_get_enable_instrument.

4.16.281 c-lw6sys-build-get-enable-mod-caca
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-mod-caca'
     Wrapper on lw6sys_build_get_enable_mod_caca.

4.16.282 c-lw6sys-build-get-enable-mod-csound
---------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-mod-csound'
     Wrapper on lw6sys_build_get_enable_mod_csound.

4.16.283 c-lw6sys-build-get-enable-mod-gl1
------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-mod-gl1'
     Wrapper on lw6sys_build_get_enable_mod_gl1.

4.16.284 c-lw6sys-build-get-enable-mod-gles2
--------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-mod-gles2'
     Wrapper on lw6sys_build_get_enable_mod_gles2.

4.16.285 c-lw6sys-build-get-enable-mod-http
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-mod-http'
     Wrapper on lw6sys_build_get_enable_mod_http.

4.16.286 c-lw6sys-build-get-enable-mod-ogg
------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-mod-ogg'
     Wrapper on lw6sys_build_get_enable_mod_ogg.

4.16.287 c-lw6sys-build-get-enable-mod-soft
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-mod-soft'
     Wrapper on lw6sys_build_get_enable_mod_soft.

4.16.288 c-lw6sys-build-get-enable-openmp
-----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-openmp'
     Wrapper on lw6sys_build_get_enable_openmp.

4.16.289 c-lw6sys-build-get-enable-optimize
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-optimize'
     Wrapper on lw6sys_build_get_enable_optimize.

4.16.290 c-lw6sys-build-get-enable-paranoid
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-paranoid'
     Wrapper on lw6sys_build_get_enable_paranoid.

4.16.291 c-lw6sys-build-get-enable-profiler
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-profiler'
     Wrapper on lw6sys_build_get_enable_profiler.

4.16.292 c-lw6sys-build-get-enable-valgrind
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-enable-valgrind'
     Wrapper on lw6sys_build_get_enable_valgrind.

4.16.293 c-lw6sys-build-get-endianness
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-endianness'
     Wrapper on lw6sys_build_get_endianness.

4.16.294 c-lw6sys-build-get-gcc-version
---------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-gcc-version'
     Wrapper on lw6sys_build_get_gcc_version.

4.16.295 c-lw6sys-build-get-home-url
------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-home-url'
     Wrapper on lw6sys_build_get_home_url.

4.16.296 c-lw6sys-build-get-host-cpu
------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-host-cpu'
     Wrapper on lw6sys_build_get_host_cpu.

4.16.297 c-lw6sys-build-get-host-os
-----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-host-os'
     Wrapper on lw6sys_build_get_host_os.

4.16.298 c-lw6sys-build-get-hostname
------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-hostname'
     Wrapper on lw6sys_build_get_hostname.

4.16.299 c-lw6sys-build-get-includedir
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-includedir'
     Wrapper on lw6sys_build_get_includedir.

4.16.300 c-lw6sys-build-get-ldflags
-----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-ldflags'
     Wrapper on lw6sys_build_get_ldflags.

4.16.301 c-lw6sys-build-get-libdir
----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-libdir'
     Wrapper on lw6sys_build_get_libdir.

4.16.302 c-lw6sys-build-get-license
-----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-license'
     Wrapper on lw6sys_build_get_license.

4.16.303 c-lw6sys-build-get-localedir
-------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-localedir'
     Wrapper on lw6sys_build_get_localedir.

4.16.304 c-lw6sys-build-get-md5sum
----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-md5sum'
     Wrapper on lw6sys_build_get_md5sum.

4.16.305 c-lw6sys-build-get-package-id
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-package-id'
     Wrapper on lw6sys_build_get_package_id.

4.16.306 c-lw6sys-build-get-package-name
----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-package-name'
     Wrapper on lw6sys_build_get_package_name.

4.16.307 c-lw6sys-build-get-package-string
------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-package-string'
     Wrapper on lw6sys_build_get_package_string.

4.16.308 c-lw6sys-build-get-package-tarname
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-package-tarname'
     Wrapper on lw6sys_build_get_package_tarname.

4.16.309 c-lw6sys-build-get-pointer-size
----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-pointer-size'
     Wrapper on lw6sys_build_get_pointer_size.

4.16.310 c-lw6sys-build-get-prefix
----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-prefix'
     Wrapper on lw6sys_build_get_prefix.

4.16.311 c-lw6sys-build-get-stamp
---------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-stamp'
     Wrapper on lw6sys_build_get_stamp.

4.16.312 c-lw6sys-build-get-time
--------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-time'
     Wrapper on lw6sys_build_get_time.

4.16.313 c-lw6sys-build-get-top-srcdir
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-top-srcdir'
     Wrapper on lw6sys_build_get_top_srcdir.

4.16.314 c-lw6sys-build-get-version
-----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-version'
     Wrapper on lw6sys_build_get_version.

4.16.315 c-lw6sys-build-get-version-base
----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-version-base'
     Wrapper on lw6sys_build_get_version_base.

4.16.316 c-lw6sys-build-get-version-major
-----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-version-major'
     Wrapper on lw6sys_build_get_version_major.

4.16.317 c-lw6sys-build-get-version-minor
-----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-get-version-minor'
     Wrapper on lw6sys_build_get_version_minor.

4.16.318 c-lw6sys-build-is-gnu
------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-is-gnu'
     Wrapper on lw6sys_build_is_gnu.

4.16.319 c-lw6sys-build-is-gp2x
-------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-is-gp2x'
     Wrapper on lw6sys_build_is_gp2x.

4.16.320 c-lw6sys-build-is-mac-os-x
-----------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-is-mac-os-x'
     Wrapper on lw6sys_build_is_mac_os_x.

4.16.321 c-lw6sys-build-is-ms-windows
-------------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-is-ms-windows'
     Wrapper on lw6sys_build_is_ms_windows.

4.16.322 c-lw6sys-build-is-unix
-------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-is-unix'
     Wrapper on lw6sys_build_is_unix.

4.16.323 c-lw6sys-build-is-x86
------------------------------

 -- C function exported to Guile: 'c-lw6sys-build-is-x86'
     Wrapper on lw6sys_build_is_x86.

4.16.324 c-lw6sys-debug-get
---------------------------

 -- C function exported to Guile: 'c-lw6sys-debug-get'
     Wrapper on lw6sys_debug_get.

4.16.325 c-lw6sys-debug-set
---------------------------

 -- C function exported to Guile: 'c-lw6sys-debug-set'
     Wrapper on lw6sys_debug_set.

4.16.326 c-lw6sys-delay
-----------------------

 -- C function exported to Guile: 'c-lw6sys-delay'
     Wrapper on lw6sys_delay.

4.16.327 c-lw6sys-dump
----------------------

 -- C function exported to Guile: 'c-lw6sys-dump'
     Wrapper on lw6sys_dump.

4.16.328 c-lw6sys-dump-clear
----------------------------

 -- C function exported to Guile: 'c-lw6sys-dump-clear'
     Wrapper on lw6sys_dump_clear.

4.16.329 c-lw6sys-generate-id-16
--------------------------------

 -- C function exported to Guile: 'c-lw6sys-generate-id-16'
     Wrapper on lw6sys_generate_id_16.

4.16.330 c-lw6sys-generate-id-32
--------------------------------

 -- C function exported to Guile: 'c-lw6sys-generate-id-32'
     Wrapper on lw6sys_generate_id_32.

4.16.331 c-lw6sys-generate-id-64
--------------------------------

 -- C function exported to Guile: 'c-lw6sys-generate-id-64'
     Wrapper on lw6sys_generate_id_64.

4.16.332 c-lw6sys-get-config-file
---------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-config-file'
     Wrapper on lw6sys_get_config_file.

4.16.333 c-lw6sys-get-cwd
-------------------------

 -- C function exported to Guile: 'c-lw6sys-get-cwd'
     Wrapper on lw6sys_get_cwd.

4.16.334 c-lw6sys-get-cycle
---------------------------

 -- C function exported to Guile: 'c-lw6sys-get-cycle'
     Wrapper on lw6sys_get_cycle.

4.16.335 c-lw6sys-get-data-dir
------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-data-dir'
     Wrapper on lw6sys_get_data_dir.

4.16.336 c-lw6sys-get-default-config-file
-----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-config-file'
     Wrapper on lw6sys_get_default_config_file.

4.16.337 c-lw6sys-get-default-data-dir
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-data-dir'
     Wrapper on lw6sys_get_default_data_dir.

4.16.338 c-lw6sys-get-default-log-file
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-log-file'
     Wrapper on lw6sys_get_default_log_file.

4.16.339 c-lw6sys-get-default-map-dir
-------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-map-dir'
     Wrapper on lw6sys_get_default_map_dir.

4.16.340 c-lw6sys-get-default-map-path
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-map-path'
     Wrapper on lw6sys_get_default_map_path.

4.16.341 c-lw6sys-get-default-mod-dir
-------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-mod-dir'
     Wrapper on lw6sys_get_default_mod_dir.

4.16.342 c-lw6sys-get-default-music-dir
---------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-music-dir'
     Wrapper on lw6sys_get_default_music_dir.

4.16.343 c-lw6sys-get-default-music-path
----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-music-path'
     Wrapper on lw6sys_get_default_music_path.

4.16.344 c-lw6sys-get-default-prefix
------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-prefix'
     Wrapper on lw6sys_get_default_prefix.

4.16.345 c-lw6sys-get-default-script-file
-----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-script-file'
     Wrapper on lw6sys_get_default_script_file.

4.16.346 c-lw6sys-get-default-user-dir
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-default-user-dir'
     Wrapper on lw6sys_get_default_user_dir.

4.16.347 c-lw6sys-get-hostname
------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-hostname'
     Wrapper on lw6sys_get_hostname.

4.16.348 c-lw6sys-get-log-file
------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-log-file'
     Wrapper on lw6sys_get_log_file.

4.16.349 c-lw6sys-get-map-dir
-----------------------------

 -- C function exported to Guile: 'c-lw6sys-get-map-dir'
     Wrapper on lw6sys_get_map_dir.

4.16.350 c-lw6sys-get-map-path
------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-map-path'
     Wrapper on lw6sys_get_map_path.

4.16.351 c-lw6sys-get-memory-bazooka-eraser
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-memory-bazooka-eraser'
     Wrapper on lw6sys_get_memory_bazooka_eraser.

4.16.352 c-lw6sys-get-memory-bazooka-size
-----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-memory-bazooka-size'
     Wrapper on lw6sys_get_memory_bazooka_size.

4.16.353 c-lw6sys-get-mod-dir
-----------------------------

 -- C function exported to Guile: 'c-lw6sys-get-mod-dir'
     Wrapper on lw6sys_get_mod_dir.

4.16.354 c-lw6sys-get-music-dir
-------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-music-dir'
     Wrapper on lw6sys_get_music_dir.

4.16.355 c-lw6sys-get-music-path
--------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-music-path'
     Wrapper on lw6sys_get_music_path.

4.16.356 c-lw6sys-get-prefix
----------------------------

 -- C function exported to Guile: 'c-lw6sys-get-prefix'
     Wrapper on lw6sys_get_prefix.

4.16.357 c-lw6sys-get-run-dir
-----------------------------

 -- C function exported to Guile: 'c-lw6sys-get-run-dir'
     Wrapper on lw6sys_get_run_dir.

4.16.358 c-lw6sys-get-script-file
---------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-script-file'
     Wrapper on lw6sys_get_script_file.

4.16.359 c-lw6sys-get-timestamp
-------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-timestamp'
     Wrapper on lw6sys_get_timestamp.

4.16.360 c-lw6sys-get-uptime
----------------------------

 -- C function exported to Guile: 'c-lw6sys-get-uptime'
     Wrapper on lw6sys_get_uptime.

4.16.361 c-lw6sys-get-user-dir
------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-user-dir'
     Wrapper on lw6sys_get_user_dir.

4.16.362 c-lw6sys-get-username
------------------------------

 -- C function exported to Guile: 'c-lw6sys-get-username'
     Wrapper on lw6sys_get_username.

4.16.363 c-lw6sys-getenv
------------------------

 -- C function exported to Guile: 'c-lw6sys-getenv'
     Wrapper on lw6sys_getenv.

4.16.364 c-lw6sys-getenv-prefixed
---------------------------------

 -- C function exported to Guile: 'c-lw6sys-getenv-prefixed'
     Wrapper on lw6sys_getenv_prefixed.

4.16.365 c-lw6sys-idle
----------------------

 -- C function exported to Guile: 'c-lw6sys-idle'
     Wrapper on lw6sys_idle.

4.16.366 c-lw6sys-log
---------------------

 -- C function exported to Guile: 'c-lw6sys-log'
     Wrapper on lw6sys_log.

4.16.367 c-lw6sys-log-get-backtrace-mode
----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-log-get-backtrace-mode'
     Wrapper on lw6sys_log_get_backtrace_mode.

4.16.368 c-lw6sys-log-get-level
-------------------------------

 -- C function exported to Guile: 'c-lw6sys-log-get-level'
     Wrapper on lw6sys_log_get_level.

4.16.369 c-lw6sys-log-set-backtrace-mode
----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-log-set-backtrace-mode'
     Wrapper on lw6sys_log_set_backtrace_mode.

4.16.370 c-lw6sys-log-set-dialog-timeout
----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-log-set-dialog-timeout'
     Wrapper on lw6sys_log_set_dialog_timeout.

4.16.371 c-lw6sys-log-set-level
-------------------------------

 -- C function exported to Guile: 'c-lw6sys-log-set-level'
     Wrapper on lw6sys_log_set_level.

4.16.372 c-lw6sys-megabytes-available
-------------------------------------

 -- C function exported to Guile: 'c-lw6sys-megabytes-available'
     Wrapper on lw6sys_megabytes_available.

4.16.373 c-lw6sys-openmp-get-num-procs
--------------------------------------

 -- C function exported to Guile: 'c-lw6sys-openmp-get-num-procs'
     Wrapper on lw6sys_openmp_get_num_procs.

4.16.374 c-lw6sys-path-concat
-----------------------------

 -- C function exported to Guile: 'c-lw6sys-path-concat'
     Wrapper on lw6sys_path_concat.

4.16.375 c-lw6sys-path-file-only
--------------------------------

 -- C function exported to Guile: 'c-lw6sys-path-file-only'
     Wrapper on lw6sys_path_file_only.

4.16.376 c-lw6sys-path-parent
-----------------------------

 -- C function exported to Guile: 'c-lw6sys-path-parent'
     Wrapper on lw6sys_path_parent.

4.16.377 c-lw6sys-path-split
----------------------------

 -- C function exported to Guile: 'c-lw6sys-path-split'
     Wrapper on lw6sys_path_split.

4.16.378 c-lw6sys-set-memory-bazooka-eraser
-------------------------------------------

 -- C function exported to Guile: 'c-lw6sys-set-memory-bazooka-eraser'
     Wrapper on lw6sys_set_memory_bazooka_eraser.

4.16.379 c-lw6sys-set-memory-bazooka-size
-----------------------------------------

 -- C function exported to Guile: 'c-lw6sys-set-memory-bazooka-size'
     Wrapper on lw6sys_set_memory_bazooka_size.

4.16.380 c-lw6sys-signal-custom
-------------------------------

 -- C function exported to Guile: 'c-lw6sys-signal-custom'
     Wrapper on lw6sys_signal_custom.

4.16.381 c-lw6sys-signal-default
--------------------------------

 -- C function exported to Guile: 'c-lw6sys-signal-default'
     Wrapper on lw6sys_signal_default.

4.16.382 c-lw6sys-signal-poll-quit
----------------------------------

 -- C function exported to Guile: 'c-lw6sys-signal-poll-quit'
     Wrapper on lw6sys_signal_poll_quit.

4.16.383 c-lw6sys-signal-send-quit
----------------------------------

 -- C function exported to Guile: 'c-lw6sys-signal-send-quit'
     Wrapper on lw6sys_signal_send_quit.

4.16.384 c-lw6sys-sleep
-----------------------

 -- C function exported to Guile: 'c-lw6sys-sleep'
     Wrapper on lw6sys_sleep.

4.16.385 c-lw6sys-snooze
------------------------

 -- C function exported to Guile: 'c-lw6sys-snooze'
     Wrapper on lw6sys_snooze.

4.16.386 c-lw6sys-url-canonize
------------------------------

 -- C function exported to Guile: 'c-lw6sys-url-canonize'
     Wrapper on lw6sys_url_canonize.

4.16.387 c-lw6tsk-loader-get-stage
----------------------------------

 -- C function exported to Guile: 'c-lw6tsk-loader-get-stage'
     Wrapper on lw6tsk_loader_get_stage.

4.16.388 c-lw6tsk-loader-new
----------------------------

 -- C function exported to Guile: 'c-lw6tsk-loader-new'
     Wrapper on lw6tsk_loader_new.

4.16.389 c-lw6tsk-loader-pop
----------------------------

 -- C function exported to Guile: 'c-lw6tsk-loader-pop'
     Wrapper on lw6tsk_loader_pop.

4.16.390 c-lw6tsk-loader-push-gen
---------------------------------

 -- C function exported to Guile: 'c-lw6tsk-loader-push-gen'
     Wrapper on lw6tsk_loader_push_gen.

4.16.391 c-lw6tsk-loader-push-ldr
---------------------------------

 -- C function exported to Guile: 'c-lw6tsk-loader-push-ldr'
     Wrapper on lw6tsk_loader_push_ldr.

4.17 Script hooks
=================

5 C API
*******

This chapter contains a description of all modules and a list of all
documented C functions in the program.  It contains many references and
is self-generated from C comments using gdoc
(http://josefsson.org/gdoc/) by Simon Josefsson (http://josefsson.org/).

   In order to reduce the number of pages of printed output, this
complete reference is, by default, disabled in printable versions of the
documentation (PostScript, PDF). This is both to make the manual more
readable and to avoid wasting paper.  Think about the environment.

   It is however available in the HTML version of the documentation,
which you can read online on
<http://www.gnu.org/software/liquidwar6/manual/html_node/>.

   Additionnally, the following adresses contain various view on the
source code, giving informations on all the internal and public C
interfaces:

   * <http://www.ufoot.org/liquidwar/v6/doc/coverage/>: the lcov
     (http://ltp.sourceforge.net/coverage/lcov.php) output when running
     './liquidwar6 --test'.  It shows what functions are actually
     tested, and how many times they are called.
   * <http://www.ufoot.org/liquidwar/v6/doc/global/>: the GNU global
     (http://www.gnu.org/software/global/) output gives complete
     cross-references, macros, headers, contants declaration.  It's a
     very good place to start browsing the code.
   * <http://www.ufoot.org/liquidwar/v6/doc/cyclo/>: the pmccabe
     (http://parisc-linux.org/~bame/pmccabe/) output shows the
     cyclomatic complexity of functions.  It enables the programmer to
     spots the "ugly" and dangerous parts of the program.
   * <http://www.ufoot.org/liquidwar/v6/doc/doxygen/>: the Doxygen
     (http://www.stack.nl/~dimitri/doxygen/) documentation gives an
     interactive access to the code, the structures and functions, and
     their dependencies.

5.1 libliquidwar6
=================

5.1.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/index.html>.

5.1.2 API
---------

 -- Function: void lw6_resize_callback (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_video_mode_t * VIDEO_MODE)
     SYS_CONTEXT: global system context

     VIDEO_MODE: the new video mode

     This callback is here because gfx needs to update the config when
     the screen is resized.  But...  we did not want to make gfx depend
     on cfg "directly".  It's cleaner to pass parameters with Scheme, in
     the long run, it should make things easier.  So this callback is
     the solution.  Another side effect is that this way there's a
     tangible obvious trace of this updating of config status by the gfx
     module.  Seeing it sticking out like a thumb isn't a bad thing.

     *Return value:* none

 -- Function: void lw6_release (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Functions which will call 'quit', 'free', 'destroy' on whatever
     smob object that has threads and/or requires hardware ressources.
     This is to be called before the Guile interpreter ends.  This is
     because when it garbage collects objects at the end of the program,
     it has no idea of what order to use when freeing objects.  So if an
     object which uses another one in a thread is freed after the other
     is freed, you get a (rather unexplainabled if not warned) segfault.

     *Return value:* none

 -- Function: void lw6_exit (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Sends a quit message and displays a newline.

     *Return value:* none

 -- Function: void lw6_set_ret (lw6sys_context_t * SYS_CONTEXT, int RET)
     SYS_CONTEXT: global system context

     RET: return value to set, 1 for success, 0 for failure

     Sets the ret value for the script.

     *Return value:* none

 -- Function: int lw6_get_ret (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Get the ret value for the script.

     *Return value:* 1 if success, 0 if not.

 -- Function: int lw6_fix_env (lw6sys_context_t * SYS_CONTEXT, int ARGC,
          const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: array of strings as passed to main

     Fixes environment variables (path related) so that program can find
     its requirements.  This must be called early in the program flow
     (else other calls might fail).

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6_register_funcs_bot (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the bot module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register all the functions, make them callable from Guile.  This is
     a very simple yet long and very usefull function, without it Guile
     has no knowledge of what LW6 is.

     *Return value:* 1 on success, 0 if failed.

 -- Function: extern void lw6_cns_handler (lw6sys_context_t *
          SYS_CONTEXT, char * C_LINE)
     SYS_CONTEXT: global system context

     C_LINE: the line typed by the user

     This function will be called every time a message is typed on the
     console.  It runs the given line in the current Guile environment.

     *Return value:* none

 -- Function: int lw6_register_funcs_cfg (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the cfg module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_cli (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the cli module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_cns (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the cns module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_dsp (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the dsp module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_gen (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the gen module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_gfx (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the gfx module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_gui (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the gui module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_hlp (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the hlp module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_img (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the img module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_ker (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the ker module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_ldr (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the ldr module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_map (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the map module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_net (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the net module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_p2p (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the p2p module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_pil (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the pil module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_snd (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the snd module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_srv (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the srv module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_sys (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the sys module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_register_funcs_tsk (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register the functions of the tsk module, make them callable from
     Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_init_global (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: array of strings as passed to main

     Initializes global values to their defaults.

     *Return value:* 1 on success, 0 if failed

 -- Function: void lw6_quit_global (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Frees global values.  Will also garbage collect objects in case
     Guile failed to do it perfectly (or we failed to tell Guile how to
     do it).  Important note: this function can only be called once in a
     program, usually at the end.  If called twice, and typically, if
     *any* Guile code is run after it, the risk is that Guile code does
     not find objects that it should, or said differently, Guile might
     try to manipulate stuff that has been deleted without its being
     warned about it.  In practice, libGC way of doing thing is usually
     a good thing, since it will from time to time keep objects in
     memory that shouldn't, so there's no point in changing that, but as
     we are pedantic in LW6 about the fact that everything at program
     exit must be perfectly freed, the problem arises.  So well, only
     call this once at the end, else problem will show up, the usual
     form is a segfault on the delete callback, as when Guile finally
     runs its GC, the object does not exist any more.

     *Return value:* none.

 -- Function: int lw6_main (lw6sys_context_t * SYS_CONTEXT, int ARGC,
          const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: the argc parameter of the 'main' function, that is, the
     number of command-line args.

     ARGV: the argv parameter of the 'main' function, that is, an array
     containing pointers on command-line args.

     This function is directly called by 'main'.  This means by linking
     against libliquidwar6 and calling it, you would have a program that
     is almost exactly the "official" upstream liquidwar6 binary, except
     you can tweak it and have all the power to call whatever other
     functions you like, embed it.  In short, everything the binary
     does, you can do it in your own binarn, by linking against the
     library and calling this function.

     *Return value:* 1 if success, zero if failure.  Note that this is
     the "standard" C / liquidwar6 way to proceed, but your 'main'
     function should return 0 if success, else an error code.  Typical
     use is "return !lw6_main(argc, argv);".

 -- Function: int lw6_process_non_run_options (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, int * RUN_GAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line args, as passed to main

     ARGV: an array of strings containing command-line args, as passed
     to main

     RUN_GAME: a pointer to a boolean which will contain true (1) if the
     game must be launched, or false (0) if the option is such that game
     must be skipped.  Example: -copyright, -help, ...

     Interprets command line arguments, and if some need to be
     processed, typically those args that are used to display stuff on
     the console, then perform the corresponding actions.

     *Return value:* non-zero if success, 0 if error.  The error can be,
     for instance, the test suite returning "no, tests were not OK".

 -- Function: SCM lw6_make_scm_dsp (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * C_DSP)
     SYS_CONTEXT: global system context

     C_DSP: the display object

     Creates an SCM 'dsp' object from C data.

     *Return value:* the SCM object

 -- Function: lw6dsp_backend_t * lw6_scm_to_dsp (lw6sys_context_t *
          SYS_CONTEXT, SCM DSP)
     SYS_CONTEXT: global system context

     DSP: the dsp to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'dsp'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_dsp_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_dsp_smob_t * DSP_SMOB)
     SYS_CONTEXT: global system context

     DSP_SMOB: the smob to free

     Frees a dsp smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_snd (lw6sys_context_t * SYS_CONTEXT,
          lw6snd_backend_t * C_SND)
     SYS_CONTEXT: global system context

     C_SND: the sound object

     Creates an SCM 'snd' object from C data.

     *Return value:* the SCM object

 -- Function: lw6snd_backend_t * lw6_scm_to_snd (lw6sys_context_t *
          SYS_CONTEXT, SCM SND)
     SYS_CONTEXT: global system context

     SND: the snd to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'snd'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_snd_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_snd_smob_t * SND_SMOB)
     SYS_CONTEXT: global system context

     SND_SMOB: the smob to free

     Frees a snd smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_map (lw6sys_context_t * SYS_CONTEXT,
          lw6map_level_t * C_MAP)
     SYS_CONTEXT: global system context

     C_MAP: the map object

     Creates an SCM 'map' object from C data.

     *Return value:* the SCM object

 -- Function: lw6map_level_t * lw6_scm_to_map (lw6sys_context_t *
          SYS_CONTEXT, SCM MAP)
     SYS_CONTEXT: global system context

     MAP: the map to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'map'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_map_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_map_smob_t * MAP_SMOB)
     SYS_CONTEXT: global system context

     MAP_SMOB: the smob to free

     Frees a map smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_menu (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * C_MENU)
     SYS_CONTEXT: global system context

     C_MENU: the menu object

     Creates an SCM 'menu' object from C data.

     *Return value:* the SCM object

 -- Function: lw6gui_menu_t * lw6_scm_to_menu (lw6sys_context_t *
          SYS_CONTEXT, SCM MENU)
     SYS_CONTEXT: global system context

     MENU: the menu to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'menu'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_menu_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_menu_smob_t * MENU_SMOB)
     SYS_CONTEXT: global system context

     MENU_SMOB: the smob to free

     Frees a menu smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_game_struct (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_struct_t * C_GAME_STRUCT, SCM MAP)
     SYS_CONTEXT: global system context

     C_GAME_STRUCT: the game struct object

     MAP: the map (SCM object) referenced

     Creates an SCM 'game-struct' object from C data.  Passing the map
     object enables the garbage collector not to free the map until the
     game struct is freed.

     *Return value:* the SCM object

 -- Function: lw6ker_game_struct_t * lw6_scm_to_game_struct
          (lw6sys_context_t * SYS_CONTEXT, SCM GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme
     'game_struct' object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_game_struct_smob (lw6sys_context_t *
          SYS_CONTEXT, lw6_game_struct_smob_t * GAME_STRUCT_SMOB)
     SYS_CONTEXT: global system context

     GAME_STRUCT_SMOB: the smob to free

     Frees a game_struct smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_game_state (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * C_GAME_STATE, SCM
          GAME_STRUCT)
     SYS_CONTEXT: global system context

     C_GAME_STATE: the game state object

     GAME_STRUCT: the game struct (SCM object) referenced

     Creates an SCM 'game_state' object from C data.  Passing
     game_struct enables the garbage collector not to free the
     game_struct until the game_state is freed.

     *Return value:* the SCM object

 -- Function: lw6ker_game_state_t * lw6_scm_to_game_state
          (lw6sys_context_t * SYS_CONTEXT, SCM GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme
     'game_state' object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_game_state_smob (lw6sys_context_t *
          SYS_CONTEXT, lw6_game_state_smob_t * GAME_STATE_SMOB)
     SYS_CONTEXT: global system context

     GAME_STATE_SMOB: the smob to free

     Frees a game_state smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_pilot (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_pilot_t * C_PILOT)
     SYS_CONTEXT: global system context

     C_PILOT: the pilot object

     Creates an SCM 'pilot' object from C data.

     *Return value:* the SCM object

 -- Function: lw6pil_pilot_t * lw6_scm_to_pilot (lw6sys_context_t *
          SYS_CONTEXT, SCM PILOT)
     SYS_CONTEXT: global system context

     PILOT: the pilot to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'pilot'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_pilot_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_pilot_smob_t * PILOT_SMOB)
     SYS_CONTEXT: global system context

     PILOT_SMOB: the smob to free

     Frees a pilot smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_bot (lw6sys_context_t * SYS_CONTEXT,
          lw6bot_backend_t * C_BOT, SCM GAME_STATE, SCM PILOT)
     SYS_CONTEXT: global system context

     C_BOT: the bot object

     GAME_STATE: the game state

     PILOT: the pilot

     Creates an SCM 'bot' object from C data.  Passing game_state and
     pilot enables the garbage collector not the free them until bot is
     freed.

     *Return value:* the SCM object

 -- Function: lw6bot_backend_t * lw6_scm_to_bot (lw6sys_context_t *
          SYS_CONTEXT, SCM BOT)
     SYS_CONTEXT: global system context

     BOT: the bot to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'bot'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_bot_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_bot_smob_t * BOT_SMOB)
     SYS_CONTEXT: global system context

     BOT_SMOB: the smob to free

     Frees a bot smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_look (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * C_LOOK)
     SYS_CONTEXT: global system context

     C_LOOK: the look object

     Creates an SCM 'look' object from C data.

     *Return value:* the SCM object

 -- Function: lw6gui_look_t * lw6_scm_to_look (lw6sys_context_t *
          SYS_CONTEXT, SCM LOOK)
     SYS_CONTEXT: global system context

     LOOK: the look to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'look'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_look_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_look_smob_t * LOOK_SMOB)
     SYS_CONTEXT: global system context

     LOOK_SMOB: the smob to free

     Frees a look smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_loader (lw6sys_context_t * SYS_CONTEXT,
          lw6tsk_loader_t * C_LOADER)
     SYS_CONTEXT: global system context

     C_LOADER: the loader object

     Creates an SCM 'loader' object from C data.

     *Return value:* the SCM object

 -- Function: lw6tsk_loader_t * lw6_scm_to_loader (lw6sys_context_t *
          SYS_CONTEXT, SCM LOADER)
     SYS_CONTEXT: global system context

     LOADER: the loader to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'loader'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_loader_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_loader_smob_t * LOADER_SMOB)
     SYS_CONTEXT: global system context

     LOADER_SMOB: the smob to free

     Frees a loader smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_db (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_db_t * C_DB)
     SYS_CONTEXT: global system context

     C_DB: the database object

     Creates an SCM 'db' object from C data.

     *Return value:* the SCM object

 -- Function: lw6p2p_db_t * lw6_scm_to_db (lw6sys_context_t *
          SYS_CONTEXT, SCM DB)
     SYS_CONTEXT: global system context

     DB: the db to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'db'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_db_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_db_smob_t * DB_SMOB)
     SYS_CONTEXT: global system context

     DB_SMOB: the smob to free

     Frees a db smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_node (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_node_t * C_NODE, SCM DB)
     SYS_CONTEXT: global system context

     C_NODE: the node object

     DB: the db (SCM object) referenced

     Creates an SCM 'node' object from C data.  Passing db enables the
     garbage collector not to free db until node is freed.

     *Return value:* the SCM object

 -- Function: lw6p2p_node_t * lw6_scm_to_node (lw6sys_context_t *
          SYS_CONTEXT, SCM NODE)
     SYS_CONTEXT: global system context

     NODE: the node to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'node'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_node_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_node_smob_t * NODE_SMOB)
     SYS_CONTEXT: global system context

     NODE_SMOB: the smob to free

     Frees a node smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: SCM lw6_make_scm_jpeg (lw6sys_context_t * SYS_CONTEXT,
          lw6img_jpeg_t * C_JPEG)
     SYS_CONTEXT: global system context

     C_JPEG: the database object

     Creates an SCM 'jpeg' object from C data.

     *Return value:* the SCM object

 -- Function: lw6img_jpeg_t * lw6_scm_to_jpeg (lw6sys_context_t *
          SYS_CONTEXT, SCM JPEG)
     SYS_CONTEXT: global system context

     JPEG: the jpeg to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'jpeg'
     object.

     *Return value:* a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_jpeg_smob (lw6sys_context_t * SYS_CONTEXT,
          lw6_jpeg_smob_t * JPEG_SMOB)
     SYS_CONTEXT: global system context

     JPEG_SMOB: the smob to free

     Frees a jpeg smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:* none

 -- Function: int lw6_register_smobs (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Register all smobs to Guile.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6_test_register (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the lw6 module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the liquidwar6 core module test suite, this will mostly test
     how Guile script integration works, loading a sample script and
     running it.  It does not launch all the other sub modules tests.

     *Return value:* 1 if test is successfull, 0 on error.

5.2 libbot
==========

5.2.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/bot/index.html>.

5.2.2 API
---------

 -- Function: int lw6bot_init (lw6sys_context_t * SYS_CONTEXT,
          lw6bot_backend_t * BACKEND, lw6bot_seed_t * SEED)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     SEED: parameters required to build bot (game state, among other
     things)

     Initializes a bot object.  Must be performed before any other call.
     The seed is absolutely required, for a bot really needs to know
     what map/context it's working on, including at creation time

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6bot_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6bot_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: unitialize a bot backend

     Closes a bot, but does not free all ressources.

 -- Function: int lw6bot_next_move (lw6sys_context_t * SYS_CONTEXT,
          lw6bot_backend_t * BACKEND, int * X, int * Y)
     SYS_CONTEXT: global system context

     BACKEND: bot to work on

     X: next x position (out param)

     Y: next y position (out param)

     Queries the bot for its next move, this is actually the one
     interesting function in the whole bot API.

     *Return value:* 1 on success, 0 on failure.

 -- Function: char * lw6bot_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6bot_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: bot to represent

     Gives a human readable representation of bot

     *Return value:* dynamically allocated string.

 -- Function: lw6sys_assoc_t * lw6bot_get_backends (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     List available bot backends.  The hash contains pairs with id and
     name for each backend.  The id is the technical key you can use to
     load the backend, the name is something more readable you can
     display in an interface.  The backend objects themselves are not
     instanciated by this (in fact, they are, but released on the fly)
     you need to load and initialize them afterwards.

     *Return value:* hash containing id/name pairs.

 -- Function: lw6bot_backend_t * lw6bot_create_backend (lw6sys_context_t
          * SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          NAME)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     NAME: string containing bot key, typically got from
     'lw6bot_get_backends'

     Creates a bot backend, this is just about loading the dynamic
     library if needed, and/or check bot engine is available, and
     connect to it.  It does not perform initialization.

     *Return value:* bot backend.

 -- Function: void lw6bot_destroy_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6bot_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: bot backend to destroy

     Frees the ressources associated to a bot, which must have been
     properly uninitialized before.

     *Return value:* none.

 -- Function: int lw6bot_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libbot module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6bot_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'bot' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6bot_backend_s

     The bot backend is the first argument passed to any bot function,
     it contains reference to all the functions which can be used as
     well as a pointer on associated data.  In OO, this would just be an
     object, with members and methods, using polymorphism through opaque
     pointers.

 -- Member of lw6bot_backend_s: dl_handle
     *Type:* 'lw6dyn_dl_handle_t *'

     *Definition:* 'lw6dyn_dl_handle_t* lw6bot_backend_s::dl_handle'

     Handle on dynamic library (if it makes sense).

 -- Member of lw6bot_backend_s: bot_context
     *Type:* 'void *'

     *Definition:* 'void* lw6bot_backend_s::bot_context'

     Bot specific data, what is behind this pointer really depends on
     the bot engine.

 -- Member of lw6bot_backend_s: argc
     *Type:* 'int'

     *Definition:* 'int lw6bot_backend_s::argc'

     The argc value passed to main.

 -- Member of lw6bot_backend_s: argv
     *Type:* 'const char **'

     *Definition:* 'const char** lw6bot_backend_s::argv'

     The argv value passed to main.

 -- Member of lw6bot_backend_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6bot_backend_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6bot_backend_s: seed
     *Type:* 'lw6bot_seed_t'

     *Definition:* 'lw6bot_seed_t lw6bot_backend_s::seed'

     Parameters passed at initialization.

 -- Member of lw6bot_backend_s: init
     *Type:* 'void *(*'

     *Definition:* 'void*(* lw6bot_backend_s::init)(lw6sys_context_t
     *sys_context, int argc, const char *argv[], lw6bot_data_t *data)'

     Pointer on lw6bot_init callback code.

 -- Member of lw6bot_backend_s: quit
     *Type:* 'void(*'

     *Definition:* 'void(* lw6bot_backend_s::quit)(lw6sys_context_t
     *sys_context, void *bot_context)'

     Pointer on lw6bot_context callback code.

 -- Member of lw6bot_backend_s: next_move
     *Type:* 'int(*'

     *Definition:* 'int(* lw6bot_backend_s::next_move)(lw6sys_context_t
     *sys_context, void *bot_context, int *x, int *y, lw6bot_data_t
     *data)'

     Pointer on lw6bot_next_move callback code.

 -- Member of lw6bot_backend_s: repr
     *Type:* 'char *(*'

     *Definition:* 'char*(* lw6bot_backend_s::repr)(lw6sys_context_t
     *sys_context, void *bot_context, u_int32_t id)'

     Pointer on lw6bot_repr callback code.

 -- Struct: lw6bot_data_s

     Data used by a bot, those are essentially stable data passed as an
     argument plus changing data, that is, the game state.

 -- Member of lw6bot_data_s: game_state
     *Type:* 'const lw6ker_game_state_t *'

     *Definition:* 'const lw6ker_game_state_t*
     lw6bot_data_s::game_state'

     Game state the bot will have to base its reflexion upon.  This not
     need be always the same game state, the pointer might change, but
     it should always refer to the same logical game, that is, at least,
     same struct.

 -- Member of lw6bot_data_s: param
     *Type:* 'lw6bot_param_t'

     *Definition:* 'lw6bot_param_t lw6bot_data_s::param'

     Constant parameters passed to the bot at creation.

 -- Struct: lw6bot_param_s

     Parameters usable by a bot engine.  Those are the stable, fixed
     parameters passed at bot creation, they don't change during the bot
     life.

 -- Member of lw6bot_param_s: speed
     *Type:* 'float'

     *Definition:* 'float lw6bot_param_s::speed'

     Speed of the bot, this is a value between 0.0f and 1.0f, 1 means
     normal speed, 0 is as slow as possible.  Values over 1 will make
     the bot act/move faster than usual.

 -- Member of lw6bot_param_s: iq
     *Type:* 'int'

     *Definition:* 'int lw6bot_param_s::iq'

     IQ is supposed to reflect the cleverness of the bot.  The default
     is 100 (this value is basically a percentage), 0 means just so
     stupid, and a high value, for instance 200, means very clever.

 -- Member of lw6bot_param_s: cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6bot_param_s::cursor_id'

     The cursor ID, which is a 16-bit non-null integer.

 -- Struct: lw6bot_seed_s

     Parameters passed at bot creation, the only use for this is to
     simplify the protoype of the init function.

 -- Member of lw6bot_seed_s: game_state
     *Type:* 'const lw6ker_game_state_t *'

     *Definition:* 'const lw6ker_game_state_t*
     lw6bot_seed_s::game_state'

     Game state, that is, the level used, the fighters on it, the other
     cursors positions, and so on.

 -- Member of lw6bot_seed_s: pilot
     *Type:* 'lw6pil_pilot_t *'

     *Definition:* 'lw6pil_pilot_t* lw6bot_seed_s::pilot'

     This can be NULL, it's a pilot object which can be used in some
     case, when, for instance, in dirty read mode, we want to read the
     level on the fly without syncing.

 -- Member of lw6bot_seed_s: dirty_read
     *Type:* 'int'

     *Definition:* 'int lw6bot_seed_s::dirty_read'

     The dirty read mode (between 0 and 2).

 -- Member of lw6bot_seed_s: param
     *Type:* 'lw6bot_param_t'

     *Definition:* 'lw6bot_param_t lw6bot_seed_s::param'

     Parameters given to the bot at creation.

5.3 mod-brute
=============

5.3.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/bot/mod-brute/index.html>.

5.3.2 API
---------

 -- Function: void mod_brute_is_GPL_compatible ()

     Defined to tell mod_brute is compatible with GNU General Public
     License.  Of course it is.  This function does nothing, but the
     fact it's declared makes its GPL compatibility obvious.  Having
     this declared is required.

     *Return value:* none

 -- Function: void mod_brute_is_dlclose_safe ()

     Defined to tell mod_brute has no dlclose issue, once can safely
     call lt_dlclose on it when done with it, without risking any
     segfault.  Some other LW6 modules/shared libraries do have this
     problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_brute_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-brute, giving details about the
     module, including name, description, licence, date/time of
     compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6bot_backend_t * mod_brute_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-brute backend.

     *Return value:* backend pointer.

5.4 mod-follow
==============

5.4.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/bot/mod-follow/index.html>.

5.4.2 API
---------

 -- Function: void mod_follow_is_GPL_compatible ()

     Defined to tell mod_follow is compatible with GNU General Public
     License.  Of course it is.  This function does nothing, but the
     fact it's declared makes its GPL compatibility obvious.  Having
     this declared is required.

     *Return value:* none

 -- Function: void mod_follow_is_dlclose_safe ()

     Defined to tell mod_follow has no dlclose issue, once can safely
     call lt_dlclose on it when done with it, without risking any
     segfault.  Some other LW6 modules/shared libraries do have this
     problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_follow_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-follow, giving details about the
     module, including name, description, licence, date/time of
     compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6bot_backend_t * mod_follow_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-follow backend.

     *Return value:* backend pointer.

5.5 mod-idiot
=============

5.5.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/bot/mod-idiot/index.html>.

5.5.2 API
---------

 -- Function: void mod_idiot_is_GPL_compatible ()

     Defined to tell mod_idiot is compatible with GNU General Public
     License.  Of course it is.  This function does nothing, but the
     fact it's declared makes its GPL compatibility obvious.  Having
     this declared is required.

     *Return value:* none

 -- Function: void mod_idiot_is_dlclose_safe ()

     Defined to tell mod_idiot has no dlclose issue, once can safely
     call lt_dlclose on it when done with it, without risking any
     segfault.  Some other LW6 modules/shared libraries do have this
     problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_idiot_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-idiot, giving details about the
     module, including name, description, licence, date/time of
     compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6bot_backend_t * mod_idiot_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-idiot backend.

     *Return value:* backend pointer.

5.6 mod-random
==============

5.6.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/bot/mod-random/index.html>.

5.6.2 API
---------

 -- Function: void mod_random_is_GPL_compatible ()

     Defined to tell mod_random is compatible with GNU General Public
     License.  Of course it is.  This function does nothing, but the
     fact it's declared makes its GPL compatibility obvious.  Having
     this declared is required.

     *Return value:* none

 -- Function: void mod_random_is_dlclose_safe ()

     Defined to tell mod_random has no dlclose issue, once can safely
     call lt_dlclose on it when done with it, without risking any
     segfault.  Some other LW6 modules/shared libraries do have this
     problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_random_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-random, giving details about the
     module, including name, description, licence, date/time of
     compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6bot_backend_t * mod_random_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-random backend.

     *Return value:* backend pointer.

5.7 libcfg
==========

5.7.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/cfg/index.html>.

5.7.2 API
---------

 -- Function: int lw6cfg_parse_command_line (lw6sys_context_t *
          SYS_CONTEXT, void * CFG_CONTEXT)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: opaque pointer on a context

     Overwrites any existing option with command line args

     *Return value:* 1 if success, 0 if error

 -- Function: int lw6cfg_defaults (lw6sys_context_t * SYS_CONTEXT, void
          * CFG_CONTEXT)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: opaque pointer on a context

     Sets all values to their defaults.

     *Return value:* 1 if success, 0 if error

 -- Function: int lw6cfg_merge_env (lw6sys_context_t * SYS_CONTEXT, void
          * CFG_CONTEXT)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: a context returned by 'lw6cfg_init'

     Overwrites any existing vale in the config with environment
     variables prefixed by LW6_.

     *Return value:* 1 if successfull, 0 if error.

 -- Function: int lw6cfg_load_exp (lw6sys_context_t * SYS_CONTEXT, const
          char * USER_DIR, int * EXP)
     SYS_CONTEXT: global system context

     USER_DIR: the user directory

     EXP: the exp (out param)

     Gets exp from file.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6cfg_save_exp (lw6sys_context_t * SYS_CONTEXT, const
          char * USER_DIR, int EXP)
     SYS_CONTEXT: global system context

     USER_DIR: the user directory

     EXP: the exp

     Saves exp to file.

     *Return value:* 1 on success, 0 on failure

 -- Function: char * lw6cfg_format (lw6sys_context_t * SYS_CONTEXT,
          const char * KEY, const char * VALUE, lw6hlp_type_t TYPE)
     SYS_CONTEXT: global system context

     KEY: the key of the value to format

     VALUE: the value to format

     TYPE: the type of the value to format

     Formats, converts, a given value to its cannonical representation.
     Booleans will be converted to true/false, strings containing
     integers will be stripped from junk, and so on.  This is a
     performance killer but will ensure everything is correct.

     *Return value:* a newly allocated string, containing the same as
     the input, but reformatted the pedantic way.

 -- Function: char * lw6cfg_format_guess_type (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     KEY: the key of the value to format

     VALUE: the value to format

     Formats, converts, a given value to its cannonical representation.
     Booleans will be converted to true/false, strings containing
     integers will be stripped from junk, and so on.  This is a
     performance killer but will ensure everything is correct.  This
     function will automatically guess the type of the value from its
     description in the help system.

     *Return value:* a newly allocated string, containing the same as
     the input, but reformatted the pedantic way.

 -- Function: int lw6cfg_load (lw6sys_context_t * SYS_CONTEXT, void *
          CFG_CONTEXT, const char * FILENAME)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: a context returned by 'lw6cfg_init'

     FILENAME: a file path, absolute or relative

     Loads the given config file, and stores its values into the current
     context.  Parameters which are both in the config file and given as
     command line parameters, will be taken from the command-line.

     *Return value:* 1 if successfull, 0 if error.

 -- Function: int lw6cfg_option_exists (lw6sys_context_t * SYS_CONTEXT,
          void * CFG_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: context to query

     KEY: key to search

     Returns wether a key exists within context or not.

     *Return value:* 1 if exists, 0 if not

 -- Function: char * lw6cfg_get_option (lw6sys_context_t * SYS_CONTEXT,
          void * CFG_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: context to query

     KEY: key to search

     Returns the current value for a given query, the returned value is
     always a string, typically the string one would pass on the command
     line or set in a config file

     *Return value:* pointer to string, must be freed.

 -- Function: void lw6cfg_set_option (lw6sys_context_t * SYS_CONTEXT,
          void * CFG_CONTEXT, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: context to modify

     KEY: key to search and change

     VALUE: new value

     Sets a given key to the specified value, this is a string only
     function, pass the value you would pass on the command line or set
     in a config file.

     *Return value:* none

 -- Function: int lw6cfg_get_option_int (lw6sys_context_t * SYS_CONTEXT,
          void * CFG_CONTEXT, const char * KEY)
     KEY: key to search

     Returns an option as an integer.  Note that this function does not
     know wether the parameter should really be an integer or not, so
     you can call it even on non-integer values, but of course results
     will have no real meaning.

     *Return value:* option value converted to int

 -- Function: void lw6cfg_set_option_int (lw6sys_context_t *
          SYS_CONTEXT, void * CFG_CONTEXT, const char * KEY, int VALUE)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: context to modify

     KEY: key to search and change

     VALUE: new value

     Set a config option to an integer value.  Note that this function
     does not know wether the parameter should really be an integer or
     not, so you can call it even on non-integer values, at your own
     risk.

     *Return value:* none.

 -- Function: int lw6cfg_get_option_bool (lw6sys_context_t *
          SYS_CONTEXT, void * CFG_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: context to query

     KEY: key to search

     Returns an option as a boolean.  Note that this function does not
     know wether the parameter should really be a boolean or not, so you
     can call it even on non-boolean values, but of course results will
     have no real meaning.

     *Return value:* option value converted to boolean

 -- Function: void lw6cfg_set_option_bool (lw6sys_context_t *
          SYS_CONTEXT, void * CFG_CONTEXT, const char * KEY, int VALUE)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: context to modify

     KEY: key to search and change

     VALUE: new value

     Set a config option to a boolean value.  Note that this function
     does not know wether the parameter should really be a boolean or
     not, so you can call it even on non-boolean values, at your own
     risk.

     *Return value:* none.

 -- Function: int lw6cfg_must_be_saved (lw6sys_context_t * SYS_CONTEXT,
          const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key to test

     Tells wether a key should be saved in the config file.  Typically,
     some options you don't want to savem such as the location of the
     config file itself.  Most of those non-savable parameters are
     path-related.  This does not mean no paths are saved in the config
     file.

     *Return value:* 1 if must be saved, 0 if not

 -- Function: int lw6cfg_save (lw6sys_context_t * SYS_CONTEXT, void *
          CFG_CONTEXT, const char * FILENAME)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: a context returned by 'lw6cfg_init'

     FILENAME: a file path, absolute or relative

     Save current options into the given config file.  Before saving the
     file, all command line arguments will be read and will override
     current values.  This means the saved file will contain values
     given as command line arguments.

     *Return value:* 1 if successfull, 0 if error.

 -- Function: void * lw6cfg_init (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of command line arguments, as given to 'main'

     ARGV: a list of command line arguments, as given to 'main'

     Initializes a config context object.  This object is hidden behind
     an opaque void * pointer to avoid direct access to its elements.

     *Return value:* an opaque pointer, must be freed with
     'lw6cfg_quit'.

 -- Function: void lw6cfg_quit (lw6sys_context_t * SYS_CONTEXT, void *
          CFG_CONTEXT)
     SYS_CONTEXT: global system context

     CFG_CONTEXT: a context returned by 'lw6cfg_init'

     Frees a config cfg_context object.  You must call this once you're
     done with the context.

     *Return value:* none.

 -- Function: void lw6cfg_reset (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of command line arguments, as given to 'main'

     ARGV: a list of command line arguments, as given to 'main'

     Overwrites the config file with defaults.  Use this to get rid of
     old configurations.

 -- Function: int lw6cfg_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libcfg module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6cfg_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'cfg' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: char * lw6cfg_unified_get_value (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, char * KEY)
     SYS_CONTEXT: global system context

     ARGC: number of command-line args, as passed to 'main'

     ARGV: arry of command-line args, as passed to 'main'

     KEY: the key to query

     Unified "value" getter, which gets informations from environment
     variables, command line, and config file.  The rules is that the
     command-line argument always has the last word.  It will override
     any other value.  Follows environment variables, which will be used
     if no command-line argument is supplied.  Note that these are
     "LW6_" prefixed and uppercased environment variables as opposed to
     lowercased and "dash-separated" keys.  Finally, if there's no
     environment variable, nor any config-file corresponding entry, the
     value will be searched in the config file.  If there's no
     information in the config file, NULL is returned.

     *Return value:* a string with the value.  Can be NULL. Must be
     freed.

 -- Function: char * lw6cfg_unified_get_user_dir (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of command-line args, as passed to 'main'

     ARGV: arry of command-line args, as passed to 'main'

     Gets the user dir, taking all parameters in account, that's to say
     the "LW6_USER_DIR" env value, the "-user-dir" command-line
     paramater and the LW6DEF_USER_DIR config file entry.

     *Return value:* the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_unified_get_log_file (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of command-line args, as passed to 'main'

     ARGV: arry of command-line args, as passed to 'main'

     Gets the log file, taking all parameters in account, that's to say
     the "LW6_LOG_FILE" env value, the "-log-file" command-line
     paramater and the LW6DEF_LOG_FILE config file entry.

     *Return value:* the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_unified_get_music_path (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of command-line args, as passed to 'main'

     ARGV: arry of command-line args, as passed to 'main'

     Gets the user dir, taking all parameters in account, that's to say
     the "LW6_MUSIC_PATH" env value, the "-music-path" command-line
     paramater and the LW6DEF_MUSIC_PATH config file entry.

     *Return value:* the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_unified_get_map_path (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of command-line args, as passed to 'main'

     ARGV: arry of command-line args, as passed to 'main'

     Gets the user dir, taking all parameters in account, that's to say
     the "LW6_MAP_PATH" env value, the "-map-path" command-line
     paramater and the LW6DEF_MAP_PATH config file entry.

     *Return value:* the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_xml_element (lw6sys_context_t * SYS_CONTEXT,
          lw6hlp_type_t TYPE)
     SYS_CONTEXT: global system context

     TYPE: type as an enum

     Returns the string corresponding to a given type, suitable for use
     in XML files.  For instance if you pass 'LW6HLP_TYPE_INT' then you
     will obtain the string int (string of 3 chars containing i, n and
     t.

     *Return value:* string, must not be freed.

 -- Function: void lw6cfg_read_xml_int (lw6sys_context_t * SYS_CONTEXT,
          const char * XML_KEY, const char * XML_VALUE, const char *
          TARGET_KEY, int * VALUE)
     SYS_CONTEXT: global system context

     XML_KEY: key found in XML file

     XML_VALUE: value found in XML file

     TARGET_KEY: key we're searching for

     VALUE: the value if found (out param)

     Tries to find a value in a key/value pair.  If 'xml_key' and
     'target_key' match, then will put the corresponding value
     (converted to int) in the 'value' param.  Typically, you would call
     this in a loop on every single entry found in an XML file, in an
     expat callback.

     *Return value:* none.

 -- Function: void lw6cfg_read_xml_bool (lw6sys_context_t * SYS_CONTEXT,
          const char * XML_KEY, const char * XML_VALUE, const char *
          TARGET_KEY, int * VALUE)
     SYS_CONTEXT: global system context

     XML_KEY: key found in XML file

     XML_VALUE: value found in XML file

     TARGET_KEY: key we're searching for

     VALUE: the value if found (out param)

     Tries to find a value in a key/value pair.  If 'xml_key' and
     'target_key' match, then will put the corresponding value
     (converted to boolean) in the 'value' param.  Typically, you would
     call this in a loop on every single entry found in an XML file, in
     an expat callback.

     *Return value:* none.

 -- Function: void lw6cfg_read_xml_float (lw6sys_context_t *
          SYS_CONTEXT, const char * XML_KEY, const char * XML_VALUE,
          const char * TARGET_KEY, float * VALUE)
     SYS_CONTEXT: global system context

     XML_KEY: key found in XML file

     XML_VALUE: value found in XML file

     TARGET_KEY: key we're searching for

     VALUE: the value if found (out param)

     Tries to find a value in a key/value pair.  If 'xml_key' and
     'target_key' match, then will put the corresponding value
     (converted to float) in the 'value' param.  Typically, you would
     call this in a loop on every single entry found in an XML file, in
     an expat callback.

     *Return value:* none.

 -- Function: void lw6cfg_read_xml_string (lw6sys_context_t *
          SYS_CONTEXT, const char * XML_KEY, const char * XML_VALUE,
          const char * TARGET_KEY, char ** VALUE)
     SYS_CONTEXT: global system context

     XML_KEY: key found in XML file

     XML_VALUE: value found in XML file

     TARGET_KEY: key we're searching for

     VALUE: the value if found (out param)

     Tries to find a value in a key/value pair.  If 'xml_key' and
     'target_key' match, then will put the corresponding value (as a
     string) in the 'value' param.  Typically, you would call this in a
     loop on every single entry found in an XML file, in an expat
     callback.

     *Return value:* none.

 -- Function: void lw6cfg_read_xml_color (lw6sys_context_t *
          SYS_CONTEXT, const char * XML_KEY, const char * XML_VALUE,
          const char * TARGET_KEY, lw6sys_color_8_t * VALUE)
     SYS_CONTEXT: global system context

     XML_KEY: key found in XML file

     XML_VALUE: value found in XML file

     TARGET_KEY: key we're searching for

     VALUE: the value if found (out param)

     Tries to find a value in a key/value pair.  If 'xml_key' and
     'target_key' match, then will put the corresponding value
     (converted to a color) in the 'value' param.  Typically, you would
     call this in a loop on every single entry found in an XML file, in
     an expat callback.

     *Return value:* none.

 -- Function: int lw6cfg_read_key_value_xml_file (lw6sys_context_t *
          SYS_CONTEXT, const char * FILENAME,
          lw6cfg_read_xml_callback_func_t CALLBACK_FUNC, void *
          CALLBACK_DATA)
     SYS_CONTEXT: global system context

     FILENAME: full path of file to read

     CALLBACK_FUNC: callback function to be called on each element

     CALLBACK_DATA: additionnal pointer passed to callback function

     Will parse a file and call the given callback on each element.
     This is an over-simplified way to read XML file, in fact we just
     explain plain non-nested simple elements but this is exactly what
     LW config files are made of.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6cfg_write_xml_int (lw6sys_context_t * SYS_CONTEXT,
          FILE * F, const char * KEY, int VALUE)
     SYS_CONTEXT: global system context

     F: file to write data to (append mode)

     KEY: key to write

     VALUE: value to write

     Writes an int entry into an opened XML file.

     *Return value:* none.

 -- Function: void lw6cfg_write_xml_bool (lw6sys_context_t *
          SYS_CONTEXT, FILE * F, const char * KEY, int VALUE)
     SYS_CONTEXT: global system context

     F: file to write data to (append mode)

     KEY: key to write

     VALUE: value to write

     Writes a boolean entry into an opened XML file.

     *Return value:* none.

 -- Function: void lw6cfg_write_xml_float (lw6sys_context_t *
          SYS_CONTEXT, FILE * F, const char * KEY, float VALUE)
     SYS_CONTEXT: global system context

     F: file to write data to (append mode)

     KEY: key to write

     VALUE: value to write

     Writes a float entry into an opened XML file.

     *Return value:* none.

 -- Function: void lw6cfg_write_xml_string (lw6sys_context_t *
          SYS_CONTEXT, FILE * F, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     F: file to write data to (append mode)

     KEY: key to write

     VALUE: value to write

     Writes a string entry into an opened XML file.

     *Return value:* none.

 -- Function: void lw6cfg_write_xml_color (lw6sys_context_t *
          SYS_CONTEXT, FILE * F, const char * KEY, lw6sys_color_8_t
          VALUE)
     SYS_CONTEXT: global system context

     F: file to write data to (append mode)

     KEY: key to write

     VALUE: value to write

     Writes a color entry into an opened XML file.

     *Return value:* none.

 -- Function: void lw6cfg_write_xml_guess_type (lw6sys_context_t *
          SYS_CONTEXT, FILE * F, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     F: file to write data to (append mode)

     KEY: key to write

     VALUE: value to write

     Writes an entry into an opened XML file, will try and guess type
     from the internal help system, typically, if this is a standard
     config file entry (the one documented by the about command line
     function) it will pick up the right type.  The reason not to use
     this all the times is that sometimes, one might to to store
     non-standard options, and additionnally, guessing the type does
     consume some CPU.

     *Return value:* none.

 -- Function: void lw6cfg_write_xml_guess_type_skip_same
          (lw6sys_context_t * SYS_CONTEXT, FILE * F, const char * KEY,
          const char * VALUE)
     SYS_CONTEXT: global system context

     F: file to write data to (append mode)

     KEY: key to write

     VALUE: value to write

     Writes an entry into an opened XML file, will try and guess type
     from the internal help system, typically, if this is a standard
     config file entry (the one documented by the about command line
     function) it will pick up the right type.  The reason not to use
     this all the times is that sometimes, one might to to store
     non-standard options, and additionnally, guessing the type does
     consume some CPU. Also, this function will write only values that
     are different from the default.

     *Return value:* none.

5.8 libcli
==========

5.8.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/cli/index.html>.

5.8.2 API
---------

 -- Function: int lw6cli_init (lw6sys_context_t * SYS_CONTEXT,
          lw6cli_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     Initializes a client backend.  Must be performed before any other
     call.

     *Return value:* 1 on success, 0 on failure

 -- Function: void lw6cli_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6cli_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: unitialize a cli backend

     Closes a cli, but does not free all ressources.

 -- Function: int lw6cli_process_oob (lw6sys_context_t * SYS_CONTEXT,
          lw6cli_backend_t * BACKEND, lw6nod_info_t * NODE_INFO,
          lw6cli_oob_data_t * OOB_DATA)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     NODE_INFO: information on the current node

     OOB_DATA: data of the out-of-band request

     Processes the required out-of-band tasks, this typically, for a
     client, includes broadcasting.  Depending on parameters passed in
     oob_data, might actually do a broadcast or simply call a given host
     and see what's the answer.  A typicall exchange is PING then INFO
     and finally LIST. It's the responsability of the client to take the
     OOB initiative and contact the server.

     *Return value:* 1 on success, 0 on failure.

 -- Function: lw6cnx_connection_t * lw6cli_open (lw6sys_context_t *
          SYS_CONTEXT, lw6cli_backend_t * BACKEND, const char *
          LOCAL_URL, const char * REMOTE_URL, const char * REMOTE_IP,
          int REMOTE_PORT, const char * PASSWORD, u_int64_t LOCAL_ID,
          u_int64_t REMOTE_ID, int DNS_OK, int NETWORK_RELIABILITY)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     LOCAL_URL: our local public url

     REMOTE_URL: the remote url we want to connect to

     REMOTE_IP: remote IP address

     REMOTE_PORT: remote IP port

     PASSWORD: password to use (if needed)

     LOCAL_ID: our local id

     REMOTE_ID: the remote id

     DNS_OK: wether the remote announced URL matches DNS information

     NETWORK_RELIABILITY: network reliability (the highest, the better)

     Opens a connection with a remote host.

     *Return value:* new object.

 -- Function: void lw6cli_close (lw6sys_context_t * SYS_CONTEXT,
          lw6cli_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     CONNECTION: connection to use

     Closes a connection, this will free the connection object.

     *Return value:* none.

 -- Function: int lw6cli_send (lw6sys_context_t * SYS_CONTEXT,
          lw6cli_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION,
          int64_t NOW, u_int32_t PHYSICAL_TICKET_SIG, u_int32_t
          LOGICAL_TICKET_SIG, u_int64_t LOGICAL_FROM_ID, u_int64_t
          LOGICAL_TO_ID, const char * MESSAGE)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     CONNECTION: connection to use

     NOW: current timestamp

     PHYSICAL_TICKET_SIG: signature of physical sender

     LOGICAL_TICKET_SIG: signature of logical sender

     LOGICAL_FROM_ID: id of logical sender

     LOGICAL_TO_ID: id of logicial target

     MESSAGE: text of message to send

     Sends a message to a peer over a given connection.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6cli_can_send (lw6sys_context_t * SYS_CONTEXT,
          lw6cli_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     CONNECTION: connection to use

     Tells wether a client connection can technically send messages.
     This does not garantee send will succeed, but if it's not OK at
     this stage, it's not even worth trying.

     *Return value:* 1 if it can be used to send messages, 0 if not
     ready.

 -- Function: void lw6cli_poll (lw6sys_context_t * SYS_CONTEXT,
          lw6cli_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     CONNECTION: connection to use

     Performs required duty on connection, depending on the backend,
     this can include sending messages and/or receiving them.  Must be
     called on a regular basis.

     *Return value:* none.

 -- Function: char * lw6cli_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6cli_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     CONNECTION: connection to represent

     Gives a human readable representation of the connection.

     *Return value:* dynamically allocated string.

 -- Function: lw6cli_oob_t * lw6cli_oob_new (lw6sys_context_t *
          SYS_CONTEXT, const char * PUBLIC_URL,
          lw6cli_verify_callback_func_t VERIFY_CALLBACK_FUNC, void *
          VERIFY_CALLBACK_DATA)
     SYS_CONTEXT: global system context

     PUBLIC_URL: the address of the distant server to test

     VERIFY_CALLBACK_FUNC: a function which will be called when a node
     has been verified

     VERIFY_CALLBACK_DATA: additionnal data passed to the callback func

     Create a new OOB structure, copying required objects.  We need to
     make copies for this is for usage in a separate thread.  The thread
     member is not set here since the right way to do things is first to
     set up data then to fire the thread.

     *Return value:* new object

 -- Function: void lw6cli_oob_free (lw6sys_context_t * SYS_CONTEXT,
          lw6cli_oob_t * OOB)
     SYS_CONTEXT: global system context

     OOB: the object to free

     Frees an OOB structure.

     *Return value:* none

 -- Function: char * lw6cli_default_backends (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of the default cli backends.

     *Return value:* comma separated string, must not be freed.

 -- Function: lw6sys_assoc_t * lw6cli_get_backends (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     List available cli backends.  The hash contains pairs with id and
     name for each backend.  The id is the technical key you can use to
     load the backend, the name is something more readable you can
     display in an interface.  The backend objects themselves are not
     instanciated by this (in fact, they are, but released on the fly)
     you need to load and initialize them afterwards.

     *Return value:* hash containing id/name pairs.

 -- Function: lw6cli_backend_t * lw6cli_create_backend (lw6sys_context_t
          * SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          NAME)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     NAME: string containing cli key, typically got from
     'lw6cli_get_backends'

     Creates a cli backend, this is just about loading the dynamic
     library if needed, and/or check cli engine is available, and
     connect to it.  It does not perform initialization.

     *Return value:* cli backend.

 -- Function: void lw6cli_destroy_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6cli_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: backend to destroy

     Destroys a cli backend.

     *Return value:* none.

 -- Function: int lw6cli_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libcli module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6cli_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'cli' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6cli_backend_s

     The cli backend is the first argument passed to any cli function,
     it contains reference to all the functions which can be used as
     well as a pointer on associated data.  In OO, this would just be an
     object, with members and methods, using polymorphism through opaque
     pointers.

 -- Member of lw6cli_backend_s: dl_handle
     *Type:* 'lw6dyn_dl_handle_t *'

     *Definition:* 'lw6dyn_dl_handle_t* lw6cli_backend_s::dl_handle'

     Handle on dynamic library (if it makes sense).

 -- Member of lw6cli_backend_s: cli_context
     *Type:* 'void *'

     *Definition:* 'void* lw6cli_backend_s::cli_context'

     Cli specific data, what is behind this pointer really depends on
     the cli engine.

 -- Member of lw6cli_backend_s: argc
     *Type:* 'int'

     *Definition:* 'int lw6cli_backend_s::argc'

     The argc value passed to main.

 -- Member of lw6cli_backend_s: argv
     *Type:* 'const char **'

     *Definition:* 'const char** lw6cli_backend_s::argv'

     The argv value passed to main.

 -- Member of lw6cli_backend_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6cli_backend_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6cli_backend_s: name
     *Type:* 'char *'

     *Definition:* 'char* lw6cli_backend_s::name'

     Module name.

 -- Member of lw6cli_backend_s: properties
     *Type:* 'lw6cnx_properties_t'

     *Definition:* 'lw6cnx_properties_t lw6cli_backend_s::properties'

     General backend properties.

 -- Member of lw6cli_backend_s: init
     *Type:* 'void *(*'

     *Definition:* 'void*(* lw6cli_backend_s::init)(lw6sys_context_t
     *sys_context, int argc, const char *argv[], lw6cnx_properties_t
     *properties)'

     Pointer on lw6cli_init callback code.

 -- Member of lw6cli_backend_s: quit
     *Type:* 'void(*'

     *Definition:* 'void(* lw6cli_backend_s::quit)(lw6sys_context_t
     *sys_context, void *cli_context)'

     Pointer on lw6cli_quit callback code.

 -- Member of lw6cli_backend_s: process_oob
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6cli_backend_s::process_oob)(lw6sys_context_t *sys_context, void
     *cli_context, lw6nod_info_t *node_info, lw6cli_oob_data_t
     *oob_data)'

     Pointer on lw6cli_process_oob callback code.

 -- Member of lw6cli_backend_s: open
     *Type:* 'lw6cnx_connection_t *(*'

     *Definition:* 'lw6cnx_connection_t*(*
     lw6cli_backend_s::open)(lw6sys_context_t *sys_context, void
     *cli_context, const char *local_url, const char *remote_url, const
     char *remote_ip, int remote_port, const char *password, u_int64_t
     local_id, u_int64_t remote_id, int dns_ok, int
     network_reliability)'

     Pointer on lw6cli_open callback code.

 -- Member of lw6cli_backend_s: close
     *Type:* 'void(*'

     *Definition:* 'void(* lw6cli_backend_s::close)(lw6sys_context_t
     *sys_context, void *cli_context, lw6cnx_connection_t *connection)'

     Pointer on lw6cli_close callback code.

 -- Member of lw6cli_backend_s: send
     *Type:* 'int(*'

     *Definition:* 'int(* lw6cli_backend_s::send)(lw6sys_context_t
     *sys_context, void *cli_context, lw6cnx_connection_t *connection,
     int64_t now, u_int32_t physical_ticket_sig, u_int32_t
     logical_ticket_sig, u_int64_t logical_from_id, u_int64_t
     logical_to_id, const char *message)'

     Pointer on lw6cli_send callback code.

 -- Member of lw6cli_backend_s: can_send
     *Type:* 'int(*'

     *Definition:* 'int(* lw6cli_backend_s::can_send)(lw6sys_context_t
     *sys_context, void *cli_context, lw6cnx_connection_t *connection)'

     Pointer on lw6cli_can_send callback code.

 -- Member of lw6cli_backend_s: poll
     *Type:* 'void(*'

     *Definition:* 'void(* lw6cli_backend_s::poll)(lw6sys_context_t
     *sys_context, void *cli_context, lw6cnx_connection_t *connection)'

     Pointer on lw6cli_poll callback code.

 -- Member of lw6cli_backend_s: repr
     *Type:* 'char *(*'

     *Definition:* 'char*(* lw6cli_backend_s::repr)(lw6sys_context_t
     *sys_context, void *cli_context, lw6cnx_connection_t *connection)'

     Pointer on lw6cli_repr callback code.

 -- Struct: lw6cli_oob_data_s

     Holds the data for the process_oob function, this is merely a
     utility struct to simplify headers/

 -- Member of lw6cli_oob_data_s: creation_timestamp
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6cli_oob_data_s::creation_timestamp'

     Creation timestamp of the OOB request, this is used to know wether
     we have already timed out or not.  This is not the node creation
     timestamp.

 -- Member of lw6cli_oob_data_s: do_not_finish
     *Type:* 'int'

     *Definition:* 'volatile int lw6cli_oob_data_s::do_not_finish'

     Flag used to force finish, for instance when we want to delete the
     object quickly and do not want to wait until a long polling-based
     network operation finishes completely.

 -- Member of lw6cli_oob_data_s: public_url
     *Type:* 'char *'

     *Definition:* 'char* lw6cli_oob_data_s::public_url'

     Public URL of the node, we need this at hand to serve it quickly to
     peers, and be able to perform basic checks.

 -- Member of lw6cli_oob_data_s: verify_callback_func
     *Type:* 'lw6cli_verify_callback_func_t'

     *Definition:* 'lw6cli_verify_callback_func_t
     lw6cli_oob_data_s::verify_callback_func'

     Pointer on a function which will verify if peer is OK, and act
     accordinlgy if it's OK or not.  Note that the callback function
     might be called pretty much anytime in the heavily multithreaded
     context of LW6 so it must be reentrant and have mutexes if needed.
     Indeed, it's very likely to update some shared list of available
     nodes.

 -- Member of lw6cli_oob_data_s: verify_callback_data
     *Type:* 'void *'

     *Definition:* 'void* lw6cli_oob_data_s::verify_callback_data'

     Data passed to the verify_callback function.

 -- Struct: lw6cli_oob_s

     Structure containing both the thread running an OOB request and its
     data.  It was advantagious to separate thoses two and not make the
     thread a permanent member of the OOB data struct, since it allows
     the actual OOB code to be totally unaware of the thread running it,
     which is, to some extent, safer.

 -- Member of lw6cli_oob_s: thread
     *Type:* 'lw6sys_thread_handler_t *'

     *Definition:* 'lw6sys_thread_handler_t* lw6cli_oob_s::thread'

     Pointer on thread running the OOB request.

 -- Member of lw6cli_oob_s: data
     *Type:* 'lw6cli_oob_data_t'

     *Definition:* 'lw6cli_oob_data_t lw6cli_oob_s::data'

     Data used by the OOB request.

5.9 mod-http
============

5.9.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/cli/mod-http/index.html>.

5.9.2 API
---------

 -- Function: void mod_http_is_GPL_compatible ()

     Defined to tell mod_http is compatible with GNU General Public
     License.  Of course it is.  This function does nothing, but the
     fact it's declared makes its GPL compatibility obvious.  Having
     this declared is required.

     *Return value:* none

 -- Function: void mod_http_is_dlclose_safe ()

     Defined to tell mod_http has no dlclose issue, once can safely call
     lt_dlclose on it when done with it, without risking any segfault.
     Some other LW6 modules/shared libraries do have this problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_http_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-http, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6cli_backend_t * mod_http_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-http backend.

     *Return value:* backend pointer.

5.10 mod-tcp
============

5.10.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/cli/mod-tcp/index.html>.

5.10.2 API
----------

 -- Function: void mod_tcp_is_GPL_compatible ()

     Defined to tell mod_tcp is compatible with GNU General Public
     License.  Of course it is.  This function does nothing, but the
     fact it's declared makes its GPL compatibility obvious.  Having
     this declared is required.

     *Return value:* none

 -- Function: void mod_tcp_is_dlclose_safe ()

     Defined to tell mod_tcp has no dlclose issue, once can safely call
     lt_dlclose on it when done with it, without risking any segfault.
     Some other LW6 modules/shared libraries do have this problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_tcp_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-tcp, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6cli_backend_t * mod_tcp_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-tcp backend.

     *Return value:* backend pointer.

5.11 mod-udp
============

5.11.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/cli/mod-udp/index.html>.

5.11.2 API
----------

 -- Function: void mod_udp_is_GPL_compatible ()

     Defined to tell mod_udp is compatible with GNU General Public
     License.  Of course it is.  This function does nothing, but the
     fact it's declared makes its GPL compatibility obvious.  Having
     this declared is required.

     *Return value:* none

 -- Function: void mod_udp_is_dlclose_safe ()

     Defined to tell mod_udp has no dlclose issue, once can safely call
     lt_dlclose on it when done with it, without risking any segfault.
     Some other LW6 modules/shared libraries do have this problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_udp_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-udp, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6cli_backend_t * mod_udp_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-udp backend.

     *Return value:* backend pointer.

5.12 libcns
===========

5.12.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/cns/index.html>.

5.12.2 API
----------

 -- Function: void lw6cns_handler_callback (char * LINE)
     LINE: the input line

     The global console handler.  Because readline does not, or at
     least, because I did not find any proper way to pass it a general
     pointer along with the string, and since we need 'sys_context'
     pretty much everywhere, we rely on using this handler which, in
     turn, calls the handler passed to 'lw6cns_handler_install' with
     'sys_context' added as a first argument.

     *Return value:* none.

 -- Function: void lw6cns_handler_install (lw6sys_context_t *
          SYS_CONTEXT, lw6cns_callback_func_t CALLBACK)
     SYS_CONTEXT: global system context

     CALLBACK: handler function.

     Installs a console handler.

     *Return value:* none.

 -- Function: void lw6cns_handler_poll (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Polling function for console, must be called on a regular basis.

     *Return value:* none.

 -- Function: void lw6cns_handler_remove (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Remove console handler.

     *Return value:* none.

 -- Function: void lw6cns_history_add_if_needed (lw6sys_context_t *
          SYS_CONTEXT, char * LINE)
     SYS_CONTEXT: global system context

     LINE: line to add

     Adds a line to the console history, won't add it if it's NULL or
     empty.

     *Return value:* none.

 -- Function: int lw6cns_console_support (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Tells wether console is supported.

     *Return value:* 1 if console can be enabled, 0 if not

 -- Function: int lw6cns_term_support (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Tells wether program is likely to have proper term (xterm, Linux
     console) support.

     *Return value:* 1 if has validated TERM support, 0 if not

 -- Function: int lw6cns_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libcns module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6cns_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'cns' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

5.13 libcnx
===========

5.13.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/cnx/index.html>.

5.13.2 API
----------

 -- Function: lw6cnx_connection_t * lw6cnx_connection_new
          (lw6sys_context_t * SYS_CONTEXT, const char * LOCAL_URL, const
          char * REMOTE_URL, const char * REMOTE_IP, int REMOTE_PORT,
          const char * PASSWORD, u_int64_t LOCAL_ID, u_int64_t
          REMOTE_ID, int DNS_OK, int NETWORK_RELIABILITY)
     SYS_CONTEXT: global system context

     LOCAL_URL: the local public URL

     REMOTE_URL: the remote public URL

     REMOTE_IP: the remote IP address

     REMOTE_PORT: the remote port

     PASSWORD: the password to use

     LOCAL_ID: the local ID

     REMOTE_ID: the remote ID

     DNS_OK: 1 if no DNS mismatch, 0 if IP does not match public URL

     NETWORK_RELIABILITY: drop 1 out of X packets

     Create a connection object.  This object in itself does nothing,
     it's just to share common structures among modules, more precisely,
     between cli and srv code.  It's the responsability off the
     caller/backend to handle the 'backend_specific_data' field which is
     NULL after this call.

     *Return value:* newly allocated object.

 -- Function: void lw6cnx_connection_free (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     CONNECTION: object to free

     Frees a connection object.  It's the responsibility of the
     caller/backend to handle the 'backend_specific_data' field.

     *Return value:* none.

 -- Function: int lw6cnx_connection_should_send_foo (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_connection_t * CONNECTION, int64_t NOW)
     SYS_CONTEXT: global system context

     CONNECTION: the connection concerned

     NOW: the current timestamp

     Tells wether a new foo message must be issued.

     *Return value:* 1 if true, 0 if false.

 -- Function: void lw6cnx_connection_init_foo_bar_key (lw6sys_context_t
          * SYS_CONTEXT, lw6cnx_connection_t * CONNECTION, int64_t NOW,
          int NEXT_FOO_DELAY)
     SYS_CONTEXT: global system context

     CONNECTION: the connection concerned

     NOW: the current timestamp

     NEXT_FOO_DELAY: the delay (msec) before next foo message is sent

     Generates a new foo_bar_key, and schedules the next foo message
     send timestamp.

     *Return value:* none.

 -- Function: int lw6cnx_connection_lock_send (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     CONNECTION: the connexion to lock

     Acquires a "send" lock on the connexion, the idea is to avoid too
     threads sending data using the same socket at the same time.  Note
     that each backend must call this when accessing the socket, there's
     no top-level lock for the sake of performance.

     *Return value:* 1 on success, 0 if not.

 -- Function: void lw6cnx_connection_unlock_send (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     CONNECTION: the connexion to lock

     Releases a "send" lock on the connexion, the idea is to avoid too
     threads sending data using the same socket at the same time.  Note
     that each backend must call this when accessing the socket, there's
     no top-level lock for the sake of performance.

     *Return value:* none.

 -- Function: int lw6cnx_connection_reliability_filter (lw6sys_context_t
          * SYS_CONTEXT, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     CONNECTION: the connexion concerned

     Will filter and return true only in "rare" cases when packets must
     be artificially dropped for testing purpose.

     *Return value:* 1 if message must be sent/received, 0 if not

 -- Function: lw6cnx_packet_t * lw6cnx_packet_new (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t LOGICAL_TICKET_SIG, u_int32_t
          PHYSICAL_TICKET_SIG, u_int64_t LOGICAL_FROM_ID, u_int64_t
          LOGICAL_TO_ID, const char * MSG)
     SYS_CONTEXT: global system context

     LOGICAL_TICKET_SIG: logical signature

     PHYSICAL_TICKET_SIG: physical signature

     LOGICAL_FROM_ID: logical sender

     LOGICAL_TO_ID: logical receiver

     MSG: the message text

     Creates a new packet object, this simply allocates memory and copy
     the string.  The string is duplicated, param msg can be freed.

     *Return value:* new object.

 -- Function: void lw6cnx_packet_free (lw6sys_context_t * SYS_CONTEXT,
          lw6cnx_packet_t * PACKET)
     SYS_CONTEXT: global system context

     PACKET: object to free

     Frees a packet object.

     *Return value:* none.

 -- Function: u_int32_t lw6cnx_packet_checksum (lw6sys_context_t *
          SYS_CONTEXT, const lw6cnx_packet_t * PACKET)
     SYS_CONTEXT: global system context

     PACKET: packet to analyse

     Calculates a checksum for a packet.

     *Return value:* 32-bit checksum.

 -- Function: int lw6cnx_packet_compare (lw6sys_context_t * SYS_CONTEXT,
          const lw6cnx_packet_t * A, const lw6cnx_packet_t * B)
     SYS_CONTEXT: global system context

     A: first packet to analyse

     B: second packet to analyse

     Compares two packets.  The comparison is made using checksums, the
     result is a strcmp-like integer, which is adapted to sorting.  The
     order has no real signification, it's mostly used to re-order
     packets in a pseudo-random order, to ensure no algorithm relies on
     packets arriving in the right order.

     *Return value:* -1 if a lower than b, 0 if a equals b, 1 if a is
     greater than b.

 -- Function: int lw6cnx_packet_sort_callback (lw6sys_context_t *
          SYS_CONTEXT, void * FUNC_DATA, const void * PTR_A, const void
          * PTR_B)
     SYS_CONTEXT: global system context

     FUNC_DATA: additionnal data, function specific

     PTR_A: first packet to analyse

     PTR_B: second packet to analyse

     Callback usable to sort packets, relies on 'lw6cnx_packet_compare'
     internally.

     *Return value:* -1 if ptr_a lower than ptr_b, 0 if ptr_a equals
     ptr_b, 1 if ptr_a is greater than ptr_b.

 -- Function: char * lw6cnx_password_checksum (lw6sys_context_t *
          SYS_CONTEXT, const char * SEED, const char * PASSWORD)
     SYS_CONTEXT: global system context

     SEED: a seed to blur the password, can be NULL

     PASSWORD: the password, can be NULL

     Calculates the checksum of a password, and returns it as a string,
     ready to be sent on the network.  If password is empty or NULL,
     then an empty (but not NULL unless internal error) string will be
     returned.  All LW6 protocols should send these checksums instead of
     real passwords, then on server side value can be checked against
     both real password and its checksum.  The seed is here so that
     eavesdropper can't reuse the checksum to connect on random
     sessions.  Seed can typically be the node 'public_url' value.

     *Return value:* a dynamically allocated string

 -- Function: int lw6cnx_password_verify (lw6sys_context_t *
          SYS_CONTEXT, const char * SEED, const char * PASSWORD_HERE,
          const char * PASSWORD_RECEIVED)
     SYS_CONTEXT: global system context

     SEED: a seed to blur the password, can be NULL

     PASSWORD_HERE: the local password, can be NULL

     PASSWORD_RECEIVED: the password received from network, can be NULL

     Tells wether a password received over the network is valid.  The
     'password_here' argument (the local password) will be checksumed so
     that 'password_received' is checked against both clear and
     checksumed values, so it can be in any form.

     *Return value:* 1 if OK, passwords are the same, 0 if not.

 -- Function: int lw6cnx_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libcnx module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6cnx_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'cnx' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: void lw6cnx_ticket_table_zero (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_ticket_table_t * TICKET_TABLE)
     SYS_CONTEXT: global system context

     TICKET_TABLE: the ticket table to fill with zero

     Fills the ticket table struct with 0s.

     *Return value:* none.

 -- Function: int lw6cnx_ticket_table_init (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_ticket_table_t * TICKET_TABLE, int
          HASH_SIZE)
     SYS_CONTEXT: global system context

     TICKET_TABLE: the ticket table to init

     HASH_SIZE: the hash size for both recv/send hashs

     Initialize a ticket table, that is, set it up with two empty hashs.
     Recv hash is filled automatically as it's queried for tickets, send
     hash must be filled explicitely with info from the network.

     *Return value:* none.

 -- Function: void lw6cnx_ticket_table_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_ticket_table_t * TICKET_TABLE)
     SYS_CONTEXT: global system context

     TICKET_TABLE: the ticket table to clear

     Clears the object (frees memory).

     *Return value:* none.

 -- Function: u_int64_t lw6cnx_ticket_table_get_recv (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_ticket_table_t * TICKET_TABLE, const char
          * PEER_ID)
     SYS_CONTEXT: global system context

     TICKET_TABLE: the ticket table to query

     PEER_ID: the id of remote node

     Gets the ticket used to communicate with peer, to check its
     incoming (recv) messages.  If ticket does not exist yet, it's
     automatically generated so tunction will always return a non-zero
     value.

     *Return value:* the ticket used to check incoming messages.

 -- Function: void lw6cnx_ticket_table_ack_recv (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_ticket_table_t * TICKET_TABLE, const char
          * PEER_ID, int ACK_DELAY_MSEC)
     SYS_CONTEXT: global system context

     TICKET_TABLE: the ticket table to query

     PEER_ID: the id of remote node

     ACK_DELAY_MSEC: delay before which we'll consider the ticket as
     really received

     Acknowledges the ticket used to communicate with peer, to check its
     incoming (recv) messages has been received.  This is to avoid
     sending it again when it has been received, as it's kept "forever"
     by peer, we never need to send it again.  The delay is here to
     avoid checking tickets too quickly, for instance one could have
     sent the ticket yet, but for some reason some unsigned messages are
     still in the pipe, typically they transit through another slow
     channel such as httpd while the ticket was sent on udp.

     *Return value:* none.

 -- Function: int lw6cnx_ticket_table_was_recv_exchanged
          (lw6sys_context_t * SYS_CONTEXT, lw6cnx_ticket_table_t *
          TICKET_TABLE, const char * PEER_ID)
     SYS_CONTEXT: global system context

     TICKET_TABLE: the ticket table to query

     PEER_ID: the id of remote node

     Acknowledges the ticket used to communicate with peer, to check its
     incoming (recv) messages has been received.  This is to avoid
     sending it again when it has been received, as it's kept "forever"
     by peer, we never need to send it again.

     *Return value:* the ticket used to check incoming messages.

 -- Function: u_int64_t lw6cnx_ticket_table_get_send (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_ticket_table_t * TICKET_TABLE, const char
          * PEER_ID)
     SYS_CONTEXT: global system context

     TICKET_TABLE: the ticket table to query

     PEER_ID: the id of remote node

     Gets the ticket used to communicate with peer, to stamp the
     outgoing messages.  If ticket does not exist yet, 0 is returned,
     indeed this value must be initialized with the value the peer gives
     us.

     *Return value:* the ticket used to stamp outgoing messages.

 -- Function: void lw6cnx_ticket_table_set_send (lw6sys_context_t *
          SYS_CONTEXT, lw6cnx_ticket_table_t * TICKET_TABLE, const char
          * PEER_ID, u_int64_t SEND_TICKET)
     SYS_CONTEXT: global system context

     TICKET_TABLE: the ticket table to query

     PEER_ID: the id of remote node

     SEND_TICKET: the ticket to use to stamp outgoing messages

     Sets the ticket used to communicate with peer, to stamp the
     outgoing (send) messages.  This value should be received from the
     network.  Note that once it's set, it's impossible to change it, it
     will remain the same for the whole duration of the node existence.

     *Return value:* NULL

 -- Struct: lw6cnx_connection_s

     This structure holds all data associated to a physical connexion
     with a remote peer.  This includes informations about the local
     node, informations about the peer, and protocol specific details.
     Depending on which backend is used to handle the connection, it
     will behave differently.  If you search for attributes such as
     socket id, search for them in backend_specific_data which is, in
     fact, handle by the backend code.

 -- Member of lw6cnx_connection_s: local_url
     *Type:* 'char *'

     *Definition:* 'char* lw6cnx_connection_s::local_url'

     URL of our local node.

 -- Member of lw6cnx_connection_s: remote_url
     *Type:* 'char *'

     *Definition:* 'char* lw6cnx_connection_s::remote_url'

     URL of the remote node.

 -- Member of lw6cnx_connection_s: remote_ip
     *Type:* 'char *'

     *Definition:* 'char* lw6cnx_connection_s::remote_ip'

     IP address of the remote node.

 -- Member of lw6cnx_connection_s: remote_port
     *Type:* 'int'

     *Definition:* 'int lw6cnx_connection_s::remote_port'

     IP port of the remote node.

 -- Member of lw6cnx_connection_s: password
     *Type:* 'char *'

     *Definition:* 'char* lw6cnx_connection_s::password'

     Password as clear text.

 -- Member of lw6cnx_connection_s: password_send_checksum
     *Type:* 'char *'

     *Definition:* 'char* lw6cnx_connection_s::password_send_checksum'

     Password as a checksum, what will be sent on the network.

 -- Member of lw6cnx_connection_s: local_id_int
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6cnx_connection_s::local_id_int'

     ID of the local node, as an unsigned 64-bit integer.

 -- Member of lw6cnx_connection_s: local_id_str
     *Type:* 'char *'

     *Definition:* 'char* lw6cnx_connection_s::local_id_str'

     ID of the local node, as an hexa string.

 -- Member of lw6cnx_connection_s: remote_id_int
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6cnx_connection_s::remote_id_int'

     ID of the remote node, as an unsigned 64-bit integer.

 -- Member of lw6cnx_connection_s: remote_id_str
     *Type:* 'char *'

     *Definition:* 'char* lw6cnx_connection_s::remote_id_str'

     ID of the local node, as an hexa string.

 -- Member of lw6cnx_connection_s: dns_ok
     *Type:* 'int'

     *Definition:* 'int lw6cnx_connection_s::dns_ok'

     Will be set to 1 if the peer domain name is the same as the one
     reported in the URL. For instance, if we get a connection from
     23.45.23.45, but this host claims to be on www.foo.bar and DNS
     reports www.foo.bar as being 111.222.111.222 then there's something
     strange.  It could just be someone doing NAT, but in all cases it's
     worth mentionning, so we keep the information here.  Having 0 here
     is a bad point for the connection.

 -- Member of lw6cnx_connection_s: network_reliability
     *Type:* 'int'

     *Definition:* 'int lw6cnx_connection_s::network_reliability'

     The higher, the most reliable message sending will be.  It can
     never be perfect, LW6 will always drop some packets from time to
     time, just to simulate real packet loss and be sure if it happens,
     it's handled nicely.

 -- Member of lw6cnx_connection_s: properties
     *Type:* 'lw6cnx_properties_t'

     *Definition:* 'lw6cnx_properties_t lw6cnx_connection_s::properties'

     Properties got from the backend.

 -- Member of lw6cnx_connection_s: recv_list
     *Type:* 'lw6sys_list_r_t *'

     *Definition:* 'lw6sys_list_r_t* lw6cnx_connection_s::recv_list'

     List of messages received.  This is a list_r and not a plain list
     because it can typically be filled and consumed in different
     threads.

 -- Member of lw6cnx_connection_s: send_mutex
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6cnx_connection_s::send_mutex'

     Send mutex, this will be used so that sending operations are
     properly serialized.  Indeed, threads that respond on the fly could
     be likely to call this concurrently.

 -- Member of lw6cnx_connection_s: foo_bar_key
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6cnx_connection_s::foo_bar_key'

     This is used to handle keepalive.  Actually, the protocol is that
     from time to time FOO key is sent and then each connection (in a
     tentacle object, typically) is supposed to respond BAR key to show
     it has received the latest message.  This field just stores the
     value so that when we receive a BAR message we know which key to
     check against.

 -- Member of lw6cnx_connection_s: last_send_foo_timestamp
     *Type:* 'int64_t'

     *Definition:* 'int64_t
     lw6cnx_connection_s::last_send_foo_timestamp'

     The last time FOO was sent.

 -- Member of lw6cnx_connection_s: next_send_foo_timestamp
     *Type:* 'int64_t'

     *Definition:* 'int64_t
     lw6cnx_connection_s::next_send_foo_timestamp'

     The next time FOO needs to be sent.

 -- Member of lw6cnx_connection_s: ping_msec
     *Type:* 'int'

     *Definition:* 'int lw6cnx_connection_s::ping_msec'

     The current ping, updated when receiving BAR message.

 -- Member of lw6cnx_connection_s: sent_nb_total
     *Type:* 'int'

     *Definition:* 'int lw6cnx_connection_s::sent_nb_total'

     Number of sent messages on this cnx.

 -- Member of lw6cnx_connection_s: sent_nb_success
     *Type:* 'int'

     *Definition:* 'int lw6cnx_connection_s::sent_nb_success'

     Number of successfully sent messages on this cnx.

 -- Member of lw6cnx_connection_s: sent_nb_fail
     *Type:* 'int'

     *Definition:* 'int lw6cnx_connection_s::sent_nb_fail'

     Number of failed sent messages on this cnx.

 -- Member of lw6cnx_connection_s: last_recv_timestamp
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6cnx_connection_s::last_recv_timestamp'

     Last time something was received on this connection.

 -- Member of lw6cnx_connection_s: backend_specific_data
     *Type:* 'void *'

     *Definition:* 'void* lw6cnx_connection_s::backend_specific_data'

     Store backend data, this is when, for instance, a socket handle
     will be kept, or a library handle (CURL, to name it).  Common code
     does not know what's in there.

 -- Struct: lw6cnx_packet_s

     Used to hold a network message plus some metadata, such as who it
     is for, and who emitted the message.

 -- Member of lw6cnx_packet_s: logical_ticket_sig
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6cnx_packet_s::logical_ticket_sig'

     Logical signature for the packet.

 -- Member of lw6cnx_packet_s: physical_ticket_sig
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6cnx_packet_s::physical_ticket_sig'

     Physical signature for the packet.

 -- Member of lw6cnx_packet_s: logical_from_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6cnx_packet_s::logical_from_id'

     Logical sender.

 -- Member of lw6cnx_packet_s: logical_to_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6cnx_packet_s::logical_to_id'

     Logical receiver.

 -- Member of lw6cnx_packet_s: msg
     *Type:* 'char *'

     *Definition:* 'char* lw6cnx_packet_s::msg'

 -- Struct: lw6cnx_properties_s

     Used to hold generic client/server properties, set up by the
     backend, can then be queried by the caller.

 -- Member of lw6cnx_properties_s: hint_timeout
     *Type:* 'int'

     *Definition:* 'int lw6cnx_properties_s::hint_timeout'

     Gives an idea of what timeout one can expect with this backend,
     this is not necessarly the exact timeout but it gives an order of
     magnitude.  Unit is seconds.

 -- Member of lw6cnx_properties_s: ping_alter_base
     *Type:* 'int'

     *Definition:* 'int lw6cnx_properties_s::ping_alter_base'

     Modifies the ping returned by terrain experience, this is a way to
     help some kind of connections to be preferred over others.  Set it
     to N to add N milliseconds to the real ping.  Adding a few msecs,
     such as 1 or 5 will just give an advantage to a given connection
     while not giving really wrong results.  High values like 50 or 100
     seriously penalizes some kind of connections, which is whishable,
     think of the httpd way to send things for instance.

 -- Member of lw6cnx_properties_s: ping_alter_percent
     *Type:* 'int'

     *Definition:* 'int lw6cnx_properties_s::ping_alter_percent'

     Modifies the ping returned by terrain experience, this is a way to
     help some kind of connections to be preferred over others.  Set it
     to 100 for default value, means 100% of real ping delay, set it to
     50 to make the algorithm believe lag is twice lower (this means,
     connection twice faster) and set it to 1000 to make believe that
     everything is slow.  In practice only a slight alteration should be
     required, one should still favor really fast connections when it's
     proved in real life that they are faster!

 -- Member of lw6cnx_properties_s: reliable
     *Type:* 'int'

     *Definition:* 'int lw6cnx_properties_s::reliable'

     Wether this connexion is to be considered reliable or not.  Well,
     in LW6, all connexions are unrealiable since LW6 will drop packets
     on purpose to simulate problems, but however, some are well-known
     to be unreliable (UDP...) while others are OK.

 -- Member of lw6cnx_properties_s: backend_id
     *Type:* 'const char *'

     *Definition:* 'const char* lw6cnx_properties_s::backend_id'

     The backend id, beware, this is a static string, must not be freed,
     and depends on backend library to be here, if this one is unloaded,
     will point to nowhere.

 -- Struct: lw6cnx_ticket_table_s

     A common, shared table, to store all the tickets associated with
     various connections.  This needs to be in-memory and quite fast for
     it's called very often (at each message, in fact) to perform sanity
     checks and avoid fakes/cheaters.

 -- Member of lw6cnx_ticket_table_s: recv_spinlock
     *Type:* 'lw6sys_spinlock_t *'

     *Definition:* 'lw6sys_spinlock_t*
     lw6cnx_ticket_table_s::recv_spinlock'

     Lock for the recv_table hash.

 -- Member of lw6cnx_ticket_table_s: recv_ack_spinlock
     *Type:* 'lw6sys_spinlock_t *'

     *Definition:* 'lw6sys_spinlock_t*
     lw6cnx_ticket_table_s::recv_ack_spinlock'

     Lock for the recv_ack_table hash.

 -- Member of lw6cnx_ticket_table_s: send_spinlock
     *Type:* 'lw6sys_spinlock_t *'

     *Definition:* 'lw6sys_spinlock_t*
     lw6cnx_ticket_table_s::send_spinlock'

     Lock for the send_table hash.

 -- Member of lw6cnx_ticket_table_s: recv_table
     *Type:* 'lw6sys_hash_t *'

     *Definition:* 'lw6sys_hash_t* lw6cnx_ticket_table_s::recv_table'

     Hash table containing the tickets for recv operations.  This table
     is auto-generated, if one asks for a ticket for an unknown host,
     one is generated.  The key is the ID (64-bit integer) of the host,
     as an hexa string.

 -- Member of lw6cnx_ticket_table_s: recv_ack_table
     *Type:* 'lw6sys_hash_t *'

     *Definition:* 'lw6sys_hash_t*
     lw6cnx_ticket_table_s::recv_ack_table'

     Hash table containing wether the send ticket was received by a
     given host.  The data is just a NULL pointer, only if the key is
     present, we know we don't need to resend our key to the peer.  An
     easy way to know that the key was sent is if the peer was abled to
     produce a valid message/checksum.  The key is the ID (64-bit
     integer) of the host, as an hexa string.

 -- Member of lw6cnx_ticket_table_s: send_table
     *Type:* 'lw6sys_hash_t *'

     *Definition:* 'lw6sys_hash_t* lw6cnx_ticket_table_s::send_table'

     Hash table containing the tickets for send operations.  Those
     tickets are typically received from the peers themselves who
     generate them on the fly.  The key is the ID (64-bit integer) of
     the host, as an hexa string.

5.14 libdat
===========

5.14.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/dat/index.html>.

5.14.2 API
----------

 -- Function: lw6dat_miss_t * lw6dat_miss_new (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t FROM_ID, int SERIAL_MIN, int
          SERIAL_MAX)
     FROM_ID: who needs to resend the message

     SERIAL_MIN: serial range begin (included)

     SERIAL_MAX: serial range end (included)

     Creates a miss structure, simply allocates memory and pumps values
     into the right fields.

     *Return value:* new dynamically allocated object

 -- Function: void lw6dat_miss_free (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_miss_t * MISS)
     MISS: structure to free

     Frees a miss structure, simply unallocates memory.

     *Return value:* none.

 -- Function: void lw6dat_miss_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_miss_t * DST, lw6dat_miss_t * SRC)
     DST: target object

     SRC: source object

     Writes the contents of src to dst

     *Return value:* none.

 -- Function: int lw6dat_miss_is_same (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_miss_t * A, lw6dat_miss_t * B)
     A: first element to compare

     B: second element to compare

     Compares two miss objects, returning true if they are the same.

     *Return value:* 1 if same, else 0.

 -- Function: int lw6dat_miss_is_included (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_miss_t * A, lw6dat_miss_t * B)
     A: first element to compare

     B: second element to compare

     Compares two miss objects, returning true if a is included in b.

     *Return value:* 1 if included, else 0.

 -- Function: int lw6dat_miss_overlaps (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_miss_t * A, lw6dat_miss_t * B)
     A: first element to compare

     B: second element to compare

     Compares two miss objects, returning true if a overlaps with b.

     *Return value:* 1 if included, else 0.

 -- Function: int lw6dat_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libdat module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6dat_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'dat' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6dat_warehouse_init (lw6sys_context_t * SYS_CONTEXT,
          lw6dat_warehouse_t * WAREHOUSE, u_int64_t LOCAL_NODE_ID,
          int64_t SEQ_0)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to initialize

     LOCAL_NODE_ID: id of local node, used to handle local messages

     SEQ_0: initial seq number

     Initializes a warehouse object.  Won't free anything, will just
     erase values if they're here

     *Return value:* new object, allocated dynamically

 -- Function: lw6dat_warehouse_t * lw6dat_warehouse_new
          (lw6sys_context_t * SYS_CONTEXT, u_int64_t LOCAL_NODE_ID,
          int64_t SEQ_0)
     SYS_CONTEXT: global system context

     LOCAL_NODE_ID: id of local node, used to handle local messages

     SEQ_0: initial seq number

     Creates a new warehouse object.

     *Return value:* new object, allocated dynamically

 -- Function: void lw6dat_warehouse_free (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the object to free

     Frees a warehouse object.

     *Return value:* new object, allocated dynamically

 -- Function: void lw6dat_warehouse_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the object to clear

     Clears a warehouse object.  Clears means emptying everything and
     resetting the current seq_id to the minimal/start value.

     *Return value:* none.

 -- Function: void lw6dat_warehouse_purge (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the object to purge

     Purges a warehouse object.  Purges means emptying everything but
     keeping the current seq_id and the nodes list unchanged.

     *Return value:* none.

 -- Function: int lw6dat_warehouse_get_nb_nodes (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query.

     Tells how many nodes are registered in the object.

     *Return value:* integer, number of nodes

 -- Function: u_int64_t lw6dat_warehouse_get_local_id (lw6sys_context_t
          * SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query.

     Returns the local id.

     *Return value:* 64-bit id.

 -- Function: int lw6dat_warehouse_get_local_serial (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query.

     Returns the latest (highest) serial number given for local node.

     *Return value:* integer, latest serial number

 -- Function: int64_t lw6dat_warehouse_get_local_seq_0 (lw6sys_context_t
          * SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query

     Gives the warehouse seq_0 number, any seq below does not make
     sense.

     *Return value:* long integer.

 -- Function: void lw6dat_warehouse_set_local_seq_0 (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, int64_t SEQ_0)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to modify

     SEQ_0: the new seq value

     Set the warehouse seq_0 number, any seq below does not make sense.

     *Return value:* none.

 -- Function: int64_t lw6dat_warehouse_get_local_seq_last
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: the warehouse object to query

     Gives the warehouse seq_last number, this is the seq that
     corresponds to the last local message put in this warehouse.  This
     is usefull to get the last seq used and, for instance, put a NOP
     message just for keepalive purposes.

     *Return value:* long integer.

 -- Function: int lw6dat_warehouse_register_node (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          NODE_ID, int SERIAL_0, int64_t SEQ_0)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to update

     NODE_ID: id of node to register

     SERIAL_0: serial number of first message

     SEQ_0: initial seq number

     Registers a node, in practice this is automatically done when
     receiving a data message but it might be interesting to do it
     elsewhere and force it.

     *Return value:* the stack index of the registered node, <0 is
     invalid.

 -- Function: int lw6dat_warehouse_is_node_registered (lw6sys_context_t
          * SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to update

     NODE_ID: id of node to register

     Tells wether a node is registered or not in our list.

     *Return value:* 1 if registered, 0 if not.

 -- Function: int lw6dat_warehouse_put_atom_str (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          LOGICAL_FROM, const char * FULL_STR)
     SYS_CONTEXT: global system context

     WAREHOUSE: warehouse object to use

     LOGICAL_FROM: from who the message came from originally

     FULL_STR: message of the form serial i n seq from cmd

     Puts an atomic string in the object, this kind of string is
     typically received on the network.

     *Return value:* 1 on success, 0 on error

 -- Function: int lw6dat_warehouse_calc_serial_draft_and_reference
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to work on

     The various 'get_seq' functions can perform slowly if we don't
     pre-calculate the serial number of draft and reference atoms.  So
     this calculation is not within the functions themselves but can be
     cached by using this function.  Just call it and after you might
     query the object for reference and draft info.

     *Return value:* 1 if some valid informations were found, else 0,
     which means no interesting (complete) atoms where found, and
     there's probably nothing to do yet.

 -- Function: int lw6dat_warehouse_put_local_msg (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, const char * MSG)
     SYS_CONTEXT: global system context

     WAREHOUSE: warehouse object to use

     MSG: message

     Puts a message in the object.  The message will be splitted into
     several atoms if needed, it can be arbitrary long.

     *Return value:* 1 on success, 0 on error

 -- Function: int64_t lw6dat_warehouse_get_seq_min (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     Tells the lowest seq referenced in the warehouse.  Does not mean
     this is the lowest ever received, only we really have no chances of
     going below that point, nothing is stored, either complete or
     partial, below that.

     *Return value:* integer.

 -- Function: int64_t lw6dat_warehouse_get_seq_max (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     Tells the highest seq referenced in the warehouse.  Does not mean
     an actual message can be built from it, only we've got some traces
     of such a high seq.

     *Return value:* integer.

 -- Function: int64_t lw6dat_warehouse_get_seq_draft (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     Tells the highest seq that can be considered as a valid draft.
     This is not exactly the maximimum seq encountered, for here we want
     at least one complete message and not just one chunk of data (an
     atom) referring to a high seq, we want the complete stuff.  However
     there can be missing messages in between.

     *Return value:* integer.

 -- Function: int64_t lw6dat_warehouse_get_seq_reference
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     Tells the highest seq that can be considered as a reference.  Being
     considered as a reference means we received all messages for this
     seq *and* at least one message from the following seq, and this for
     every node involved.  This being said, we're sure to have the right
     information, nothing is missing.

     *Return value:* integer.

 -- Function: lw6sys_list_t * lw6dat_warehouse_get_msg_list_by_seq
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE, int64_t SEQ_MIN, int64_t SEQ_MAX, int
          FOR_REFERENCE, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     SEQ_MIN: lowest sequence number (round or chat index)

     SEQ_MAX: highest sequence number (round or chat index)

     FOR_REFERENCE: set to 1 if this is for reference building else 0
     for draft

     PROGRESS: progress indicator (read/write).

     Gets the list of messages for a given sequence (round or chat
     index), polling all the nodes.  The from and to boundaries are
     included.

     *Return value:* a list of strings.

 -- Function: lw6sys_list_t *
          lw6dat_warehouse_get_atom_str_list_not_sent (lw6sys_context_t
          * SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          LOGICAL_TO)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     LOGICAL_TO: the id of the node that we want to send data to

     Returns all the messages that were not sent for the given
     warehouse.

     *Return value:* a list of strings, containing atoms.

 -- Function: lw6sys_list_t * lw6dat_warehouse_get_miss_list
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE, int MAX_RANGE, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to query

     MAX_RANGE: max range of the returned list (-1 if none)

     PROGRESS: progress indicator, to show advancement to end-user

     Returns a list of 'lw6dat_miss_t' objects which contains
     informations about the messages which need to be re-sent by peers.
     The function will always return something, the list is not cleared
     if it's called several times, so one should not poll this too
     often.  Additionnally, the max_range parameter can be used to limit
     the size of the returned ranges, to avoid querying for too many
     messages at once.

     *Return value:* a list of pointers to 'lw6dat_miss_t' structs, NULL
     on failure.

 -- Function: void lw6dat_warehouse_miss_invalidate (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, u_int64_t
          FROM_ID, u_int64_t TO_ID, int SERIAL_MIN, int SERIAL_MAX)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to modify

     FROM_ID: node which needs to resend data

     TO_ID: node which needs to get the data

     SERIAL_MIN: minimum serial number to send

     SERIAL_MAX: maximum serial number to send

     Re-sends messages in a given serial range.  Actually, does not
     really resend messages, but marks them as needing to be sent again.
     We might, or not, have those messages in stock, if we have them we
     send them, if not we just do nothing, someone else might have them.

     *Return value:* none

 -- Function: void lw6dat_warehouse_update_serial_miss_max
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE, u_int64_t REMOTE_ID, int SERIAL)
     SYS_CONTEXT: global system context

     WAREHOUSE: object to update

     REMOTE_ID: id of remote host to update (which stack)

     SERIAL: new max serial value

     *Return value:* none

 -- Function: void lw6dat_warehouse_reset_nb_atom_parts_since_last_poll
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE)
     SYS_CONTEXT: global system context

     WAREHOUSE: data warehouse to reset

     Resets the nb_atom_parts_since_last_poll attribute of every stack.

     *Return value:* none

 -- Function: int lw6dat_warehouse_get_nb_atom_parts_since_last_poll
          (lw6sys_context_t * SYS_CONTEXT, lw6dat_warehouse_t *
          WAREHOUSE, u_int64_t REMOTE_ID)
     SYS_CONTEXT: global system context

     WAREHOUSE: data warehouse to get info from

     REMOTE_ID: remote id to get info about

     Returns the nb_atom_parts_since_last_poll attribute of the stack
     concerning the remote_id.  The idea is to track down, since the
     last call to the companion reset function, how many "atom parts"
     have been received, by "atom part" we mean atoms representing a
     splitted message.  Usually this corresponds to very long messages
     and if this number of splitted messages is large enough, we don't
     send MISS commands, as it would overload the network for nothing.

     *Return value:* number of atom parts received since last reset.

 -- Function: int lw6dat_warehouse_meta_put (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE, int64_t SEQ)
     SYS_CONTEXT: global system context

     WAREHOUSE: data warehouse to put message into

     SEQ: seq to use to stamp the message

     Puts a META message in the warehouse.  The META message purpose is
     to tell other warehouses (on other nodes, peers) that the list of
     peers is updated.  This typically happens when a node joins in.

     *Return value:* 1 on success, 0 if failed.

 -- Function: int lw6dat_warehouse_meta_get (lw6sys_context_t *
          SYS_CONTEXT, lw6dat_warehouse_t * WAREHOUSE,
          lw6msg_meta_array_t * META_ARRAY, int64_t SEQ)
     SYS_CONTEXT: global system context

     WAREHOUSE: data warehouse to put message into

     META_ARRAY: current informations sendable by a meta message

     SEQ: seq to use to stamp the message

     Gets the data required for a META message.  Note that this function
     can be called in other contexts to know who is registered within
     the warehouse, which, as an opaque type, doesn't export that info
     otherwise.

     *Return value:* 1 on success, 0 if failed.

 -- Struct: lw6dat_miss_s

     Used to get informations about "what messages are missing", The
     struct typically contains informations to send a MISS message on
     the network, that is, who needs to resend the information, and the
     message serial range.  The informations "who needs it" need not be
     stored as this is logically our local node.

 -- Member of lw6dat_miss_s: from_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6dat_miss_s::from_id'

     Id of node which needs to resend the information.

 -- Member of lw6dat_miss_s: serial_min
     *Type:* 'int'

     *Definition:* 'int lw6dat_miss_s::serial_min'

     Minimum serial, included in the range.

 -- Member of lw6dat_miss_s: serial_max
     *Type:* 'int'

     *Definition:* 'int lw6dat_miss_s::serial_max'

     Maximum serial, included in the range.

 -- Struct: lw6dat_warehouse_s

     Contains all recent messages sent to peers, and received from them,
     int fact this is a local database, think of it as a giant array,
     containing all messages.  This is usefull both resend messages if
     one peer wants one and also to check wether informations are
     consistent and nobody is cheating.  This structure is hiddent,
     casted to the real stuff internally if needed, so that other parts
     of the code don't rely on specific implementation.

 -- Member of lw6dat_warehouse_s: dummy
     *Type:* 'int'

     *Definition:* 'int lw6dat_warehouse_s::dummy'

     Dummy field, unused.

5.15 libdef
===========

5.15.1 Overview
---------------

5.15.2 API
----------

There are no functions in 'libdef', only a header file with constants.

5.16 libdsp
===========

5.16.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/dsp/index.html>.

5.16.2 API
----------

 -- Function: lw6dsp_backend_t * lw6dsp_create_backend (lw6sys_context_t
          * SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          GFX_BACKEND_NAME)
     SYS_CONTEXT: global system context

     ARGC: argc as passed to 'main'

     ARGV: argv as passed to 'main'

     GFX_BACKEND_NAME: the id/name of the gfx backend to use

     Creates a dsp_backend object.  The created object won't be
     displaying things until 'lw6dsp_init' is called.  No thread is
     created, but the graphics backend is loaded into memory.  If video
     mode is not available, it will appear later, when trying to start
     displaying things, this function only allocates memory and checks
     code is available in case of a dynamically loaded gfx backend.

     *Return value:* a newly allocated object.

 -- Function: void lw6dsp_destroy_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend object to free

     Frees all ressources used by a dsp_backend object.  Note that you
     must call this on a inactive 'stopped' dsp_backend object.

     *Return value:* none.

 -- Function: char * lw6dsp_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the object to represent

     Gives a short human-readable description of the object.

     *Return value:* a newly allocated string, must be freed.

 -- Function: int lw6dsp_init (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND, const lw6dsp_param_t * PARAM,
          lw6gui_resize_callback_func_t RESIZE_CALLBACK)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to start

     PARAM: parameters to pass to the display funcs

     RESIZE_CALLBACK: a function which will be called when there's a
     resize event

     Starts a dsp_backend object, that is, fire a separate thread and
     start rendering.  This will set up a video mode, so it's very
     likely to fail if for some reason the video context isn't right,
     for instance if you try to set up graphical stuff but only have
     console access.

     *Return value:* 1 if success, 0 if error.

 -- Function: void lw6dsp_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to stop

     Stops a dsp_backend, that is, cancel rendering and unset the video
     mode, hardware shouldn't be used any more after this call.

     *Return value:* none.

 -- Function: int lw6dsp_update (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND, const lw6dsp_param_t * PARAM)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to update

     PARAM: parameters to pass to the dsp_backend funcs

     Passes a new set of parameters to the display function.  This is in
     fact the only way to pass informations to the dsp_backend object
     once it's been started.  This function will acquire a mutex, copy
     parameters, then give control back to the main thread while display
     keeps on going with new parameters in the background.  It will get
     input informations.  You really must call it often otherwise the
     screen won't get updated, or, at least, it will always display the
     same informations.  It should be reasonnable to call this 10 or 20
     times per second, the display itself can be faster, run at 60 or
     100 fps to show smooth animation (eye candy).

     *Return value:* 1 if success, 0 if error.

 -- Function: int lw6dsp_get_nb_frames (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     Returns the number of frames displayed since the display was
     started.

     *Return value:* the number of frames displayed.

 -- Function: int lw6dsp_get_last_frame_rendering_time (lw6sys_context_t
          * SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND: the dsp_backend to query

     Returns the rendering time of the last frame.  Gives clues about
     performance.

     *Return value:* the number of milliseconds it took to draw screen

 -- Function: int lw6dsp_get_instant_fps (lw6sys_context_t *
          SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     Returns the current frames per sec display rate.  This is the
     instant value, it changes very often even if display seems smooth.

     *Return value:* the current instant display rate.

 -- Function: int lw6dsp_get_average_fps (lw6sys_context_t *
          SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     Returns the current frames per sec display rate.  This is not
     absolutely accurate but fits for displaying info to the player,
     it's an average.

     *Return value:* the current averaged display rate.

 -- Function: int lw6dsp_get_video_mode (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_backend_t * DSP_BACKEND, lw6gui_video_mode_t *
          VIDEO_MODE)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     VIDEO_MODE: a structure which will contain the results

     Returns the current video mode, the one obtained by the driver.
     This function is also a way to know wether display is running
     correcly or not, by testing its return value.

     *Return value:* 1 if ok, 0 if failure (mode not set)

 -- Function: int lw6dsp_get_fullscreen_modes (lw6sys_context_t *
          SYS_CONTEXT, lw6dsp_backend_t * DSP_BACKEND,
          lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     SYS_CONTEXT: global system context

     DSP_BACKEND: the dsp_backend to query

     FULLSCREEN_MODES: a structure which will contain the results

     Returns the current available fullscreen modes.  Note that this one
     will only work if display is started, unlike
     'lw6gfx_get_fullscreen_modes' which is used internally.  The reason
     is that in this dsp module context, we need the thread to be
     launched, and the thread does start/stop display on its own.

     *Return value:* 1 if ok, 0 if failure (mode not set)

 -- Function: void lw6dsp_param_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6dsp_param_t * PARAM)
     SYS_CONTEXT: global system context

     PARAM: the structure to initialize

     Fills a display param struct with zeros, this is mandatory before
     any use.  Think of it as a raw memset.

     *Return value:* none.

 -- Function: int lw6dsp_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libdsp module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6dsp_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'dsp' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6dsp_backend_s

     The dsp backend is the first argument passed to any dsp function,
     it contains reference to all the functions which can be used as
     well as a pointer on associated data.  In OO, this would just be an
     object, with members and methods, using polymorphism through opaque
     pointers.

 -- Member of lw6dsp_backend_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6dsp_backend_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6dsp_backend_s: thread
     *Type:* 'lw6sys_thread_handler_t *'

     *Definition:* 'lw6sys_thread_handler_t* lw6dsp_backend_s::thread'

     Thread running the display code.  In fact running in a separate
     thread is the whole point of this display object.

 -- Member of lw6dsp_backend_s: data
     *Type:* 'void *'

     *Definition:* 'void* lw6dsp_backend_s::data'

     Data used by the display code.  This is an opaque pointer, the
     internal structure will store details such as mutexes, parameters,
     information about the graphics backend, and so on.

 -- Member of lw6dsp_backend_s: input
     *Type:* 'lw6gui_input_t *'

     *Definition:* 'lw6gui_input_t* lw6dsp_backend_s::input'

     Input structure, will be updated by the display thread, so that it
     contains up-to-date information.  This is actually the only way to
     get input from the user.

 -- Struct: lw6dsp_misc_s

     Miscellaneous parameters for display.  One of the idea with this
     structure is that one must be able to compare two of them with a
     simple memcmp.  Even the progress pointer can be compared this way,
     the rest is just plain data.

 -- Member of lw6dsp_misc_s: mask
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::mask'

     Display mask, define what must be displayed.

 -- Member of lw6dsp_misc_s: target_fps
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::target_fps'

     How many frames per second the engine needs to display.

 -- Member of lw6dsp_misc_s: gfx_cpu_usage
     *Type:* 'float'

     *Definition:* 'float lw6dsp_misc_s::gfx_cpu_usage'

     How much CPU need be used, the maximum is 1.0f, the idea behind
     this parameter is that if you set it to a low value, the display
     thread will yield timeslices letting other threads speed up.  On a
     single-core CPU this can be usefull if the main calculation thread,
     the one that updates the game state, is falling behind.

 -- Member of lw6dsp_misc_s: dirty_read
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::dirty_read'

     Dirty read mode.

 -- Member of lw6dsp_misc_s: capture
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::capture'

     Wether we want to capture screen and dump it on disk.

 -- Member of lw6dsp_misc_s: gfx_debug
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::gfx_debug'

     Wether to enable GFX debug mode.

 -- Member of lw6dsp_misc_s: debug_team_id
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::debug_team_id'

     Parameter for debug mode, team ID to show info about.

 -- Member of lw6dsp_misc_s: debug_layer_id
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::debug_layer_id'

     Parameter for debug mode, layer ID to show info about.

 -- Member of lw6dsp_misc_s: repeat_settings
     *Type:* 'lw6gui_repeat_settings_t'

     *Definition:* 'lw6gui_repeat_settings_t
     lw6dsp_misc_s::repeat_settings'

     Repeat settings, used by the input module.

 -- Member of lw6dsp_misc_s: log_timeout
     *Type:* 'int'

     *Definition:* 'int lw6dsp_misc_s::log_timeout'

     Delay after which messages disappear, in milliseconds.

 -- Member of lw6dsp_misc_s: progress
     *Type:* 'float *'

     *Definition:* 'volatile float* lw6dsp_misc_s::progress'

     Pointer on progress float, provides feedback to user.

 -- Struct: lw6dsp_param_s

     Parameters used by the display thread.  Be carefull, those need be
     modify with adequate functions, else a (serious) race condition
     could occur.

 -- Member of lw6dsp_param_s: misc
     *Type:* 'lw6dsp_misc_t'

     *Definition:* 'lw6dsp_misc_t lw6dsp_param_s::misc'

     Miscellaneous parameters, things that didn't fit elsewhere.

 -- Member of lw6dsp_param_s: video_mode
     *Type:* 'lw6gui_video_mode_t'

     *Definition:* 'lw6gui_video_mode_t lw6dsp_param_s::video_mode'

     Video mode.  This is separated from the misc parameters for it
     requires special handling, indeed changing resolution might need
     calls to special functions to set up a new graphical context.

 -- Member of lw6dsp_param_s: look
     *Type:* 'lw6gui_look_t *'

     *Definition:* 'lw6gui_look_t* lw6dsp_param_s::look'

     Visual parameters.

 -- Member of lw6dsp_param_s: menu
     *Type:* 'lw6gui_menu_t *'

     *Definition:* 'lw6gui_menu_t* lw6dsp_param_s::menu'

     Menu object, the main interface to gather and transmit informations
     to the user, when not playing.

 -- Member of lw6dsp_param_s: level
     *Type:* 'lw6map_level_t *'

     *Definition:* 'lw6map_level_t* lw6dsp_param_s::level'

     The level, as loaded from disk.

 -- Member of lw6dsp_param_s: game_struct
     *Type:* 'lw6ker_game_struct_t *'

     *Definition:* 'lw6ker_game_struct_t* lw6dsp_param_s::game_struct'

     The game struct, that is the level post-processed to be usable by
     game algorithms.

 -- Member of lw6dsp_param_s: game_state
     *Type:* 'lw6ker_game_state_t *'

     *Definition:* 'lw6ker_game_state_t* lw6dsp_param_s::game_state'

     Changeable state of the game.  Not that this pointer must really
     always be available, you can technically change its value but any
     value passed to it must be available and valid as long as the
     display is running, else you end up with a good old segfault.

 -- Member of lw6dsp_param_s: pilot
     *Type:* 'lw6pil_pilot_t *'

     *Definition:* 'lw6pil_pilot_t* lw6dsp_param_s::pilot'

     If in dirty-read mode, then game_state will be fetched from this
     object.  It can be NULL if you don't want to use the pilot.

5.17 libdyn
===========

5.17.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/dyn/index.html>.

5.17.2 API
----------

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend_so
          (lw6sys_context_t * SYS_CONTEXT, const char * SO_FILE)
     SYS_CONTEXT: global system context

     Opens a .so file directly, using a valid (full) path name.

     *Return value:* a handle to the module, once it's opened.  You
     might still need to call a module specific 'init' function, but
     it's another story.

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_shared_so
          (lw6sys_context_t * SYS_CONTEXT, const char * SO_FILE)
     SYS_CONTEXT: global system context

     Opens a .so file directly, using a valid (full) path name.

     *Return value:* a handle to the shared code, once it's opened.  You
     might still need to call a module specific 'init' function, but
     it's another story.

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend
          (lw6sys_context_t * SYS_CONTEXT, int ARGC, const char * []
          ARGV, const char * TOP_LEVEL_LIB, const char * BACKEND_NAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line arguments as passed to 'main'

     TOP_LEVEL_LIB: the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv".  This will tell the function to
     search for the .so file in the correct subdirectory.  Think of this
     as a category.

     Opens a .so file corresponding to the given backend, it is capable
     to search for system libraries installed after "make install" but
     if not found, it will also search in the current build directory,
     finding the .so files in hidden .libs subdirectories.

     *Return value:* a handle to the module, once it's opened.  You
     might still need to call a module specific 'init' function, but
     it's another story.

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_shared
          (lw6sys_context_t * SYS_CONTEXT, int ARGC, const char * []
          ARGV, const char * TOP_LEVEL_LIB, const char * SHARED_NAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line arguments as passed to 'main'

     TOP_LEVEL_LIB: the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv".  This will tell the function to
     search for the .so file in the correct subdirectory.  Think of this
     as a category.

     Opens a .so file corresponding to the given shared code, it is
     capable to search for system libraries installed after "make
     install" but if not found, it will also search in the current build
     directory, finding the .so files in hidden .libs subdirectories.

     *Return value:* a handle to the shared code, once it's opened.
     This is different from a real module, there's no real prototype, it
     just loads code.

 -- Function: int lw6dyn_dlclose_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6dyn_dl_handle_t * HANDLE)
     SYS_CONTEXT: global system context

     HANDLE: the backend to close.

     Closes an opened backend.  Note that you must call any backend
     specific clear, destroy, deinit, exit, function before.

     *Return value:* 1 if success, 0 on error.

 -- Function: int lw6dyn_dlclose_shared (lw6sys_context_t * SYS_CONTEXT,
          lw6dyn_dl_handle_t * HANDLE)
     SYS_CONTEXT: global system context

     HANDLE: the shared code library to close.

     Closes an opened shared code library.  Note that you must call any
     shared code library specific clear, destroy, deinit, exit, function
     before.

     *Return value:* 1 if success, 0 on error.

 -- Function: void * lw6dyn_dlsym (lw6sys_context_t * SYS_CONTEXT,
          lw6dyn_dl_handle_t * HANDLE, const char * FUNC_NAME)
     SYS_CONTEXT: global system context

     HANDLE: the backend concerned

     FUNC_NAME: the function name, as a NULL terminated string

     Finds a C function in the given backend.

     *Return value:* a pointer to the function, NULL if not found.

 -- Function: lw6sys_assoc_t * lw6dyn_list_backends (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          TOP_LEVEL_LIB)
     SYS_CONTEXT: global system context

     ARGC: the number of command line args, as passed to main

     ARGV: the commind line args, as passed to main

     TOP_LEVEL_LIB: the library category to query (gfx, snd, cli, srv
     ...)

     Returns an assoc which lists all the available modules.  The key of
     the assoc entries in the module internal name such as 'gl' and the
     value associated is a NULL terminated string describing the module,
     for instance 'OpenGL'.

     *Return value:* an assoc object containing key/label pairs.

 -- Function: char * lw6dyn_path_find_backend (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          TOP_LEVEL_LIB, const char * BACKEND_NAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line arguments as passed to 'main'

     TOP_LEVEL_LIB: the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv".  This will tell the function to
     search for the .so file in the correct subdirectory.  Think of this
     as a category.

     BACKEND_NAME: the actual name of the backend, this is the name of
     the .so file, between "libmod_" and ".so".  For instance, to find
     "libmod_gl.so", the right argument is "gl1".

     Get the full path to a .so file corresponding to the given backend,
     it is capable to search for system libraries installed after "make
     install" but if not found, it will also search in the current build
     directory, finding the .so files in hidden .libs subdirectories.

     *Return value:* the full path of the .so file, needs to be freed.

 -- Function: char * lw6dyn_path_find_shared (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          TOP_LEVEL_LIB, const char * SHARED_NAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line arguments as passed to 'main'

     TOP_LEVEL_LIB: the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv".  This will tell the function to
     search for the .so file in the correct subdirectory.  Think of this
     as a category.

     SHARED_NAME: the actual name of the shared code, this is the name
     of the .so file, between "libshared_" and ".so".  For instance, to
     find "libshared_sdl.so", the right argument is "sdl".

     Get the full path to a .so file corresponding to the given shared
     code entry, it is capable to search for system libraries installed
     after "make install" but if not found, it will also search in the
     current build directory, finding the .so files in hidden .libs
     subdirectories.  This is different from the standard module loader,
     since it will search for .so files with a slightly different name.
     The idea is to distinguish modules that are truely loadable and
     shared code that can't be used standalone and can't either be
     stuffed in the main binary since it refers to external dynamic
     library which will only be loaded at runtime.

     *Return value:* the full path of the .so file, needs to be freed.

 -- Function: int lw6dyn_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libdyn module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6dyn_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'dyn' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6dyn_dl_handle_s

     Handle on dynamic library.  Well, actually, ltdl does already
     provide something like, so why use our own wrapper?  It happens
     storing the library path, that's to say what .so files it comes
     from, is usefull for debugging, so this structure bundles those two
     informations together.

 -- Member of lw6dyn_dl_handle_s: handle
     *Type:* 'lt_dlhandle'

     *Definition:* 'lt_dlhandle lw6dyn_dl_handle_s::handle'

     Libtool handler.

 -- Member of lw6dyn_dl_handle_s: library_path
     *Type:* 'char *'

     *Definition:* 'char* lw6dyn_dl_handle_s::library_path'

     Path to .so file containing the code, or whatever file is relevant
     on the current platform, the idea is to keep track of where the
     library comes from.

 -- Member of lw6dyn_dl_handle_s: is_backend
     *Type:* 'int'

     *Definition:* 'int lw6dyn_dl_handle_s::is_backend'

     True (1) if the handle is a backend or false (0) if it's just some
     shared code.

 -- Member of lw6dyn_dl_handle_s: is_dlclose_safe
     *Type:* 'int'

     *Definition:* 'int lw6dyn_dl_handle_s::is_dlclose_safe'

     True (1) if one can safely call dlclose on this backend.  Set to
     false (0) if low level dlclose must be skipped.  For some reason,
     some (external) libraries really do not behave well when unloaded
     on the fly, even if we stop threads using them and don't use them
     anymore.  The workarround is to have this flag defined, to skip the
     internal close to dlclose.  LW will still free the memory, but
     won't call libtool dlclose for real.  Libtool keeps track of this
     internally and won't reload it on next call, maintain reference
     counts etc.  so there's no real harm.  Except it just looks ugly
     not to be able to truely unload the module.

5.18 libgen
===========

5.18.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gen/index.html>.

5.18.2 API
----------

 -- Function: lw6map_level_t * lw6gen_create_from_seed (lw6sys_context_t
          * SYS_CONTEXT, const char * SEED, int MAP_W, int MAP_H)
     SYS_CONTEXT: global system context

     SEED: a random seed used to generate the map

     MAP_W: width of the screen, in pixels

     MAP_H: height of the screen, in pixels

     Builds a complete, usable map from the string passed in seed.  Each
     triplet composed of seed/map_w/map_h should build the same map on
     any computer, in any context, for a given version of the game (no
     backwards compatibility).

     *Return value:* new map on success, NULL on failure.

 -- Function: char * lw6gen_seed_new (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Generate a new random seed.  The seed is composed of letters and
     numbers.

     *Return value:* newly allocated string.

 -- Function: char * lw6gen_seed_normalize (lw6sys_context_t *
          SYS_CONTEXT, const char * SEED)
     SYS_CONTEXT: global system context

     SEED: the seed to normalize

     Builds a normalized seed from an arbitrary string.  The idea is to
     avoid sending strange stuff on the network and/or storing strange
     stuff in config files, so we process correct strings only

     *Return value:* newly allocated string.

 -- Function: char lw6gen_seed_char (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns a random char suitable for seed (letter or digit).

     *Return value:* a single char

 -- Function: int lw6gen_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libgen module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6gen_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'gen' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

5.19 libgfx
===========

5.19.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/index.html>.

5.19.2 API
----------

 -- Function: int lw6gfx_init (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND, lw6gui_video_mode_t * VIDEO_MODE,
          lw6gui_resize_callback_func_t RESIZE_CALLBACK)
     SYS_CONTEXT: global system context

     BACKEND: the graphical backend to use

     VIDEO_MODE: the video mode to use at start up

     RESIZE_CALLBACK: a callback function which will be called at each
     resize event

     Sets up the graphical backend for good, initializing a video mode
     and allocating ressources.  This call can typically fail if there's
     no device available, if the user doesn't have enough rights to
     access the hardware, and so on.

     *Return value:* 1 on success, 0 if not

 -- Function: void lw6gfx_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: the backend to quit

     Uninitializes the backend, that is, exits the graphical mode.  All
     threads that use graphics must be closed when this is called.

     *Return value:* none.

 -- Function: char * lw6gfx_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6gfx_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: the backend to represent

     Returns a readable version of the backend object.

     *Return value:* a newly allocated pointer.

 -- Function: int lw6gfx_set_video_mode (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND, lw6gui_video_mode_t * VIDEO_MODE)
     SYS_CONTEXT: global system context

     BACKEND: the backend to use

     VIDEO_MODE: the new video mode

     This function changes the video mode.  Note that the first time you
     set up the graphical environment you must call 'lw6gfx_init' but to
     change the current mode, use this function.  It should reload
     backend data automatically if needed (textures for instance).  Note
     that before giving up and failing this function will try alternate
     video modes, and you're not garanteed to have the right mode after
     the call, even if it returns true.  To check this, use
     'lw6gfx_get_video_mode'.

     *Return value:* 1 on success, 0 on failure;

 -- Function: int lw6gfx_get_video_mode (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND, lw6gui_video_mode_t * VIDEO_MODE)
     SYS_CONTEXT: global system context

     BACKEND: the backend to use

     VIDEO_MODE: the current video mode (will be overwritten, out
     parameter)

     This function returns the current video mode.

     *Return value:* 1 on success, 0 on failure;

 -- Function: int lw6gfx_get_fullscreen_modes (lw6sys_context_t *
          SYS_CONTEXT, lw6gfx_backend_t * BACKEND,
          lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     SYS_CONTEXT: global system context

     BACKEND: the backend to use

     FULLSCREEN_MODES: the available fullscreen modes (will be
     overwritten, out parameter)

     This function returns the current video mode.

     *Return value:* 1 on success, 0 on failure;

 -- Function: lw6gui_input_t * lw6gfx_pump_events (lw6sys_context_t *
          SYS_CONTEXT, lw6gfx_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: the backend to use

     This function "pumps" events, that is gets pending events, puts
     them in queues, maintains internal states up to date.  You really
     must call this very often or no input will be processed at all.

     *Return value:* a pointer on the internal input state, musn't be
     freed.

 -- Function: int lw6gfx_display (lw6sys_context_t * SYS_CONTEXT,
          lw6gfx_backend_t * BACKEND, int MASK, const lw6gui_look_t *
          LOOK, const lw6map_level_t * LEVEL, const lw6ker_game_struct_t
          * GAME_STRUCT, const lw6ker_game_state_t * GAME_STATE,
          lw6pil_local_cursors_t * LOCAL_CURSORS, lw6gui_menu_t * MENU,
          float PROGRESS, float FPS, float MPS, const char ** LOG_LIST,
          int CAPTURE, int GFX_DEBUG, int DEBUG_TEAM_ID, int
          DEBUG_LAYER_ID)
     SYS_CONTEXT: global system context

     BACKEND: the graphical backend to use

     MASK: display flag, tells what to display

     LOOK: the look, the skin, contains display options

     LEVEL: the level to display

     GAME_STRUCT: the game_struct associated with the level

     GAME_STATE: the game_state associated with the level

     LOCAL_CURSORS: the cursor to center the focus on

     MENU: the menu to display

     PROGRESS: the value of the progress indicator

     FPS: the number of frames per second to display

     MPS: the number of moves per second to display

     LOG_LIST: log messages to display

     CAPTURE: wether to enable capture mode or not

     GFX_DEBUG: wether to enable gfx debugging tools

     DEBUG_TEAM_ID: for debug display, team to display informations
     about

     DEBUG_LAYER_ID: for debug display, layer to display

     This is the major drawing function, the one that encapsulates all
     others.  As the program uses a separate thread to display things,
     we just pass this function many parameters, and let it do its job
     alone.  So many parameters might sometimes be useless.  It also
     allows the graphics backend decide wether menus and hud and
     background should interact.  Or not.

     *Return value:* 1 on success, 0 on failure.

 -- Function: lw6sys_assoc_t * lw6gfx_get_backends (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     List available gfx backends.  The hash contains pairs with id and
     name for each backend.  The id is the technical key you can use to
     load the backend, the name is something more readable you can
     display in an interface.  The backend objects themselves are not
     instanciated by this (in fact, they are, but released on the fly)
     you need to load and initialize them afterwards.

     *Return value:* hash containing id/name pairs.

 -- Function: lw6gfx_backend_t * lw6gfx_create_backend (lw6sys_context_t
          * SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          NAME)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     NAME: string containing gfx key, typically got from
     'lw6gfx_get_backends'

     Creates a gfx backend, this is just about loading the dynamic
     library if needed, and/or check gfx engine is available, and
     connect to it.  It does not perform initialization.

     *Return value:* gfx backend.

 -- Function: void lw6gfx_destroy_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6gfx_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: gfx backend to destroy

     Frees the ressources associated to a gfx, which must have been
     properly uninitialized before.

     *Return value:* none.

 -- Function: int lw6gfx_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libgfx module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6gfx_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'gfx' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6gfx_backend_s

     The gfx backend is the first argument passed to any gfx function,
     it contains reference to all the functions which can be used as
     well as a pointer on associated data.  In OO, this would just be an
     object, with members and methods, using polymorphism through opaque
     pointers.

 -- Member of lw6gfx_backend_s: dl_handle
     *Type:* 'lw6dyn_dl_handle_t *'

     *Definition:* 'lw6dyn_dl_handle_t* lw6gfx_backend_s::dl_handle'

     Handle on dynamic library (if it makes sense).

 -- Member of lw6gfx_backend_s: gfx_context
     *Type:* 'void *'

     *Definition:* 'void* lw6gfx_backend_s::gfx_context'

     Gfx specific data, what is behind this pointer really depends on
     the gfx engine.

 -- Member of lw6gfx_backend_s: argc
     *Type:* 'int'

     *Definition:* 'int lw6gfx_backend_s::argc'

     The argc value passed to main.

 -- Member of lw6gfx_backend_s: argv
     *Type:* 'const char **'

     *Definition:* 'const char** lw6gfx_backend_s::argv'

     The argv value passed to main.

 -- Member of lw6gfx_backend_s: call_lock
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6gfx_backend_s::call_lock'

     Lock used to avoid concurrent access to underlying libs.

 -- Member of lw6gfx_backend_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6gfx_backend_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6gfx_backend_s: init
     *Type:* 'void *(*'

     *Definition:* 'void*(* lw6gfx_backend_s::init)(lw6sys_context_t
     *sys_context, int argc, const char *argv[], lw6gui_video_mode_t
     *video_mode, lw6gui_resize_callback_func_t resize_callback)'

     Pointer on lw6gfx_init callback code.

 -- Member of lw6gfx_backend_s: quit
     *Type:* 'void(*'

     *Definition:* 'void(* lw6gfx_backend_s::quit)(lw6sys_context_t
     *sys_context, void *gfx_context)'

     Pointer on lw6gfx_quit callback code.

 -- Member of lw6gfx_backend_s: repr
     *Type:* 'char *(*'

     *Definition:* 'char*(* lw6gfx_backend_s::repr)(lw6sys_context_t
     *sys_context, void *gfx_context, u_int32_t id)'

     Pointer on lw6gfx_repr callback code.

 -- Member of lw6gfx_backend_s: set_video_mode
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6gfx_backend_s::set_video_mode)(lw6sys_context_t *sys_context,
     void *gfx_context, lw6gui_video_mode_t *video_mode)'

     Pointer on lw6gfx_set_video_mode callback code.

 -- Member of lw6gfx_backend_s: get_video_mode
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6gfx_backend_s::get_video_mode)(lw6sys_context_t *sys_context,
     void *gfx_context, lw6gui_video_mode_t *video_mode)'

     Pointer on lw6gfx_get_video_mode callback code.

 -- Member of lw6gfx_backend_s: get_fullscreen_modes
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6gfx_backend_s::get_fullscreen_modes)(lw6sys_context_t
     *sys_context, void *gfx_context, lw6gui_fullscreen_modes_t *modes)'

     Pointer on lw6gfx_get_fullscreen_modes callback code.

 -- Member of lw6gfx_backend_s: pump_events
     *Type:* 'lw6gui_input_t *(*'

     *Definition:* 'lw6gui_input_t*(*
     lw6gfx_backend_s::pump_events)(lw6sys_context_t *sys_context, void
     *gfx_context)'

     Pointer on lw6gfx_pump_events code.

 -- Member of lw6gfx_backend_s: display
     *Type:* 'int(*'

     *Definition:* 'int(* lw6gfx_backend_s::display)(lw6sys_context_t
     *sys_context, void *gfx_context, int mask, const lw6gui_look_t
     *look, const lw6map_level_t *level, const lw6ker_game_struct_t
     *game_struct, const lw6ker_game_state_t *game_state,
     lw6pil_local_cursors_t *local_cursors, lw6gui_menu_t *menu, float
     progress, float fps, float mps, const char **log_list, int capture,
     int gfx_debug, int debug_team_id, int debug_layer_id)'

     Pointer on lw6gfx_display code.

5.20 mod-gl1
============

5.20.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/mod-gl1/gl-utils/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.20.2 API
----------

 -- Function: void mod_gl1_is_GPL_compatible ()

     Defined to tell mod_gl1 is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_gl1_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-gl1, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6gfx_backend_t * mod_gl1_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-gl1 backend.

     *Return value:* backend pointer.

5.21 mod-gles2
==============

5.21.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/mod-gles2/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.21.2 API
----------

 -- Function: void mod_gles2_is_GPL_compatible ()

     Defined to tell mod_gles2 is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_gles2_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-gles2, giving details about the
     module, including name, description, licence, date/time of
     compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6gfx_backend_t * mod_gles2_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-gles2 backend.

     *Return value:* backend pointer.

5.22 mod-soft
=============

5.22.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/mod-soft/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.22.2 API
----------

 -- Function: void mod_soft_is_GPL_compatible ()

     Defined to tell mod_soft is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_soft_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-soft, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6gfx_backend_t * mod_soft_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-soft backend.

     *Return value:* backend pointer.

5.23 shared-sdl
===============

5.23.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/shared-sdl/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.23.2 API
----------

 -- Function: void shared_sdl_is_GPL_compatible ()

     Defined to tell shared_sdl is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

5.24 mod-caca
=============

5.24.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gfx/mod-caca/index.html>
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.ufoot.org/liquidwar/v6/doc/coverage/index.html) for complete
information).

5.24.2 API
----------

 -- Function: void mod_caca_is_GPL_compatible ()

     Defined to tell mod_caca is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_caca_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-caca, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6gfx_backend_t * mod_caca_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-caca backend.

     *Return value:* backend pointer.

5.25 libglb
===========

5.25.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/glb/index.html>.

5.25.2 API
----------

 -- Function: char * lw6glb_base64_encode_bin (lw6sys_context_t *
          SYS_CONTEXT, const char * BUF, int SIZE)
     SYS_CONTEXT: global system context

     BUF: the data to encode

     SIZE: the size of data to encode

     Encodes data into base64.  Memory allocation is done automatically.

     *Return value:* newly allocated string.

 -- Function: char * lw6glb_base64_decode_bin (lw6sys_context_t *
          SYS_CONTEXT, int * SIZE, const char * BASE64_STR)
     SYS_CONTEXT: global system context

     SIZE: the size of the decoded data

     BASE64_STR: the string to decode

     Decodes data from base64.  Memory allocation is done automatically.
     Note that this function only works for strings, other data might
     not be handled correctly.

     *Return value:* newly allocated pointer, NULL on error.

 -- Function: char * lw6glb_base64_encode_str (lw6sys_context_t *
          SYS_CONTEXT, const char * STR)
     SYS_CONTEXT: global system context

     STR: the string to encode

     Encodes a string into base64.

     *Return value:* newly allocated string.

 -- Function: char * lw6glb_base64_decode_str (lw6sys_context_t *
          SYS_CONTEXT, const char * STR)
     SYS_CONTEXT: global system context

     STR: the string to decode

     Decodes a string from base64.

     *Return value:* newly allocated string, NULL on error.

 -- Function: char * lw6glb_base64_encode_bin_prefix (lw6sys_context_t *
          SYS_CONTEXT, const char * BUF, int SIZE, const char * PREFIX)
     SYS_CONTEXT: global system context

     BUF: the data to encode

     SIZE: the size of data to encode

     PREFIX: a prefix string

     Encodes data into base64.  Memory allocation is done automatically.
     The encoded string will be prefixed with 'prefix'.

     *Return value:* newly allocated string.

 -- Function: char * lw6glb_base64_decode_bin_prefix (lw6sys_context_t *
          SYS_CONTEXT, int * SIZE, const char * BASE64_STR, const char *
          PREFIX)
     SYS_CONTEXT: global system context

     SIZE: the size of the decoded data

     BASE64_STR: the string to decode

     PREFIX: a prefix string

     Decodes data from base64.  Memory allocation is done automatically.
     Note that this function only works for strings, other data might
     not be handled correctly.  The encoded is expected to start with
     prefix 'prefix' and then contain base64 data.

     *Return value:* newly allocated pointer, NULL on error.

 -- Function: char * lw6glb_base64_encode_str_prefix (lw6sys_context_t *
          SYS_CONTEXT, const char * STR, const char * PREFIX)
     SYS_CONTEXT: global system context

     STR: the string to encode

     PREFIX: a prefix string

     Encodes a string into base64.  The encoded string will be prefixed
     with 'prefix'.

     *Return value:* newly allocated string.

 -- Function: char * lw6glb_base64_decode_str_prefix (lw6sys_context_t *
          SYS_CONTEXT, const char * STR, const char * PREFIX)
     SYS_CONTEXT: global system context

     STR: the string to decode

     PREFIX: a prefix string

     Decodes a string from base64.  The encoded is expected to start
     with prefix 'prefix' and then contain base64 data.

     *Return value:* newly allocated string, NULL on error.

 -- Function: char * lw6glb_sha1_hmac_80_bin (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY, int KEY_SIZE, const char * BUF,
          int BUF_SIZE)
     SYS_CONTEXT: global system context

     KEY: the key buffer 'key_size'

     BUF: the data to analyse

     BUF_SIZE: the size of data to analyse

     Calculates an SHA-1 sum of buffer, using key to seed calc.

     *Return value:* newly allocated string, containing 20 chars
     checksum.

 -- Function: char * lw6glb_sha1_hmac_80_str (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY, const char * STR)
     SYS_CONTEXT: global system context

     KEY: a key (string)

     STR: the string to calculate the checksum for

     Calculates an SHA-1 sum of a string, using key to seed calc.

     *Return value:* newly allocated string, containing 20 chars
     checksum.

 -- Function: u_int32_t lw6glb_sha1_hmac_32_bin (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY, int KEY_SIZE, const char * BUF,
          int BUF_SIZE)
     SYS_CONTEXT: global system context

     KEY: the key buffer

     KEY_SIZE: the key buffer size

     BUF: the data to analyse

     BUF_SIZE: the size of data to analyse

     Calculates an SHA-1 sum of buffer, using key to seed calc.

     *Return value:* a 32-bit unsigned integer

 -- Function: u_int32_t lw6glb_sha1_hmac_32_str (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY, const char * STR)
     SYS_CONTEXT: global system context

     KEY: a key (string)

     STR: the string to calculate the checksum for

     Calculates an SHA-1 sum of a string, using key to seed calc.

     *Return value:* a 32-bit unsigned integer

 -- Function: int lw6glb_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libglb module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6glb_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'glb' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

5.26 libgui
===========

5.26.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/gui/index.html>.

5.26.2 API
----------

 -- Function: void lw6gui_button_register_down (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     BUTTON: the button to update

     TIMESTAMP: the current ticks (milliseconds)

     Registers a "down" (press) event on a button.

     *Return value:* none.

 -- Function: void lw6gui_button_register_up (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to update

     Registers a "up" (release) event on a button.

     *Return value:* none.

 -- Function: int lw6gui_button_is_pressed (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells wether a button is pressed or not.

     *Return value:* 1 if pressed, 0 if not.

 -- Function: int lw6gui_button_pop_press (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells how many times the button has been pressed.  Typical usage:
     the button is pressed, released, pressed, released several times.
     Then, after all this, you want to know how many times it has been
     pressed.  Querying its state with 'lw6gui_button_is_pressed' won't
     tell you much but this 'pop_press' function will return 1 for each
     press there's been.

     *Return value:* 1 if there's a press event in the queue, 0 if
     empty.

 -- Function: int lw6gui_button_pop_simple_click (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells how many times the button has been simpleclicked.  This is
     different from a simple press, in fact, there's a delay, we must
     wait until the double-click delay is elapsed to make sure this is a
     simple click...  Designed for use with mouse to differentiate fire
     and alternate fire.

     *Return value:* 1 if there's a simpleclick event in the queue, 0 if
     empty.

 -- Function: int lw6gui_button_pop_double_click (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells how many times the button has been doubleclicked.  Typical
     usage: the button is doubleclicked, released, doubleclicked,
     released several times.  Then, after all this, you want to know how
     many times it has been doubleclicked.

     *Return value:* 1 if there's a doubleclick event in the queue, 0 if
     empty.

 -- Function: int lw6gui_button_pop_triple_click (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON)
     SYS_CONTEXT: global system context

     BUTTON: the button to query

     Tells how many times the button has been tripleclicked.  Typical
     usage: the button is tripleclicked, released, tripleclicked,
     released several times.  Then, after all this, you want to know how
     many times it has been tripleclicked.

     *Return value:* 1 if there's a tripleclick event in the queue, 0 if
     empty.

 -- Function: void lw6gui_button_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_button_t * BUTTON,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP,
          int AUTO_RELEASE_ENABLED)
     SYS_CONTEXT: global system context

     BUTTON: the button to update

     REPEAT_SETTINGS: the repeat settings

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for a button, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: int lw6gui_button_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_button_t * DST, lw6gui_button_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target button object

     SRC: the source button object

     Synchronizes two button objects.  This is typically used to pass
     data from one thread to another.  This is not a simple copy, it
     will handle data such as "when was it pressed last" it an
     intelligent manner, popping src data to put it in dst, and clearing
     src.

     *Return value:* 1 if success, O if failure.

 -- Function: int lw6gui_coord_calc_xy (lw6sys_context_t * SYS_CONTEXT,
          float * DST_X, float * DST_Y, float DST_X0, float DST_Y0,
          float DST_W, float DST_H, float SRC_X, float SRC_Y, float
          SRC_X0, float SRC_Y0, float SRC_W, float SRC_H)
     SYS_CONTEXT: global system context

     DST_X: the x coord to return

     DST_Y: the y coord to return

     DST_X0: the x coord of point 0 in destination coord system

     DST_Y0: the y coord of point 0 in destination coord system

     DST_W: the width of the area in destination coord system

     DST_H: the width of the area in destination coord system

     SRC_X: the x coord in source coord system

     SRC_Y: the y coord in source coord system

     SRC_X0: the x coord of point 0 in source coord system

     SRC_Y0: the y coord of point 0 in source coord system

     SRC_W: the width of the area in source coord system

     SRC_H: the width of the area in source coord system

     Registers a "down" (press) event on a button.

     *Return value:* 1 if OK, 0 if error (unable to calculate).

 -- Function: void lw6gui_coords_fix_xy_float (lw6sys_context_t *
          SYS_CONTEXT, float * X, float * Y, int * X_FLIP, int * Y_FLIP,
          float W, float H, int X_POLARITY, int Y_POLARITY)
     SYS_CONTEXT: global system context

     X: x coord (in/out param)

     Y: y coord (in/out param)

     X_FLIP: flip on x (out param, -1 or +1)

     Y_FLIP: flip on y (out param, -1 or +1)

     W: width

     H: height

     X_POLARITY: x polarity (-1, 0 or 1)

     Y_POLARITY: y polarity (-1, 0 or 1)

     Same as 'lw6map_fix_coords' except it operates on floats.  Usefull
     for cursor and other rendering operations.  Additionnally, will
     keep track of inversions, that is to say if map is flip in one or
     another way.  Be carefull, the flip values are -1 or 1 so that it's
     easy to multiply an offset by it, for instance, but this means
     testing if flip is not 0 will always return true, you must test if
     flip is stritly positive or negative.

     *Return value:* none

 -- Function: int lw6gui_input_init (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input struct to initialise

     Initialises an input structure, don't use twice, it won't free a
     previous init.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_input_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input struct to uninitialise

     Unitialises an input structure, need to call it to free event
     queue.

     *Return value:* a pointer to the newly allocated object.

 -- Function: lw6gui_input_t * lw6gui_input_new (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates an input structure, which can be used to handle input state
     & buffer.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_input_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input object to free.

     Deletes an input structure.

     *Return value:* none.

 -- Function: int lw6gui_input_reset (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input struct to reset

     Resets an input structure.  Must have been initialized before.  It
     will empty all queues and mark everything as unpressed.

     *Return value:* 1 on success, 0 if failure.

 -- Function: void lw6gui_input_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_input_t * INPUT, lw6gui_repeat_settings_t
          * REPEAT_SETTINGS, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     INPUT: the input to update

     REPEAT_SETTINGS: the repeat settings (delay + interval)

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for an input, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: void lw6gui_input_register_change (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input to update

     Tells an input object that one of its descendants has been
     modified.  This will affect the return value of
     'lw6gui_input_need_sync'

     *Return value:* none.

 -- Function: int lw6gui_input_need_sync (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: the input to test

     Tests wether an input object contains was modified and needs
     synchronisation.

     *Return value:* 1 if sync is need, 0 if not.

 -- Function: int lw6gui_input_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_input_t * DST, lw6gui_input_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target input object

     SRC: the source input object

     Synchronizes two input objects.  This is typically used to pass
     data from one thread to another.  This is not a copy, it will
     brute-force copy the static data such as mouse position, but
     anything like a queue will be treated in a "empty source and fill
     target with data" scheme.  So source will be affected by this, the
     key buffer will be emptied, and so on.  And if there are key in the
     target buffer, they won't be overwritten but kept in front of the
     FIFO list.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_input_enable_auto_release (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_input_t * INPUT)
     SYS_CONTEXT: global system context

     INPUT: input object to modify

     Enables auto_release mode, in this mode, it's assummed after some
     time any key is automatically released.

     *Return value:* none.

 -- Function: int lw6gui_joystick_check_index (lw6sys_context_t *
          SYS_CONTEXT, int I)
     SYS_CONTEXT: global system context

     I: index to check

     Checks wether the index is correct.  Does not mean the joystick
     exists, it's just to avoid out of bounds errors.

     *Return value:* 1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_axis_x (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_joystick_t * JOYSTICK, int X, int LIMIT,
          int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     JOYSTICK: joystick to update

     X: x-axis position, as returned by the driver

     LIMIT: the limit, under this, buttons are considered unpressed.

     TIMESTAMP: current ticks (timestamp in ms)

     Updates the x axis of a joystick, this will convert an information
     of analog type such as "joystick is here" to a pad-like information
     such as "pressed in that direction".

     *Return value:* 1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_axis_y (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_joystick_t * JOYSTICK, int Y, int LIMIT,
          int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     JOYSTICK: joystick to update

     LIMIT: the limit, under this, buttons are considered unpressed.

     TIMESTAMP: current ticks (timestamp in ms)

     Updates the y axis of a joystick, this will convert an information
     of analog type such as "joystick is here" to a pad-like information
     such as "pressed in that direction".

     *Return value:* 1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_joystick_t * JOYSTICK,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     JOYSTICK: the joystick to update

     REPEAT_SETTINGS: the repeat settings (delay + interval)

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for a joystick, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: int lw6gui_joystick_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_joystick_t * DST, lw6gui_joystick_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target joystick object

     SRC: the source joystick object

     Synchronizes two joystick objects.  This is typically used to pass
     data from one thread to another.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_joystick_get_move_pad (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_joystick_t * JOYSTICK,
          lw6gui_move_pad_t * MOVE_PAD)
     SYS_CONTEXT: global system context

     JOYSTICK: the joystick to query

     MOVE_PAD: the structure which will contain the results

     Returns the state of the joystick in a uniform, non-device specific
     structure containing only the up/down/left/right information.

     *Return value:* none, the value are stored in 'move_pad'.

 -- Function: int lw6gui_keyboard_check_keysym (lw6sys_context_t *
          SYS_CONTEXT, int KEYSYM)
     SYS_CONTEXT: global system context

     KEYSYM: the keysym to check

     Tells wether the keysym is valid or not.

     *Return value:* 1 if valid, 0 if not

 -- Function: lw6gui_keypress_t * lw6gui_keyboard_pop_keypress
          (lw6sys_context_t * SYS_CONTEXT, lw6gui_keyboard_t * KEYBOARD)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard structure which stores keyboard state

     Pops (in FIFO mode) a keypress stored in the keyboard buffer.  You
     must free the obtained keypress object after you're done with it.

     *Return value:* a newly allocated pointer, or NULL if no keypress
     pending.

 -- Function: int lw6gui_keyboard_is_pressed (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_keyboard_t * KEYBOARD, int KEYSYM)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard structure which stores keyboard state

     Tells wether a key is pressed or not.  The function will test out
     of bound values.

     *Return value:* 1 if pressed, 0 if not.

 -- Function: int lw6gui_keyboard_register_key_down (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_keyboard_t * KEYBOARD, int KEYSYM, int
          UNICODE, char * LABEL, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard structure which will store the keypress

     KEYSYM: the keysym for the keypress

     UNICODE: the ASCII/unicode code for the keypress

     LABEL: the label for the keypress

     TIMESTAMP: the current ticks (timestamp in ms)

     Registers a keypress event, that is, puts it in the event queue.
     This function does not take an 'lw6gui_keypress_t' structure but
     separated args, this is because it will construct the object
     internally.  You may free 'label' after calling this, an internal
     copy will be done.  This function will also maintain the array of
     key states up to date.

     *Return value:* 1 if success, O if failure.

 -- Function: int lw6gui_keyboard_register_key_up (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_keyboard_t * KEYBOARD, int KEYSYM)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard structure which will store the keypress

     KEYSYM: the keysym for the keypress

     Registers a key release event.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_keyboard_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_keyboard_t * KEYBOARD,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard to update

     REPEAT_SETTINGS: the repeat settings (delay + interval)

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for a keyboard, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: int lw6gui_keyboard_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_keyboard_t * DST, lw6gui_keyboard_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target keyboard object

     SRC: the source keyboard object

     Synchronizes two keyboard objects.  This is typically used to pass
     data from one thread to another.  Will pop the src queue to fill
     the dst queue.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_keyboard_get_move_pad (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_keyboard_t * KEYBOARD,
          lw6gui_move_pad_t * MOVE_PAD)
     SYS_CONTEXT: global system context

     KEYBOARD: the keyboard to query

     MOVE_PAD: the structure which will contain the results

     Returns the state of the keyboard in a uniform, non-device specific
     structure containing only the up/down/left/right information.

     *Return value:* none, the value are stored in 'move_pad'.

 -- Function: lw6gui_keypress_t * lw6gui_keypress_new (lw6sys_context_t
          * SYS_CONTEXT, int KEYSYM, int UNICODE, const char * LABEL)
     SYS_CONTEXT: global system context

     KEYSYM: the keysym to use

     UNICODE: the unicode value for this keysym

     LABEL: the label (optional, might be NULL)

     Creates a keypress structure, the only reason for needing a
     contructor is that the label field needs be duplicated.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_keypress_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_keypress_t * KEYPRESS)
     SYS_CONTEXT: global system context

     KEYPRESS: the keypress object to free.

     Deletes a keypress structure.

     *Return value:* none.

 -- Function: char * lw6gui_keypress_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_keypress_t * KEYPRESS)
     SYS_CONTEXT: global system context

     KEYPRESS: the keypress to work on

     Returns a human-readable representation of the keypress.

     *Return value:* a newly allocated string

 -- Function: lw6gui_look_t * lw6gui_look_new (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_style_t * MAP_STYLE)
     SYS_CONTEXT: global system context

     MAP_STYLE: map_style to use as a base

     Create a new look object, a look is basically a style plus some
     dynamic parameters.

     *Return value:* newly created object.

 -- Function: void lw6gui_look_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: look object to free

     Frees a look and all its members.

     *Return value:* none.

 -- Function: int lw6gui_look_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: look object to query

     Gives the memory taken by this object in memory.

     *Return value:* number of bytes.

 -- Function: char * lw6gui_look_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: look object to describe

     Returns a readable description of the object.

     *Return value:* newly allocated string.

 -- Function: int lw6gui_look_set (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK, char * KEY, char * VALUE)
     SYS_CONTEXT: global system context

     LOOK: look object to modify

     KEY: the key to change

     VALUE: the new value for the key

     Sets a new value for a given key in the look.  The value is always
     a string, it will be converted/casted to the right type if needed.

     *Return value:* 1 on success, 0 on failure.

 -- Function: char * lw6gui_look_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_look_t * LOOK, char * KEY)
     SYS_CONTEXT: global system context

     LOOK: look object to query

     KEY: the key to get

     Gets a new value for a given key in the look.  The value is always
     a string, it will be converted/casted from the right type if
     needed.

     *Return value:* dynamically allocated string.

 -- Function: int lw6gui_look_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_look_t * LOOK_A, const lw6gui_look_t * LOOK_B)
     SYS_CONTEXT: global system context

     LOOK_A: first object to compare

     LOOK_B: second object to compare

     Compares two look objects, doing recursive comparisons.  This can
     be very usefull if, for instance, a graphics renderer is using some
     contextual objects that depend on the look (colors?)  and need to
     be updated/regenerated on a look change

     *Return value:* 1 if they are the same, 0 if not.

 -- Function: lw6gui_look_t * lw6gui_look_dup (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: object to duplicate

     Duplicates a look object, performing recursive copies.

     *Return value:* newly allocated object.

 -- Function: void lw6gui_look_fix (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK)
     SYS_CONTEXT: global system context

     LOOK: look object to modify

     Peforms sanity checks and modifies the look if needed, to make all
     values fit within acceptable ranges, among other things.

     *Return value:* none.

 -- Function: int lw6gui_look_zoom_in (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK, float ZOOM_STEP)
     SYS_CONTEXT: global system context

     LOOK: look object to act upon

     ZOOM_STEP: how much we should zoom, 2.0 means 2 times bigger

     Zooms in, the function does not only multiplicates the current
     zoom, it also performs sanity checks.

     *Return value:* 1 if zoom was changed, 0 if not.

 -- Function: int lw6gui_look_zoom_out (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_look_t * LOOK, float ZOOM_STEP)
     SYS_CONTEXT: global system context

     LOOK: look object to act upon

     ZOOM_STEP: how much we should zoom, 2.0 means 2 times smaller

     Zooms out, the function does not only divides the current zoom, it
     also performs sanity checks.

     *Return value:* 1 if zoom was changed, 0 if not.

 -- Function: lw6gui_menu_t * lw6gui_menu_new (lw6sys_context_t *
          SYS_CONTEXT, const char * TITLE, const char * HELP, const char
          * POPUP, const char * ESC, int ENABLE_ESC)
     SYS_CONTEXT: global system context

     TITLE: the string to be displayed, what the user sees.  Can be
     freed after the call is done, function will make a copy internally.

     HELP: a string introducing the menu, describing what it does,
     giving hints on how to use it.

     POPUP: a string to be displayed in popup mode when menu is
     displayed for the first time.

     ESC: the label to be displayed in the ESC button

     ENABLE_ESC: wether to enable the escape button.

     Constructs a new menu object.  Note that you can always call other
     functions to modify it afterwards.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_menu_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Frees the menu, checking if things are OK before doing so.

     *Return value:* none.

 -- Function: int lw6gui_menu_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Gets the memory occupied by the menu.  Could be usefull to help a
     garbage collector taking decisions or reporting erros, for
     instance.

     *Return value:* the number of bytes used.

 -- Function: char * lw6gui_menu_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Constructs a readable description of the object.  Usefull for
     debugging, or to introspect things using scripts, at run-time.
     Does not necessarly describe all the informations about the object,
     but helps knowing what it is.

     *Return value:* a string describing the object, must be freed.

 -- Function: void lw6gui_menu_set_title (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, const char * TITLE)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     TITLE: the new title, you can free it after calling the function,
     an internal copy will be made.

     Change the title of the menu.  Use this function to change the
     title, don't try to access the struct directly.  The idea is to
     have safe memory management.

     *Return value:* none

 -- Function: void lw6gui_menu_set_help (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, const char * HELP)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     HELP: the new help, you can free it after calling the function, an
     internal copy will be made.

     Change the help of the menu.  Use this function to change the help,
     don't try to access the struct directly.  The idea is to have safe
     memory management.

     *Return value:* none

 -- Function: void lw6gui_menu_set_popup (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, const char * POPUP)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     POPUP: the new popup, you can free it after calling the function,
     an internal copy will be made.

     Change the popup of the menu.  That is to say, its popup.  Use this
     function to change the popup, don't try to access the struct
     directly.  The idea is to have safe memory management.

     *Return value:* none

 -- Function: void lw6gui_menu_close_popup (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Closes the popup, in practice, this is equivalent to setting the
     popup string to "" or NULL.

     *Return value:* none

 -- Function: int lw6gui_menu_has_popup (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: a pointer to the menu.

     Tells wether a popup is defined.  Behavior is simplistic, at
     creation (when a non-NULL non-empty popup string has been set) then
     the popup is displayed.  In this state, popup is considered to be
     defined.  Then it can be close, and after this action the popup
     ain't here anymore, program continues the way it started.

     *Return value:* 1 if has popup, 0 if does not

 -- Function: lw6gui_menuitem_t * lw6gui_menu_get_item (lw6sys_context_t
          * SYS_CONTEXT, lw6gui_menu_t * MENU, int POSITION)
     SYS_CONTEXT: global system context

     MENU: the menu we want to query

     POSITION: the order of the item we want

     Gets the menu item at the given position.  First item is 0, last is
     N-1.  Returns a pointer on the real object, not a copy.

     *Return value:* a pointer to a menu item, NULL if out of range.

 -- Function: int lw6gui_menu_select (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, int POSITION, int ALLOW_SCROLL, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     POSITION: the position of the item we want to select

     ALLOW_SCROLL: wether scrolling should be allowed when displaying it

     NOW: the current time, as a timestamp.

     Selects the item at the given position.  Use this function to be
     sure that only one item is selected, and all other states are
     consistent.  Timestamp is needed for the sake of eye-candy.

     *Return value:* 1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_select_esc (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int STATE, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     STATE: 1 to select, 0 to unselect

     NOW: the current time, as a timestamp.

     Selects the escape item, this does not affect other items, it's
     mostly.  to handle eye candy.

     *Return value:* none.

 -- Function: void lw6gui_menu_enable_esc (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int STATE, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     STATE: 1 to enable, 0 to disable

     NOW: the current time, as a timestamp.

     Enables the escape item, this does not affect other items, it's
     mostly.  to handle eye candy.

     *Return value:* none.

 -- Function: int lw6gui_menu_scroll_up (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: the menu to scroll

     Scrolls a menu up, used as a callback for mouse wheel up for
     instance.  The idea is just to decrement the first displayed item
     index.

     *Return value:* 1 if OK, 0 if failed (out of range).

 -- Function: int lw6gui_menu_scroll_down (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: the menu to scroll

     Scrolls a menu down, used as a callback for mouse wheel down for
     instance.  The idea is just to increment the first displayed item
     index.

     *Return value:* 1 if OK, 0 if failed (out of range).

 -- Function: int lw6gui_menu_set_breadcrumbs (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, lw6sys_list_t *
          BREADCRUMBS)
     SYS_CONTEXT: global system context

     MENU: the menu to scroll

     BREADCRUMBS: list of strings containing breadcrumbs

     Set the breadcrumbs, that's to say the readable, logical path to
     get to a given menu.  This is just eye candy, not linked to any
     logic at this level.

     *Return value:* 1 if OK, 0 if failed.

 -- Function: void lw6gui_menu_center (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, int POSITION, int MAX_DISPLAYED_ITEMS)
     SYS_CONTEXT: global system context

     MENU: the menu to center

     POSITION: the position of the menuitem to be put in the center

     MAX_DISPLAYED_ITEMS: the maximum number of items displayed

     Centers the menu on a given menuitem.  Typically used when pushing
     a menu with a menuitem selected 'anywhere' in the list.

     *Return value:* none.

 -- Function: int lw6gui_menu_insert (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, lw6gui_menuitem_t * MENUITEM, int
          POSITION, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     MENUITEM: the item to insert

     POSITION: the position the new item will occupy ("insert before"
     mode)

     NOW: the current time, as a timestamp.

     Inserts the given item in the menu.  All items starting at the
     insert position will be "pushed" (that is, their position
     incremented by 1).  Once the menuitem is inserted, the menu object
     will take care of memory management and automatically free it when
     needed.

     *Return value:* 1 if success, 0 if failure (memory problem, out of
     range).

 -- Function: int lw6gui_menu_append (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, lw6gui_menuitem_t * MENUITEM, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     MENUITEM: the item to insert

     NOW: the current time, as a timestamp.

     Appends the given item to the menu.  Once the menuitem is appended,
     the menu object will take care of memory management and
     automatically free it when needed.

     *Return value:* 1 if success, 0 if failure (memory problem).

 -- Function: int lw6gui_menu_remove (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * MENU, int POSITION, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     POSITION: the item to insert

     NOW: the current time, as a timestamp.

     Removes an item from the menu.  It will automatically be freed.

     *Return value:* 1 if success, 0 if failure (out of range).

 -- Function: int lw6gui_menu_remove_all (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu we want to modify

     NOW: the current time, as a timestamp.

     Removes all items from the menu, usefull when one wants to
     repopulate the items completely, from scratch.

     *Return value:* 1 if success, 0 if failure.

 -- Function: void lw6gui_menu_update_display_range (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int MAX_DISPLAYED_ITEMS)
     SYS_CONTEXT: global system context

     MENU: the menu concerned

     MAX_DISPLAYED_ITEMS: the maximum number of items to display at once

     Updates the display range.  The reason for having this is that the
     first item, that is, how far we scroll in a very long menu, depends
     on the previous position.  Plus you have to handle limit cases
     (begin/end).  Thus, this function, which will automatically pick-up
     a suitable position.  Of course, 'first_item_displayed' is not
     necessarly equal to 'selected_item'.

     *Return value:* none.

 -- Function: int lw6gui_menu_insert_for_id_use (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, char * LABEL, char *
          TOOLTIP, int VALUE, int ENABLED, int SELECTED, int COLORED,
          int POSITION, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu to work on

     LABEL: the label of the menuitem to append

     TOOLTIP: the tooltip of the menuitem to append

     VALUE: the value of the menuitem to append

     ENABLED: wether the inserted menuitem should be enabled

     SELECTED: wether the inserted menuitem should be selected

     COLORED: wether the inserted menuitem should use value as its color

     NOW: current time (timestamp)

     Inserts a menu item at the given position.  The idea is that the
     menu item object is automatically constructed on the fly, and an id
     is returned, which can be passed to '_using_id' menu-related
     functions.  This is typically for using in scripts.  The idea is
     that the script just keeps a copy of the id returned, and can this
     way operate directly on the menuitem without keeping a pointer, a
     smob or anything internally.  From the C point of view, having a
     real C structure enables persistent data from one display to the
     other, and this is nice and conveninent.  I acknowledge the
     prototype is scary.

     *Return value:* 0 if error, or else an id which will later be used
     with '_using_id' functions.

 -- Function: int lw6gui_menu_append_for_id_use (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, char * LABEL, char *
          TOOLTIP, int VALUE, int ENABLED, int SELECTED, int COLORED,
          int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu to work on

     LABEL: the label of the menuitem to append

     TOOLTIP: the tooltip of the menuitem to append

     VALUE: the value of the menuitem to append

     ENABLED: wether the appended menuitem should be enabled

     SELECTED: wether the appended menuitem should be selected

     COLORED: wether the appended menuitem should use value as its color

     NOW: current time (timestamp)

     Appends a menuitem using the same logic as
     'lw6gui_menu_insert_for_id_use' that is to say a parameter is
     returned which can later be used to directly operate on a given
     menuitem, without having its pointer, and even if its position
     changes.

     *Return value:* 0 if error, or else an id which will later be used
     with '_using_id' functions.

 -- Function: int lw6gui_menu_remove_using_id (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int MENUITEM_ID, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENU: the menu to work on

     MENUITEM_ID: the id of the menuitem to remove

     NOW: current time (timestamp)

     Deletes the menuitem with the given id.  Very important: the id is
     not the position.  Id are arbitrary numbers that stick to
     menuitems, but they are not directly linked with the position.
     This function is practical to use if, for some reason, you don't
     have the pointer on the menuitem.

     *Return value:* 1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_sync_using_id (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menu_t * MENU, int MENUITEM_ID, char *
          LABEL, char * TOOLTIP, int VALUE, int ENABLED, int SELECTED,
          int COLORED, int64_t NOW)
     SYS_CONTEXT: global system context

     MENU: the menu to work on

     MENUITEM_ID: the id of the menuitem to synchronize

     LABEL: menu label

     TOOLTIP: menu tooltip

     VALUE: value

     ENABLED: wether it's usable or not

     SELECTED: 1 if the menuite is current item

     COLORED: wether to use color

     NOW: current time (timestamp)

     Updates the menuitem with the given id.  Very important: the id is
     not the position.  Id are arbitrary numbers that stick to
     menuitems, but they are not directly linked with the position.
     This function is practical to use if, for some reason, you don't
     have the pointer on the menuitem.  In practice, it's heavily used
     in the game to transmit informations from the scripts to the core C
     engine.  Additionnaly, this function will automatically synchronize
     the 'selected_item' field of the menu struct.

     *Return value:* 1 if success, 0 if failure (out of range).

 -- Function: int lw6gui_menu_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6gui_menu_t * MENU_A, const lw6gui_menu_t * MENU_B)
     SYS_CONTEXT: global system context

     MENU_A: first item to compare

     MENU_B: second item to compare

     Compares two menus.

     *Return value:* 1 if they are the same, 0 if not

 -- Function: lw6gui_menu_t * lw6gui_menu_dup (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_menu_t * MENU)
     SYS_CONTEXT: global system context

     MENU: the menu to duplicate

     Duplicates a menu structure.

     *Return value:* a pointer to the new menu.

 -- Function: int lw6gui_menu_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menu_t * DST, lw6gui_menu_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target menu

     SRC: the source menu

     Synchronizes two menus, this supposes that they represent the same
     menu, but simply in a different state.  This function does not
     really copy src to dst, it has a special behavior, indeed
     everything is copied from src to dst, except the
     'first_item_displayed' and 'nb_items_displayed' which are taken
     from dst and copied to src.  This is because in practise, those
     values are updated in the display loop/thread, which is the one
     which uses the target.  This is not very orthodox, but should work.

     *Return value:* 1 if success, 0 if failure

 -- Function: lw6gui_menuitem_t * lw6gui_menuitem_new (lw6sys_context_t
          * SYS_CONTEXT, const char * LABEL, const char * TOOLTIP, int
          VALUE, int ENABLED, int SELECTED, int COLORED)
     SYS_CONTEXT: global system context

     LABEL: the string to be displayed, what the user sees.  Can be
     freed after the call is done, function will make a copy internally.

     TOOLTIP: the string to be displayed as a tooltip, describing the
     menu item in detail.  Can be NULL if you don't want to use this
     feature.

     VALUE: the value.  No GUI function uses this, this is the "real"
     value associated to the item.

     ENABLED: wether the menu item can be selected, used, and so on

     SELECTED: wether the menu item is the item selected among all menu
     items.

     COLORED: wetherr the menu item must, when drawn, be colored
     according to its value.

     Constructs a new menuitem object.  Note that you can always call
     other functions to modify these values afterwards, this might
     change rendering since 'lw6gui_menuitem_set_value' or
     'lw6gui_menuitem_set_label' will, for instance, modify the "when
     was that item last modified" information.

     *Return value:* a pointer to the newly allocated object.

 -- Function: void lw6gui_menuitem_free (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menuitem_t * MENUITEM)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     Frees the menuitem, checking if things are OK before doing so.

     *Return value:* none.

 -- Function: int lw6gui_menuitem_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     Gets the memory occupied by the menuitem.  Could be usefull to help
     a garbage collector taking decisions or reporting erros, for
     instance.

     *Return value:* the number of bytes used.

 -- Function: char * lw6gui_menuitem_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_menuitem_t * MENUITEM)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     Constructs a readable description of the object.  Usefull for
     debugging, or to introspect things using scripts, at run-time.
     Does not necessarly describe all the informations about the object,
     but helps knowing what it is.

     *Return value:* a string describing the object, must be freed.

 -- Function: void lw6gui_menuitem_set_label (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, const char * LABEL,
          int64_t NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     LABEL: the new label, you can free it after calling the function,
     an internal copy will be made.

     NOW: the current time, as a timestamp.

     Change the label of the menu item.  That is to say, what the user
     sees.  Use this function to change the menuitem value, don't try to
     access the struct directly.  The idea is 1) to have safe memory
     management and 2) to keep the 'last_change' member up to date.  It
     can be later used for eye-candy effects.

     *Return value:* none

 -- Function: void lw6gui_menuitem_set_tooltip (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, const char *
          TOOLTIP, int64_t NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     TOOLTIP: the new tooltip, you can free it after calling the
     function, an internal copy will be made.

     NOW: the current time, as a timestamp.

     Change the tooltip of the menu item (the explanation of what the
     item is about) Use this function to change the menuitem value,
     don't try to access the struct directly.  The idea is 1) to have
     safe memory management and 2) to keep the 'last_change' member up
     to date.  It can be later used for eye-candy effects.

     *Return value:* none

 -- Function: void lw6gui_menuitem_set_value (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, int VALUE, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     VALUE: the new value.

     NOW: the current time, as a timestamp.

     Changes the value of a menuitem.  This is the internal value, not
     what the user sees.  Use this function to change the menuitem
     value, don't try to access the struct directly.  The idea is to
     keep the 'last_change' member up to date.  It can be later used for
     eye-candy effects.

     *Return value:* none

 -- Function: void lw6gui_menuitem_select (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, int STATE, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     STATE: 1 to select, 0 to unselect

     NOW: the current time, as a timestamp.

     Switches the menuitem to (un)selected state.  Use this function,
     don't try to modify the struct members directly.  The idea is to
     have the 'last_select' parameter up to date.  It can be later used
     for eye-candy effects.

     *Return value:* none

 -- Function: void lw6gui_menuitem_enable (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, int STATE, int64_t
          NOW)
     SYS_CONTEXT: global system context

     MENUITEM: a pointer to the menuitem.

     STATE: 1 to enable, 0 to disable

     NOW: the current time, as a timestamp.

     Switches the menuitem to enabled/disabled state.  Use this
     function, don't try to modify the struct members directly.  The
     idea is to have the 'last_select' parameter up to date.  It can be
     later used for eye-candy effects.

     *Return value:* none

 -- Function: u_int32_t lw6gui_menuitem_checksum (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_menuitem_t * MENUITEM, lw6gui_look_t *
          LOOK)
     SYS_CONTEXT: global system context

     MENUITEM: the menuitem we want to identify

     Returns a checksum which can be used to know, for instance, wether
     the menuitem has changed or not, and if we should redraw it.

     *Return value:* a checksum.

 -- Function: int lw6gui_menuitem_is_same (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_menuitem_t * MENUITEM_A, const
          lw6gui_menuitem_t * MENUITEM_B)
     SYS_CONTEXT: global system context

     MENUITEM_A: first item to compare

     MENUITEM_B: second item to compare

     Compares two menuitems.

     *Return value:* 1 if they are the same, 0 if not

 -- Function: lw6gui_menuitem_t * lw6gui_menuitem_dup (lw6sys_context_t
          * SYS_CONTEXT, const lw6gui_menuitem_t * MENUITEM)
     SYS_CONTEXT: global system context

     MENUITEM: the menuitem to duplicate

     The menuitem to duplicate.

     *Return value:* a pointer to the duplicted menuitem.

 -- Function: int lw6gui_menuitem_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_menuitem_t * DST, lw6gui_menuitem_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target menuitem

     SRC: the source menuitem

     Synchronizes two menuitems, this supposes that they represent the
     same item, but simply in a different state.

     *Return value:* 1 if success, 0 if failure

 -- Function: void lw6gui_mouse_register_move (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE, int SCREEN_POS_X, int
          SCREEN_POS_Y, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     MOUSE: the mouse object to work on

     SCREEN_POS_X: the x position on screen

     SCREEN_POS_Y: the y position on screen

     TIMESTAMP: current timestamp

     Registers a mouse move event.

     *Return value:* note.

 -- Function: int lw6gui_mouse_poll_move (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE, int * SCREEN_POS_X, int *
          SCREEN_POS_Y)
     SYS_CONTEXT: global system context

     MOUSE: the mouse object to poll

     SCREEN_POS_X: pointer to the x position (can be NULL), will be
     updated even if no move

     SCREEN_POS_Y: pointer to the y position (can be NULL), will be
     updated even if no move

     Asks wether the mouse has moved or not.

     *Return value:* 1 if mouse was moved since last call, 0 if not.

 -- Function: void lw6gui_mouse_update_repeat (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE, lw6gui_repeat_settings_t
          * REPEAT_SETTINGS, int64_t TIMESTAMP)
     MOUSE: the mouse to update

     REPEAT_SETTINGS: the repeat settings (delay + interval)

     TIMESTAMP: the current ticks (milliseconds)

     Updates the repeat informations for a mouse, must be called
     regularly, as often as possible.

     *Return value:* none.

 -- Function: int lw6gui_mouse_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_mouse_t * DST, lw6gui_mouse_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target mouse object

     SRC: the source mouse object

     Synchronizes two mouse objects.  This is typically used to pass
     data from one thread to another.  Will handle "mouse move"
     attribute and clear it in src if needed while setting it in dst.

     *Return value:* 1 if success, O if failure.

 -- Function: void lw6gui_mouse_drag_begin (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE)
     SYS_CONTEXT: global system context

     MOUSE: mouse struct to update

     To be called when one wants to start recording a drag session,
     typically when left button is pressed.

     *Return value:* none.

 -- Function: void lw6gui_mouse_drag_end (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_mouse_t * MOUSE)
     SYS_CONTEXT: global system context

     MOUSE: mouse struct to update

     To be called when one wants to stop recording a drag session,
     typically when left button is released.

     *Return value:* none.

 -- Function: int lw6gui_mouse_drag_pop (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_mouse_t * MOUSE, int * DELTA_X, int * DELTA_Y, int *
          POS_X, int * POS_Y, int * SPEED_X, int * SPEED_Y)
     SYS_CONTEXT: global system context

     MOUSE: mouse struct to query

     DELTA_X: x movement (on screen, out param can be NULL)

     DELTA_Y: y movement (on screen, out param can be NULL)

     POS_X: x pos (on screen, out param can be NULL)

     POS_Y: y pos (on screen, out param can be NULL)

     SPEED_X: x speed (on screen, out param can be NULL)

     SPEED_Y: y speed (on screen, out param can be NULL)

     To be called when one wants to stop recording a drag session,
     typically when left button is released.

     *Return value:* none.

 -- Function: int lw6gui_point_is_inside_rect (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_point_t POINT, const lw6gui_rect_t * RECT)
     SYS_CONTEXT: global system context

     POINT: point to test

     RECT: rectangle in which point is supposed to be

     Tests wether a point is inside a rectangle, this is typically used
     to know if a point is inside the right texture or if we're outside.

     *Return value:* 1 if OK, 0 if outside

 -- Function: int lw6gui_power_of_two_ge (lw6sys_context_t *
          SYS_CONTEXT, int INPUT)
     SYS_CONTEXT: global system context

     INPUT: the value to approach

     Finds the closest power of two, which is at least greater or equal
     to input.  Typically used to size textures.

     *Return value:* a power of two.

 -- Function: int lw6gui_power_of_two_le (lw6sys_context_t *
          SYS_CONTEXT, int INPUT)
     SYS_CONTEXT: global system context

     INPUT: the value to approach

     Finds the closest power of two, which is equal of inferior to
     input.  Typically used to size textures.

     *Return value:* a power of two.

 -- Function: int lw6gui_quad_is_inside_rect (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_quad_t * QUAD, const lw6gui_rect_t *
          RECT)
     SYS_CONTEXT: global system context

     QUAD: quad to test

     RECT: rectangle in which quad is supposed to be

     Tests wether a quad is inside a rectangle, this is typically used
     to know if a quad is inside the right texture or if we're outside.

     *Return value:* 1 if OK, 0 if outside

 -- Function: int lw6gui_rect_array_init (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_rect_array_t * RECT_ARRAY, int W, int H,
          int TILE_SIZE, int BORDER_SIZE)
     SYS_CONTEXT: global system context

     RECT_ARRAY: the rectangle array to initializae

     W: width of the zone to initialize

     H: height of the zone to initialize

     TILE_SIZE: tile size, that is, width and height of sub rectangles

     BORDER_SIZE: border to add so that sub rectangles overlap

     Initializes a rect array structure, this is usefull for texture
     handling, it builds an array of sub-rectangle which slightly
     overlap each other.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6gui_rect_array_get_tile_by_source_xy
          (lw6sys_context_t * SYS_CONTEXT, const lw6gui_rect_array_t *
          RECT_ARRAY, lw6gui_rect_t * RECT, int * I, int SOURCE_X, int
          SOURCE_Y)
     SYS_CONTEXT: global system context

     RECT_ARRAY: the rectangle array to initializae

     RECT: the sub-rectangle (out param)

     I: the index of the sub-rectangle (out param)

     SOURCE_X: the x position on the global rect array

     SOURCE_Y: the y position on the global rect array

     Finds out which sub-rectangle is the right one, given a source
     position.  The output values are a correctly initialized
     sub-rectangle with relative position set plus its index within the
     container rectangle array.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6gui_rect_array_get_tile_by_i (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_rect_array_t * RECT_ARRAY,
          lw6gui_rect_t * RECT, int I)
     SYS_CONTEXT: global system context

     RECT_ARRAY: the rectangle array to initializae

     RECT: the sub-rectangle (out param)

     I: the index of the sub-rectangle

     Finds out which sub-rectangle is the right one, given a source
     position.  The output value is a correctly initialized
     sub-rectangle with relative position set.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6gui_rect_array_get_tile_and_quad (lw6sys_context_t
          * SYS_CONTEXT, const lw6gui_rect_array_t * RECT_ARRAY,
          lw6gui_rect_t * RECT, int * I, lw6gui_quad_t * QUAD, const
          lw6gui_quad_t * SOURCE_QUAD, int X_POLARITY, int Y_POLARITY)
     SYS_CONTEXT: global system context

     RECT_ARRAY: the rectangle array to initializae

     RECT: the sub-rectangle (out param)

     I: the index of the sub-rectangle (out param)

     QUAD: the 4 corresponding points within the sub-rectangle (out
     param)

     SOURCE_QUAD: 4 points within the container rectangle array

     X_POLARITY: polarity along the X axis

     Y_POLARITY: polarity along the Y axis

     Finds out which sub-rectangle is the right one, given 4 points as
     an input, and places these 4 points on the sub-rectangle, taking in
     account the polarity.  This is typically used for texture mapping.
     Note that a rectangle array can't handle all requests, it need have
     the good size, granularity.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6gui_rect_init_x1y1x2y2 (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_rect_t * RECT, int X1, int Y1, int X2, int
          Y2)
     SYS_CONTEXT: global system context

     RECT: the structure to initialize

     X1: x for top left corner

     Y1: y for top left corner

     X2: x for bottom right corner

     Y2: y for bottom right corner

     Initializes a rect structure, will calculate w & h.

     *Return value:* none.

 -- Function: void lw6gui_rect_init_xywh (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_rect_t * RECT, int X, int Y, int W, int H)
     SYS_CONTEXT: global system context

     RECT: the structure to initialize

     X: x for top left corner

     Y: y for top left corner

     W: width

     H: height

     Initializes a rect structure, will calculate x2 & y2.

     *Return value:* none.

 -- Function: void lw6gui_rect_clip (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_rect_t * DST, const lw6gui_rect_t * SRC, const
          lw6gui_rect_t * CLIP)
     SYS_CONTEXT: global system context

     DST: the structure which will contain the result

     SRC: the source rect

     CLIP: the clipping rect (boundaries)

     Clips a rect (think of rectangle clips).

     *Return value:* none.

 -- Function: int lw6gui_segment_is_inside_rect (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_segment_t * SEGMENT, const
          lw6gui_rect_t * RECT)
     SYS_CONTEXT: global system context

     SEGMENT: segment to test

     RECT: rectangle in which segment is supposed to be

     Tests wether a segment is inside a rectangle, this is typically
     used to know if a segment is inside the right texture or if we're
     outside.

     *Return value:* 1 if OK, 0 if outside

 -- Function: void lw6gui_smoother_init (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_smoother_t * SMOOTHER, float VALUE, int DURATION)
     SYS_CONTEXT: global system context

     SMOOTHER: the structure to initialize

     VALUE: the value to use for now

     DURATION: the duration of a standard move, in ticks (msec)

     Initializes a smoother object, with a default value.  The important
     point is the duration which will condition all the behavior of the
     object.

     *Return value:* none.

 -- Function: void lw6gui_smoother_immediate_force (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_smoother_t * SMOOTHER, float VALUE)
     SYS_CONTEXT: global system context

     SMOOTHER: the structure to use

     VALUE: the target value

     Forces a smoother object to immediately point on a value.

     *Return value:* none.

 -- Function: void lw6gui_smoother_set_target (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_smoother_t * SMOOTHER, float VALUE,
          int64_t NOW)
     SYS_CONTEXT: global system context

     SMOOTHER: the structure to use

     VALUE: the target value

     NOW: the current timestamp

     Sets a new target, will automatically calculate current speed to
     smooth the next returned values.

     *Return value:* none.

 -- Function: float lw6gui_smoother_get_value (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_smoother_t * SMOOTHER, int64_t NOW)
     SYS_CONTEXT: global system context

     SMOOTHER: the structure to use

     NOW: the current timestamp

     Returns the current value of the smoother.

     *Return value:* a float.

 -- Function: void lw6gui_smoother_fix_overflow (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_smoother_t * SMOOTHER, int STEP)
     SYS_CONTEXT: global system context

     SMOOTHER: object to modify

     STEP: step size, typically twice the map size

     Companion function of 'lw6pil_coords_fix_x10', this one will fix a
     smoother target to avoid crazy scrolls when cursor is on a map
     edge.

     *Return value:* none.

 -- Function: int lw6gui_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libgui module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6gui_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'gui' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6gui_triangle_is_inside_rect (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_triangle_t * TRIANGLE, const
          lw6gui_rect_t * RECT)
     SYS_CONTEXT: global system context

     TRIANGLE: triangle to test

     RECT: rectangle in which triangle is supposed to be

     Tests wether a triangle is inside a rectangle, this is typically
     used to know if a triangle is inside the right texture or if we're
     outside.

     *Return value:* 1 if OK, 0 if outside

 -- Function: int lw6gui_video_mode_find_closest (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_video_mode_t * CLOSEST, const
          lw6gui_video_mode_t * WISHED, lw6sys_list_t * AVAILABLE)
     SYS_CONTEXT: global system context

     CLOSEST: the closest video_mode found

     WISHED: the wished video_mode

     AVAILABLE: a list of available video_modes (list of
     lw6gui_video_mode_t *)

     Finds the closest video_mode available, this is just a small
     utility to cope with different screen shapes and avoid requesting
     640x480 when it's just not available but there's a 640x400 instead.

     *Return value:* 1 if the wished video_mode exists in available list
     and was found, else 0 if the wished video_mode doesn't exist and an
     approximative match was picked.

 -- Function: int lw6gui_video_mode_is_same (lw6sys_context_t *
          SYS_CONTEXT, const lw6gui_video_mode_t * MODE_A, const
          lw6gui_video_mode_t * MODE_B)
     SYS_CONTEXT: global system context

     MODE_A: first mode to compare

     MODE_B: second mode to compare

     Compares two video modes, to know if they're the same.

     *Return value:* 1 if equal, 0 if not.

 -- Function: int lw6gui_video_mode_sync_ratio (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_video_mode_t * DST, const
          lw6gui_video_mode_t * SRC)
     SYS_CONTEXT: global system context

     DST: the target video mode

     SRC: the source video mode

     Applies the ratio of src to dst, for instance if src is 16/9, then
     dst will be made 16/9 too, trying to keep the same surface.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6gui_viewport_init (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_viewport_t * VIEWPORT, int SCREEN_W, int SCREEN_H,
          float DRAWABLE_X1, float DRAWABLE_Y1, float DRAWABLE_X2, float
          DRAWABLE_Y2, float CENTER_X, float CENTER_Y, int MAP_W, int
          MAP_H, int X_POLARITY, int Y_POLARITY, int X_WRAP, int Y_WRAP,
          int KEEP_RATIO, float GLOBAL_ZOOM, float SCROLL_LIMIT, int
          USE_OLD_CENTER)
     SYS_CONTEXT: global system context

     VIEWPORT: the viewport to initalize

     SCREEN_W: screen width

     SCREEN_H: screen height

     DRAWABLE_X1: viewport min x

     DRAWABLE_Y1: viewport min y

     DRAWABLE_X2: viewport max x

     DRAWABLE_Y2: viewport max y

     CENTER_X: center of display (in map coordinates)

     CENTER_Y: center of display (in map coordinates)

     MAP_W: map width (shape)

     MAP_H: map height (shape)

     X_POLARITY: x polarity

     Y_POLARITY: y polarity

     X_WRAP: wether to wrap horizontally

     Y_WRAP: wether to wrap vertically

     KEEP_RATIO: wether to adapt to viewport shape or keep original

     GLOBAL_ZOOM: global zoom is style_zoom * dynamic_zoom

     SCROLL_LIMIT: inside this zone, don't scroll

     USE_OLD_CENTER: wether to take previous center in account

     Initializes all the (jumbo?)  viewport structure which will contain
     valuable informations for a simple "flat" display.  Special
     renderers might not find usefull some fields and handle wrapping
     and zooming their own way, but this offers a basic skeleton.

     *Return value:* 1 if ok, 0 on failure

 -- Function: void lw6gui_viewport_map_to_screen (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_viewport_t * VIEWPORT, float * SCREEN_X,
          float * SCREEN_Y, float MAP_X, float MAP_Y, int CLIP)
     SYS_CONTEXT: global system context

     VIEWPORT: the viewport to use

     SCREEN_X: the x coord on the screen

     SCREEN_Y: the y coord on the screen

     MAP_X: the x coord in map coordinates

     MAP_Y: the y coord in map coordinates

     CLIP: wether to clip returned values

     Translates from map coords to screen coords.  Returned values might
     be outside screen boundaries if clip is 0.  If screen coords are
     outside drawable area anc clip is 1, then they will be clipped.

     *Return value:* NULL

 -- Function: void lw6gui_viewport_screen_to_map (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_viewport_t * VIEWPORT, float * MAP_X,
          float * MAP_Y, float SCREEN_X, float SCREEN_Y, int WRAP)
     SYS_CONTEXT: global system context

     VIEWPORT: the viewport to use

     MAP_X: the x coord in map coordinates

     MAP_Y: the y coord in map coordinates

     SCREEN_X: the x coord on the screen

     SCREEN_Y: the y coord on the screen

     WRAP: wether to use polarity informations to wrap coords.

     Translates from screen coords to map coords.  If wrap is set, it
     will interpret coords the way 'lw6map_coords_fix_xy' would, only it
     can still be formally outside map boundaries for it can return a
     value exactly equal to w,h while in interger mode it would be
     w-1,h-1.

     *Return value:* NULL

 -- Function: void lw6gui_viewport_calc_drag (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_viewport_t * VIEWPORT, float * MAP_DST_X,
          float * MAP_DST_Y, float MAP_SRC_X, float MAP_SRC_Y, int
          SCREEN_DX, int SCREEN_DY)
     SYS_CONTEXT: global system context

     VIEWPORT: viewport to work on

     MAP_DST_X: map det x coord (out param)

     MAP_DST_Y: map dst y coord (out param)

     MAP_SRC_X: map src x coord

     MAP_SRC_Y: map src y coord

     SCREEN_DX: drag x (on screen)

     SCREEN_DY: drag y (on screen)

     Used to calculate the new "center" when in drag mode.

     *Return value:* none.

 -- Function: void lw6gui_zone_init_x1y1x2y2 (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_zone_t * ZONE, float X1, float Y1, float
          X2, float Y2)
     SYS_CONTEXT: global system context

     ZONE: the structure to initialize

     X1: x for top left corner

     Y1: y for top left corner

     X2: x for bottom right corner

     Y2: y for bottom right corner

     Initializes a zone structure, will calculate w & h.

     *Return value:* none.

 -- Function: void lw6gui_zone_init_xywh (lw6sys_context_t *
          SYS_CONTEXT, lw6gui_zone_t * ZONE, float X, float Y, float W,
          float H)
     SYS_CONTEXT: global system context

     ZONE: the structure to initialize

     X: x for top left corner

     Y: y for top left corner

     W: width

     H: height

     Initializes a zone structure, will calculate x2 & y2.

     *Return value:* none.

 -- Function: void lw6gui_zone_clip (lw6sys_context_t * SYS_CONTEXT,
          lw6gui_zone_t * DST, lw6gui_zone_t * SRC, lw6gui_zone_t *
          CLIP)
     SYS_CONTEXT: global system context

     DST: the structure which will contain the result

     SRC: the source zone

     CLIP: the clipping zone (boundaries)

     Clips a zone (think of rectangle clips).

     *Return value:* none.

 -- Struct: lw6gui_button_s

     Used to store a complete button state, along with repeat
     informations, queues.  It might be overkill for basic cases, having
     different types of buttons (union?)  for different cases might be a
     good idea.

 -- Member of lw6gui_button_s: is_pressed
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::is_pressed'

     Wether button is pressed, 1 means pressed, 0 unpressed.

 -- Member of lw6gui_button_s: press_queue
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::press_queue'

     Each time the button is pressed, this increases, each times one
     "pops" a press from it, it's decreased.  This allows for button
     buffering, as events might take some time to go through the
     pipeline given the heavily multithreaded nature of the dsp/gfx
     couple.

 -- Member of lw6gui_button_s: simple_click_queue
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::simple_click_queue'

     Simple-click counter, as opposed to double-click.  A "simple-click"
     is validated when one has pressed the button, and then waiting long
     enough to discard the possibility to double-click.  This is not
     really buffered, queue will ignore simple-clicks if one is already
     buffered.

 -- Member of lw6gui_button_s: double_click_queue
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::double_click_queue'

     Double-click counter.  This is not really buffered, queue will
     ignore double-clicks if one is already buffered.

 -- Member of lw6gui_button_s: triple_click_queue
     *Type:* 'int'

     *Definition:* 'int lw6gui_button_s::triple_click_queue'

     Triple-click counter.  This is not really buffered, queue will
     ignore triple-clicks if one is already buffered.

 -- Member of lw6gui_button_s: last_press
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::last_press'

     Timestamp of last key press.

 -- Member of lw6gui_button_s: last_repeat
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::last_repeat'

     Timestamp of last key repeat.

 -- Member of lw6gui_button_s: double_click_t1
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::double_click_t1'

     Used to handle multiple-clicks, this is the timestamp of the click
     "2 clicks ago".

 -- Member of lw6gui_button_s: double_click_t2
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::double_click_t2'

     Used to handle multiple-clicks, this is the timestamp of the click
     just before the last click.

 -- Member of lw6gui_button_s: double_click_t3
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_button_s::double_click_t3'

     Used to handle multiple-clicks, this is the timestamp of the last
     click.

 -- Struct: lw6gui_fullscreen_modes_s

     Contains information about available fullscreen modes.

 -- Member of lw6gui_fullscreen_modes_s: low
     *Type:* 'lw6gui_video_mode_t'

     *Definition:* 'lw6gui_video_mode_t lw6gui_fullscreen_modes_s::low'

     Low resolution mode.

 -- Member of lw6gui_fullscreen_modes_s: standard
     *Type:* 'lw6gui_video_mode_t'

     *Definition:* 'lw6gui_video_mode_t
     lw6gui_fullscreen_modes_s::standard'

     Standard resolution mode.

 -- Member of lw6gui_fullscreen_modes_s: high
     *Type:* 'lw6gui_video_mode_t'

     *Definition:* 'lw6gui_video_mode_t lw6gui_fullscreen_modes_s::high'

     High resolution mode.

 -- Struct: lw6gui_input_s

     Global input state, contains informations about the keyboard, mouse
     and joystick.  This is the macro object used to exchange data and
     transmit input information from the rendering thread which gathers
     it to the logical thread which computes the game state.

 -- Member of lw6gui_input_s: need_sync
     *Type:* 'int'

     *Definition:* 'int lw6gui_input_s::need_sync'

     Wether this input struct has changed and needs to be synchronized.

 -- Member of lw6gui_input_s: keyboard
     *Type:* 'lw6gui_keyboard_t'

     *Definition:* 'lw6gui_keyboard_t lw6gui_input_s::keyboard'

     Keyboard information.

 -- Member of lw6gui_input_s: mouse
     *Type:* 'lw6gui_mouse_t'

     *Definition:* 'lw6gui_mouse_t lw6gui_input_s::mouse'

     Mouse information.

 -- Member of lw6gui_input_s: joysticks
     *Type:* 'lw6gui_joystick_t'

     *Definition:* 'lw6gui_joystick_t
     lw6gui_input_s::joysticks[LW6GUI_NB_JOYSTICKS]'

     Joysticks information.

 -- Struct: lw6gui_joystick_s

     Joystick information, contains detailed joystick state.  This
     structure uses a pad-like interface, there's no knowledge of analog
     interfaces, it transforms everything to a binary "up or down" and
     "left or right".  This interface only knows about 6 buttons, this
     is done on purpose, the logic behind it is that more than 6 buttons
     makes the control way too complicated.  Actually, most common
     functions are and should be available through the 4 first (a,b,c,d)
     buttons.  The e and f are here for additionnal not-so-important
     features.

 -- Member of lw6gui_joystick_s: pad_up
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::pad_up'

     Joystick up button state.

 -- Member of lw6gui_joystick_s: pad_down
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::pad_down'

     Joystick down button state.

 -- Member of lw6gui_joystick_s: pad_left
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::pad_left'

     Joystick left button state.

 -- Member of lw6gui_joystick_s: pad_right
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::pad_right'

     Joystick right button state.

 -- Member of lw6gui_joystick_s: button_a
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_a'

     Joystick a button state.

 -- Member of lw6gui_joystick_s: button_b
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_b'

     Joystick b button state.

 -- Member of lw6gui_joystick_s: button_c
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_c'

     Joystick c button state.

 -- Member of lw6gui_joystick_s: button_d
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_d'

     Joystick d button state.

 -- Member of lw6gui_joystick_s: button_e
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_e'

     Joystick e button state.

 -- Member of lw6gui_joystick_s: button_f
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_joystick_s::button_f'

     Joystick f button state.

 -- Struct: lw6gui_keyboard_s

     Stores a complete keyboard state.

 -- Member of lw6gui_keyboard_s: auto_release_enabled
     *Type:* 'int'

     *Definition:* 'int lw6gui_keyboard_s::auto_release_enabled'

     Wether auto_release mode is set.

 -- Member of lw6gui_keyboard_s: arrow_up
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::arrow_up'

     State of keyboard up arrow.  This can be the combination of several
     keys, for instance the numeric pad up arrow, and the corresponding
     arrow pad key.

 -- Member of lw6gui_keyboard_s: arrow_down
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::arrow_down'

     State of keyboard down arrow.  This can be the combination of
     several keys, for instance the numeric pad down arrow, and the
     corresponding arrow pad key.

 -- Member of lw6gui_keyboard_s: arrow_left
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::arrow_left'

     State of keyboard left arrow.  This can be the combination of
     several keys, for instance the numeric pad left arrow, and the
     corresponding arrow pad key.

 -- Member of lw6gui_keyboard_s: arrow_right
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::arrow_right'

     State of keyboard right arrow.  This can be the combination of
     several keys, for instance the numeric pad right arrow, and the
     corresponding arrow pad key.

 -- Member of lw6gui_keyboard_s: key_enter
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_enter'

     State of keyboard ENTER key.  This can be the combination of
     several keys, for instance both the numeric pad ENTER and the
     standard, default one.

 -- Member of lw6gui_keyboard_s: key_esc
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_esc'

     State of keyboard ESC key.  This can be the combination of several
     keys, for instance both the standard ESC key and another key.

 -- Member of lw6gui_keyboard_s: key_ctrl
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_ctrl'

     State of keyboard ESC key.  This can be the combination of several
     keys, for instance both left and right CTRL keys.

 -- Member of lw6gui_keyboard_s: key_alt
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_alt'

     State of keyboard ESC key.  This can be the combination of several
     keys, for instance both left and right ALT keys.

 -- Member of lw6gui_keyboard_s: key_pgup
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_pgup'

     State of keyboard PAGE UP key.  This can be the combination of
     several keys.

 -- Member of lw6gui_keyboard_s: key_pgdown
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_keyboard_s::key_pgdown'

     State of keyboard PAGE UP key.  This can be the combination of
     several keys.

 -- Member of lw6gui_keyboard_s: queue
     *Type:* 'lw6sys_list_t *'

     *Definition:* 'lw6sys_list_t* lw6gui_keyboard_s::queue'

     List of events, contains keypress objects.

 -- Member of lw6gui_keyboard_s: keys_state
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t
     lw6gui_keyboard_s::keys_state[LW6GUI_NB_KEYS]'

     Array of button states, indexed by keycodes.

 -- Struct: lw6gui_keypress_s

     Keypress information, contains more than just a keycode but also
     meta/readable informations about it.

 -- Member of lw6gui_keypress_s: keysym
     *Type:* 'int'

     *Definition:* 'int lw6gui_keypress_s::keysym'

     The keysym, note that this is implementation specific.  In
     practice, SDL uniformizes this, but there's no garantee all
     graphics engine are SDL based, so don't rely on this too much
     outside the graphics backend.

 -- Member of lw6gui_keypress_s: unicode
     *Type:* 'int'

     *Definition:* 'int lw6gui_keypress_s::unicode'

     Unicode code for this letter/key.

 -- Member of lw6gui_keypress_s: label
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_keypress_s::label'

     Readable label for the key, typically usable in a "choose keyboard
     settings" interface.

 -- Struct: lw6gui_look_s

     The look structure contains everything the renderer needs to skin
     the display.  This is where one specifies the color set, dynamic
     zoom effect, and possibly other things.

 -- Member of lw6gui_look_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6gui_look_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6gui_look_s: dynamic_zoom
     *Type:* 'float'

     *Definition:* 'float lw6gui_look_s::dynamic_zoom'

     Dynamic zoom, this is multiplicated by the map zoom, and gives the
     global zoom, the one finally used.

 -- Member of lw6gui_look_s: gfx_quality
     *Type:* 'int'

     *Definition:* 'int lw6gui_look_s::gfx_quality'

     Overall graphics quality, the higher the better, will trigger
     various parameters, depending on the renderer.

 -- Member of lw6gui_look_s: style
     *Type:* 'lw6map_style_t'

     *Definition:* 'lw6map_style_t lw6gui_look_s::style'

     A style structure which will override the one from the map,
     depending on the local options (config file, environnement,
     command-line options).

 -- Struct: lw6gui_menuitem_s

     Menu item object.  Basically, a menu is an array of these items,
     it's up to the gfx backend to render this as accurately as
     possible.  The most important field is probably the label.

 -- Member of lw6gui_menuitem_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6gui_menuitem_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6gui_menuitem_s: label
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menuitem_s::label'

     What is displayed in the menu item.

 -- Member of lw6gui_menuitem_s: tooltip
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menuitem_s::tooltip'

     An additionnal tooltip explaining what the item is about.

 -- Member of lw6gui_menuitem_s: value
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::value'

     The value for this item, can typically be used for booleans and
     integer values, in addition to the information conveyed by the
     label.  One special case is colored items, in that case the value
     will be used as a color index.

 -- Member of lw6gui_menuitem_s: enabled
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::enabled'

     Wether the item is valid and can be used.

 -- Member of lw6gui_menuitem_s: selected
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::selected'

     Wether the item is the current selection.

 -- Member of lw6gui_menuitem_s: colored
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::colored'

     Wether to colorize the item, and in that case, use the value field
     to know which color to use.

 -- Member of lw6gui_menuitem_s: last_change
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::last_change'

     Timestamp of last time the menu item was updated and changed.

 -- Member of lw6gui_menuitem_s: last_select
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::last_select'

     Timestamp of last time the menu was selected.

 -- Member of lw6gui_menuitem_s: last_unselect
     *Type:* 'int'

     *Definition:* 'int lw6gui_menuitem_s::last_unselect'

     Timestamp of last time the menu was unselected.

 -- Struct: lw6gui_menu_s

     Menu item object.  Basically, a menu is an array of menu items,
     it's up to the gfx backend to render this as accurately as
     possible.  The most important field is probably the items labels.
     The menu object also stores state information such as what was the
     first item displayed lately.

 -- Member of lw6gui_menu_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6gui_menu_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6gui_menu_s: title
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menu_s::title'

     Title of the menu, used for breadcrumbs.

 -- Member of lw6gui_menu_s: help
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menu_s::help'

     Additionnal help text, explaining what the menu is about.

 -- Member of lw6gui_menu_s: popup
     *Type:* 'char *'

     *Definition:* 'char* lw6gui_menu_s::popup'

     Popup text, will be displayed when the menu is first displayed, and
     then disappear.

 -- Member of lw6gui_menu_s: nb_items
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::nb_items'

     Number of items.

 -- Member of lw6gui_menu_s: esc_item
     *Type:* 'lw6gui_menuitem_t *'

     *Definition:* 'lw6gui_menuitem_t* lw6gui_menu_s::esc_item'

     Special item describing the ESC button.

 -- Member of lw6gui_menu_s: items
     *Type:* 'lw6gui_menuitem_t **'

     *Definition:* 'lw6gui_menuitem_t** lw6gui_menu_s::items'

     Array of items, containing all the menu items.

 -- Member of lw6gui_menu_s: selected_item
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::selected_item'

     The current selection.

 -- Member of lw6gui_menu_s: first_item_displayed
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::first_item_displayed'

     The first item displayed, this is mandatory if we want the menus to
     be displayable in different states, for instance with first item
     being 2 and items displayed from 2 to 10 or with first item being 5
     and items displayed from 2 to 10.  In the first case the 1st item
     is selected, in the second case it's the 4th.

 -- Member of lw6gui_menu_s: nb_items_displayed
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::nb_items_displayed'

     Number of items displayed.

 -- Member of lw6gui_menu_s: order_of_selected_on_display
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::order_of_selected_on_display'

     Index, display-based (that is, 0 here means first displayed and not
     necessarly first in the items array), of the selected item.

 -- Member of lw6gui_menu_s: allow_scroll
     *Type:* 'int'

     *Definition:* 'int lw6gui_menu_s::allow_scroll'

     Wether scrolling is allowed.

 -- Member of lw6gui_menu_s: breadcrumbs
     *Type:* 'lw6sys_list_t *'

     *Definition:* 'lw6sys_list_t* lw6gui_menu_s::breadcrumbs'

     List of strings containing the breadcrumbs, that is to say all the
     menu titles that one must use to get here.

 -- Struct: lw6gui_mouse_pointer_s

     Use to store mouse pointer information.

 -- Member of lw6gui_mouse_pointer_s: pos_x
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_pointer_s::pos_x'

     Mouse X position (pixels).

 -- Member of lw6gui_mouse_pointer_s: pos_y
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_pointer_s::pos_y'

     Mouse Y position (pixels).

 -- Member of lw6gui_mouse_pointer_s: speed_x
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_pointer_s::speed_x'

     Mouse X speed.  The unit is pixels per second.  This is based on
     the last move, for instance if between two moves 100 msec have
     elapsed, and mouse moved 13 pixels, then speed is 130.

 -- Member of lw6gui_mouse_pointer_s: speed_y
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_pointer_s::speed_y'

     Mouse Y speed.  The unit is pixels per second.  This is based on
     the last move, for instance if between two moves 100 msec have
     elapsed, and mouse moved 13 pixels, then speed is 130.

 -- Struct: lw6gui_mouse_s

     Mouse information, contains detailed mouse state, including mouse
     position and button states but also keeps track of mouse speed as
     well as its corresponding map coordinates.  That is, given the
     current screen position, what does it mean on the logical
     map/battlefield.

 -- Member of lw6gui_mouse_s: moved
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_s::moved'

     Wether mouse was moved lately.  1 means yes, 0 no.

 -- Member of lw6gui_mouse_s: last_moved
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_mouse_s::last_moved'

     Timestamp of last move.

 -- Member of lw6gui_mouse_s: screen_pointer
     *Type:* 'lw6gui_mouse_pointer_t'

     *Definition:* 'lw6gui_mouse_pointer_t
     lw6gui_mouse_s::screen_pointer'

     Information about the mouse pointer, using screen coordinates, the
     unit being pixels.

 -- Member of lw6gui_mouse_s: map_pointer
     *Type:* 'lw6gui_mouse_pointer_t'

     *Definition:* 'lw6gui_mouse_pointer_t lw6gui_mouse_s::map_pointer'

     Information about the mouse pointer, using map coordinates, the
     unit being the map slot.  This is possibly very different from
     screen coordinates, they can be inverted, have a different scale,
     and globally it's just something else, even if it refers to the
     same physical move.

 -- Member of lw6gui_mouse_s: screen_drag_start
     *Type:* 'lw6gui_mouse_pointer_t'

     *Definition:* 'lw6gui_mouse_pointer_t
     lw6gui_mouse_s::screen_drag_start'

     Information about the mouse pointer when drag mode was entered.
     The unit is screen pixels.

 -- Member of lw6gui_mouse_s: drag_mode
     *Type:* 'lw6gui_drag_mode_t'

     *Definition:* 'lw6gui_drag_mode_t lw6gui_mouse_s::drag_mode'

     The current drag state.

 -- Member of lw6gui_mouse_s: menu_position
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_s::menu_position'

     The index of the menu item the mouse is on.  This is the only was
     to know when to select an item, one should not use mouse coords
     outside the gfx renderer code for this purpose, it's the renderer
     which has knowledge about where menu items are.

 -- Member of lw6gui_mouse_s: menu_scroll
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_s::menu_scroll'

     Set to -1 if one needs to scroll up (decrease menu index) to +1 if
     one needs to scroll down (increase menu index) and 0 if one needs
     to do nothing as far as scrolling is concerned.

 -- Member of lw6gui_mouse_s: menu_esc
     *Type:* 'int'

     *Definition:* 'int lw6gui_mouse_s::menu_esc'

     Wether mouse pointer is over the ESC button.

 -- Member of lw6gui_mouse_s: button_left
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::button_left'

     Mouse left button state.

 -- Member of lw6gui_mouse_s: button_right
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::button_right'

     Mouse right button state.

 -- Member of lw6gui_mouse_s: button_middle
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::button_middle'

     Mouse middle button state.

 -- Member of lw6gui_mouse_s: wheel_up
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::wheel_up'

     Mouse wheel up state.

 -- Member of lw6gui_mouse_s: wheel_down
     *Type:* 'lw6gui_button_t'

     *Definition:* 'lw6gui_button_t lw6gui_mouse_s::wheel_down'

     Mouse wheel down state.

 -- Struct: lw6gui_move_pad_s

     Standard interface for joypad-like interfaces, can also be used to
     map keyboard arrows.

 -- Member of lw6gui_move_pad_s: up
     *Type:* 'int'

     *Definition:* 'int lw6gui_move_pad_s::up'

     Up button (boolean).

 -- Member of lw6gui_move_pad_s: down
     *Type:* 'int'

     *Definition:* 'int lw6gui_move_pad_s::down'

     Down button (boolean).

 -- Member of lw6gui_move_pad_s: left
     *Type:* 'int'

     *Definition:* 'int lw6gui_move_pad_s::left'

     Left button (boolean).

 -- Member of lw6gui_move_pad_s: right
     *Type:* 'int'

     *Definition:* 'int lw6gui_move_pad_s::right'

     Right button (boolean).

 -- Struct: lw6gui_point_s

     Basic point type, 3 floating point coords.

 -- Member of lw6gui_point_s: x
     *Type:* 'float'

     *Definition:* 'float lw6gui_point_s::x'

     X position.

 -- Member of lw6gui_point_s: y
     *Type:* 'float'

     *Definition:* 'float lw6gui_point_s::y'

     Y position.

 -- Member of lw6gui_point_s: z
     *Type:* 'float'

     *Definition:* 'float lw6gui_point_s::z'

     Z position.

 -- Struct: lw6gui_quad_s

     Basic quad type, composed of 4 points (floating point values).

 -- Member of lw6gui_quad_s: p1
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_quad_s::p1'

     1st point.

 -- Member of lw6gui_quad_s: p2
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_quad_s::p2'

     2nd point.

 -- Member of lw6gui_quad_s: p3
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_quad_s::p3'

     3rd point.

 -- Member of lw6gui_quad_s: p4
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_quad_s::p4'

     4th point.

 -- Struct: lw6gui_rect_array_s

     Array of rectangles.  This is typically used to make tiles that
     overlap.  It's mostly used to display fighters/maps using multiple
     textures when the whole stuff does not fit in one single OpenGL
     texture and needs to be splitted.  Technically, when one needs to
     split textures, performance is poor, but still better than relying
     on software renderer only.

 -- Member of lw6gui_rect_array_s: source
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6gui_rect_array_s::source'

     Size of original source data.

 -- Member of lw6gui_rect_array_s: limits
     *Type:* 'lw6gui_rect_t'

     *Definition:* 'lw6gui_rect_t lw6gui_rect_array_s::limits'

     Boundary limits of the rect array, this is typically bigger that
     source size, it starts at negative values and finishes outside the
     source.  It's interesting to cover that big an area to enable both
     the water effect and proper wrapping/clamping.

 -- Member of lw6gui_rect_array_s: tile_size
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::tile_size'

     Width and height of the tiles, this is typically a power of two, as
     it's designed to match an OpenGL low-level texture object.

 -- Member of lw6gui_rect_array_s: border_size
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::border_size'

     The border size one needs to cut from the tile_size (on both sides,
     up and down or left and right) to get the real usable size of the
     tile.

 -- Member of lw6gui_rect_array_s: tile_spacing
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::tile_spacing'

     The tile spacing, difference of X or Y between two tiles, this is
     typically smaller that tile_size.

 -- Member of lw6gui_rect_array_s: nb_tiles_w
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::nb_tiles_w'

     Number of tiles on the X axis (width).

 -- Member of lw6gui_rect_array_s: nb_tiles_h
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::nb_tiles_h'

     Number of tiles on the Y axis (height).

 -- Member of lw6gui_rect_array_s: nb_tiles
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_array_s::nb_tiles'

     Overall number of tiles.

 -- Struct: lw6gui_rect_s

     A basic rectangle data.  The idea is to store both corner positions
     and width and height to cache the values and avoid always
     recalculating them.  Values are integer based, for a floating point
     equivalent, see the zone struct.

 -- Member of lw6gui_rect_s: x1
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::x1'

     Top-left corner X position.

 -- Member of lw6gui_rect_s: y1
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::y1'

     Top-left corner Y position.

 -- Member of lw6gui_rect_s: x2
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::x2'

     Bottom-right corner X position.

 -- Member of lw6gui_rect_s: y2
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::y2'

     Bottom-right corner Y position.

 -- Member of lw6gui_rect_s: w
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::w'

     Width.

 -- Member of lw6gui_rect_s: h
     *Type:* 'int'

     *Definition:* 'int lw6gui_rect_s::h'

     Height.

 -- Struct: lw6gui_repeat_settings_s

     Parameters used to handle repeat.  This is used both by keys and
     buttons (joystick buttons and mouse buttons).

 -- Member of lw6gui_repeat_settings_s: delay
     *Type:* 'int'

     *Definition:* 'int lw6gui_repeat_settings_s::delay'

     Delay, in milliseconds, after which a given key/button enters
     repeat mode.

 -- Member of lw6gui_repeat_settings_s: interval
     *Type:* 'int'

     *Definition:* 'int lw6gui_repeat_settings_s::interval'

     Interval, in milliseconds, between two key/button press events in
     repeat mode.

 -- Member of lw6gui_repeat_settings_s: double_click_delay
     *Type:* 'int'

     *Definition:* 'int lw6gui_repeat_settings_s::double_click_delay'

     If pressed twice within this delay (in milliseconds) then a
     double-click event is generated.

 -- Member of lw6gui_repeat_settings_s: auto_release_delay
     *Type:* 'int'

     *Definition:* 'int lw6gui_repeat_settings_s::auto_release_delay'

     After this delay (milliseconds) any key will be considered be
     unpressed, that is, it will be released automatically.  This is
     usefull when the input library (depends on the gfx backend) does
     not send proper "key up" events.  The workarround is to
     automatically consider the key is released after some time.
     Usually, this would typically be set just below the repeat delay.

 -- Struct: lw6gui_segment_s

     Basic segment type, composed of 2 points (floating point values).

 -- Member of lw6gui_segment_s: p1
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_segment_s::p1'

     1st point.

 -- Member of lw6gui_segment_s: p2
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_segment_s::p2'

     2nd point.

 -- Struct: lw6gui_smoother_s

     Statefull object used to make transitions between 2 floats.
     Basically, one needs to choose a target, which is y2, and give a
     start, which is defined by s1 and y1 (speed and y value).  Then
     with t1 (start timestamp) and duration the object has functions
     which enables interpolation between those two values, knowing at
     the end the value will be y2 and the speed 0.  To some extent, this
     is a primitive bezier-like tool.

 -- Member of lw6gui_smoother_s: s1
     *Type:* 'float'

     *Definition:* 'float lw6gui_smoother_s::s1'

     Speed at startup.

 -- Member of lw6gui_smoother_s: y1
     *Type:* 'float'

     *Definition:* 'float lw6gui_smoother_s::y1'

     Y value at startup.

 -- Member of lw6gui_smoother_s: y2
     *Type:* 'float'

     *Definition:* 'float lw6gui_smoother_s::y2'

     Y target value.

 -- Member of lw6gui_smoother_s: t1
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6gui_smoother_s::t1'

     Timestamp at startup.

 -- Member of lw6gui_smoother_s: duration
     *Type:* 'int'

     *Definition:* 'int lw6gui_smoother_s::duration'

     Duration (in milliseconds) of the transition.

 -- Struct: lw6gui_triangle_s

     Basic triangle type, composed of 3 points (floating point values).

 -- Member of lw6gui_triangle_s: p1
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_triangle_s::p1'

     1st point.

 -- Member of lw6gui_triangle_s: p2
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_triangle_s::p2'

     2nd point.

 -- Member of lw6gui_triangle_s: p3
     *Type:* 'lw6gui_point_t'

     *Definition:* 'lw6gui_point_t lw6gui_triangle_s::p3'

     3rd point.

 -- Struct: lw6gui_video_mode_s

     Contains the parameters for a video mode, regardless of driver
     used.

 -- Member of lw6gui_video_mode_s: width
     *Type:* 'int'

     *Definition:* 'int lw6gui_video_mode_s::width'

     Width, in pixels.

 -- Member of lw6gui_video_mode_s: height
     *Type:* 'int'

     *Definition:* 'int lw6gui_video_mode_s::height'

     Height, in pixels.

 -- Member of lw6gui_video_mode_s: fullscreen
     *Type:* 'int'

     *Definition:* 'int lw6gui_video_mode_s::fullscreen'

     1 for fullscreen mode, 0 for windowed mode.

 -- Struct: lw6gui_viewport_s

     Macro object used to store viewport information.  Viewport here
     means "what part of the map should we display, on which part of the
     screen, and with which parameters".

 -- Member of lw6gui_viewport_s: map_shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6gui_viewport_s::map_shape'

     Shape of the map to display, unit is map slot.

 -- Member of lw6gui_viewport_s: screen_shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6gui_viewport_s::screen_shape'

     Shape of the screen, unit is pixels.

 -- Member of lw6gui_viewport_s: center_x
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::center_x'

     X coord of the point we want to display at the center of the
     screen.  This is typically our main cursor if we're using the
     keyboard to move it.  Unit is map slot.

 -- Member of lw6gui_viewport_s: center_y
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::center_y'

     Y coord of the point we want to display at the center of the
     screen.  This is typically our main cursor if we're using the
     keyboard to move it.  Unit is map slot.

 -- Member of lw6gui_viewport_s: old_center_x
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::old_center_x'

     Previous X coord of the point we wanted to display at the center of
     the screen.  This is typically our main cursor if we're using the
     keyboard to move it.  Unit is map slot.

 -- Member of lw6gui_viewport_s: old_center_y
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::old_center_y'

     Previous Y coord of the point we wanted to display at the center of
     the screen.  This is typically our main cursor if we're using the
     keyboard to move it.  Unit is map slot.

 -- Member of lw6gui_viewport_s: speed_x
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::speed_x'

     Speed at which the viewport is moving on the X axis, unit is map
     slot per second.

 -- Member of lw6gui_viewport_s: speed_y
     *Type:* 'float'

     *Definition:* 'float lw6gui_viewport_s::speed_y'

     Speed at which the viewport is moving on the Y axis, unit is map
     slot per second.

 -- Member of lw6gui_viewport_s: x_polarity
     *Type:* 'int'

     *Definition:* 'int lw6gui_viewport_s::x_polarity'

     X-polarity parameter (1=on, 0=off, -1=invert).

 -- Member of lw6gui_viewport_s: y_polarity
     *Type:* 'int'

     *Definition:* 'int lw6gui_viewport_s::y_polarity'

     Y-polarity parameter (1=on, 0=off, -1=invert).

 -- Member of lw6gui_viewport_s: x_wrap
     *Type:* 'int'

     *Definition:* 'int lw6gui_viewport_s::x_wrap'

     Wether to wrap map on the X axis.

 -- Member of lw6gui_viewport_s: y_wrap
     *Type:* 'int'

     *Definition:* 'int lw6gui_viewport_s::y_wrap'

     Wether to wrap map on the Y axis.

 -- Member of lw6gui_viewport_s: drawable
     *Type:* 'lw6gui_zone_t'

     *Definition:* 'lw6gui_zone_t lw6gui_viewport_s::drawable'

     Drawable zone, this is the physical on-screen viewport.  Unit is
     pixels.

 -- Member of lw6gui_viewport_s: map_main
     *Type:* 'lw6gui_zone_t'

     *Definition:* 'lw6gui_zone_t lw6gui_viewport_s::map_main'

     Zone corresponding to the map, if it was to be drawn as a whole,
     regardless of drawable size, wrapping and polarity.

 -- Member of lw6gui_viewport_s: map_main_clipped
     *Type:* 'lw6gui_zone_t'

     *Definition:* 'lw6gui_zone_t lw6gui_viewport_s::map_main_clipped'

     Zone corresponding to the map, only the main map, ignoring wrapping
     and polarity, but clipped with drawable zone.

 -- Member of lw6gui_viewport_s: map_visible
     *Type:* 'lw6gui_zone_t'

     *Definition:* 'lw6gui_zone_t lw6gui_viewport_s::map_visible'

     Actual visible zone of the map, including wrapping, polarity, and
     drawable clip aware.

 -- Struct: lw6gui_zone_s

     A basic rectangle data.  The idea is to store both corner positions
     and width and height to cache the values and avoid always
     recalculating them.  Values are float based, for an integer point
     equivalent, see the rect struct.

 -- Member of lw6gui_zone_s: x1
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::x1'

     Top-left corner X position.

 -- Member of lw6gui_zone_s: y1
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::y1'

     Top-left corner Y position.

 -- Member of lw6gui_zone_s: x2
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::x2'

     Bottom-right corner X position.

 -- Member of lw6gui_zone_s: y2
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::y2'

     Bottom-right corner Y position.

 -- Member of lw6gui_zone_s: w
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::w'

     Width.

 -- Member of lw6gui_zone_s: h
     *Type:* 'float'

     *Definition:* 'float lw6gui_zone_s::h'

     Height.

5.27 libhlp
===========

5.27.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/hlp/index.html>.

5.27.2 API
----------

 -- Function: int lw6hlp_is_documented (lw6sys_context_t * SYS_CONTEXT,
          const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want to check out

     Checks wether a given keyword is documented or not.

     *Return value:* 1 if documented, 0 if not.

 -- Function: const char * lw6hlp_about (lw6sys_context_t * SYS_CONTEXT,
          lw6hlp_type_t * TYPE, const char ** DEFAULT_VALUE, int *
          MIN_VALUE, int * MAX_VALUE, const char * KEYWORD)
     SYS_CONTEXT: global system context

     TYPE: the type of the data associated to the keyword, will be
     written

     DEFAULT_VALUE: the default value for the keyword, will be written

     MIN_VALUE: the min value for the keyword, will be written

     MAX_VALUE: the max value for the keyword, will be written

     KEYWORD: the keyword we want help about

     Returns the documentation string associated to a keyword.  The
     keyword might be a command-line option, a Guile function, an XML
     file entry.  Raises a warning if the keyword is undocumented, but
     never returns NULL, you can use the returned value without checking
     it.  String is localized if a translation is available.  It's safe
     to call this function with type or other parameters being NULL.

     *Return value:* a help string, never NULL, must not be freed.
     Additionnally, type will be updated.

 -- Function: lw6hlp_type_t lw6hlp_get_type (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want the type of

     Returns the type of a keyword.  Calls lw6hlp_about internally.

     *Return value:* the type, might be LW6HLP_TYPE_VOID.

 -- Function: const char * lw6hlp_get_default_value (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want the default for

     Returns the default value for a keyword.  Note that it can be NULL!
     The returned value is always a string, it's suitable to store in
     the config file, it's the value a user would pass on a command
     line, the one he wants documented.

     *Return value:* a pointer, which can be NULL, must not be freed.

 -- Function: int lw6hlp_get_min_value (lw6sys_context_t * SYS_CONTEXT,
          const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want the min for

     Returns the min value for a keyword.  Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:* the value (integer)

 -- Function: int lw6hlp_get_max_value (lw6sys_context_t * SYS_CONTEXT,
          const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword we want the max for

     Returns the max value for a keyword.  Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:* the value (integer)

 -- Function: char * lw6hlp_get_credits (lw6sys_context_t * SYS_CONTEXT,
          int ID)
     SYS_CONTEXT: global system context

     ID: the id of the credits line to return

     Returns a "credit line", that is a short sentence, about 30 to 50
     chars, saying who developped the game, created graphics, giving
     important URLs, and so on.  One can pass an arbitraty high 'id', no
     risk, it will just loop on previous lines.

     *Return value:* the string, must be freed.

 -- Function: int lw6hlp_match (lw6sys_context_t * SYS_CONTEXT, const
          char * KEYWORD1, const char * KEYWORD2)
     SYS_CONTEXT: global system context

     KEYWORD1: the 1st keyword

     KEYWORD2: the 2nd keyword

     Checks wether a keyword matches another.  Not only a string
     comparison, will also try and guess if the error is only about dash
     "-" replaced by underscode "_", for instance.

     *Return value:* 1 if matches, 0 if different.

 -- Function: lw6sys_list_t * lw6hlp_list_quick (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning quick options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_doc (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning self-documentation system.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_show (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the show options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_path (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the path options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_players (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the players options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_input (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the input options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_graphics (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the graphics options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_sound (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the sound options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_network (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the network options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the map options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_rules (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the rules options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_hints (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the hints options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_style (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the style options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_teams (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning the teams options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_funcs (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of C-function exported to Guile.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_hooks (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of hooks.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_advanced (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of keywords concerning advanced options.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_aliases (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of command-line aliases.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_team_colors (lw6sys_context_t
          * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of team_colors.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_weapons (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of weapons.

     *Return value:* list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of all available keywords.

     *Return value:* list of static strings (can't modify them)

 -- Function: int lw6hlp_process_non_run_options (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, int * RUN_GAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line args, as passed to main

     ARGV: an array of strings containing command-line args, as passed
     to main

     RUN_GAME: a pointer to a boolean which will contain true (1) if the
     game must be launched, or false (0) if the option is such that game
     must be skipped.  Example: -copyright, -help, ...

     Will interpret the command-line arguments, and trap those who are
     related to docs, this is usefull when building the game, we want to
     have an extra binary to do this without being linked to SDL, for
     instance.

     *Return value:* non-zero if success, 0 if error.  The error can be,
     for instance, the test suite returning "no, tests were not OK".

 -- Function: void lw6hlp_print_keyword (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST, FILE * F)
     SYS_CONTEXT: global system context

     LIST: a pointer to a list of keywords

     F: the file to print the content to

     Prints all the keywords from the list.  One keyword per line.

     *Return value:* none.

 -- Function: void lw6hlp_print_content (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST, FILE * F)
     SYS_CONTEXT: global system context

     LIST: a pointer to a list of keywords

     F: the file to print the content to

     Prints all the keywords from the list, with the associated keyword
     help, to the given file.  Output is formatted to fit on the
     standard terminal/console.

     *Return value:* none.

 -- Function: void lw6hlp_print_about (lw6sys_context_t * SYS_CONTEXT,
          const char * KEYWORD, FILE * F)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword to print help about

     F: the file to print the content to

     Displays the help about a keyword, to a file, directly.  It's
     formatted for the purpose of the -about=<value> option.

     *Return value:* none

 -- Function: void lw6hlp_print_help (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays a short help message.

     *Return value:* none

 -- Function: void lw6hlp_print_version (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the version of the game.

     *Return value:* none

 -- Function: void lw6hlp_print_short_copyright (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the copyright of the game (short version).

     *Return value:* none

 -- Function: void lw6hlp_print_long_copyright (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the copyright of the game (long version).

     *Return value:* none

 -- Function: void lw6hlp_print_bench (lw6sys_context_t * SYS_CONTEXT,
          float BENCH_RESULT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the program bench value.

     *Return value:* none

 -- Function: void lw6hlp_print_pedigree (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the program pedigree, think of this as version on
     steroids.

     *Return value:* none

 -- Function: void lw6hlp_print_host (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the host on which the program was compiled.

     *Return value:* none

 -- Function: void lw6hlp_print_audit (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays various paths used by the game.

     *Return value:* none

 -- Function: void lw6hlp_print_modules (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of modules compiled with the game.

     *Return value:* none

 -- Function: void lw6hlp_print_credits (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays all credits on f, those should be available elsewhere
     within the game (typically on splash screen) but it's good to be
     able to show them "standalone".

     *Return value:* none

 -- Function: void lw6hlp_print_list_quick (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'quick' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_doc (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'doc' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_show (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'show' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_path (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'path' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_players (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'players' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_input (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'input' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_graphics (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'graphics' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_sound (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'sound' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_network (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'network' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map_rules (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map rules' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map_hints (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map hints' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map_style (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map style' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_map_teams (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'map teams' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_funcs (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'funcs'.

     *Return value:* none

 -- Function: void lw6hlp_print_list_hooks (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'hooks'.

     *Return value:* none

 -- Function: void lw6hlp_print_list_advanced (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of 'advanced' options.

     *Return value:* none

 -- Function: void lw6hlp_print_list_aliases (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of options aliases.

     *Return value:* none

 -- Function: void lw6hlp_print_list_team_colors (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of team colors.

     *Return value:* none

 -- Function: void lw6hlp_print_list_weapons (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of weapons.

     *Return value:* none

 -- Function: void lw6hlp_print_list (lw6sys_context_t * SYS_CONTEXT,
          FILE * F)
     SYS_CONTEXT: global system context

     F: the file to print the content to

     Displays the list of all known options.

     *Return value:* none

 -- Function: void lw6hlp_print_hello (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: array of args as passed to main

     Displays 'hello' at the beginning of the program.

     *Return value:* none

 -- Function: void lw6hlp_print_goodbye (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Displays 'goodbye', typically use at end of program to know it's
     over and everything went fine.

     *Return value:* none

 -- Function: int lw6hlp_reference_init (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Initializes the help reference, this must be called before any call
     to lw6hlp_about or such help related functions.

     *Return value:* 1 on success, 0 if failed

 -- Function: void lw6hlp_reference_quit (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     un-initializes the help reference, this must be called at the end
     of the program.

     *Return value:* 1 on success, 0 if failed

 -- Function: int lw6hlp_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libhlp module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6hlp_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'hlp' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

5.28 libimg
===========

5.28.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/img/index.html>.

5.28.2 API
----------

 -- Function: char * lw6img_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6img_jpeg_t * JPEG)
     SYS_CONTEXT: global system context

     JPEG: the jpeg to describe

     Returns a string describing the jepg.  This is a very short
     description, use it for logs, and to debug stuff.  By no means it's
     a complete exhaustive description.  Still, the string returned
     should be unique.

     *Return value:* a dynamically allocated string.

 -- Function: lw6img_jpeg_t * lw6img_screenshot_new (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, char *
          USER_DIR, int QUALITY)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to create a screenshot from

     USER_DIR: user directory

     QUALITY: quality, from 0 to 100

     Creates a JPEG screenshot from a game state.  The 'user_dir'
     parameter is used to build a file name and then use it to write
     data on disk, it is then read and kept in memory.  Globally it's
     not that bad to store it for we do not generate screenshots that
     often, and it's nice for debugging to have it so developping a
     RAM-only writer wouldn't make it a blast anyway.

     *Return value:* dynamically allocated object.

 -- Function: void lw6img_screenshot_free (lw6sys_context_t *
          SYS_CONTEXT, lw6img_jpeg_t * SCREENSHOT)
     SYS_CONTEXT: global system context

     Frees a JPEG screenshot.

     *Return value:* none.

 -- Function: int lw6img_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libimg module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6img_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'img' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6img_jpeg_s

     Contains informations about a (loaded) JPEG file.

 -- Member of lw6img_jpeg_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6img_jpeg_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6img_jpeg_s: shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6img_jpeg_s::shape'

     JPEG file shape, only w and h are relevant.

 -- Member of lw6img_jpeg_s: jpeg_size
     *Type:* 'int'

     *Definition:* 'int lw6img_jpeg_s::jpeg_size'

     JPEG size (file size, same as data buffer size).

 -- Member of lw6img_jpeg_s: jpeg_data
     *Type:* 'void *'

     *Definition:* 'void* lw6img_jpeg_s::jpeg_data'

     JPEG raw data.

5.29 libker
===========

5.29.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/ker/index.html>.

5.29.2 API
----------

 -- Function: char * lw6ker_capture_str (lw6sys_context_t * SYS_CONTEXT,
          const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game state to represent

     Gives a string representation, an ASCII capture of the game.  This
     representation is suitable for debugging, typically print it to a
     VT100 console.

     *Return value:* dynamically allocated string.

 -- Function: void lw6ker_game_state_checksum_log_set_interval
          (lw6sys_context_t * SYS_CONTEXT, lw6ker_game_state_t *
          GAME_STATE, int CHECKSUM_LOG_INTERVAL)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to track

     CHECKSUM_LOG_INTERVAL: dump interval, if 0, feature is disabled

     Debugging function used to set automatically an interval at which
     engine will log a checksum automatically.  This is typically to
     track down where and when there starts to be a difference between
     two game_states that have evolved separately.

     *Return value:* none

 -- Function: void lw6ker_cursor_reset (lw6sys_context_t * SYS_CONTEXT,
          lw6ker_cursor_t * CURSOR)
     SYS_CONTEXT: global system context

     CURSOR: the cursor to reset

     Sets a cursor to defaults (disabled).  This function will not touch
     the node_id and cursor_id fields, so you can call it on an already
     used cursor, it will stay usable.

     *Return value:* none

 -- Function: lw6ker_game_state_t * lw6ker_game_state_new
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_struct_t *
          GAME_STRUCT, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     GAME_STRUCT: game_struct use to construct the object

     PROGRESS: progress indicator

     Creates a game state from a game struct.  The game struct must be
     kept (never freed) while game_state is in use.

     *Return value:* newly created object.

 -- Function: void lw6ker_game_state_free (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the object to free

     Frees a game_state object, releases all required objects.  At this
     stage the map_struct must still be available.

     *Return value:* none

 -- Function: void lw6ker_game_state_point_to (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, const
          lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to modify

     GAME_STRUCT: the game_struct to point to

     This can be used when one makes a copy (dup) of a game struct and
     for some reason want the game_state to point on this new copy.  Of
     course you should make the game_state point to a game_struct that
     is identical to the one that was used to construct the object in
     the first place.  Use at your own risk.

     *Return value:* none

 -- Function: int lw6ker_game_state_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the approximative amount of memory taken by the object.

     *Return value:* number of bytes (approximation)

 -- Function: char * lw6ker_game_state_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Gives a readable representation of the object.

     *Return value:* newly allocated string, must be freed

 -- Function: int lw6ker_game_state_can_sync (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * DST, const
          lw6ker_game_state_t * SRC)
     SYS_CONTEXT: global system context

     DST: the destination game_state

     SRC: the source game_state

     Tells wether src and dst can be synced.  This is not a fool proof
     function but in most cases it will raise the error, use it to avoid
     blunders.  It just compares 'dst' and 'src' and tries to guess if
     they correspond to the same logical objects.

     *Return value:* 1 if they are syncable, 0 if not.

 -- Function: int lw6ker_game_state_sync (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * DST, const
          lw6ker_game_state_t * SRC)
     SYS_CONTEXT: global system context

     DST: the destination game_state

     SRC: the source game_state

     Fundamental function, used to carbon copy a game state to another,
     this is intensively used to keep too tracks of the game state, one
     most-up-to-date but probably wrong, the one we use to display on
     the screen, and one slightly outdated (or very outdated if network
     is slow) but that we're sure of, something 100% bullet proof we can
     rely on.

     *Return value:* 1 on success, 0 on error

 -- Function: lw6ker_game_state_t * lw6ker_game_state_dup
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to copy

     PROGRESS: progress indicator

     Dups (copy) a game_state object.  The newly created object points
     to the same game_struct but is an independant copy, you can play a
     whole different game on it.  In practice this is often used to
     create the game_state objects for anticipation in network games.

     *Return value:* newly created object

 -- Function: u_int32_t lw6ker_game_state_checksum (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Calculates the checksum of a game_state, this can be very usefull
     to make sure two states are identicall (prevent network errors
     and/or cheating).

     *Return value:* 32-bit checksum

 -- Function: void lw6ker_game_state_get_shape (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE,
          lw6sys_whd_t * SHAPE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     SHAPE: the shape (out param)

     Retrieves the shape (w*h*d)of the game_state.

     *Return value:* none.

 -- Function: int lw6ker_game_state_get_w (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Retrieves the width (shape.w) of the game_state.

     *Return value:* the width.

 -- Function: int lw6ker_game_state_get_h (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Retrieves the height (shape.h) of the game_state.

     *Return value:* the height.

 -- Function: int lw6ker_game_state_get_d (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_state.

     *Return value:* the depth.

 -- Function: int lw6ker_game_state_register_node (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act on

     NODE_ID: the id of the node to register

     Registers a node in the game, this must be done, else no action
     will be allowed (such as adding a cursor or moving it).  There's a
     limited number of nodes allowed, and ids must be unique.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_unregister_node (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act on

     NODE_ID: the id of the node to register

     Unregisters a node in the game, this must be done when a node
     leaves the game, it will free ressources and allow others to
     connect.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_node_exists (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     NODE_ID: the node to test

     Tells wether a node is present in a game.

     *Return value:* 1 if node is in game, 0 if not

 -- Function: int lw6ker_game_state_get_node_info (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int16_t
          NODE_ID, u_int32_t * LAST_COMMAND_ROUND)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     NODE_ID: the node to get info about

     LAST_COMMAND_ROUND: the last round for which a command was issued
     (out parameter)

     Queries information about a given node, mostly, what was the last
     round we got a command.

     *Return value:* 1 on success, 0 on error.

 -- Function: int lw6ker_game_state_add_cursor (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID, u_int16_t CURSOR_ID, int TEAM_COLOR)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     NODE_ID: the node issuing the command

     CURSOR_ID: the id of the cursor to add

     TEAM_COLOR: the color we wish

     Adds a cursor in a game.  Note that if there's already a cursor
     with that id, it will fail, and the color is only the color we
     wish, we might indeed be attributed another color on a successfull
     call.

     *Return value:* 1 on success, 0 on error.

 -- Function: int lw6ker_game_state_remove_cursor (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int64_t
          NODE_ID, u_int16_t CURSOR_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     NODE_ID: the node issuing the command

     CURSOR_ID: the id of the cursor to remove

     Removes a cursor from the game, corresponding teams will be removed
     if needed.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_cursor_exists (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, u_int16_t
          CURSOR_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     CURSOR_ID: the cursor to test

     Tells wether a cursor is present in the game.

     *Return value:* 1 if cursor exists, 0 if not.

 -- Function: int lw6ker_game_state_get_cursor (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE,
          lw6ker_cursor_t * CURSOR, u_int16_t CURSOR_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     CURSOR: the cursor data (out param)

     CURSOR_ID: the cursor to query

     Get a pointer on a given cursor, pointer is read-only.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6ker_game_state_get_cursor_by_index
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, lw6ker_cursor_t * CURSOR, int I)
     SYS_CONTEXT: global system context

     GAME_STATE: the game state to query

     CURSOR: the cursor (out param)

     I: the index

     Gets the cursor information, using its index.  This is usefull to
     walk the whole cursor without knowing their ids.  Pointer is
     read-only.

     *Return value:* none.

 -- Function: int lw6ker_game_state_set_cursor (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, lw6ker_cursor_t
          * CURSOR)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     CURSOR: the cursor

     Sets a cursor, that is, changes its position, this is pretty much
     anything we can do about a cursor except adding or removing it,
     just because of Liquid War very simple rules.  The passed pointer
     may be freed after the call, only the 'cursor_id', 'node_id', 'x',
     'y' and 'fire' fields are used, others are ignored.  More
     precisely, the 'enabled' will be ignored, it's not a valid way to
     add/remove teams.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6ker_game_state_team_exists (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          TEAM_COLOR)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     TEAM_COLOR: the team color to test

     Tells wether a team color is present in the game.  Note that this
     is different from cursor ids.

     *Return value:* 1 if team exists, 0 if not.

 -- Function: int lw6ker_game_state_get_team_info (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          TEAM_COLOR, int32_t * NB_CURSORS, int32_t * NB_FIGHTERS)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     TEAM_COLOR: the color to get informations about

     NB_CURSORS: number of cursors with this color (out param)

     NB_FIGHTERS: number of fighters with this color (out param)

     Gets informations about a given color.  Indeed, a color can have
     several cursors, and knowing how many fighters there are with a
     given color is probably the most important things about a color.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_get_nb_teams (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Tells how many teams there are in a game.  This is different from
     the cursors number, there can be more cursors than teams, because a
     team can have several cursors.

     *Return value:* the number of teams.

 -- Function: void lw6ker_game_state_do_spread (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int32_t
          TEAM_MASK)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     TEAM_MASK: a binary mask of which gradients (teams) must be
     spreaded

     Spreads the gradient, that is, calculates the potential of each
     point on the map, ie the distance to the closest cursor.  The
     binary mask allows gradient to be spread for only some teams, this
     is usefull in a multithreaded context, as gradients can be
     calculated separately.

     *Return value:* none

 -- Function: void lw6ker_game_state_do_move (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, u_int32_t
          TEAM_MASK)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     TEAM_MASK: a binary mask of which teams must be moved

     Moves the fighters, note that you must calculate the gradient from
     time to time else they go to the wrong places.  The 'team_mask'
     allows the moving of only some given teams, but moving (for
     instance) even teams then odd teams isn't the same as moving odd
     teams then even teams.  Whereas as far as gradient calculation is
     concerned, this could have been true, you could have multithreaded
     that.

     *Return value:* none.

 -- Function: void lw6ker_game_state_finish_round (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     Finishes a round, that is, vaccums various stuff, checks if some
     team has lost, and so on.  This is complementary to the spread and
     move steps, it should be called at each round.

     *Return value:* none.

 -- Function: void lw6ker_game_state_do_round (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to act upon

     This is a fundamental function, it's called at each round, it fires
     all the complex calculations in the game, the real core algorithm.
     Every time this function is called, the round is "over" and the
     game state is ready for the next...  round.  It's equivalent to
     calling the spread, move and finish functions.

     *Return value:* none.

 -- Function: u_int32_t lw6ker_game_state_get_moves (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the number of moves done on this game.

     *Return value:* number of moves.

 -- Function: u_int32_t lw6ker_game_state_get_spreads (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the number of spreads done on this game.

     *Return value:* number of spreads.

 -- Function: u_int32_t lw6ker_game_state_get_rounds (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the number of rounds done on this game.

     *Return value:* number of rounds.

 -- Function: u_int32_t lw6ker_game_state_get_total_rounds
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the number of playable rounds in the game, that is the
     number of rounds to be played if game goes up to the time limit.
     This is a fixed number, if game slows down then time is stretched,
     but the the exact maximum number of rounds is known at game start,
     and it is the number returned by this function.

     *Return value:* number of rounds in the game

 -- Function: int lw6ker_game_state_is_over (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Tells wether the game is over or not.  The answer depends on time
     limit, game rules, and of course what happened on the battlefield.

     *Return value:* 1 if over, 0 if not.

 -- Function: int lw6ker_game_state_did_cursor_win (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, u_int16_t
          CURSOR_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     CURSOR_ID: the cursor to test

     Tells wether a cursor was the winner after a game is over.

     *Return value:* 1 if cursor is in winning team, 0 if not.

 -- Function: int lw6ker_game_state_get_winner (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          EXCLUDED_TEAM)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     EXCLUDED_TEAM: a team to exclude

     Returns the winner, if you set excluded_team to something else than
     a valid team number (for instance -1, but 0 is a valid team) then
     this team will be excluded from search.  This is usefull if you
     want to find out who's the best positionned player while excluding
     yourself, for instance if you're a bot.

     *Return value:* the winner team number, note that it can be invalid
     (-1) if there's no winner (for example, there are no teams on the
     map).

 -- Function: int lw6ker_game_state_get_looser (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          EXCLUDED_TEAM)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     EXCLUDED_TEAM: a team to exclude

     Returns the looser, if you set excluded_team to something else than
     a valid team number (for instance -1, but 0 is a valid team) then
     this team will be excluded from search.  This is usefull if you
     want to find out who's the worst positionned player while excluding
     yourself, for instance if you're a bot.

     *Return value:* the looser team number, note that it can be invalid
     (-1) if there's no looser (for example, there are no teams on the
     map).

 -- Function: int32_t lw6ker_game_state_get_nb_active_fighters
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Gets the number of active fighters, this is relatively constant
     within the game, it does not change when someone looses, but it can
     vary when a new team arrives or disappears.

     *Return value:* number of fighters.

 -- Function: int32_t lw6ker_game_state_get_time_elapsed
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the time elapsed, this is not the real time you'd time with
     an atomic clock, rather the time that would have elapsed if game
     had been run at its nominal speed.  There can be a difference if
     your computer is too slow, among other things.

     *Return value:* time elapsed, in seconds.

 -- Function: int32_t lw6ker_game_state_get_time_left (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     Returns the time left, this is not the real time you'd time with an
     atomic clock, rather the time that would theorically be left is
     game was to be run at its nominal speed.  There can be a difference
     if your computer is too slow, among other things.  You shouldn't
     rely on this to know wether a game is over or not, there's another
     dedicated function for that.

     *Return value:* time left, in seconds.

 -- Function: int32_t lw6ker_game_state_get_global_history
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, int I, int TEAM_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     I: the index of the history point

     TEAM_ID: the team to query

     Returns the number of fighters at some point in the past (the lower
     i, the oldest).  The history scrolls automatically and erases
     itself at some point, it's of constant length.  This is the global,
     long term history, reflects the whole game and could be used for an
     end-game score screen.

     *Return value:* number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_latest_history
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, int I, int TEAM_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     I: the index of the history point

     TEAM_ID: the team to query

     Returns the number of fighters at some point in the past (the lower
     i, the oldest).  The history scrolls automatically and erases
     itself at some point, it's of constant length.  This is the latest,
     short term history, reflects the recent game evolutions and could
     be used to display an in-game monitor.

     *Return value:* number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_global_history_max
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     Returns the maximum value, that is, the maximum number of fighters,
     all teams combined, for this history.  This can be used to scale
     charts.  This function for the global long term history.

     *Return value:* max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_latest_history_max
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     Returns the maximum value, that is, the maximum number of fighters,
     all teams combined, for this history.  This can be used to scale
     charts.  This function for the latest short term history.

     *Return value:* max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_fighter_id (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets the id of a fighter in a given position.  Previous versions of
     the game used to have this declared inline static for speed, but
     the price to pay in terms of maintainability was too high: too much
     stuff from the ker module had to be kept public.  This functions is
     very likely to be called often when one wants to know what's
     happening on the battlefield, to draw it, for instance.  If there's
     no fighter, the id is negative, any id equal or greater than 0
     (returned by this function) is valid.

     *Return value:* the id of the fighter at that position.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_rw_by_id
          (lw6sys_context_t * SYS_CONTEXT, lw6ker_game_state_t *
          GAME_STATE, int32_t FIGHTER_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     FIGHTER_ID: the id of the fighter

     Gets a fighter by its id.  Internally, all fighters are stored in
     an array so it could be "safe" to get fighter with id 0 then walk
     the array.  Previous versions of the game used to have this public
     (the array), it has been hidden since.  Pointer is read/write.
     Pointer is read/write.

     *Return value:* pointer to the fighter with the given id.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_rw_safe
          (lw6sys_context_t * SYS_CONTEXT, lw6ker_game_state_t *
          GAME_STATE, int32_t X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets a fighter by its position.  This function will check for
     boundaries, if there's no fighter in this place, it will return
     NULL, but nothing worse can happen.  More precisely, if the place
     is in a wall, it won't bug, unlike the non-bullet-proof equivalent
     of this function.  Pointer is read/write.

     *Return value:* pointer to the fighter at this position, or NULL if
     none.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_rw_unsafe
          (lw6sys_context_t * SYS_CONTEXT, lw6ker_game_state_t *
          GAME_STATE, int32_t X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets a fighter by its position.  This function will not check for
     boundaries, if there's no fighter in this place, not only will it
     probably not return a valid value, but it will also even segfault
     before that, trying to access non-existing structures in menory.
     So only call this if you're sure there's a fighter here.  Pointer
     is read/write.

     *Return value:* pointer to the fighter at this position, or NULL if
     none.

 -- Function: const lw6ker_fighter_t *
          lw6ker_game_state_get_fighter_ro_by_id (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int32_t
          FIGHTER_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     FIGHTER_ID: the id of the fighter

     Gets a fighter by its id.  Internally, all fighters are stored in
     an array so it could be "safe" to get fighter with id 0 then walk
     the array.  Previous versions of the game used to have this public
     (the array), it has been hidden since.  Pointer is read-only.
     Pointer is read-only.

     *Return value:* pointer to the fighter with the given id.

 -- Function: const lw6ker_fighter_t *
          lw6ker_game_state_get_fighter_ro_safe (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets a fighter by its position.  This function will check for
     boundaries, if there's no fighter in this place, it will return
     NULL, but nothing worse can happen.  More precisely, if the place
     is in a wall, it won't bug, unlike the non-bullet-proof equivalent
     of this function.  Pointer is read-only.

     *Return value:* pointer to the fighter at this position, or NULL if
     none.

 -- Function: const lw6ker_fighter_t *
          lw6ker_game_state_get_fighter_ro_unsafe (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     X: x position

     Y: y position

     Z: z position

     Gets a fighter by its position.  This function will not check for
     boundaries, if there's no fighter in this place, not only will it
     probably not return a valid value, but it will also even segfault
     before that, trying to access non-existing structures in menory.
     So only call this if you're sure there's a fighter here.  Pointer
     is read-only.

     *Return value:* pointer to the fighter at this position, or NULL if
     none.

 -- Function: int lw6ker_game_state_get_zone_potential (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int I,
          int TEAM_ID)
     SYS_CONTEXT: global system context

     GAME_STATE: the game_state to query

     TEAM_ID: the team id (color)

     Gets the potential of a zone.  In practice this is not needed to
     make the game function, you need not call this to know how to move
     fighters, however the information can be interesting for debugging.

     *Return value:* the potential

 -- Function: int lw6ker_game_state_get_charge_per1000 (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int
          TEAM_COLOR)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     TEAM_COLOR: the team color to query

     Returns the charge ratio for a given team/color.  A value of 100
     means fire is enabled, more than 1000 means super-charge, under 100
     means you have to wait.

     *Return value:* integer value.

 -- Function: int lw6ker_game_state_get_weapon_per1000_left
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_state_t *
          GAME_STATE, int TEAM_COLOR)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     TEAM_COLOR: the team color to query

     Returns how much of the weapon is yet to be consumed for a given
     team.  More than 1000 means extra time, 1000 is standard time to be
     elapsed, 0 means it's over.

     *Return value:* integer value.

 -- Function: int lw6ker_game_state_get_latest_weapon (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE, int *
          TEAM_COLOR, int * WEAPON_ID, int * PER1000_LEFT)
     SYS_CONTEXT: global system context

     GAME_STATE: game_state to query

     TEAM_COLOR: the team color corresponding to last weapon (out param)

     WEAPON_ID: the corresponding weapon_id (out param)

     PER1000_LEFT: how much of the weapon is yet to be spent (out param)

     Returns informations about the latest weapon, this is typically for
     drawing purposes, just query this and you know if you need to paint
     everything in red, green, whatever, as far as the default backend
     is concerned.  In case there's no weapon, well, parameters are
     untouched.  Pointers can be passed as NULL.

     *Return value:* 1 if found, 0 if not.

 -- Function: int lw6ker_game_state_get_nb_colors (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game state to query

     Gives the max number of colors (AKA teams) that are present in the
     game.  This is just a simple utility/wrapper function which is
     meant to be exported to Guile scripts.

     *Return value:* number of colors

 -- Function: int lw6ker_game_state_get_nb_cursors (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game state to query

     Gives the max number of cursors that are present in the game.  This
     is just a simple utility/wrapper function which is meant to be
     exported to Guile scripts.

     *Return value:* number of cursors

 -- Function: int lw6ker_game_state_get_nb_nodes (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: game state to query

     Gives the max number of nodes that are present in the game.  This
     is just a simple utility/wrapper function which is meant to be
     exported to Guile scripts.

     *Return value:* number of nodes

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_new
          (lw6sys_context_t * SYS_CONTEXT, const lw6map_level_t * LEVEL,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     LEVEL: the level on which the game_struct is based

     PROGRESS: progress indicator

     Creates a new game_struct from a level.  The game_struct is
     different from the level in the sense that the game_struct does
     contain algorithmic specific optimizations, it's a ready-to-use
     struct desgined for execution speed, while the plain level just
     stores information.

     *Return value:* newly allocated object

 -- Function: void lw6ker_game_struct_free (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to free

     Frees a game_struct object, releasing all required stuff.  The
     source level must still be available when freeing this.

     *Return value:* none

 -- Function: void lw6ker_game_struct_point_to (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_struct_t * GAME_STRUCT, const
          lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to modify

     LEVEL: the level to point to

     This can be used when one makes a copy (dup) of a level and for
     some reason want the game_struct to point on this new copy.  Of
     course you should make the game_struct point to a level that is
     identical to the one that was used to construct the object in the
     first place.  Use at your own risk.

     *Return value:* none

 -- Function: int lw6ker_game_struct_memory_footprint (lw6sys_context_t
          * SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Returns the approximative amount of memory taken by the object.

     *Return value:* number of bytes (approximation)

 -- Function: char * lw6ker_game_struct_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Gives a readable representation of the object.

     *Return value:* newly allocated string, must be freed

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_dup
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_struct_t *
          GAME_STRUCT, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to copy

     PROGRESS: progress indicator

     Dups (copy) a game_struct object.  The newly created object points
     to the same game_struct but is an independant copy, you can play a
     whole different game on it.  In practice this is often used to
     create the game_struct objects for anticipation in network games.

     *Return value:* newly created object

 -- Function: u_int32_t lw6ker_game_struct_checksum (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Calculates the checksum of a game_struct, this can be very usefull
     to make sure two structs are identicall (prevent network errors
     and/or cheating).

     *Return value:* 32-bit checksum

 -- Function: void lw6ker_game_struct_get_shape (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT,
          lw6sys_whd_t * SHAPE)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     SHAPE: the shape (out param)

     Retrieves the shape (w*h*d)of the game_struct.

     *Return value:* none.

 -- Function: int lw6ker_game_struct_get_w (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Retrieves the width (shape.w) of the game_struct.

     *Return value:* the width.

 -- Function: int lw6ker_game_struct_get_h (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Retrieves the height (shape.h) of the game_struct.

     *Return value:* the height.

 -- Function: int lw6ker_game_struct_get_d (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_struct.

     *Return value:* the depth.

 -- Function: int lw6ker_game_struct_is_fg (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     X: x position

     Y: y position

     Z: z position

     Tests wether a given position is foreground, that is, occupied by a
     wall.

     *Return value:* 1 if foreground (wall, fighters can't move), 0 if
     not

 -- Function: int lw6ker_game_struct_is_bg (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     X: x position

     Y: y position

     Z: z position

     Tests wether a given position is background, that is, there's no
     wall.

     *Return value:* 1 if background (wall, fighters can move), 0 if not

 -- Function: void lw6ker_game_struct_get_zones_info (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int *
          NB_ZONES, int * MAX_ZONE_SIZE)
     SYS_CONTEXT: global system context

     GAME_STRUCT: game_struct to query

     NB_ZONES: the maximum zone size (out param, can be NULL)

     MAX_ZONE_SIZE: the maximum zone size (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:* none.

 -- Function: void lw6ker_game_struct_get_zone_info (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int I,
          lw6sys_xyz_t * ZONE_POS, int * ZONE_SIZE)
     SYS_CONTEXT: global system context

     GAME_STRUCT: game_struct to query

     I: index of the zone to query

     ZONE_POS: coord of the zone, top-left corner (out param, can be
     NULL)

     ZONE_SIZE: size of the zone (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:* none

 -- Function: int32_t lw6ker_game_struct_get_zone_id (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT, int32_t
          X, int32_t Y, int32_t Z)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     X: x pos

     Y: y pos

     Z: z pos

     Gets the zone id for a given position.  The id returned can then be
     used to query for a potential, for instance.

     *Return value:* the zone id

 -- Function: void lw6ker_game_struct_find_free_slot_near
          (lw6sys_context_t * SYS_CONTEXT, const lw6ker_game_struct_t *
          GAME_STRUCT, lw6sys_xyz_t * THERE, lw6sys_xyz_t HERE)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game_struct to query

     THERE: the closest free slot (out param)

     HERE: where we'd like to be

     Tries to find the closest free slot (there) near a given position
     (here).  This is typically used internally to find out where to
     apply the cursor when it's flying over walls.

     *Return value:* none

 -- Function: char * lw6ker_game_struct_to_hexa (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     GAME_STRUCT: the game struct to convert

     Converts a map to something that is later readable by
     'lw6ker_game_struct_from_hexa' to reproduce the exact same map.
     Just a serializer.

     *Return value:* a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_from_hexa
          (lw6sys_context_t * SYS_CONTEXT, const char * HEXA, const
          lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     HEXA: an hexadecimal ASCII string, created by
     'lw6ker_game_struct_to_hexa'

     LEVEL: the level this game_struct is bounded to

     Constructs a game struct from an hexadecimal string generated by
     'lw6ker_game_struct_to_hexa'.  Just an un-serializer.

     *Return value:* a new map, might be NULL if string isn't correct.

 -- Function: char * lw6ker_game_state_to_hexa (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game state to convert

     Converts a map to something that is later readable by
     'lw6ker_game_state_from_hexa' to reproduce the exact same map.
     Just a serializer.

     *Return value:* a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6ker_game_state_t * lw6ker_game_state_from_hexa
          (lw6sys_context_t * SYS_CONTEXT, const char * HEXA, const
          lw6ker_game_struct_t * GAME_STRUCT)
     SYS_CONTEXT: global system context

     HEXA: an hexadecimal ASCII string, created by
     'lw6ker_game_state_to_hexa'

     GAME_STRUCT: the game_struct this game_state is bounded to

     Constructs a game state from an hexadecimal string generated by
     'lw6ker_game_state_to_hexa'.  Just an un-serializer.

     *Return value:* a new map, might be NULL if string isn't correct.

 -- Function: int lw6ker_move_get_best_next_pos (lw6sys_context_t *
          SYS_CONTEXT, const lw6ker_game_state_t * GAME_STATE,
          lw6sys_xyz_t * NEXT_POS, lw6sys_xyz_t * CURRENT_POS, int
          TEAM_COLOR)
     GAME_STATE: the game_state to work on

     NEXT_POS: the next position (out param)

     CURRENT_POS: the current position

     TEAM_COLOR: the team color

     Tries to find the best move given a position and a team.  Note that
     this function does not check for the presence of another fighter,
     it will only check walls and can even (sometimes) fail when there's
     a path.  The reason is that it uses the game_state at a given round
     and does not recalculate gradient while a real fighter has an
     ever-changing gradient.  Whatsoever, this can be used to move
     cursors like they were fighters, it's not perfect but gives a good
     illusion.

     *Return value:* 1 if best place found, 0 if not.

 -- Function: int lw6ker_score_array_update (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_score_array_t * SCORE_ARRAY, const
          lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     SCORE_ARRAY: the score array to modify

     GAME_STATE: the game_state to get the information from

     Updates a score array, that is, calculates all scores, so that they
     can be displayed, for instance.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6ker_team_mask_get (lw6sys_context_t * SYS_CONTEXT,
          u_int32_t * EVEN, u_int32_t * ODD, int32_t ROUND)
     SYS_CONTEXT: global system context

     EVEN: even team mask (out param)

     ODD: odd team mask (out param)

     ROUND: round concerned

     Returns a default team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance).

     *Return value:* none.

 -- Function: void lw6ker_team_mask_best (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * EVEN, u_int32_t * ODD,
          lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     EVEN: even team mask (out param)

     ODD: odd team mask (out param)

     GAME_STATE: the game_state concerned

     Returns an optimal team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance).  The difference with the default team mask is that this
     one will test for which teams are present and try and manage to
     find an equilibrated set of odd/even teams.

     *Return value:* none.

 -- Function: int lw6ker_team_mask_is_concerned (lw6sys_context_t *
          SYS_CONTEXT, int TEAM_COLOR, u_int32_t TEAM_MASK)
     SYS_CONTEXT: global system context

     TEAM_COLOR: color index

     TEAM_MASK: team mask

     Tells wether a given team is concerned by a team mask.

     *Return value:* 1 if concerned, 0 if not.

 -- Function: int lw6ker_team_mask_color2mask (lw6sys_context_t *
          SYS_CONTEXT, int TEAM_COLOR)
     TEAM_COLOR: color index

     Gives the mask corresponding to a given color.

     *Return value:* bitwise mask.

 -- Function: int lw6ker_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libker module.  Thoses tests Will
     perform deep checksums and *really* check many things.  If this
     passes, the algorithm is fine.  What could make it fail is a
     serious bug and/or some weird combination of endianess, byte
     alignment...  *

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6ker_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'ker' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6ker_cursor_control_s

     Contains a cursor controls state, basically a cursor is a position
     plus a fire and fire2 booleans.

 -- Member of lw6ker_cursor_control_s: pos
     *Type:* 'lw6sys_xyz_t'

     *Definition:* 'lw6sys_xyz_t lw6ker_cursor_control_s::pos'

     Cursor position, z isn't relevant for now.

 -- Member of lw6ker_cursor_control_s: fire
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_control_s::fire'

     Fire, 1 if primary weapon must be used.

 -- Member of lw6ker_cursor_control_s: fire2
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_control_s::fire2'

     Fire2, 1 if secondary weapon must be used.

 -- Struct: lw6ker_cursor_s

     Data about a given cursor.

 -- Member of lw6ker_cursor_s: node_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6ker_cursor_s::node_id'

     The id of the node this cursor belongs to.

 -- Member of lw6ker_cursor_s: cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6ker_cursor_s::cursor_id'

     The id of this cursor.

 -- Member of lw6ker_cursor_s: letter
     *Type:* 'char'

     *Definition:* 'char lw6ker_cursor_s::letter'

     ASCII code of the letter associated to the cursor.

 -- Member of lw6ker_cursor_s: enabled
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_s::enabled'

     Wether the cursor is enabled/active or not.

 -- Member of lw6ker_cursor_s: team_color
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_s::team_color'

     Team associated with this cursor.

 -- Member of lw6ker_cursor_s: pos
     *Type:* 'lw6sys_xyz_t'

     *Definition:* 'lw6sys_xyz_t lw6ker_cursor_s::pos'

     Cursor position, z isn't relevant for now.

 -- Member of lw6ker_cursor_s: fire
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_s::fire'

     Primary fire button state.

 -- Member of lw6ker_cursor_s: fire2
     *Type:* 'int'

     *Definition:* 'int lw6ker_cursor_s::fire2'

     Alternate fire button state.

 -- Member of lw6ker_cursor_s: apply_pos
     *Type:* 'lw6sys_xyz_t'

     *Definition:* 'lw6sys_xyz_t lw6ker_cursor_s::apply_pos'

     Position to apply cursor on.  Problem follows: cursor might be
     hanging on a wall, somewhere fighters can't go.  In that case an
     alternate position is find, usually the closest free space.  But
     this can take time to calculate so we cache this value here, as it
     is convenient to have it at hand.

 -- Member of lw6ker_cursor_s: pot_offset
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_cursor_s::pot_offset'

     Potential offset.  Whenever the cursor is applied to some place,
     one can add a potential to it, this can be used to make some cursor
     more attractive than others.

 -- Struct: lw6ker_fighter_s

     Contains the parameters of a fighter, one of those little squares
     that are that at the very heart of Liquid War.

 -- Member of lw6ker_fighter_s: team_color
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6ker_fighter_s::team_color'

     Team color from 0 to 9, -1 if invalid.

 -- Member of lw6ker_fighter_s: last_direction
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_fighter_s::last_direction'

     Last direction this fighter used, this is important for in some
     cases we want to know where the fighter was heading before, our
     current choice might rely on previous state.

 -- Member of lw6ker_fighter_s: health
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_fighter_s::health'

     Fighter health from 0 to 10000.

 -- Member of lw6ker_fighter_s: act_counter
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_fighter_s::act_counter'

     This counter is used to handle speed up/slow down.  At each round
     it's incremented, whenever it reaches 100 then the fighter really
     acts.  Basically, there's a Bresenham algorithm behind all that.

 -- Member of lw6ker_fighter_s: pad
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6ker_fighter_s::pad'

     Free for later use.

 -- Member of lw6ker_fighter_s: pos
     *Type:* 'lw6sys_xyz_t'

     *Definition:* 'lw6sys_xyz_t lw6ker_fighter_s::pos'

     Fighter position.

 -- Struct: lw6ker_game_state_s

     Game structure containing all changeable data state, this will hold
     the fighter positions, their health, the cursors position, the
     gradient, anything that is dynamic.  Note that this structure is a
     wrapper over the internal structure which contains the real
     members, the first two members need be the same as it is casted
     internally.

 -- Member of lw6ker_game_state_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6ker_game_state_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6ker_game_state_s: game_struct
     *Type:* 'lw6ker_game_struct_t *'

     *Definition:* 'lw6ker_game_struct_t*
     lw6ker_game_state_s::game_struct'

     Pointer on the game non-mutable structure, which holds the data
     that is never changed within a game.

 -- Struct: lw6ker_game_struct_s

     Game struct is very similar to the level struct of the lw6map
     module.  Indeed, it's immutable and won't change during the game.
     The difference with lw6map_level is that game_struct is algorithm
     aware and has many tricks, special internals, cached data, so that
     it speeds up the overall algorithm.  In fact it contains everything
     lw6ker_game_state needs to have but need not change during the
     game.  The 3 first members, id, level, rules are the same as the
     internal _lw6ker_game_struct_t structure.  The rest of it is
     hidden.  The program will cast from lw6ker_game_struct_t to
     _lw6ker_game_struct_t internally.

 -- Member of lw6ker_game_struct_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6ker_game_struct_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6ker_game_struct_s: level
     *Type:* 'lw6map_level_t *'

     *Definition:* 'lw6map_level_t* lw6ker_game_struct_s::level'

     Pointer on the level source structure.  This one might still retain
     informations we don't want to duplicate here, for instance the
     textures, which are of no use for the core algorithm so are
     pointless to backup here, but are still of interest for high-level
     functions such as display stuff.

 -- Member of lw6ker_game_struct_s: rules
     *Type:* 'lw6map_rules_t'

     *Definition:* 'lw6map_rules_t lw6ker_game_struct_s::rules'

     Game rules, this is just a cached copy to avoid derefencing the
     level pointer any time we need to query a parameter.

 -- Struct: lw6ker_score_array_s

     This is an array which contains all scores for all teams, it's
     calculated from game_state and should be used read only by code
     which is not within lw6ker.

 -- Member of lw6ker_score_array_s: active_fighters
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_array_s::active_fighters'

     Number of fighters on the battlefield.

 -- Member of lw6ker_score_array_s: nb_scores
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_array_s::nb_scores'

     Number of score items.  This can be greater than the number of
     active teams, since it retains informations about teams which have
     disappeared.

 -- Member of lw6ker_score_array_s: scores
     *Type:* 'lw6ker_score_t'

     *Definition:* 'lw6ker_score_t
     lw6ker_score_array_s::scores[LW6MAP_NB_TEAM_COLORS]'

     Scores for each team, they are sorted, the first one with index 0
     is the current winner, then all other teams follow, the last one
     being Mr Looser.

 -- Struct: lw6ker_score_s

     Stores the score information about a team, this structure is used
     to get informations from the game, and display them.

 -- Member of lw6ker_score_s: has_been_active
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::has_been_active'

     Wether this team (this color) has been active at some point during
     the game.  This is important for at score time, many teams might
     have been disabled, this is typical of dead teams in the LW5 last
     player wins scheme.  It can also happen in network games after a
     team leaves.  Note that this way of counting active teams does not
     allow fine grain knowledge of who played, for the yellow team might
     have been played by different nodes through a single game session.

 -- Member of lw6ker_score_s: team_color
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::team_color'

     The color of the team this score is about.

 -- Member of lw6ker_score_s: fighters_percent
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::fighters_percent'

     Percentage of fighters for this team.  The global score array
     object will take care of making the sum of fighters_percent be
     exactly 100, regardless of exactitude, it will round this number to
     make a nice total and hide rounding errors.

 -- Member of lw6ker_score_s: fighters_absolute
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::fighters_absolute'

     Absolute number of fighters for this team.

 -- Member of lw6ker_score_s: fighters_ratio
     *Type:* 'float'

     *Definition:* 'float lw6ker_score_s::fighters_ratio'

     One of the rare float in lw6ker, only for eye candy, this is the
     equivalent of fighters_percent but as a float between 0.0f and
     1.0f.  It gives the possibility of more precise graphical displays,
     will its integer companion value is usefull for writing down
     scores.

 -- Member of lw6ker_score_s: frags
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::frags'

     Number of frags.  Note that depending on game rules, this can have
     very different meanings.

 -- Member of lw6ker_score_s: consolidated_percent
     *Type:* 'int'

     *Definition:* 'int lw6ker_score_s::consolidated_percent'

     OK, this is probably the most non-intuitive number but still the
     most usefull.  It will show a percentage that is greater as we
     estimate the team in a stronger position.  For instance, it can be
     higher if the team has very few fighters on the field but has a
     great number of frags.  The one who has the greatest number here is
     the winner.

5.30 libldr
===========

5.30.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/ldr/index.html>.

5.30.2 API
----------

 -- Function: int lw6ldr_body_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_body_t * BODY, const char * DIRNAME, lw6map_param_t *
          PARAM, const lw6ldr_hints_t * HINTS, int DISPLAY_W, int
          DISPLAY_H, float RATIO, int BENCH_VALUE, int MAGIC_NUMBER,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     BODY: the body to read, must point to allocated memory

     DIRNAME: the directory of the map

     PARAM: map parameters

     HINTS: map hints

     DISPLAY_W: the display width

     DISPLAY_H: the display height

     RATIO: wished map ratio

     BENCH_VALUE: the bench value (depends on computer capacity)

     MAGIC_NUMBER: arbitrary constant

     PROGRESS: structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:* 1 if OK, 0 if failed.

 -- Function: void lw6ldr_auto_colors (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, const lw6ldr_hints_t * HINTS)
     STYLE: the style structure to process.

     HINTS: additionnal hints to know what to set automatically

     Deduces all colors from background color, if needed.  The function
     will check color_auto parameters and replace all other colors by
     base and alternate colors if needed.  Note that the background
     color itself is not changed by this function.  Background can only
     be guessed from texture.

     *Return value:* none.

 -- Function: int lw6ldr_cursor_texture_read (lw6sys_context_t *
          SYS_CONTEXT, lw6map_cursor_texture_t * CURSOR_TEXTURE, const
          char * DIRNAME)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE: the cursor texture (out param)

     DIRNAME: the directory we load the data form (map dir)

     Reads the cursor texture information, if not available, will use
     defaults

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6ldr_free_entry (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_entry_t * ENTRY)
     SYS_CONTEXT: global system context

     ENTRY: the entry to free

     Frees a map entry.

     *Return value:* none.

 -- Function: lw6ldr_entry_t * lw6ldr_dup_entry (lw6sys_context_t *
          SYS_CONTEXT, const lw6ldr_entry_t * ENTRY)
     SYS_CONTEXT: global system context

     ENTRY: the entry to dup

     Dup a map entry.

     *Return value:* newly allocated object.

 -- Function: lw6sys_list_t * lw6ldr_get_entries (lw6sys_context_t *
          SYS_CONTEXT, const char * MAP_PATH, const char *
          RELATIVE_PATH, const char * USER_DIR)
     SYS_CONTEXT: global system context

     MAP_PATH: the map_path environment config variable, delimited path
     list

     RELATIVE_PATH: the relative path to use to find the map directory

     USER_DIR: the user directory

     Lists all maps in a given directory.  Returns a list of
     lw6ldr_entry_t which can contain both directories with subdirs and
     actual maps.  Maps are sorted before being returned, first
     directories, then maps, sorted in alphabetical order.

     *Return value:* a list of dynamically allocated lw6ldr_entry_t.

 -- Function: void lw6ldr_for_all_entries (lw6sys_context_t *
          SYS_CONTEXT, const char * MAP_PATH, const char *
          RELATIVE_PATH, const char * USER_DIR, int RECURSIVE,
          lw6sys_list_callback_func_t CALLBACK_FUNC, void * FUNC_DATA)
     SYS_CONTEXT: global system context

     MAP_PATH: the map_path environment config variable, delimited path
     list

     RELATIVE_PATH: the relative path to use to find the map directory

     USER_DIR: the user directory

     RECURSIVE: if non-zero, map search will recurse in subdirs

     CALLBACK_FUNC: the function which will be called on each entry

     FUNC_DATA: an extra pointer to pass data to callback_func

     Executes a given function on all maps in a given place, typically
     used in test programs.

     *Return value:* none.

 -- Function: lw6ldr_entry_t * lw6ldr_chain_entry (lw6sys_context_t *
          SYS_CONTEXT, const char * MAP_PATH, const char *
          RELATIVE_PATH, const char * USER_DIR)
     SYS_CONTEXT: global system context

     MAP_PATH: the map_path environment config variable, delimited path
     list

     RELATIVE_PATH: the relative path to use to find the map directory

     USER_DIR: the user directory

     Gets the next entry used in test programs.

     *Return value:* none.

 -- Function: int lw6ldr_exp_validate (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_level_t * LEVEL, const char * USER_DIR)
     SYS_CONTEXT: global system context

     LEVEL: the level to validate

     USER_DIR: user directory

     Validates a level, acknowledges you've won it.  Upgrades exp.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ldr_grease_apply (lw6sys_context_t * SYS_CONTEXT,
          lw6map_layer_t * LAYER, const lw6map_rules_t * RULES, const
          lw6ldr_hints_t * HINTS, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     LAYER: the layer on which to apply the grease

     RULES: map rules

     HINTS: map hints

     PROGRESS: structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:* 1 if OK, 0 if failed.

 -- Function: void lw6ldr_hints_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6ldr_hints_t * HINTS)
     SYS_CONTEXT: global system context

     HINTS: data to initialize

     Set the hints struct to its defaults.

     *Return value:* none.

 -- Function: void lw6ldr_hints_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS)
     SYS_CONTEXT: global system context

     HINTS: data to initialize

     Zeros the hints struct, this is not the same as setting to
     defaults.

     *Return value:* none.

 -- Function: void lw6ldr_hints_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS)
     SYS_CONTEXT: global system context

     HINTS: data to initialize

     Clears the hints struct, this is not the same as setting to
     defaults.

     *Return value:* none.

 -- Function: int lw6ldr_hints_read (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory of the map

     Read the hints (hints.xml) of a map.  Pointer to hints must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_hints_set (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     HINTS: the hints to modify

     KEY: the key to modify

     VALUE: the value to affect to the key, as a string

     Sets one single parameter in a hints structure.  Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:* 1 if success, 0 if failed.  Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6ldr_hints_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6ldr_hints_t * HINTS, const char * KEY)
     SYS_CONTEXT: global system context

     HINTS: the hints to modify

     KEY: the key to modify

     Gets one single parameter in a hints structure.  Value is converted
     as a string.

     *Return value:* dynamically allocated string, NULL on error.

 -- Function: char * lw6ldr_hints_get_default (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: the key we want informations about.

     Gets the default value for a given hints key.

     *Return value:* dynamically allocated string, NULL on error.

 -- Function: int lw6ldr_hints_update (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_hints_t * HINTS, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     HINTS: the hints struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides hints with values.  Pointer to hints must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing hints.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_layer_read_first (lw6sys_context_t *
          SYS_CONTEXT, lw6map_layer_t * LAYER, const char * FILENAME,
          lw6map_param_t * PARAM, const lw6ldr_hints_t * HINTS, int
          DISPLAY_W, int DISPLAY_H, float TARGET_RATIO, int BENCH_VALUE,
          int MAGIC_NUMBER, int EXPECTED_DEPTH, lw6sys_progress_t *
          PROGRESS)
     SYS_CONTEXT: global system context

     LAYER: layer to update (out param)

     FILENAME: name of PNG file

     PARAM: parameters of the map

     HINTS: hints of the map

     DISPLAY_W: width of display

     DISPLAY_H: height of display

     TARGET_RATIO: width/height ratio we want

     BENCH_VALUE: bench for this computer

     MAGIC_NUMBER: arbitrary constant

     EXPECTED_DEPTH: depth of map according to files available

     PROGRESS: progress object to provide feedback (in/out)

     Reads the first layer, that is map.png.  This function has many
     parameters since it will try and guess the final (real) resolution
     of the map.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ldr_layer_read_next (lw6sys_context_t *
          SYS_CONTEXT, lw6map_layer_t * LAYER, const char * FILENAME,
          int TARGET_W, int TARGET_H)
     SYS_CONTEXT: global system context

     LAYER: layer to update (out param)

     FILENAME: name of PNG file

     TARGET_W: width we want

     TARGET_H: height we want

     Reads a layer, knowing the exact size we want.  This is typically
     to load layer2-7.png once map.png has been loaded.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ldr_metadata_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_metadata_t * METADATA, const char * DIRNAME)
     SYS_CONTEXT: global system context

     METADATA: structure containting read data (out param)

     DIRNAME: map dirname (absolute path)

     Reads the metadata, will first parse metadata.xml, and if not
     available read README and guess a title from map path.  When
     function returns, all fields in structure are non-NULL.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6ldr_meta_layer_read (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER, const char *
          FILENAME, int TARGET_W, int TARGET_H, int ANALOG)
     SYS_CONTEXT: global system context

     META_LAYER: the meta layer to read

     FILENAME: the file to open

     TARGET_W: the wanted width

     TARGET_H: the wanted height

     ANALOG: wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6ldr_meta_layer_read_if_exists (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER, const char *
          DIRNAME, const char * FILE_ONLY, int TARGET_W, int TARGET_H,
          int ANALOG)
     SYS_CONTEXT: global system context

     META_LAYER: the meta layer to read

     DIRNAME: the map directory

     FILE_ONLY: the meta-layer file name only (without the path)

     TARGET_W: the wanted width

     TARGET_H: the wanted height

     ANALOG: wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters.  This function is different from
     'lw6ldr_meta_layer_read' for it will 1) concatenate 'dirname' and
     'file_only' and 2) return OK (1) if file does not exist.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6ldr_process_non_run_options (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, int * RUN_GAME)
     SYS_CONTEXT: global system context

     ARGC: the number of command-line args, as passed to main

     ARGV: an array of strings containing command-line args, as passed
     to main

     RUN_GAME: a pointer to a boolean which will contain true (1) if the
     game must be launched, or false (0) if the option is such that game
     must be skipped.  Example: -copyright, -help, ...

     Will interpret the command-line arguments, and trap those who are
     related to xml files, this is usefull when building the game, we
     want to have an extra binary to do this without being linked to
     SDL, for instance.

     *Return value:* non-zero if success, 0 if error.  The error can be,
     for instance, the test suite returning "no, tests were not OK".

 -- Function: int lw6ldr_param_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM, const char * DIRNAME)
     SYS_CONTEXT: global system context

     PARAM: the parameter struct to fill with values (read/write
     parameter)

     DIRNAME: the directory of the map

     Read the parameters associated to a map.  Pointer to param must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_param_update (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     PARAM: the parameter struct to fill with values (read/write
     parameter)

     VALUES: an assoc containing strings with the new values

     Overrides param with values.  Pointer to param must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing param.

     *Return value:* 1 if success, 0 if failed.

 -- Function: void lw6ldr_print_example_rules_xml (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to output content to

     Print to a file a typical map rules.xml file.

     *Return value:* none.

 -- Function: void lw6ldr_print_example_hints_xml (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to output content to

     Print to a file a typical map hints.xml file.

     *Return value:* none.

 -- Function: void lw6ldr_print_example_style_xml (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to output content to

     Print to a file a typical map style.xml file.

     *Return value:* none.

 -- Function: void lw6ldr_print_example_teams_xml (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to output content to

     Print to a file a typical map teams.xml file.

     *Return value:* none.

 -- Function: int lw6ldr_print_examples (lw6sys_context_t * SYS_CONTEXT,
          char * USER_DIR)
     SYS_CONTEXT: global system context

     USER_DIR: the user directory or at least, a writable one

     Writes all example XML files in 'user_dir/example/', will create
     the directory if needed.

     *Return value:* 1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read (lw6sys_context_t *
          SYS_CONTEXT, const char * DIRNAME, lw6sys_assoc_t *
          DEFAULT_PARAM, lw6sys_assoc_t * FORCED_PARAM, int DISPLAY_W,
          int DISPLAY_H, int BENCH_VALUE, int MAGIC_NUMBER, const char *
          USER_DIR, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     DIRNAME: the directory containing the map

     DEFAULT_PARAM: default parameters, as strings

     FORCED_PARAM: forced parameters, as strings

     DISPLAY_W: the width of the display output (resolution)

     DISPLAY_H: the height of the display output (resolution)

     BENCH_VALUE: the bench value (depends on computer capacity)

     MAGIC_NUMBER: arbitrary constant

     USER_DIR: the user directory

     PROGRESS: information used to handle the progress bar

     Loads a map from dist.  The default_param and forced_param can
     contain values corresponding to rules.xml and style.xml entries.
     Parameters are read in 4 steps.  1st, a default value is picked by
     the program.  2nd, any value in 'default_param' replaces previous
     values.  3rd, any value in rules.xml or style.xml replaces previous
     values.  4th, any value in 'forced_param' replaces previous values.
     In practice, the 'default_param' allows the user to set defaults
     which can still be overwritten by the map, while 'forced_param' is
     a definitive 'ignore what is is defined in the map' way of doing
     things.  See also 'lw6ldr_read_relative'.

     *Return value:* 1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read_relative (lw6sys_context_t *
          SYS_CONTEXT, const char * MAP_PATH, const char *
          RELATIVE_PATH, lw6sys_assoc_t * DEFAULT_PARAM, lw6sys_assoc_t
          * FORCED_PARAM, int DISPLAY_W, int DISPLAY_H, int BENCH_VALUE,
          int MAGIC_NUMBER, const char * USER_DIR, lw6sys_progress_t *
          PROGRESS)
     SYS_CONTEXT: global system context

     MAP_PATH: a collection of paths where to find maps

     RELATIVE_PATH: something which will be appended to a 'map_path'
     member

     DEFAULT_PARAM: default parameters, as strings

     FORCED_PARAM: forced parameters, as strings

     DISPLAY_W: the width of the display output (resolution)

     DISPLAY_H: the height of the display output (resolution)

     BENCH_VALUE: the bench value (depends on computer capacity)

     MAGIC_NUMBER: arbitrary constant

     USER_DIR: the user directory

     PROGRESS: information used to handle the progress bar

     Reads a map from disk, using the map-path value, which is a
     collection of paths defined by the command-line, the environment
     variables, and the config file.  'default_param' and 'forced_param'
     work as in the function 'lw6ldr_read'.

     *Return value:* 1 if success, 0 if failure.

 -- Function: void lw6ldr_resampler_init (lw6sys_context_t *
          SYS_CONTEXT, lw6ldr_resampler_t * RESAMPLER, lw6map_param_t *
          PARAM, const lw6ldr_hints_t * HINTS, int SOURCE_W, int
          SOURCE_H, int DISPLAY_W, int DISPLAY_H, float TARGET_RATIO,
          int BENCH_VALUE, int MAGIC_NUMBER, int EXPECTED_DEPTH, float
          GRAY_LEVEL)
     SYS_CONTEXT: global system context

     RESAMPLER: resampler object to init

     PARAM: map parameters to use

     HINTS: loading hints

     SOURCE_W: width of source map

     SOURCE_H: height of source map

     DISPLAY_W: width of source display

     DISPLAY_H: height of source display

     TARGET_RATIO: ratio, that is width/height of the target

     BENCH_VALUE: rough estimation of this computer power

     MAGIC_NUMBER: arbitrary constant, needed to calibrate speed

     EXPECTED_DEPTH: how thick the map could be (in practice, looks like
     d in whd)

     GRAY_LEVEL: used to estimate capacity, 1.0f is white and means many
     slots

     Initializes a resampler.  There is wizardry based on the bench,
     magic number map size, gray level.  This is bot bullet proof, but
     has been experience driven and is the result of many tries /
     failures and hopefully successes.  Might need tuning as the
     algorithm evolves.  This is the very function that chooses the
     actual logical map size.

     *Return value:* none.

 -- Function: void lw6ldr_resampler_use_for_gen (lw6sys_context_t *
          SYS_CONTEXT, int * MAP_W, int * MAP_H, int DISPLAY_W, int
          DISPLAY_H, int BENCH_VALUE, int MAGIC_NUMBER)
     SYS_CONTEXT: global system context

     MAP_W: target map width (out param)

     MAP_H: target map height (out param)

     DISPLAY_W: screen width (pixels)

     DISPLAY_H: screen height (pixels)

     BENCH_VALUE: rough estimation of this computer power

     MAGIC_NUMBER: arbitrary constant, needed to calibrate speed

     Builds a resampler and does all the calculus so that one gets the
     correct map width and height for the gen module.  The idea is that
     when generating a pseudo-random map, one can not really know what
     size to give it, so this function gives a hint, relying on bench
     and magic values, which are computer/runtime dependant.

     *Return value:* none

 -- Function: void lw6ldr_resampler_force (lw6sys_context_t *
          SYS_CONTEXT, lw6ldr_resampler_t * RESAMPLER, int SOURCE_W, int
          SOURCE_H, int TARGET_W, int TARGET_H)
     SYS_CONTEXT: global system context

     RESAMPLER: resampler to set

     SOURCE_W: source map width

     SOURCE_H: source map height

     TARGET_W: target map width

     TARGET_H: target map height

     Initializes a resampler with hardcoded values, does not calibrate
     according to context, simply set it to rescale the size you want.

     *Return value:* none.

 -- Function: void lw6ldr_resampler_source2target (lw6sys_context_t *
          SYS_CONTEXT, const lw6ldr_resampler_t * RESAMPLER, int *
          TARGET_X, int * TARGET_Y, int SOURCE_X, int SOURCE_Y)
     SYS_CONTEXT: global system context

     TARGET_X: target x coordinate (out param)

     TARGET_Y: target y coordinate (out param)

     SOURCE_X: source x coordinate (in param)

     SOURCE_Y: source y coordinate (in param)

     Transforms from source coordinate to target coordinates.  Does
     rounding fine-tuning, it's not a simple integer division.

     *Return value:* none.

 -- Function: void lw6ldr_resampler_target2source (lw6sys_context_t *
          SYS_CONTEXT, const lw6ldr_resampler_t * RESAMPLER, int *
          SOURCE_X, int * SOURCE_Y, int TARGET_X, int TARGET_Y)
     SYS_CONTEXT: global system context

     SOURCE_X: source x coordinate (out param)

     SOURCE_Y: source y coordinate (out param)

     TARGET_X: target x coordinate (in param)

     TARGET_Y: target y coordinate (in param)

     Transforms from target coordinate to source coordinates.  Yes,
     target to source.  Target is our final logical map, source is what
     we loaded from disk, here we want to know, given a point in the
     target, where to fetch its data from source.  Does rounding
     fine-tuning, it's not a simple integer division.

     *Return value:* none.

 -- Function: int lw6ldr_rules_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory of the map

     Read the rules (rules.xml) of a map.  Pointer to rules must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_rules_update (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     RULES: the rules struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides rules with values.  Pointer to rules must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing rules.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_style_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory of the map

     Read the style (style.xml) of a map.  Pointer to style must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_style_set (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     STYLE: the style to modify

     KEY: the key to modify

     VALUE: the value to affect to the key, as a string

     Sets one single parameter in a style structure.  Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:* 1 if success, 0 if failed.  Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: int lw6ldr_style_update (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     STYLE: the style struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides style with values.  Pointer to style must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing style.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory of the map

     Read the teams (teams.xml) of a map.  Pointer to teams must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_update (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     TEAMS: the teams struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides teams with values.  Pointer to teams must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing teams.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6ldr_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libldr module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6ldr_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'ldr' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6ldr_texture_read (lw6sys_context_t * SYS_CONTEXT,
          lw6map_texture_t * TEXTURE, const char * DIRNAME, const
          lw6map_param_t * PARAM, const lw6ldr_hints_t * HINTS, int
          USE_TEXTURE, int DISPLAY_W, int DISPLAY_H, float * RATIO, int
          * TEXTURE_EXISTS, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     TEXTURE: structure to hold read data

     DIRNAME: map dirname (absolute path)

     PARAM: parameters to use

     HINTS: loading hints to use

     USE_TEXTURE: wether to use texture.png

     DISPLAY_W: display width

     DISPLAY_H: display height

     RATIO: target width/height factor (out param)

     TEXTURE_EXISTS: true if texture.png is here (out param)

     PROGRESS: progress indicator (in/out param)

     Read the texture associated to a map.  Pointer to texture must be
     valid, it's modified in-place.  The function will automatically
     figure out if texture.png exists or if we must use
     foreground.png/background.png.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6ldr_use_defaults (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_use_t * USE)
     SYS_CONTEXT: global system context

     USE: struct to initialize

     Sets the use structure to its defaults, this structure being used
     to now wether we should use texture, cursor textures, rules, hints,
     style, teams and music.

     *Return value:* none.

 -- Function: void lw6ldr_use_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_use_t * USE)
     SYS_CONTEXT: global system context

     USE: struct to clear

     Clears the use structure, set it to the use nothing mode.

     *Return value:* none.

 -- Function: int lw6ldr_use_set (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_use_t * USE, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     USE: struct to modify

     KEY: key to change (as a string)

     VALUE: value to set (as a string)

     Sets a key to the given value, OK all fields are integer, this is
     just a convenient function to be called in more general functions
     which are fed with those string pointers, typically coming from an
     XML file.

     *Return value:* 1 on success, 0 on failure (key not found).

 -- Function: int lw6ldr_use_update (lw6sys_context_t * SYS_CONTEXT,
          lw6ldr_use_t * USE, lw6sys_assoc_t * VALUES)
     SYS_CONTEXT: global system context

     USE: the use struct to fill with values (read/write parameter)

     VALUES: an assoc containing strings with the new values

     Overrides use with values.  Pointer to use must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values.  Not all parameters need be defined in
     values.  It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing use.

     *Return value:* 1 if success, 0 if failed.

 -- Struct: lw6ldr_entry_s

     Contains informations about a map, but just the minimum to, for
     instance, display it in a menu entry.

 -- Member of lw6ldr_entry_s: metadata
     *Type:* 'lw6map_metadata_t'

     *Definition:* 'lw6map_metadata_t lw6ldr_entry_s::metadata'

     The map metadata.

 -- Member of lw6ldr_entry_s: absolute_path
     *Type:* 'char *'

     *Definition:* 'char* lw6ldr_entry_s::absolute_path'

     The map absolute path, use this to load it.

 -- Member of lw6ldr_entry_s: relative_path
     *Type:* 'char *'

     *Definition:* 'char* lw6ldr_entry_s::relative_path'

     The map relative path, store this in config file.

 -- Member of lw6ldr_entry_s: has_subdirs
     *Type:* 'int'

     *Definition:* 'int lw6ldr_entry_s::has_subdirs'

     Wether the entry has subdirs (and consequently, isn't a map)

 -- Member of lw6ldr_entry_s: nb_submaps
     *Type:* 'int'

     *Definition:* 'int lw6ldr_entry_s::nb_submaps'

     Number of sub mpas within this map.

 -- Member of lw6ldr_entry_s: forbidden
     *Type:* 'int'

     *Definition:* 'int lw6ldr_entry_s::forbidden'

     Wether it is forbidden (eg, not enough exp).

 -- Struct: lw6ldr_hints_s

     Content of hints.xml stored into a C struct.

 -- Member of lw6ldr_hints_s: resample
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::resample'

     Wether to resample the map on the fly when loaded.

 -- Member of lw6ldr_hints_s: min_map_width
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::min_map_width'

     Minimum map width.

 -- Member of lw6ldr_hints_s: max_map_width
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::max_map_width'

     Maximum map width.

 -- Member of lw6ldr_hints_s: min_map_height
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::min_map_height'

     Minimum map height.

 -- Member of lw6ldr_hints_s: max_map_height
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::max_map_height'

     Maximum map height.

 -- Member of lw6ldr_hints_s: min_map_surface
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::min_map_surface'

     Minimum map surface.

 -- Member of lw6ldr_hints_s: max_map_surface
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::max_map_surface'

     Maximum map surface.

 -- Member of lw6ldr_hints_s: fighter_scale
     *Type:* 'float'

     *Definition:* 'float lw6ldr_hints_s::fighter_scale'

     Use greater or smaller fighters.

 -- Member of lw6ldr_hints_s: downsize_using_fighter_scale
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::downsize_using_fighter_scale'

     Wether to downsize the map, if needed, using fighter scale.

 -- Member of lw6ldr_hints_s: upsize_using_fighter_scale
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::upsize_using_fighter_scale'

     Wether to upsize the map, if needed, using fighter scale.

 -- Member of lw6ldr_hints_s: downsize_using_bench_value
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::downsize_using_bench_value'

     Wether to downsize the map, if needed, using bench value.

 -- Member of lw6ldr_hints_s: upsize_using_bench_value
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::upsize_using_bench_value'

     Wether to upsize the map, if needed, using bench value.

 -- Member of lw6ldr_hints_s: guess_colors
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::guess_colors'

     Wether to guess colors from the map.

 -- Member of lw6ldr_hints_s: background_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::background_color_auto'

     Wether to set up background colors automatically.

 -- Member of lw6ldr_hints_s: hud_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::hud_color_auto'

     Wether to set up hud colors automatically.

 -- Member of lw6ldr_hints_s: menu_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::menu_color_auto'

     Wether to set up menu colors automatically.

 -- Member of lw6ldr_hints_s: view_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::view_color_auto'

     Wether to set up view colors automatically.

 -- Member of lw6ldr_hints_s: system_color_auto
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::system_color_auto'

     Wether to set up system colors automatically.

 -- Member of lw6ldr_hints_s: wall_grease
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::wall_grease'

     Wall grease used when rescaling.

 -- Member of lw6ldr_hints_s: guess_moves_per_sec
     *Type:* 'int'

     *Definition:* 'int lw6ldr_hints_s::guess_moves_per_sec'

     Guess the moves per sec value automatically.

 -- Member of lw6ldr_hints_s: speed
     *Type:* 'float'

     *Definition:* 'float lw6ldr_hints_s::speed'

     Global speed.

 -- Struct: lw6ldr_resampler_s

     Almost internal struct use to handler the resampling process.  It
     has informations about the source, the target, and the ratio
     between them.  It basically contains informations about how to
     scale.

 -- Member of lw6ldr_resampler_s: target_w
     *Type:* 'int'

     *Definition:* 'int lw6ldr_resampler_s::target_w'

     Target width.

 -- Member of lw6ldr_resampler_s: target_h
     *Type:* 'int'

     *Definition:* 'int lw6ldr_resampler_s::target_h'

     Target height.

 -- Member of lw6ldr_resampler_s: source_w
     *Type:* 'int'

     *Definition:* 'int lw6ldr_resampler_s::source_w'

     Source width.

 -- Member of lw6ldr_resampler_s: source_h
     *Type:* 'int'

     *Definition:* 'int lw6ldr_resampler_s::source_h'

     Source height.

 -- Member of lw6ldr_resampler_s: scale_x
     *Type:* 'float'

     *Definition:* 'float lw6ldr_resampler_s::scale_x'

     Ratio for the X axis (target_w/source_w).

 -- Member of lw6ldr_resampler_s: scale_y
     *Type:* 'float'

     *Definition:* 'float lw6ldr_resampler_s::scale_y'

     Ratio for the Y axis (target_h/source_h).

 -- Struct: lw6ldr_use_s

     What files to use when loading a map.

 -- Member of lw6ldr_use_s: use_texture
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_texture'

     Wether to use texture.jpeg.

 -- Member of lw6ldr_use_s: use_cursor_texture
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_cursor_texture'

     Wether to use cursor-texture.jpeg.

 -- Member of lw6ldr_use_s: use_rules_xml
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_rules_xml'

     Wether to use rules.xml.

 -- Member of lw6ldr_use_s: use_hints_xml
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_hints_xml'

     Wether to use hints.xml.

 -- Member of lw6ldr_use_s: use_style_xml
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_style_xml'

     Wether to use style.xml.

 -- Member of lw6ldr_use_s: use_teams_xml
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_teams_xml'

     Wether to use teams.xml.

 -- Member of lw6ldr_use_s: use_music_file
     *Type:* 'int'

     *Definition:* 'int lw6ldr_use_s::use_music_file'

     Wether to use the map specific music file.

5.31 libmap
===========

5.31.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/map/index.html>.

5.31.2 API
----------

 -- Function: void lw6map_body_builtin_custom (lw6sys_context_t *
          SYS_CONTEXT, lw6map_body_t * BODY, int W, int H, int D, int
          NOISE_PERCENT, const lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     BODY: the body to initialize

     W: the width

     H: the height

     D: the depth

     NOISE_PERCENT: the noise level to fill meta layers with

     RULES: the map rules

     Sets up a default body structure.

     *Return value:* none

 -- Function: void lw6map_body_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_body_t * BODY)
     SYS_CONTEXT: global system context

     BODY: the structure to clear

     Clears a body structure.

     *Return value:* none.

 -- Function: void lw6map_body_fix_checksum (lw6sys_context_t *
          SYS_CONTEXT, lw6map_body_t * BODY)
     SYS_CONTEXT: global system context

     BODY: the structure to update

     Updates (calculates) the checksum of a map body structure.

     *Return value:* none.

 -- Function: int lw6map_body_check_and_fix_holes (lw6sys_context_t *
          SYS_CONTEXT, lw6map_body_t * BODY, const lw6map_rules_t *
          RULES)
     SYS_CONTEXT: global system context

     BODY: the structure to update

     RULES: the game rules

     This (fundamental) function ensures that all playable areas in a
     map are connected.  If isolated zones are found out, then they are
     marked as walls and not used any more.

     *Return value:* none.

 -- Function: int lw6map_body_coord_from_texture (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL, int * BODY_X, int *
          BODY_Y, int TEXTURE_X, int TEXTURE_Y)
     SYS_CONTEXT: global system context

     LEVEL: the level to work on

     BODY_X: the body (logical) x coord

     BODY_Y: the body (logical) y coord

     TEXTURE_X: the texture x coord

     TEXTURE_Y: the texture y coord

     Gets body (logical) coords from texture position.

     *Return value:* 1 on success, 0 on failure (out of bounds)

 -- Function: u_int8_t lw6map_body_get_with_texture_coord
          (lw6sys_context_t * SYS_CONTEXT, const lw6map_level_t * LEVEL,
          int TEXTURE_X, int TEXTURE_Y, int Z)
     SYS_CONTEXT: global system context

     LEVEL: the level to work on

     TEXTURE_X: the texture x coord

     TEXTURE_Y: the texture y coord

     Z: the z position (depth related)

     Tells wether a given map position is free or not, but using texture
     coords.

     *Return value:* 1 if position is playable, 0 if not (wall)

 -- Function: void lw6map_color_invert (lw6sys_context_t * SYS_CONTEXT,
          lw6map_color_couple_t * COLOR)
     SYS_CONTEXT: global system context

     COLOR: the color to invert

     Inverts a color couple, that is, replace fg by bg and vice-versa.

     *Return value:* none.

 -- Function: int lw6map_color_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_color_couple_t * COLOR1, const
          lw6map_color_couple_t * COLOR2)
     SYS_CONTEXT: global system context

     COLOR1: 1st color to compare

     COLOR2: 2nd color to compare

     Compares two colors.

     *Return value:* 1 if equal, 0 if not.

 -- Function: char * lw6map_team_color_index_to_key (lw6sys_context_t *
          SYS_CONTEXT, int INDEX)
     SYS_CONTEXT: global system context

     INDEX: index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used in config files for instance.

     *Return value:* a string, must *not* be freed.

 -- Function: int lw6map_team_color_key_to_index (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key of the color, for instance "red"

     The index of the color, between 0 & 9

     *Return value:* an integer.

 -- Function: char * lw6map_team_color_index_to_label (lw6sys_context_t
          * SYS_CONTEXT, int INDEX)
     SYS_CONTEXT: global system context

     INDEX: index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used to display information to players.

     *Return value:* a string, must *not* be freed.

 -- Function: void lw6map_coords_fix_xy (const lw6map_rules_t * RULES,
          const lw6sys_whd_t * SHAPE, int * X, int * Y)
     RULES: set of rules to use

     SHAPE: shape of the map

     X: x coord (in/out param)

     Y: y coord (in/out param)

     Fixes the x and y values so that it's always inside the map.  This
     function will read the rules and if there's some polarity enable,
     will do the right thing, for instance, a fighter too much on the
     right might reapper on the left side of the map.

     *Return value:* none.

 -- Function: void lw6map_coords_fix_z (const lw6map_rules_t * RULES,
          const lw6sys_whd_t * SHAPE, int * Z)
     RULES: set of rules to use

     SHAPE: shape of the map

     Z: z coord (in/out param)

     Fixes the z value so that it's always inside the map.  This
     function will read the rules and if there's some polarity enable,
     will do the right thing, for instance, a fighter too low it might
     reapper on top.

     *Return value:* none.

 -- Function: void lw6map_cursor_texture_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6map_cursor_texture_t * CURSOR_TEXTURE)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE: the cursor texture to clear

     Clears a cursor texture (set it all transparent).

     *Return value:* none

 -- Function: void lw6map_cursor_texture_builtin (lw6sys_context_t *
          SYS_CONTEXT, lw6map_cursor_texture_t * CURSOR_TEXTURE)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE: the cursor texture to clear

     Sets a cursor texture to the builtin defauts, that is a circle that
     is black on the outside and gets white/transparent in the middle.

     *Return value:* none

 -- Function: void lw6map_cursor_texture_layer_set (lw6sys_context_t *
          SYS_CONTEXT, lw6map_cursor_texture_layer_t *
          CURSOR_TEXTURE_LAYER, int X, int Y, lw6sys_color_8_t COLOR)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE_LAYER: the cursor texture_layer to change

     X: x coord

     Y: y coord

     COLOR: the color

     Sets a pixel in the cursor texture_layer.

     *Return value:* none

 -- Function: lw6sys_color_8_t lw6map_cursor_texture_layer_get
          (lw6sys_context_t * SYS_CONTEXT, const
          lw6map_cursor_texture_layer_t * CURSOR_TEXTURE_LAYER, int X,
          int Y)
     SYS_CONTEXT: global system context

     CURSOR_TEXTURE_LAYER: the cursor texture_layer to query

     X: x coord

     Y: y coord

     Gets a pixel in the cursor texture_layer.

     *Return value:* the color

 -- Function: lw6map_level_t * lw6map_dup (lw6sys_context_t *
          SYS_CONTEXT, lw6map_level_t * SOURCE, lw6sys_progress_t *
          PROGRESS)
     SYS_CONTEXT: global system context

     SOURCE: the map to copy

     PROGRESS: to show advancement

     Performs a deep copy of the map, all elements are newly allocated
     and source can safely be destroyed after it's been duplicated.

     *Return value:* a newly allocated map, may be NULL.

 -- Function: int lw6map_exp_get_highest_team_color_allowed
          (lw6sys_context_t * SYS_CONTEXT, int EXP)
     SYS_CONTEXT: global system context

     EXP: the player experience

     Gets the highest color available for a given exp.

     *Return value:* a color id

 -- Function: int lw6map_exp_get_highest_weapon_allowed
          (lw6sys_context_t * SYS_CONTEXT, int EXP)
     SYS_CONTEXT: global system context

     EXP: the player experience

     Gets the highest weapon available for a given exp.

     *Return value:* a weapon id

 -- Function: int lw6map_exp_is_team_color_allowed (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES, int TEAM_COLOR_ID)
     SYS_CONTEXT: global system context

     RULES: set of rules to use

     TEAM_COLOR_ID: color id to test

     Tests wether a team color is allowed for a given set of rules.

     *Return value:* 1 if allowed, 0 if not.

 -- Function: int lw6map_exp_is_weapon_allowed (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES, int WEAPON_ID)
     SYS_CONTEXT: global system context

     RULES: set of rules to use

     WEAPON_ID: weapon id to test

     Tests wether a weapon is allowed for a given set of rules.

     *Return value:* 1 if allowed, 0 if not.

 -- Function: int lw6map_exp_get_unlocked_team_color (lw6sys_context_t *
          SYS_CONTEXT, int EXP)
     SYS_CONTEXT: global system context

     EXP: exp to test

     Get the unlocked team color for a given exp, if applyable.

     *Return value:* -1 if nothing unlocked, else the team color

 -- Function: int lw6map_exp_get_unlocked_weapon (lw6sys_context_t *
          SYS_CONTEXT, int EXP)
     SYS_CONTEXT: global system context

     EXP: exp to test

     Get the unlocked primary weapon for a given exp, if applyable.

     *Return value:* -1 if nothing unlocked, else the weapon id

 -- Function: char * lw6map_to_hexa (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     Converts a map to something that is later readable by
     'lw6map_from_hexa' to reproduce the exact same map.  Just a
     serializer.

     *Return value:* a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6map_level_t * lw6map_from_hexa (lw6sys_context_t *
          SYS_CONTEXT, const char * HEXA)
     SYS_CONTEXT: global system context

     HEXA: an hexadecimal ASCII string, created by 'lw6map_to_hexa'

     Constructs a map from an hexadecimal string generated by
     'lw6map_to_hexa'.  Just an un-serializer.

     *Return value:* a new map, might be NULL if string isn't correct.

 -- Function: void lw6map_layer_builtin_custom (lw6sys_context_t *
          SYS_CONTEXT, lw6map_layer_t * LAYER, int W, int H)
     SYS_CONTEXT: global system context

     LAYER: the layer to init

     W: width

     H: height

     Creates a default layer.  This is mostly for testing purposes, the
     default layer is not empty, it contains a simplified map of the
     world.

     *Return value:* none

 -- Function: void lw6map_layer_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_layer_t * LAYER)
     SYS_CONTEXT: global system context

     LAYER: the layer to init

     Clears a layer struct.  This means freeing the pointer if it's non
     NULL and setting everything to 0.

     *Return value:* none

 -- Function: lw6map_level_t * lw6map_new (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a new empty map.  This object is perfectly unusable as is,
     since it has a 0x0 size, and many things set to "NULL". Still, it's
     used internally and is the canonical way to create the object, it
     ensures later calls that set up default parameters, for instance,
     will succeed.

     *Return value:* a newly allocated pointer.

 -- Function: lw6map_level_t * lw6map_builtin_defaults (lw6sys_context_t
          * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a map, set to defaults.  This is usefull mostly for
     testing.  This builtin map has walls, paths, it's playable.

     *Return value:* a newly allocated map.

 -- Function: lw6map_level_t * lw6map_builtin_scale (lw6sys_context_t *
          SYS_CONTEXT, int PERCENT_FACTOR)
     SYS_CONTEXT: global system context

     PERCENT_FACTOR: how big the map should be, 100 is defaults 200 is
     double.

     Creates a map, set to defaults.  This is usefull mostly for
     testing.  This builtin map has walls, paths, it's playable,
     additionnally it's scalable, that's to say one can make it bigger
     if needed, using a percent factor.

     *Return value:* a newly allocated map.

 -- Function: lw6map_level_t * lw6map_builtin_custom (lw6sys_context_t *
          SYS_CONTEXT, int W, int H, int D, int NOISE_PERCENT)
     SYS_CONTEXT: global system context

     W: the width of the map

     H: the height of the map

     D: the depth (number of layers) of the map

     NOISE_PERCENT: percentage of noise to use for metalayers

     Creates a map, set to defaults.  This is usefull mostly for
     testing.  This one, unlike 'lw6map_builtin_defaults' will let you
     give a width, height and a depth.

     *Return value:* a newly allocated map.

 -- Function: void lw6map_free (lw6sys_context_t * SYS_CONTEXT,
          lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     Frees a map and releases all its internal ressources.

     *Return value:* none.

 -- Function: int lw6map_memory_footprint (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     Reports how many bytes the map needs, in memory.  Note that this is
     not contiguous memory, it involves a bunch of pointers, and
     possibly much more...

 -- Function: char * lw6map_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     Returns a string describing the map.  This is a very short
     description, use it for logs, and to debug stuff.  By no means it's
     a complete exhaustive description.  Still, the string returned
     should be unique.

     *Return value:* a dynamically allocated string.

 -- Function: int lw6map_is_same (lw6sys_context_t * SYS_CONTEXT, const
          lw6map_level_t * LEVEL_A, const lw6map_level_t * LEVEL_B)
     SYS_CONTEXT: global system context

     LEVEL_A: the first level to compare

     LEVEL_B: the other level to compare

     Compares two level structs, the idea is to compare the content, not
     only the pointers and level ids.

     *Return value:* 1 if they're the same, 0 if not.

 -- Function: const char * lw6map_get_title (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     LEVEL: level to get informations about

     Gives the map name.  This is just a simple utility/wrapper function
     which is meant to be exported to Guile scripts.

     *Return value:* static string, must not be freed, can't be NULL

 -- Function: int lw6map_get_max_nb_colors (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     LEVEL: level to get informations about

     Gives the max number of colors (AKA teams) that can fit on this
     map.  This is just a simple utility/wrapper function which is meant
     to be exported to Guile scripts.

     *Return value:* number of colors, taken from rules

 -- Function: int lw6map_get_max_nb_cursors (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     LEVEL: level to get informations about

     Gives the max number of cursors that can fit on this map.  This is
     just a simple utility/wrapper function which is meant to be
     exported to Guile scripts.

     *Return value:* number of cursors, taken from rules

 -- Function: int lw6map_get_max_nb_nodes (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL)
     SYS_CONTEXT: global system context

     LEVEL: level to get informations about

     Gives the max number of nodes that can fit on this map.  This is
     just a simple utility/wrapper function which is meant to be
     exported to Guile scripts.

     *Return value:* number of nodes, taken from rules

 -- Function: int lw6map_local_info_set_music_dir (lw6sys_context_t *
          SYS_CONTEXT, lw6map_local_info_t * LOCAL_INFO, const char *
          MUSIC_DIR)
     SYS_CONTEXT: global system context

     LOCAL_INFO: the structure to modify

     MUSIC_DIR: the new music_dir value

     Sets the music_dir value, in a 'safe' manner, freeing any previous
     value and performing a string duplication.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6map_local_info_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6map_local_info_t * LOCAL_INFO)
     SYS_CONTEXT: global system context

     LOCAL_INFO: the structure to clear

     Clears the local_info structure, before destroying a level for
     instance.

     *Return value:* none

 -- Function: void lw6map_metadata_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_metadata_t * METADATA)
     SYS_CONTEXT: global system context

     METADATA: struct to set to defaults

     Sets the metadata struct to defaults, this does not set fields to
     NULL/empty values, but rather fills it with data claiming, for
     instance, that this is a default map.

     *Return value:* none.

 -- Function: void lw6map_metadata_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6map_metadata_t * METADATA)
     SYS_CONTEXT: global system context

     METADATA: struct to clear

     Clears a metadata, will expect it to be in a consistent state, that
     is either filled with proper values or completely zeroed.

     *Return value:* none.

 -- Function: int lw6map_metadata_is_same (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_metadata_t * METADATA_A, const
          lw6map_metadata_t * METADATA_B)
     SYS_CONTEXT: global system context

     METADATA_A: first item to compare

     METADATA_B: second item to compare

     Tells wether both metadata items contain the same values.

     *Return value:* 1 if same, 0 if different.

 -- Function: void lw6map_meta_layer_set (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER, int X, int Y,
          u_int8_t VALUE)
     SYS_CONTEXT: global system context

     META_LAYER: the meta_layer structure

     X: x coord

     Y: y coord

     VALUE: the value to set at this place

     Simple setter for the meta_layer struct.

     *Return value:* none

 -- Function: u_int8_t lw6map_meta_layer_get (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_meta_layer_t * META_LAYER, int X,
          int Y)
     SYS_CONTEXT: global system context

     META_LAYER: the meta_layer structure

     X: x coord

     Y: y coord

     Simple getter for the meta_layer struct.

     *Return value:* the value at this place

 -- Function: void lw6map_meta_layer_clear (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER)
     SYS_CONTEXT: global system context

     META_LAYER: the meta_layer to clear

     Clears a meta_layer struct.  This means freeing the pointer if it's
     non NULL and setting everything to 0.

     *Return value:* none

 -- Function: int lw6map_meta_layer_builtin_custom (lw6sys_context_t *
          SYS_CONTEXT, lw6map_meta_layer_t * META_LAYER, int W, int H,
          int ANALOG, int NOISE_PERCENT, int SEED)
     SYS_CONTEXT: global system context

     META_LAYER: the object to init

     W: width

     H: height

     ANALOG: wether to use analog mode (0-255) or boolean (0-1)

     NOISE_PERCENT: the quantity of noise to initialise the layer with

     SEED: a pseudo-random seed to feed the pseudo-random generator

     Builds a custom metalyer, suitable for tests or demo, letting the
     choice of its size and the noise to fill it with.  If noise is 100
     then metalayer is "full".  If noise is 0, then meta layer is empty.

     *Return value:* 1 if OK, 0 on failure.

 -- Function: void lw6map_param_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM)
     SYS_CONTEXT: global system context

     PARAM: struct to initialize

     Sets a param struct to zero, simply puts zero everywhere without
     checking what was here before

     *Return value:* none.

 -- Function: void lw6map_param_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_param_t * PARAM)
     SYS_CONTEXT: global system context

     PARAM: the param struct to modify

     Sets a param structure to its default value, note that current
     structured must be zeroed or correctly initialized.

     *Return value:* none

 -- Function: void lw6map_param_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM)
     SYS_CONTEXT: global system context

     PARAM: the param struct to modify

     Resets a param structure to nothing.  Note that current structured
     must be zeroed or correctly initialized.  The idea is just to free
     member pointers before calling free.

     *Return value:* none

 -- Function: void lw6map_param_copy (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * DST, const lw6map_param_t * SRC)
     SYS_CONTEXT: global system context

     DST: the destination param struct

     SRC: the source param struct

     Copies parameters.  Both structures must be zeroed or correctly
     initialized.

     *Return value:* none

 -- Function: int lw6map_param_set (lw6sys_context_t * SYS_CONTEXT,
          lw6map_param_t * PARAM, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     PARAM: the param struct to modify

     KEY: the name of the parameter to modify

     VALUE: the value of the parameter to modify

     Sets an entry in a param struct.  All values must be submitted as
     strings, internally, the function will call atoi to convert to
     integers if needed, for instance.  It will also dispatch
     automatically between rules, style and teams.

     *Return value:* 1 if parameter successfully set, 0 on error.

 -- Function: char * lw6map_param_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_param_t * PARAM, const char * KEY)
     SYS_CONTEXT: global system context

     PARAM: the param struct to query

     KEY: the name of the parameter to get

     Gets an entry from a param struct.  All values returned as strings,
     do not use this in performance bottlenecks, this is just to export
     values to scripts, for instance.

     *Return value:* dynamically allocated string, NULL on error, might
     return a string containing 0 on bad keys.

 -- Function: int lw6map_param_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_param_t * PARAM_A, const lw6map_param_t *
          PARAM_B)
     SYS_CONTEXT: global system context

     PARAM_A: one struct to compare

     PARAM_B: another struct to compare

     Compares the contents of two param structs.

     *Return value:* 1 if they contain the same thing, 0 if not

 -- Function: void lw6map_rules_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     RULES: struct to initialize

     Sets a rules struct to zero, simply puts zero everywhere without
     checking what was here before

     *Return value:* none.

 -- Function: void lw6map_rules_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     RULES: struct to set to defaults

     Set rules to default values, as these are all integers, you can
     call this on any rules object.

     *Return value:* none.

 -- Function: void lw6map_rules_copy (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * DST, const lw6map_rules_t * SRC)
     SYS_CONTEXT: global system context

     DST: destination (out param)

     SRC: source (in param)

     Copies the data from source to destination, simple wrapper on
     memcpy.

     *Return value:* none.

 -- Function: void lw6map_rules_update_checksum (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES, u_int32_t *
          CHECKSUM)
     SYS_CONTEXT: global system context

     RULES: rules struct to check

     CHECKSUM: checksum to update (in/out param)

     Updates a checksum with the rules data.

     *Return value:* none.

 -- Function: int32_t lw6map_rules_get_default (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key to query

     Get the default value for a given string key.  Of course you could
     access the member, but this function internally does the conversion
     between readable string and actual struct offset.

     *Return value:* integer.

 -- Function: int32_t lw6map_rules_get_min (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key to query

     Get the min value for a given string key.  Of course you could
     access the member, but this function internally does the conversion
     between readable string and actual struct offset.

     *Return value:* integer.

 -- Function: int32_t lw6map_rules_get_max (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key to query

     Get the min value for a given string key.  Of course you could
     access the member, but this function internally does the conversion
     between readable string and actual struct offset.

     *Return value:* integer.

 -- Function: int32_t lw6map_rules_get_int (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES, const char * KEY)
     SYS_CONTEXT: global system context

     RULES: struct to use

     KEY: key to query

     Get the value for a given string key, as an integer.  Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:* integer.

 -- Function: int lw6map_rules_set_int (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, const char * KEY, int32_t VALUE)
     SYS_CONTEXT: global system context

     RULES: struct to use

     KEY: key to set

     VALUE: new integer value for key

     Set the value for a given string key, as an integer.  Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:* 1 on success, 0 on failure (eg key not found)

 -- Function: int lw6map_rules_get_bool (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_rules_t * RULES, const char * KEY)
     SYS_CONTEXT: global system context

     RULES: struct to use

     KEY: key to query

     Get the value for a given string key, as a boolean.  Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:* boolean.

 -- Function: int lw6map_rules_set_bool (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, const char * KEY, int VALUE)
     RULES: struct to use

     KEY: key to set

     VALUE: new boolean value for key

     Set the value for a given string key, as a boolean.  Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:* 1 on success, 0 on failure (eg key not found)

 -- Function: void lw6map_rules_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     RULES: struct to init

     Set rules to 0, this is not defaults, this is 0 (probably unusable
     as a real-world setting).

     *Return value:* none.

 -- Function: int lw6map_rules_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_rules_t * RULES_A, const lw6map_rules_t *
          RULES_B)
     SYS_CONTEXT: global system context

     RULES_A: first item to compare

     RULES_B: second item to compare

     Compares two rules items.  Will tell if they contain the same data.

     *Return value:* 1 if same, 0 if different.

 -- Function: int lw6map_rules_sanity_check (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_rules_t * RULES)
     SYS_CONTEXT: global system context

     RULES: rules to check.

     Check wether the rules are within the acceptable range.

     *Return value:* 1 if same, 0 if different.

 -- Function: void lw6map_style_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE)
     SYS_CONTEXT: global system context

     STYLE: struct to initialize

     Sets a style struct to zero, simply puts zero everywhere without
     checking what was here before

     *Return value:* none.

 -- Function: void lw6map_style_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_style_t * STYLE)
     SYS_CONTEXT: global system context

     STYLE: struct to modify

     Sets a style struct to defaults values, expects the object to be in
     a consistent style, that's to say either containing real data or
     being zeroed.

     *Return value:* none.

 -- Function: void lw6map_style_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE)
     SYS_CONTEXT: global system context

     STYLE: struct to clear

     Clears a style struct.  This function won't work on an unitialized
     structure, structure must be zeroed by some CALLOC or something,
     else automatic freeing of pointers will fail.

     *Return value:* none.

 -- Function: void lw6map_style_copy (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * DST, const lw6map_style_t * SRC)
     SYS_CONTEXT: global system context

     DST: destination

     SRC: source

     Copies style data from source to destination.  Like with clear,
     'dst' must be either initialized or totally zeroed, else function
     will fail (core dump)

     *Return value:* none.

 -- Function: int lw6map_style_set (lw6sys_context_t * SYS_CONTEXT,
          lw6map_style_t * STYLE, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     STYLE: style struct to modify (out param)

     KEY: key to use

     VALUE: value to use

     Sets a style entry, takes string values and will identify the
     struct offset and convert the value to whatever C type is needed.

     *Return value:* 1 on success, 0 on failure (key not found)

 -- Function: char * lw6map_style_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_style_t * STYLE, const char * KEY)
     SYS_CONTEXT: global system context

     STYLE: style struct to query

     KEY: key to use

     Get a style entry, takes a string key and will identify the struct
     offset.  The return value is converted to string, typically the
     cannonical representation suitable to write in an XML config file.

     *Return value:* dynamically allocated string.

 -- Function: char * lw6map_style_get_default (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key to query

     Get the default value for a style entry.  This is quite a
     cost-expensive function given what it does, indeed it will convert
     anything to a string, and also perform key lookup to fetch the
     value.

     *Return value:* dynamically allocated string.

 -- Function: int lw6map_color_set_is_same (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_color_set_t * COLOR_SET_A, const
          lw6map_color_set_t * COLOR_SET_B)
     SYS_CONTEXT: global system context

     COLOR_SET_A: first item to compare

     COLOR_SET_B: second item to compare

     Compares two color sets, telling if they contain the same data.

     *Return value:* 1 if same, 0 if different.

 -- Function: int lw6map_style_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_style_t * STYLE_A, const lw6map_style_t *
          STYLE_B)
     SYS_CONTEXT: global system context

     STYLE_A: first item to compare

     STYLE_B: second item to compare

     Compares two style structures, telling if they contain the same
     data.

     *Return value:* 1 if same, 0 if different.

 -- Function: void lw6map_teams_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS)
     SYS_CONTEXT: global system context

     TEAMS: data to initialize

     Zeros the teams struct, this is not the same as setting to
     defaults.

     *Return value:* none.

 -- Function: void lw6map_teams_defaults (lw6sys_context_t *
          SYS_CONTEXT, lw6map_teams_t * TEAMS)
     SYS_CONTEXT: global system context

     TEAMS: data to initialize

     Set the teams struct to its defaults.

     *Return value:* none.

 -- Function: void lw6map_teams_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS)
     SYS_CONTEXT: global system context

     TEAMS: data to initialize

     Clears the teams struct, this is not the same as setting to
     defaults.  This one supposes the struct has been properly
     initialized, at least zeroed before usage, it might contain
     pointers which should be freed.

     *Return value:* none.

 -- Function: void lw6map_teams_copy (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * DST, const lw6map_teams_t * SRC)
     SYS_CONTEXT: global system context

     DST: destination

     SRC: source

     Copies the contents of the teams struct.  It's a real duplicate,
     any string is reallocated.

     *Return value:* none.

 -- Function: int lw6map_teams_set (lw6sys_context_t * SYS_CONTEXT,
          lw6map_teams_t * TEAMS, const char * KEY, const char * VALUE)
     SYS_CONTEXT: global system context

     TEAMS: the teams to modify

     KEY: the key to modify

     VALUE: the value to affect to the key, as a string

     Sets one single parameter in a teams structure.  Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:* 1 if success, 0 if failed.  Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6map_teams_get (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_teams_t * TEAMS, const char * KEY)
     SYS_CONTEXT: global system context

     TEAMS: the teams to modify

     KEY: the key to modify

     Gets one single parameter in a teams structure.  Value is converted
     as a string.

     *Return value:* dynamically allocated string, NULL on error.

 -- Function: char * lw6map_teams_get_default (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: the key we want informations about.

     Gets the default value for a given teams key.

     *Return value:* dynamically allocated string, NULL on error.

 -- Function: int lw6map_teams_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6map_teams_t * TEAMS_A, const lw6map_teams_t *
          TEAMS_B)
     SYS_CONTEXT: global system context

     TEAMS_A: one struct to compare

     TEAMS_B: another struct to compare

     Compares the contents of two teams structs.

     *Return value:* 1 if they contain the same thing, 0 if not

 -- Function: int lw6map_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libmap module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6map_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'map' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6map_texture_from_body (lw6sys_context_t *
          SYS_CONTEXT, lw6map_texture_t * TEXTURE, const lw6map_body_t *
          BODY, const lw6map_color_couple_t * COLOR)
     SYS_CONTEXT: global system context

     TEXTURE: texture to load (out param)

     BODY: body to pick data from

     COLOR: colors to use

     Will create a default bicolor texture from the body data, this is
     in case we don't want to use the texture or there is none.  Result
     is not beautifull but might be very comfortable to play.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6map_texture_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6map_texture_t * TEXTURE)
     SYS_CONTEXT: global system context

     TEXTURE: data to clear

     Clears a texture object, expects it to be in a consitent state,
     either filled with real data of zeroed.

     *Return value:* none.

 -- Function: int lw6map_texture_coord_from_body (lw6sys_context_t *
          SYS_CONTEXT, const lw6map_level_t * LEVEL, int * TEXTURE_X,
          int * TEXTURE_Y, int BODY_X, int BODY_Y)
     SYS_CONTEXT: global system context

     LEVEL: map to work on

     TEXTURE_X: texture x coordinate (out param)

     TEXTURE_Y: texture y coordinate (out param)

     BODY_X: body x coordinate (in param)

     BODY_Y: body y coordinate (in param)

     Translates from body coordinate space to texture coordinate space.

     *Return value:* 1 on success, 0 if failure.

 -- Function: lw6sys_color_8_t lw6map_texture_get_with_body_coord
          (lw6sys_context_t * SYS_CONTEXT, const lw6map_level_t * LEVEL,
          int BODY_X, int BODY_Y)
     SYS_CONTEXT: global system context

     LEVEL: map to use

     BODY_X: x coordinate in body space

     BODY_Y: y coordinate in body space

     Get the color of a given point in the texture, using the body
     coordinate space.

     *Return value:* RGBA 8-bit color.

 -- Function: int lw6map_texture_has_alpha (lw6sys_context_t *
          SYS_CONTEXT, lw6map_texture_t * TEXTURE)
     SYS_CONTEXT: global system context

     TEXTURE: texture object to test

     Finds out if the texture is fully opaque or not.  If it has an
     alpha layer (typically, PNG file) but this one is filled at 100%
     everywhere, then it will consider opaque.  This is a slow function
     but the result is cached in the has_alpha member, so as the
     function is called at map loading, use the cached value instead.

     *Return value:* 1 if has used alpha layer, 0 if opaque.

 -- Function: char * lw6map_weapon_index_to_key (lw6sys_context_t *
          SYS_CONTEXT, int INDEX)
     SYS_CONTEXT: global system context

     INDEX: index of the weapon between 0 & 19

     Transforms a team weapon index into its readable string form, which
     can be used in config files for instance.

     *Return value:* a string, must *not* be freed.

 -- Function: int lw6map_weapon_key_to_index (lw6sys_context_t *
          SYS_CONTEXT, const char * KEY)
     SYS_CONTEXT: global system context

     KEY: key of the weapon, for instance "red"

     The index of the weapon, between 0 & 19

     *Return value:* an integer.

 -- Function: char * lw6map_weapon_index_to_label (lw6sys_context_t *
          SYS_CONTEXT, int INDEX)
     SYS_CONTEXT: global system context

     INDEX: index of the weapon between 0 & 19

     Transforms a team weapon index into its readable string form, which
     can be used to display information to players.

     *Return value:* a string, must *not* be freed.

 -- Struct: lw6map_body_s

     Logical layers for the map.  This is the big collection of bytes
     arrays containing most of the information, anything loaded from
     images (JPEG, PNG) from disk and having some logical (and not pure
     eye candy) meaning.

 -- Member of lw6map_body_s: checksum
     *Type:* 'int'

     *Definition:* 'int lw6map_body_s::checksum'

     Checksum for this map body, we could recalculate it dynamically but
     it's cached here for convenience and speed.

 -- Member of lw6map_body_s: shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6map_body_s::shape'

     Shape of the map, all layers need to be compatible with this.

 -- Member of lw6map_body_s: layers
     *Type:* 'lw6map_layer_t'

     *Definition:* 'lw6map_layer_t
     lw6map_body_s::layers[LW6MAP_MAX_BODY_DEPTH]'

     Layers, layer 0 is the top layer, the one stored in map.png, other
     layers are layerN.png.  Not all layers are defined, just depends on
     body shape.

 -- Member of lw6map_body_s: glue
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::glue'

     Informations stored in glue.png.

 -- Member of lw6map_body_s: boost
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::boost'

     Informations stored in boost.png.

 -- Member of lw6map_body_s: danger
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::danger'

     Informations stored in danger.png.

 -- Member of lw6map_body_s: medicine
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::medicine'

     Informations stored in medicine.png.

 -- Member of lw6map_body_s: one_way_north
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::one_way_north'

     Informations stored in one-way-north.png.

 -- Member of lw6map_body_s: one_way_east
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::one_way_east'

     Informations stored in one-way-east.png.

 -- Member of lw6map_body_s: one_way_south
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::one_way_south'

     Informations stored in one-way-south.png.

 -- Member of lw6map_body_s: one_way_west
     *Type:* 'lw6map_meta_layer_t'

     *Definition:* 'lw6map_meta_layer_t lw6map_body_s::one_way_west'

     Informations stored in one-way-west.png.

 -- Struct: lw6map_bot_info_s

     Bot information, contains the relevant generic parameters for a
     bot.

 -- Member of lw6map_bot_info_s: color
     *Type:* 'int'

     *Definition:* 'int lw6map_bot_info_s::color'

     Team/color the bot is associated to.

 -- Member of lw6map_bot_info_s: ai
     *Type:* 'char *'

     *Definition:* 'char* lw6map_bot_info_s::ai'

     AI engine used by bot, the name of the backend to load.

 -- Struct: lw6map_color_couple_s

     This structure simply binds 2 colors together, one being foreground
     and the other background.  There's a good reason to bind those
     together, indeed foreground and background need to be different
     enough so that text written in fg over bg is readable, and they
     need to go together well.

 -- Member of lw6map_color_couple_s: fg
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t lw6map_color_couple_s::fg'

     Foreground color.

 -- Member of lw6map_color_couple_s: bg
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t lw6map_color_couple_s::bg'

     Background color.

 -- Struct: lw6map_color_set_s

     Holds the complete color set for the game, including all color
     couples used for background, hud, menu, view, as well as team
     colors.

 -- Member of lw6map_color_set_s: color_base
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::color_base'

     Base color couple.

 -- Member of lw6map_color_set_s: color_alternate
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::color_alternate'

     Alternate color couple.

 -- Member of lw6map_color_set_s: background_color_root
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::background_color_root'

     Background color couple for root image.

 -- Member of lw6map_color_set_s: background_color_stuff
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::background_color_stuff'

     Background color couple for drawn stuff.

 -- Member of lw6map_color_set_s: hud_color_frame
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::hud_color_frame'

     Hud color couple for frames.

 -- Member of lw6map_color_set_s: hud_color_text
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::hud_color_text'

     Hud color couple for text.

 -- Member of lw6map_color_set_s: menu_color_default
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::menu_color_default'

     Menu default color couple.

 -- Member of lw6map_color_set_s: menu_color_selected
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::menu_color_selected'

     Menu color couple for selected items.

 -- Member of lw6map_color_set_s: menu_color_disabled
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::menu_color_disabled'

     Menu color couple for disabled items.

 -- Member of lw6map_color_set_s: view_color_cursor
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::view_color_cursor'

     Map view color couple for cursor.

 -- Member of lw6map_color_set_s: view_color_map
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::view_color_map'

     Map view color couple for map.

 -- Member of lw6map_color_set_s: system_color
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_color_set_s::system_color'

     System color couple (log messages).

 -- Member of lw6map_color_set_s: team_color_dead
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t
     lw6map_color_set_s::team_color_dead'

     Color to use for dead fighters.

 -- Member of lw6map_color_set_s: team_colors
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t
     lw6map_color_set_s::team_colors[LW6MAP_NB_TEAM_COLORS]'

     Team colors.

 -- Struct: lw6map_cursor_texture_layer_s

     Contains a cursor texture layer, this is basically a fixed (64x64)
     sized array of colors.

 -- Member of lw6map_cursor_texture_layer_s: data
     *Type:* 'lw6sys_color_8_t'

     *Definition:* 'lw6sys_color_8_t
     lw6map_cursor_texture_layer_s::data[LW6MAP_CURSOR_TEXTURE_SIZE][LW6MAP_CURSOR_TEXTURE_SIZE]'

     Color for each pixel.

 -- Struct: lw6map_cursor_texture_s

     A cursor texture.  It's divided between a texture that will be
     colorized depending on the map and another texture which will be
     colorized depending on the team playing the cursor.

 -- Member of lw6map_cursor_texture_s: fg_bg_layer
     *Type:* 'lw6map_cursor_texture_layer_t'

     *Definition:* 'lw6map_cursor_texture_layer_t
     lw6map_cursor_texture_s::fg_bg_layer'

     Layer to be colorized using foreground and background colors.

 -- Member of lw6map_cursor_texture_s: color_layer
     *Type:* 'lw6map_cursor_texture_layer_t'

     *Definition:* 'lw6map_cursor_texture_layer_t
     lw6map_cursor_texture_s::color_layer'

     Layer to be colorized using team colors.

 -- Struct: lw6map_layer_s

     A layer contains the actual data for a layer.

 -- Member of lw6map_layer_s: shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6map_layer_s::shape'

     Shape of the layer.  Z should be 1, logically.

 -- Member of lw6map_layer_s: data
     *Type:* 'u_int8_t *'

     *Definition:* 'u_int8_t* lw6map_layer_s::data'

     Raw (byte) data.

 -- Struct: lw6map_level_s

     This structure contains everything about a level, once it's loaded
     from disk.  It's immutable, it cannot be changed once it's loaded,
     and does not have any algorithm aware struct, this is just plain
     raw data, file data transformed into C struct.

 -- Member of lw6map_level_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6map_level_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6map_level_s: metadata
     *Type:* 'lw6map_metadata_t'

     *Definition:* 'lw6map_metadata_t lw6map_level_s::metadata'

     Metadata (title, copyright, description, ...)

 -- Member of lw6map_level_s: local_info
     *Type:* 'lw6map_local_info_t'

     *Definition:* 'lw6map_local_info_t lw6map_level_s::local_info'

     Informations that depend on the host loading the map.

 -- Member of lw6map_level_s: body
     *Type:* 'lw6map_body_t'

     *Definition:* 'lw6map_body_t lw6map_level_s::body'

     All layers (bytes array) forming the map.

 -- Member of lw6map_level_s: texture
     *Type:* 'lw6map_texture_t'

     *Definition:* 'lw6map_texture_t lw6map_level_s::texture'

     Texture used by the map.

 -- Member of lw6map_level_s: cursor_texture
     *Type:* 'lw6map_cursor_texture_t'

     *Definition:* 'lw6map_cursor_texture_t
     lw6map_level_s::cursor_texture'

     Cursor texture.

 -- Member of lw6map_level_s: param
     *Type:* 'lw6map_param_t'

     *Definition:* 'lw6map_param_t lw6map_level_s::param'

     All map parameters.

 -- Struct: lw6map_local_info_s

     Local info is for fields which can be exploited locally, but make
     no sense if transfered to another computer, over the network for
     instance.  This is typically something which will be updated by the
     ldr module or some other external code, but it's not directly
     linked to the content of the map itself.

 -- Member of lw6map_local_info_s: music_dir
     *Type:* 'char *'

     *Definition:* 'char* lw6map_local_info_s::music_dir'

     Directory where music files can be loaded.

 -- Struct: lw6map_metadata_s

     Content of metadata.xml stored into a C struct.

 -- Member of lw6map_metadata_s: title
     *Type:* 'char *'

     *Definition:* 'char* lw6map_metadata_s::title'

     Title of the map.

 -- Member of lw6map_metadata_s: author
     *Type:* 'char *'

     *Definition:* 'char* lw6map_metadata_s::author'

     Author of the map.

 -- Member of lw6map_metadata_s: description
     *Type:* 'char *'

     *Definition:* 'char* lw6map_metadata_s::description'

     Description of the map.

 -- Member of lw6map_metadata_s: license
     *Type:* 'char *'

     *Definition:* 'char* lw6map_metadata_s::license'

     License of the map (short, like GPLv2+ or GPLv3+).

 -- Member of lw6map_metadata_s: vanilla_exp
     *Type:* 'int'

     *Definition:* 'int lw6map_metadata_s::vanilla_exp'

     Exp as stored in the XML file of the map.

 -- Struct: lw6map_meta_layer_s

     A meta layer is a special layer which contains, for instance,
     informations such as where there's a special trick like glue.

 -- Member of lw6map_meta_layer_s: shape
     *Type:* 'lw6sys_whd_t'

     *Definition:* 'lw6sys_whd_t lw6map_meta_layer_s::shape'

     Shape of the metalayer.

 -- Member of lw6map_meta_layer_s: data
     *Type:* 'u_int8_t *'

     *Definition:* 'u_int8_t* lw6map_meta_layer_s::data'

     Raw (byte) data.

 -- Struct: lw6map_param_s

     All parameters in a map, indludes rules, style and teams.

 -- Member of lw6map_param_s: rules
     *Type:* 'lw6map_rules_t'

     *Definition:* 'lw6map_rules_t lw6map_param_s::rules'

     Content of rules.xml.

 -- Member of lw6map_param_s: style
     *Type:* 'lw6map_style_t'

     *Definition:* 'lw6map_style_t lw6map_param_s::style'

     Content of style.xml.

 -- Member of lw6map_param_s: teams
     *Type:* 'lw6map_teams_t'

     *Definition:* 'lw6map_teams_t lw6map_param_s::teams'

     Content of teams.xml.

 -- Struct: lw6map_rules_s

     Content of rules.xml stored into a C struct.  This structure is
     used a lot, it needs to be like this for we don't want to parse
     (even a hash) each time we want a param so we need it in a real C
     struct.  In this structure, it's important, fundamental, that
     floats are never ever used in map rules.  In fact, we need maps to
     be 100,00 (lots of zeroes) predictable, given some identical user
     actions.  Using floats could lead us to very slight differences
     (floats are never accurate, especially when you run calculus on
     different hardwares) which could, with time, become very important.
     Sort of a "butterfly effect".  So well, we use int.  Int32 to be
     exact.

 -- Member of lw6map_rules_s: total_time
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::total_time'

     total_time parameter, stored as an integer.

 -- Member of lw6map_rules_s: respawn_team
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::respawn_team'

     respawn_team parameter, stored as an integer.

 -- Member of lw6map_rules_s: respawn_position_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::respawn_position_mode'

     respawn_position_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: respawn_delay
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::respawn_delay'

     respawn_delay parameter, stored as an integer.

 -- Member of lw6map_rules_s: moves_per_round
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::moves_per_round'

     moves_per_round parameter, stored as an integer.

 -- Member of lw6map_rules_s: spreads_per_round
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::spreads_per_round'

     spreads_per_round parameter, stored as an integer.

 -- Member of lw6map_rules_s: rounds_per_sec
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::rounds_per_sec'

     rounds_per_sec parameter, stored as an integer.

 -- Member of lw6map_rules_s: fighter_attack
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::fighter_attack'

     fighter_attack parameter, stored as an integer.

 -- Member of lw6map_rules_s: fighter_defense
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::fighter_defense'

     fighter_defense parameter, stored as an integer.

 -- Member of lw6map_rules_s: fighter_new_health
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::fighter_new_health'

     fighter_new_health parameter, stored as an integer.

 -- Member of lw6map_rules_s: fighter_regenerate
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::fighter_regenerate'

     fighter_regenerate parameter, stored as an integer.

 -- Member of lw6map_rules_s: side_attack_factor
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::side_attack_factor'

     side_attack_factor parameter, stored as an integer.

 -- Member of lw6map_rules_s: side_defense_factor
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::side_defense_factor'

     side_defense_factor parameter, stored as an integer.

 -- Member of lw6map_rules_s: nb_move_tries
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::nb_move_tries'

     nb_move_tries parameter, stored as an integer.

 -- Member of lw6map_rules_s: nb_attack_tries
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::nb_attack_tries'

     nb_attack_tries parameter, stored as an integer.

 -- Member of lw6map_rules_s: nb_defense_tries
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::nb_defense_tries'

     nb_defense_tries parameter, stored as an integer.

 -- Member of lw6map_rules_s: vertical_move
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::vertical_move'

     vertical_move parameter, stored as an integer.

 -- Member of lw6map_rules_s: spread_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::spread_mode'

     spread_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: single_army_size
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::single_army_size'

     single_army_size parameter, stored as an integer.

 -- Member of lw6map_rules_s: total_armies_size
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::total_armies_size'

     total_armies_size parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_nb_teams
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_nb_teams'

     max_nb_teams parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_nb_cursors
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_nb_cursors'

     max_nb_cursors parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_nb_nodes
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_nb_nodes'

     max_nb_nodes parameter, stored as an integer.

 -- Member of lw6map_rules_s: exp
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::exp'

     exp parameter, stored as an integer.

 -- Member of lw6map_rules_s: highest_team_color_allowed
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::highest_team_color_allowed'

     highest_team_color_allowed parameter, stored as an integer.

 -- Member of lw6map_rules_s: highest_weapon_allowed
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::highest_weapon_allowed'

     highest_weapon_allowed parameter, stored as an integer.

 -- Member of lw6map_rules_s: x_polarity
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::x_polarity'

     x_polarity parameter, stored as an integer.

 -- Member of lw6map_rules_s: y_polarity
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::y_polarity'

     y_polarity parameter, stored as an integer.

 -- Member of lw6map_rules_s: z_polarity
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::z_polarity'

     z_polarity parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_zone_size
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_zone_size'

     max_zone_size parameter, stored as an integer.

 -- Member of lw6map_rules_s: round_delta
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::round_delta'

     round_delta parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_round_delta
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_round_delta'

     max_round_delta parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_cursor_pot
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_cursor_pot'

     max_cursor_pot parameter, stored as an integer.

 -- Member of lw6map_rules_s: cursor_pot_init
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::cursor_pot_init'

     cursor_pot_init parameter, stored as an integer.

 -- Member of lw6map_rules_s: max_cursor_pot_offset
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::max_cursor_pot_offset'

     max_cursor_pot_offset parameter, stored as an integer.

 -- Member of lw6map_rules_s: start_x
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::start_x[LW6MAP_MAX_NB_TEAMS]'

     start_x parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: start_y
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::start_y[LW6MAP_MAX_NB_TEAMS]'

     start_y parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: start_position_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::start_position_mode'

     start_position_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: color_conflict_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::color_conflict_mode'

     color_conflict_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: spread_thread
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::spread_thread'

     spread_thread parameter, stored as an integer.

 -- Member of lw6map_rules_s: glue_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::glue_power'

     glue_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: boost_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::boost_power'

     boost_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: danger_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::danger_power'

     danger_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: medicine_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::medicine_power'

     medicine_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: frags_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::frags_mode'

     frags_mode parameter, stored as an integer.

 -- Member of lw6map_rules_s: frags_to_distribute
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::frags_to_distribute'

     frags_to_distribute parameter, stored as an integer.

 -- Member of lw6map_rules_s: frags_fade_out
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::frags_fade_out'

     frags_fade_out parameter, stored as an integer.

 -- Member of lw6map_rules_s: use_team_profiles
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::use_team_profiles'

     use_team_profiles parameter, stored as an integer.

 -- Member of lw6map_rules_s: team_profile_aggressive
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_aggressive[LW6MAP_MAX_NB_TEAMS]'

     team_profile_aggressive parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_vulnerable
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_vulnerable[LW6MAP_MAX_NB_TEAMS]'

     team_profile_vulnerable parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_mobile
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_mobile[LW6MAP_MAX_NB_TEAMS]'

     team_profile_mobile parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_fast
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_fast[LW6MAP_MAX_NB_TEAMS]'

     team_profile_fast parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_handicap
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_handicap[LW6MAP_MAX_NB_TEAMS]'

     team_profile_handicap parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_weapon_id
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_weapon_id[LW6MAP_MAX_NB_TEAMS]'

     team_profile_weapon_id parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: team_profile_weapon_alternate_id
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_weapon_alternate_id[LW6MAP_MAX_NB_TEAMS]'

     team_profile_weapon_alternate_id parameters, stored as a per team
     integer.

 -- Member of lw6map_rules_s: team_profile_weapon_mode
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6map_rules_s::team_profile_weapon_mode[LW6MAP_MAX_NB_TEAMS]'

     team_profile_weapon_mode parameters, stored as a per team integer.

 -- Member of lw6map_rules_s: weapon_duration
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_duration'

     weapon_duration parameter, stored as an integer.

 -- Member of lw6map_rules_s: weapon_charge_delay
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_charge_delay'

     weapon_charge_delay parameter, stored as an integer.

 -- Member of lw6map_rules_s: weapon_charge_max
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_charge_max'

     weapon_charge_max parameter, stored as an integer.

 -- Member of lw6map_rules_s: weapon_tune_berzerk_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_tune_berzerk_power'

     weapon_tune_berzerk_power parameter, stored as an integer.

 -- Member of lw6map_rules_s: weapon_tune_turbo_power
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6map_rules_s::weapon_tune_turbo_power'

     weapon_tune_turbo_power parameter, stored as an integer.

 -- Struct: lw6map_style_s

     Content of style.xml stored into a C struct.

 -- Member of lw6map_style_s: keep_ratio
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::keep_ratio'

     Boolean, wether to keep the map ratio or not.

 -- Member of lw6map_style_s: zoom
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::zoom'

     Default zoom.

 -- Member of lw6map_style_s: zoom_min
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::zoom_min'

     Min zoom.

 -- Member of lw6map_style_s: zoom_max
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::zoom_max'

     Max zoom.

 -- Member of lw6map_style_s: x_wrap
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::x_wrap'

     Wether to wrap on X axis.

 -- Member of lw6map_style_s: y_wrap
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::y_wrap'

     Wether to wrap on Y axis.

 -- Member of lw6map_style_s: background_style
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::background_style'

     Background style to use (for instance, bubbles).

 -- Member of lw6map_style_s: hud_style
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::hud_style'

     Hud style to use (for instance, floating).

 -- Member of lw6map_style_s: menu_style
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::menu_style'

     Menu style to use (for instance, cylinder).

 -- Member of lw6map_style_s: view_style
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::view_style'

     View style to use (for instance, flat).

 -- Member of lw6map_style_s: animation_density
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::animation_density'

     How dense animations should be (many or few sprites).

 -- Member of lw6map_style_s: animation_speed
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::animation_speed'

     How fast animations should be (sprites speed).

 -- Member of lw6map_style_s: cursor_size
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::cursor_size'

     Cursor size.

 -- Member of lw6map_style_s: colorize_cursor
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::colorize_cursor'

     Wether to colorize cursors or not.

 -- Member of lw6map_style_s: blink_cursor
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::blink_cursor'

     Wether to make cursors blink or not.

 -- Member of lw6map_style_s: hidden_layer_alpha
     *Type:* 'float'

     *Definition:* 'float lw6map_style_s::hidden_layer_alpha'

     Alpha value used to represent fighters hidden behind a layer.

 -- Member of lw6map_style_s: colorize
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::colorize'

     Wether to use colorization or not.

 -- Member of lw6map_style_s: pixelize
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::pixelize'

     Wether to pixelize the map and fighters or not.

 -- Member of lw6map_style_s: color_set
     *Type:* 'lw6map_color_set_t'

     *Definition:* 'lw6map_color_set_t lw6map_style_s::color_set'

     All colors used by the game.

 -- Member of lw6map_style_s: music_file
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::music_file'

     Music file to play.

 -- Member of lw6map_style_s: music_filter
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::music_filter'

     Music files to keep.

 -- Member of lw6map_style_s: music_exclude
     *Type:* 'char *'

     *Definition:* 'char* lw6map_style_s::music_exclude'

     Music files to exclude.

 -- Member of lw6map_style_s: waves
     *Type:* 'int'

     *Definition:* 'int lw6map_style_s::waves'

     Wether to turn on the wave effect or not.

 -- Struct: lw6map_teams_s

     Content of teams.xml stored into a C struct.

 -- Member of lw6map_teams_s: player_color
     *Type:* 'int'

     *Definition:* 'int
     lw6map_teams_s::player_color[LW6MAP_TEAMS_NB_PLAYERS]'

     Players colors.

 -- Member of lw6map_teams_s: nb_bots
     *Type:* 'int'

     *Definition:* 'int lw6map_teams_s::nb_bots'

     Number of bots.

 -- Member of lw6map_teams_s: bot_speed
     *Type:* 'float'

     *Definition:* 'float lw6map_teams_s::bot_speed'

     Bots speed.

 -- Member of lw6map_teams_s: bot_iq
     *Type:* 'int'

     *Definition:* 'int lw6map_teams_s::bot_iq'

     Bots IQ (how strong they are)

 -- Member of lw6map_teams_s: bot
     *Type:* 'lw6map_bot_info_t'

     *Definition:* 'lw6map_bot_info_t
     lw6map_teams_s::bot[LW6MAP_TEAMS_MAX_NB_BOTS]'

     Per-bot parameters, including their color and the ai engine they
     use.

 -- Struct: lw6map_texture_s

     Texture information, this is a bit different from a layer, since
     this is RGBA data, plus some meta-informations such as guessed
     colors.

 -- Member of lw6map_texture_s: w
     *Type:* 'int'

     *Definition:* 'int lw6map_texture_s::w'

     Texture width.

 -- Member of lw6map_texture_s: h
     *Type:* 'int'

     *Definition:* 'int lw6map_texture_s::h'

     Texture height.

 -- Member of lw6map_texture_s: has_alpha
     *Type:* 'int'

     *Definition:* 'int lw6map_texture_s::has_alpha'

     True if texture has an alpha channel.  If it has an alpha channel
     on disk (for instance, it's a PNG) and if in practice it has
     nothing else than full opaque 255 alpha values, then this will be
     set to 0 anyway, the idea is to detect textures that really need
     the engine to handle transparency.

 -- Member of lw6map_texture_s: data
     *Type:* 'lw6sys_color_8_t *'

     *Definition:* 'lw6sys_color_8_t* lw6map_texture_s::data'

     Color for each pixel.

 -- Member of lw6map_texture_s: guessed_color_base
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_texture_s::guessed_color_base'

     Base guessed color couple.  This is typically the best or more
     representative color couple (fg and bg) the program was able to
     automatically extract from the map.

 -- Member of lw6map_texture_s: guessed_color_alternate
     *Type:* 'lw6map_color_couple_t'

     *Definition:* 'lw6map_color_couple_t
     lw6map_texture_s::guessed_color_alternate'

     An alternate color couple which still comes from the map but is a
     bit different from the base one.

5.32 libmat
===========

5.32.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/mat/index.html>.

5.32.2 API
----------

 -- Function: void lw6mat_dmat2_zero (lw6mat_dmat2_t * DMAT2)
     DMAT2: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_dmat2_identity (lw6mat_dmat2_t * DMAT2)
     DMAT2: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_dmat2_translation (lw6mat_dmat2_t * DMAT2,
          double D)
     DMAT2: the matrix to initialize.

     D: value which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat2_scale (lw6mat_dmat2_t * DMAT2, double D)
     DMAT2: the matrix to initialize.

     D: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: int lw6mat_dmat2_is_same (const lw6mat_dmat2_t * DMAT2_A,
          const lw6mat_dmat2_t * DMAT2_B)
     DMAT2_A: 1st matrix to compare

     DMAT2_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_dmat2_transpose (lw6mat_dmat2_t * DMAT2)
     DMAT2: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: double lw6mat_dmat2_det (const lw6mat_dmat2_t * DMAT2)
     DMAT2: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_dmat2_mul_scale (lw6mat_dmat2_t * DMAT2,
          double F)
     DMAT2: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_dmat2_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_dmat2_t * DMAT2_DST, const lw6mat_dmat2_t * DMAT2_SRC)
     SYS_CONTEXT: global system context

     DMAT2_DST: the matrix inverted

     DMAT2_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_dmat2_mul_dmat2 (lw6mat_dmat2_t * DMAT2, const
          lw6mat_dmat2_t * DMAT2_A, const lw6mat_dmat2_t * DMAT2_B)
     DMAT2: the result matrix

     DMAT2_A: the 1st matrix to multiply, on the left

     DMAT2_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_dmat2_mul_dvec2 (lw6mat_dvec2_t * DVEC2_DST,
          const lw6mat_dmat2_t * DMAT2, const lw6mat_dvec2_t *
          DVEC2_SRC)
     DVEC2_DST: the result vector

     DVEC2_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: char * lw6mat_dmat2_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dmat2_t * DMAT2)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_dmat3_zero (lw6mat_dmat3_t * DMAT3)
     DMAT3: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_identity (lw6mat_dmat3_t * DMAT3)
     DMAT3: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_translation (lw6mat_dmat3_t * DMAT3,
          const lw6mat_dvec2_t * DVEC2)
     DMAT3: the matrix to initialize.

     DVEC2: vector which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_scale (lw6mat_dmat3_t * DMAT3, const
          lw6mat_dvec2_t * DVEC2)
     DMAT3: the matrix to initialize.

     DVEC2: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_rot (lw6mat_dmat3_t * DMAT3, double R)
     DMAT3: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over a virtual Z axis such as Z is the
     cross product of X and Y.

     *Return value:* none.

 -- Function: int lw6mat_dmat3_is_same (const lw6mat_dmat3_t * DMAT3_A,
          const lw6mat_dmat3_t * DMAT3_B)
     DMAT3_A: 1st matrix to compare

     DMAT3_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_dmat3_transpose (lw6mat_dmat3_t * DMAT3)
     DMAT3: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: double lw6mat_dmat3_det (const lw6mat_dmat3_t * DMAT3)
     DMAT3: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_dmat3_mul_scale (lw6mat_dmat3_t * DMAT3,
          double F)
     DMAT3: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_dmat3_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_dmat3_t * DMAT3_DST, const lw6mat_dmat3_t * DMAT3_SRC)
     SYS_CONTEXT: global system context

     DMAT3_DST: the matrix inverted

     DMAT3_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_dmat3_mul_dmat3 (lw6mat_dmat3_t * DMAT3, const
          lw6mat_dmat3_t * DMAT3_A, const lw6mat_dmat3_t * DMAT3_B)
     DMAT3: the result matrix

     DMAT3_A: the 1st matrix to multiply, on the left

     DMAT3_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_mul_dvec3 (lw6mat_dvec3_t * DVEC3_DST,
          const lw6mat_dmat3_t * DMAT3, const lw6mat_dvec3_t *
          DVEC3_SRC)
     DVEC3_DST: the result vector

     DVEC3_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: void lw6mat_dmat3_mul_dvec2 (lw6mat_dvec2_t * DVEC2_DST,
          const lw6mat_dmat3_t * DMAT3, const lw6mat_dvec2_t *
          DVEC2_SRC)
     DVEC2_DST: the result vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.  The vector, here, is smaller than
     the matrix, the last element is supposed to be 1, this is how one
     implements translation through multiplication.

     *Return value:* none.

 -- Function: char * lw6mat_dmat3_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dmat3_t * DMAT3)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_dmat4_zero (lw6mat_dmat4_t * DMAT4)
     DMAT4: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_identity (lw6mat_dmat4_t * DMAT4)
     DMAT4: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_translation (lw6mat_dmat4_t * DMAT4,
          const lw6mat_dvec3_t * DVEC3)
     DMAT4: the matrix to initialize.

     DVEC3: vector which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_scale (lw6mat_dmat4_t * DMAT4, const
          lw6mat_dvec3_t * DVEC3)
     DMAT4: the matrix to initialize.

     DVEC3: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_rot_x (lw6mat_dmat4_t * DMAT4, double R)
     DMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the X axis.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_rot_y (lw6mat_dmat4_t * DMAT4, double R)
     DMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the Y axis.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_rot_z (lw6mat_dmat4_t * DMAT4, double R)
     DMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the Z axis.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_ortho (lw6mat_dmat4_t * DMAT4, double
          LEFT, double RIGHT, double BOTTOM, double TOP, double NEARVAL,
          double FARVAL)
     DMAT4: the matrix to initialize.

     LEFT: left plane coordinate

     RIGHT: right plane coordinate

     BOTTOM: bottom plane coordinate

     TOP: top plane coordinate

     NEARVAL: near plane coordinate

     FARVAL: far plane coordinate

     Loads the matrix with an orthogonal projection matrix.  Does it the
     way glOrtho would, see
     https://www.opengl.org/sdk/docs/man2/xhtml/glOrtho.xml for details.

     *Note:* use -nearVal and -farVal to initialize.  It's a little
     akward, if you expect to pass vectors with positions ranging from
     nearVal to farVal then you need to pass -nearVal and -farVal to
     this function.  This is probably due to the fact that with a
     right-handed basis and X,Y set up "as usual", then Z is negative
     when going farther and farther.  This tweak allows farVal to yield
     +1 and nearVal -1.  We keep this function as is here, as this is
     the way OpenGL functions seem to work.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_perspective (lw6mat_dmat4_t * DMAT4,
          double FOVY, double ASPECT, double ZNEAR, double ZFAR)
     DMAT4: the matrix to initialize.

     FOVY: vertical field of view (degrees, not radians)

     ASPECT: x/y ratio

     ZNEAR: near plane coordinate (use -znear to initialize)

     ZFAR: far plane coordinate (use -zfar to initialize)

     Loads the matrix with a projection matrix.  Does it the way
     gluPerspective would, see
     https://www.opengl.org/sdk/docs/man2/xhtml/gluPerspective.xml for
     details.

     *Return value:* none.

 -- Function: int lw6mat_dmat4_is_same (const lw6mat_dmat4_t * DMAT4_A,
          const lw6mat_dmat4_t * DMAT4_B)
     DMAT4_A: 1st matrix to compare

     DMAT4_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_dmat4_transpose (lw6mat_dmat4_t * DMAT4)
     DMAT4: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: double lw6mat_dmat4_det (const lw6mat_dmat4_t * DMAT4)
     DMAT4: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_dmat4_mul_scale (lw6mat_dmat4_t * DMAT4,
          double F)
     DMAT4: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_dmat4_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_dmat4_t * DMAT4_DST, const lw6mat_dmat4_t * DMAT4_SRC)
     SYS_CONTEXT: global system context

     DMAT4_DST: the matrix inverted

     DMAT4_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_dmat4_mul_dmat4 (lw6mat_dmat4_t * DMAT4, const
          lw6mat_dmat4_t * DMAT4_A, const lw6mat_dmat4_t * DMAT4_B)
     DMAT4: the result matrix

     DMAT4_A: the 1st matrix to multiply, on the left

     DMAT4_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_mul_dvec4 (lw6mat_dvec4_t * DVEC4_DST,
          const lw6mat_dmat4_t * DMAT4, const lw6mat_dvec4_t *
          DVEC4_SRC)
     DVEC4_DST: the result vector

     DMAT4: the matrix to use

     DVEC4_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: void lw6mat_dmat4_mul_dvec3 (lw6mat_dvec3_t * DVEC3_DST,
          const lw6mat_dmat4_t * DMAT4, const lw6mat_dvec3_t *
          DVEC3_SRC)
     DVEC3_DST: the result vector

     DMAT4: the matrix to use

     DVEC3_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.  The vector, here, is smaller than
     the matrix, the last element is supposed to be 1, this is how one
     implements translation through multiplication.

     *Return value:* none.

 -- Function: char * lw6mat_dmat4_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dmat4_t * DMAT4)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_dvec2_zero (lw6mat_dvec2_t * DVEC2)
     DVEC2: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_dvec2_is_same (const lw6mat_dvec2_t * DVEC2_A,
          const lw6mat_dvec2_t * DVEC2_B)
     DVEC2_A: 1st vector to compare

     DVEC2_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: double lw6mat_dvec2_len_sq (const lw6mat_dvec2_t * DVEC2)
     DVEC2: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: double lw6mat_dvec2_len (const lw6mat_dvec2_t * DVEC2)
     DVEC2: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_dvec2_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec2_t * DVEC2)
     SYS_CONTEXT: global system context

     DVEC2: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_dvec2_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec2_t * DVEC2)
     SYS_CONTEXT: global system context

     DVEC2: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_dvec2_neg (lw6mat_dvec2_t * DVEC2)
     DVEC2: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_dvec2_add (lw6mat_dvec2_t * DVEC2, const
          lw6mat_dvec2_t * DVEC2_A, const lw6mat_dvec2_t * DVEC2_B)
     DVEC2: result vector

     DVEC2_A: 1st vector to add

     DVEC2_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec2_sub (lw6mat_dvec2_t * DVEC2, const
          lw6mat_dvec2_t * DVEC2_A, const lw6mat_dvec2_t * DVEC2_B)
     DVEC2: result vector

     DVEC2_A: 1st vector

     DVEC2_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: double lw6mat_dvec2_dot (const lw6mat_dvec2_t * DVEC2_A,
          const lw6mat_dvec2_t * DVEC2_B)
     DVEC2_A: 1st vector

     DVEC2_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec2_cross (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec2_t * DVEC2_A, const lw6mat_dvec2_t * DVEC2_B)
     DVEC3: result vector

     DVEC2_A: 1st vector

     DVEC2_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.
     Since cross product only really makes sense in 3D, this function
     will interpret the 2D vectors as 3D vectors with z set t zero, that
     is, a vector in the xy plane.

     *Return value:* none

 -- Function: void lw6mat_dvec2_mul_scale (lw6mat_dvec2_t * DVEC2,
          double F)
     DVEC2: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_dvec2_mul_dvec2 (lw6mat_dmat2_t * DMAT2, const
          lw6mat_dvec2_t * DVEC2_A, const lw6mat_dvec2_t * DVEC2_B)
     DMAT2: result matrix

     DVEC2_A: 1st row vector

     DVEC2_B: 2nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_dvec2_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dvec2_t * DVEC2)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_dvec3_zero (lw6mat_dvec3_t * DVEC3)
     DVEC3: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_dvec3_is_same (const lw6mat_dvec3_t * DVEC3_A,
          const lw6mat_dvec3_t * DVEC3_B)
     DVEC3_A: 1st vector to compare

     DVEC3_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: double lw6mat_dvec3_len_sq (const lw6mat_dvec3_t * DVEC3)
     DVEC3: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: double lw6mat_dvec3_len (const lw6mat_dvec3_t * DVEC3)
     DVEC3: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_dvec3_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec3_t * DVEC3)
     SYS_CONTEXT: global system context

     DVEC3: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_dvec3_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec3_t * DVEC3)
     SYS_CONTEXT: global system context

     DVEC3: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_dvec3_neg (lw6mat_dvec3_t * DVEC3)
     DVEC3: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_dvec3_add (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec3_t * DVEC3_A, const lw6mat_dvec3_t * DVEC3_B)
     DVEC3: result vector

     DVEC3_A: 1st vector to add

     DVEC3_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec3_sub (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec3_t * DVEC3_A, const lw6mat_dvec3_t * DVEC3_B)
     DVEC3: result vector

     DVEC3_A: 1st vector

     DVEC3_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: double lw6mat_dvec3_dot (const lw6mat_dvec3_t * DVEC3_A,
          const lw6mat_dvec3_t * DVEC3_B)
     DVEC3_A: 1st vector

     DVEC3_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec3_cross (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec3_t * DVEC3_A, const lw6mat_dvec3_t * DVEC3_B)
     DVEC3: result vector

     DVEC3_A: 1st vector

     DVEC3_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec3_mul_scale (lw6mat_dvec3_t * DVEC3,
          double F)
     DVEC3: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_dvec3_mul_dvec3 (lw6mat_dmat3_t * DMAT3, const
          lw6mat_dvec3_t * DVEC3_A, const lw6mat_dvec3_t * DVEC3_B)
     DMAT3: result matrix

     DVEC3_A: 1st row vector

     DVEC3_B: 3nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_dvec3_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dvec3_t * DVEC3)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_dvec4_zero (lw6mat_dvec4_t * DVEC4)
     DVEC4: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_dvec4_is_same (const lw6mat_dvec4_t * DVEC4_A,
          const lw6mat_dvec4_t * DVEC4_B)
     DVEC4_A: 1st vector to compare

     DVEC4_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: double lw6mat_dvec4_len_sq (const lw6mat_dvec4_t * DVEC4)
     DVEC4: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: double lw6mat_dvec4_len (const lw6mat_dvec4_t * DVEC4)
     DVEC4: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_dvec4_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec4_t * DVEC4)
     SYS_CONTEXT: global system context

     DVEC4: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_dvec4_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_dvec4_t * DVEC4)
     SYS_CONTEXT: global system context

     DVEC4: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_dvec4_neg (lw6mat_dvec4_t * DVEC4)
     DVEC4: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_dvec4_add (lw6mat_dvec4_t * DVEC4, const
          lw6mat_dvec4_t * DVEC4_A, const lw6mat_dvec4_t * DVEC4_B)
     DVEC4: result vector

     DVEC4_A: 1st vector to add

     DVEC4_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec4_sub (lw6mat_dvec4_t * DVEC4, const
          lw6mat_dvec4_t * DVEC4_A, const lw6mat_dvec4_t * DVEC4_B)
     DVEC4: result vector

     DVEC4_A: 1st vector

     DVEC4_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: double lw6mat_dvec4_dot (const lw6mat_dvec4_t * DVEC4_A,
          const lw6mat_dvec4_t * DVEC4_B)
     DVEC4_A: 1st vector

     DVEC4_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_dvec4_cross (lw6mat_dvec3_t * DVEC3, const
          lw6mat_dvec4_t * DVEC4_A, const lw6mat_dvec4_t * DVEC4_B)
     DVEC3: result vector

     DVEC4_A: 1st vector

     DVEC4_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.
     Since cross product only really makes sense in 3D, this function
     will interpret the 4D vectors as 3D vectors only, ignoring the last
     value.

     *Return value:* none

 -- Function: void lw6mat_dvec4_mul_scale (lw6mat_dvec4_t * DVEC4,
          double F)
     DVEC4: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_dvec4_mul_dvec4 (lw6mat_dmat4_t * DMAT4, const
          lw6mat_dvec4_t * DVEC4_A, const lw6mat_dvec4_t * DVEC4_B)
     DMAT4: result matrix

     DVEC4_A: 1st row vector

     DVEC4_B: 4nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_dvec4_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_dvec4_t * DVEC4)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_fmat2_zero (lw6mat_fmat2_t * FMAT2)
     FMAT2: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_fmat2_identity (lw6mat_fmat2_t * FMAT2)
     FMAT2: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_fmat2_translation (lw6mat_fmat2_t * FMAT2,
          float F)
     FMAT2: the matrix to initialize.

     F: value which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat2_scale (lw6mat_fmat2_t * FMAT2, float F)
     FMAT2: the matrix to initialize.

     F: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: int lw6mat_fmat2_is_same (const lw6mat_fmat2_t * FMAT2_A,
          const lw6mat_fmat2_t * FMAT2_B)
     FMAT2_A: 1st matrix to compare

     FMAT2_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_fmat2_transpose (lw6mat_fmat2_t * FMAT2)
     FMAT2: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: float lw6mat_fmat2_det (const lw6mat_fmat2_t * FMAT2)
     FMAT2: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_fmat2_mul_scale (lw6mat_fmat2_t * FMAT2, float
          F)
     FMAT2: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_fmat2_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_fmat2_t * FMAT2_DST, const lw6mat_fmat2_t * FMAT2_SRC)
     SYS_CONTEXT: global system context

     FMAT2_DST: the matrix inverted

     FMAT2_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_fmat2_mul_fmat2 (lw6mat_fmat2_t * FMAT2, const
          lw6mat_fmat2_t * FMAT2_A, const lw6mat_fmat2_t * FMAT2_B)
     FMAT2: the result matrix

     FMAT2_A: the 1st matrix to multiply, on the left

     FMAT2_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_fmat2_mul_fvec2 (lw6mat_fvec2_t * FVEC2_DST,
          const lw6mat_fmat2_t * FMAT2, const lw6mat_fvec2_t *
          FVEC2_SRC)
     FVEC2_DST: the result vector

     FVEC2_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: char * lw6mat_fmat2_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fmat2_t * FMAT2)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_fmat3_zero (lw6mat_fmat3_t * FMAT3)
     FMAT3: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_identity (lw6mat_fmat3_t * FMAT3)
     FMAT3: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_translation (lw6mat_fmat3_t * FMAT3,
          const lw6mat_fvec2_t * FVEC2)
     FMAT3: the matrix to initialize.

     FVEC2: vector which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_scale (lw6mat_fmat3_t * FMAT3, const
          lw6mat_fvec2_t * FVEC2)
     FMAT3: the matrix to initialize.

     FVEC2: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_rot (lw6mat_fmat3_t * FMAT3, float R)
     FMAT3: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over a virtual Z axis such as Z is the
     cross product of X and Y.

     *Return value:* none.

 -- Function: int lw6mat_fmat3_is_same (const lw6mat_fmat3_t * FMAT3_A,
          const lw6mat_fmat3_t * FMAT3_B)
     FMAT3_A: 1st matrix to compare

     FMAT3_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_fmat3_transpose (lw6mat_fmat3_t * FMAT3)
     FMAT3: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: float lw6mat_fmat3_det (const lw6mat_fmat3_t * FMAT3)
     FMAT3: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_fmat3_mul_scale (lw6mat_fmat3_t * FMAT3, float
          F)
     FMAT3: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_fmat3_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_fmat3_t * FMAT3_DST, const lw6mat_fmat3_t * FMAT3_SRC)
     SYS_CONTEXT: global system context

     FMAT3_DST: the matrix inverted

     FMAT3_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_fmat3_mul_fmat3 (lw6mat_fmat3_t * FMAT3, const
          lw6mat_fmat3_t * FMAT3_A, const lw6mat_fmat3_t * FMAT3_B)
     FMAT3: the result matrix

     FMAT3_A: the 1st matrix to multiply, on the left

     FMAT3_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_mul_fvec3 (lw6mat_fvec3_t * FVEC3_DST,
          const lw6mat_fmat3_t * FMAT3, const lw6mat_fvec3_t *
          FVEC3_SRC)
     FVEC3_DST: the result vector

     FVEC3_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: void lw6mat_fmat3_mul_fvec2 (lw6mat_fvec2_t * FVEC2_DST,
          const lw6mat_fmat3_t * FMAT3, const lw6mat_fvec2_t *
          FVEC2_SRC)
     FVEC2_DST: the result vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.  The vector, here, is smaller than
     the matrix, the last element is supposed to be 1, this is how one
     implements translation through multiplication.

     *Return value:* none.

 -- Function: char * lw6mat_fmat3_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fmat3_t * FMAT3)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_fmat4_zero (lw6mat_fmat4_t * FMAT4)
     FMAT4: the matrix to initialize.

     Fills the matrix with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_identity (lw6mat_fmat4_t * FMAT4)
     FMAT4: the matrix to initialize.

     Loads the matrix with the identity matrix, that is, zero everywhere
     but one on the main diag.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_translation (lw6mat_fmat4_t * FMAT4,
          const lw6mat_fvec3_t * FVEC3)
     FMAT4: the matrix to initialize.

     FVEC3: vector which defines the translation.

     Loads the matrix with a translation transformation matrix.  By
     multiplicating by this matrix, a translation is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_scale (lw6mat_fmat4_t * FMAT4, const
          lw6mat_fvec3_t * FVEC3)
     FMAT4: the matrix to initialize.

     FVEC3: value used to scale matrix.

     Loads the matrix with a scale matrix.  By multiplicating by this
     matrix, a scaling is done.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_rot_x (lw6mat_fmat4_t * FMAT4, float R)
     FMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the X axis.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_rot_y (lw6mat_fmat4_t * FMAT4, float R)
     FMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the Y axis.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_rot_z (lw6mat_fmat4_t * FMAT4, float R)
     FMAT4: the matrix to initialize.

     R: value used to for the rotation, angle in radians.

     Loads the matrix with a rotation matrix.  By multiplicating by this
     matrix, a rotation is done, over the Z axis.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_ortho (lw6mat_fmat4_t * FMAT4, float
          LEFT, float RIGHT, float BOTTOM, float TOP, float NEARVAL,
          float FARVAL)
     FMAT4: the matrix to initialize.

     LEFT: left plane coordinate

     RIGHT: right plane coordinate

     BOTTOM: bottom plane coordinate

     TOP: top plane coordinate

     NEARVAL: near plane coordinate

     FARVAL: far plane coordinate

     Loads the matrix with an orthogonal projection matrix.  Does it the
     way glOrtho would, see
     https://www.opengl.org/sdk/docs/man2/xhtml/glOrtho.xml for details.

     *Note:* use -nearVal and -farVal to initialize.  It's a little
     akward, if you expect to pass vectors with positions ranging from
     nearVal to farVal then you need to pass -nearVal and -farVal to
     this function.  This is probably due to the fact that with a
     right-handed basis and X,Y set up "as usual", then Z is negative
     when going farther and farther.  This tweak allows farVal to yield
     +1 and nearVal -1.  We keep this function as is here, as this is
     the way OpenGL functions seem to work.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_perspective (lw6mat_fmat4_t * FMAT4,
          float FOVY, float ASPECT, float ZNEAR, float ZFAR)
     FMAT4: the matrix to initialize.

     FOVY: vertical field of view (degrees, not radians)

     ASPECT: x/y ratio

     ZNEAR: near plane coordinate (use -znear to initialize)

     ZFAR: far plane coordinate (use -zfar to initialize)

     Loads the matrix with a projection matrix.  Does it the way
     gluPerspective would, see
     https://www.opengl.org/sdk/docs/man2/xhtml/gluPerspective.xml for
     details.

     *Return value:* none.

 -- Function: int lw6mat_fmat4_is_same (const lw6mat_fmat4_t * FMAT4_A,
          const lw6mat_fmat4_t * FMAT4_B)
     FMAT4_A: 1st matrix to compare

     FMAT4_B: 2nd matrix to compare

     Compares two matrix, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: void lw6mat_fmat4_transpose (lw6mat_fmat4_t * FMAT4)
     FMAT4: the matrix to transpose

     Transposes the matrix, that is, inverts rows and columns.

     *Return value:* none.

 -- Function: float lw6mat_fmat4_det (const lw6mat_fmat4_t * FMAT4)
     FMAT4: the matrix used to calculate the determinant

     Calulates the determinant of the matrix.

     *Return value:* the determinant.

 -- Function: void lw6mat_fmat4_mul_scale (lw6mat_fmat4_t * FMAT4, float
          F)
     FMAT4: matrix to modify

     F: scale factor

     Scales the matrix by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: int lw6mat_fmat4_inv (lw6sys_context_t * SYS_CONTEXT,
          lw6mat_fmat4_t * FMAT4_DST, const lw6mat_fmat4_t * FMAT4_SRC)
     SYS_CONTEXT: global system context

     FMAT4_DST: the matrix inverted

     FMAT4_SRC: the matrix to invert

     Inverts a matrix.  Probably not the fastest implementation, but
     should work in all cases.  Use hardware accelerated API such as
     OpenGL on dedicated hardware if you want power.

     *Return value:* 1 if inverted, 0 if error, typically if determinant
     was 0, matrix can not be inverted.

 -- Function: void lw6mat_fmat4_mul_fmat4 (lw6mat_fmat4_t * FMAT4, const
          lw6mat_fmat4_t * FMAT4_A, const lw6mat_fmat4_t * FMAT4_B)
     FMAT4: the result matrix

     FMAT4_A: the 1st matrix to multiply, on the left

     FMAT4_B: the 2nd matrix to multiply, on the right

     Classic matrix multiplication.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_mul_fvec4 (lw6mat_fvec4_t * FVEC4_DST,
          const lw6mat_fmat4_t * FMAT4, const lw6mat_fvec4_t *
          FVEC4_SRC)
     FVEC4_DST: the result vector

     FMAT4: the matrix to use

     FVEC4_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.

     *Return value:* none.

 -- Function: void lw6mat_fmat4_mul_fvec3 (lw6mat_fvec3_t * FVEC3_DST,
          const lw6mat_fmat4_t * FMAT4, const lw6mat_fvec3_t *
          FVEC3_SRC)
     FVEC3_DST: the result vector

     FMAT4: the matrix to use

     FVEC3_SRC: the source vector

     Multiplication of matrix by vector.  The result is a vector, the
     convention used is that of OpenGL, matrix are column major and
     vector are columns, that is, should you do it on a paper, vector is
     placed vertically, on the right of matrix.  The other
     multiplication is not implemented, transposing the matrix will do
     it the other way if you wish.  The vector, here, is smaller than
     the matrix, the last element is supposed to be 1, this is how one
     implements translation through multiplication.

     *Return value:* none.

 -- Function: char * lw6mat_fmat4_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fmat4_t * FMAT4)
     SYS_CONTEXT: global system context

     Gives a readable version of the matrix, the representation uses
     newlines, with a different line for each row

     *Return value:* newly allocated string

 -- Function: void lw6mat_fvec2_zero (lw6mat_fvec2_t * FVEC2)
     FVEC2: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_fvec2_is_same (const lw6mat_fvec2_t * FVEC2_A,
          const lw6mat_fvec2_t * FVEC2_B)
     FVEC2_A: 1st vector to compare

     FVEC2_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: float lw6mat_fvec2_len_sq (const lw6mat_fvec2_t * FVEC2)
     FVEC2: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: float lw6mat_fvec2_len (const lw6mat_fvec2_t * FVEC2)
     FVEC2: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_fvec2_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec2_t * FVEC2)
     SYS_CONTEXT: global system context

     FVEC2: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_fvec2_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec2_t * FVEC2)
     SYS_CONTEXT: global system context

     FVEC2: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_fvec2_neg (lw6mat_fvec2_t * FVEC2)
     FVEC2: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_fvec2_add (lw6mat_fvec2_t * FVEC2, const
          lw6mat_fvec2_t * FVEC2_A, const lw6mat_fvec2_t * FVEC2_B)
     FVEC2: result vector

     FVEC2_A: 1st vector to add

     FVEC2_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec2_sub (lw6mat_fvec2_t * FVEC2, const
          lw6mat_fvec2_t * FVEC2_A, const lw6mat_fvec2_t * FVEC2_B)
     FVEC2: result vector

     FVEC2_A: 1st vector

     FVEC2_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: float lw6mat_fvec2_dot (const lw6mat_fvec2_t * FVEC2_A,
          const lw6mat_fvec2_t * FVEC2_B)
     FVEC2_A: 1st vector

     FVEC2_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec2_cross (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec2_t * FVEC2_A, const lw6mat_fvec2_t * FVEC2_B)
     FVEC3: result vector

     FVEC2_A: 1st vector

     FVEC2_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.
     Since cross product only really makes sense in 3D, this function
     will interpret the 2D vectors as 3D vectors with z set t zero, that
     is, a vector in the xy plane.

     *Return value:* none

 -- Function: void lw6mat_fvec2_mul_scale (lw6mat_fvec2_t * FVEC2, float
          F)
     FVEC2: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_fvec2_mul_fvec2 (lw6mat_fmat2_t * FMAT2, const
          lw6mat_fvec2_t * FVEC2_A, const lw6mat_fvec2_t * FVEC2_B)
     FMAT2: result matrix

     FVEC2_A: 1st row vector

     FVEC2_B: 2nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_fvec2_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fvec2_t * FVEC2)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_fvec3_zero (lw6mat_fvec3_t * FVEC3)
     FVEC3: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_fvec3_is_same (const lw6mat_fvec3_t * FVEC3_A,
          const lw6mat_fvec3_t * FVEC3_B)
     FVEC3_A: 1st vector to compare

     FVEC3_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: float lw6mat_fvec3_len_sq (const lw6mat_fvec3_t * FVEC3)
     FVEC3: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: float lw6mat_fvec3_len (const lw6mat_fvec3_t * FVEC3)
     FVEC3: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_fvec3_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec3_t * FVEC3)
     SYS_CONTEXT: global system context

     FVEC3: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_fvec3_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec3_t * FVEC3)
     SYS_CONTEXT: global system context

     FVEC3: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_fvec3_neg (lw6mat_fvec3_t * FVEC3)
     FVEC3: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_fvec3_add (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec3_t * FVEC3_A, const lw6mat_fvec3_t * FVEC3_B)
     FVEC3: result vector

     FVEC3_A: 1st vector to add

     FVEC3_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec3_sub (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec3_t * FVEC3_A, const lw6mat_fvec3_t * FVEC3_B)
     FVEC3: result vector

     FVEC3_A: 1st vector

     FVEC3_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: float lw6mat_fvec3_dot (const lw6mat_fvec3_t * FVEC3_A,
          const lw6mat_fvec3_t * FVEC3_B)
     FVEC3_A: 1st vector

     FVEC3_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec3_cross (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec3_t * FVEC3_A, const lw6mat_fvec3_t * FVEC3_B)
     FVEC3: result vector

     FVEC3_A: 1st vector

     FVEC3_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec3_mul_scale (lw6mat_fvec3_t * FVEC3, float
          F)
     FVEC3: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_fvec3_mul_fvec3 (lw6mat_fmat3_t * FMAT3, const
          lw6mat_fvec3_t * FVEC3_A, const lw6mat_fvec3_t * FVEC3_B)
     FMAT3: result matrix

     FVEC3_A: 1st row vector

     FVEC3_B: 3nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_fvec3_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fvec3_t * FVEC3)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: void lw6mat_fvec4_zero (lw6mat_fvec4_t * FVEC4)
     FVEC4: the vector to initialize.

     Fills the vector with zeros, regardless of what was there before.
     Internally, does a memset the only advantage is that this function
     should use the right sizeof and therefore avoids typo errors.

     *Return value:* none.

 -- Function: int lw6mat_fvec4_is_same (const lw6mat_fvec4_t * FVEC4_A,
          const lw6mat_fvec4_t * FVEC4_B)
     FVEC4_A: 1st vector to compare

     FVEC4_B: 2nd vector to compare

     Compares two vectors, returns true if they are equal.

     *Return value:* 1 if equal, 0 if different.

 -- Function: float lw6mat_fvec4_len_sq (const lw6mat_fvec4_t * FVEC4)
     FVEC4: the vector to query.

     Returns the square of a vector length.  To get the real length one
     should then apply a square root but at this stage one has at least
     an idea about vector length, and this information is enough to
     compare them.

     *Return value:* sigma(coord*coord)

 -- Function: float lw6mat_fvec4_len (const lw6mat_fvec4_t * FVEC4)
     FVEC4: the vector to query.

     Returns the size/length of a vector, this is the distance of the
     point from origin, not the number of elements.

     *Return value:* the length of the vector.

 -- Function: int lw6mat_fvec4_normalize (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec4_t * FVEC4)
     SYS_CONTEXT: global system context

     FVEC4: the vector to normalize.

     Normalizes a vector, that is, make its length be 1.

     *Return value:* 1 if OK, 0 if error, such as trying to normalize
     vector zero.

 -- Function: int lw6mat_fvec4_homogeneous (lw6sys_context_t *
          SYS_CONTEXT, lw6mat_fvec4_t * FVEC4)
     SYS_CONTEXT: global system context

     FVEC4: the vector to homogeneous.

     Transforms a vector into homegeneous coords, that is, scales it so
     that its last member is 1.

     *Return value:* 1 if OK, 0 if error, such as trying to operate on
     vector zero.

 -- Function: void lw6mat_fvec4_neg (lw6mat_fvec4_t * FVEC4)
     FVEC4: vector to modify

     Calcs the opposite vector, by making a negation on all its members

     *Return value:* none

 -- Function: void lw6mat_fvec4_add (lw6mat_fvec4_t * FVEC4, const
          lw6mat_fvec4_t * FVEC4_A, const lw6mat_fvec4_t * FVEC4_B)
     FVEC4: result vector

     FVEC4_A: 1st vector to add

     FVEC4_B: 2nd vector to add

     Adds two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec4_sub (lw6mat_fvec4_t * FVEC4, const
          lw6mat_fvec4_t * FVEC4_A, const lw6mat_fvec4_t * FVEC4_B)
     FVEC4: result vector

     FVEC4_A: 1st vector

     FVEC4_B: 2nd vector, will be substracted to 1st vector

     Substracts vector b from vector a.

     *Return value:* none

 -- Function: float lw6mat_fvec4_dot (const lw6mat_fvec4_t * FVEC4_A,
          const lw6mat_fvec4_t * FVEC4_B)
     FVEC4_A: 1st vector

     FVEC4_B: 2nd vector

     Calculates the dot AKA scalar product of the two vectors.

     *Return value:* none

 -- Function: void lw6mat_fvec4_cross (lw6mat_fvec3_t * FVEC3, const
          lw6mat_fvec4_t * FVEC4_A, const lw6mat_fvec4_t * FVEC4_B)
     FVEC3: result vector

     FVEC4_A: 1st vector

     FVEC4_B: 2nd vector

     Calculates the cross AKA vectorial product of the two vectors.
     Since cross product only really makes sense in 3D, this function
     will interpret the 4D vectors as 3D vectors only, ignoring the last
     value.

     *Return value:* none

 -- Function: void lw6mat_fvec4_mul_scale (lw6mat_fvec4_t * FVEC4, float
          F)
     FVEC4: vector to modify

     F: scale factor

     Scales the vector by multiplying all its members by a scalar value.

     *Return value:* none

 -- Function: void lw6mat_fvec4_mul_fvec4 (lw6mat_fmat4_t * FMAT4, const
          lw6mat_fvec4_t * FVEC4_A, const lw6mat_fvec4_t * FVEC4_B)
     FMAT4: result matrix

     FVEC4_A: 1st row vector

     FVEC4_B: 4nd column vector

     Multiplication of a row vector by a column vector to give a matrix.

     *Return value:* none

 -- Function: char * lw6mat_fvec4_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6mat_fvec4_t * FVEC4)
     SYS_CONTEXT: global system context

     Gives a readable version of the vector

     *Return value:* newly allocated string

 -- Function: int lw6mat_is_similar_f (float F_A, float F_B)
     F_A: 1st value to compare

     F_B: 2nd value to compare

     Compares two value, and returns true if they look the same.  This
     similarity is based on a percentage of difference for big enough
     values, and for very small values, they are just considered equal
     whatever happens.  This is far from perfect but the purpose is
     usually just to track blunders in matrix code.

     *Return value:* 1 if similar, 0 if not.

 -- Function: int lw6mat_is_similar_i (int32_t I_A, int32_t I_B)
     I_A: 1st value to compare

     I_B: 2nd value to compare

     Compares two value, and returns true if they look the same.  This
     similarity is based on a percentage of difference for big enough
     values, and for very small values, they are just considered equal
     whatever happens.  This is far from perfect but the purpose is
     usually just to track blunders in matrix code.

     *Return value:* 1 if similar, 0 if not.

 -- Function: int lw6mat_is_similar_d (double D_A, double D_B)
     D_A: 1st value to compare

     D_B: 2nd value to compare

     Compares two value, and returns true if they look the same.  This
     similarity is based on a percentage of difference for big enough
     values, and for very small values, they are just considered equal
     whatever happens.  This is far from perfect but the purpose is
     usually just to track blunders in matrix code.

     *Return value:* 1 if similar, 0 if not.

 -- Function: int lw6mat_is_similar_x (int32_t X_A, int32_t X_B)
     X_A: 1st value to compare

     X_B: 2nd value to compare

     Compares two value, and returns true if they look the same.  This
     similarity is based on a percentage of difference for big enough
     values, and for very small values, they are just considered equal
     whatever happens.  This is far from perfect but the purpose is
     usually just to track blunders in matrix code.

     *Return value:* 1 if similar, 0 if not.

 -- Function: int lw6mat_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libmat module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6mat_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'mat' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6mat_dmat2_t

     Double 2x2 matrix (AKA 2D rectangle).

 -- Member of lw6mat_dmat2_t: m
     *Type:* 'double'

     *Definition:* 'double
     lw6mat_dmat2_t::m[LW6MAT_MAT2_M_SIZE][LW6MAT_MAT2_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_dmat2_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dmat2_t::v[LW6MAT_MAT2_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*2+j.

 -- Struct: lw6mat_dmat3_t

     Double 3x3 matrix (AKA 3D triangle).

 -- Member of lw6mat_dmat3_t: m
     *Type:* 'double'

     *Definition:* 'double
     lw6mat_dmat3_t::m[LW6MAT_MAT3_M_SIZE][LW6MAT_MAT3_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_dmat3_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dmat3_t::v[LW6MAT_MAT3_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_dmat4_t

     Double 4x4 matrix (AKA 3D transformation/composition matrix).

 -- Member of lw6mat_dmat4_t: m
     *Type:* 'double'

     *Definition:* 'double
     lw6mat_dmat4_t::m[LW6MAT_MAT4_M_SIZE][LW6MAT_MAT4_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_dmat4_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dmat4_t::v[LW6MAT_MAT4_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_dvec2_t

     Double vector with 2 elements (AKA 2D point).

 -- Member of lw6mat_dvec2_t: x
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::x'

 -- Member of lw6mat_dvec2_t: y
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::y'

 -- Member of lw6mat_dvec2_t: p
     *Type:* 'struct lw6mat_dvec2_t::16'

     *Definition:* 'struct lw6mat_dvec2_t::16 lw6mat_dvec2_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_dvec2_t: s
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::s'

 -- Member of lw6mat_dvec2_t: t
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::t'

 -- Member of lw6mat_dvec2_t: t
     *Type:* 'struct lw6mat_dvec2_t::17'

     *Definition:* 'struct lw6mat_dvec2_t::17 lw6mat_dvec2_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_dvec2_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec2_t::v[LW6MAT_VEC2_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_dvec3_t

     Double vector with 3 elements (AKA 3D point).

 -- Member of lw6mat_dvec3_t: x
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::x'

 -- Member of lw6mat_dvec3_t: y
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::y'

 -- Member of lw6mat_dvec3_t: z
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::z'

 -- Member of lw6mat_dvec3_t: p
     *Type:* 'struct lw6mat_dvec3_t::18'

     *Definition:* 'struct lw6mat_dvec3_t::18 lw6mat_dvec3_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_dvec3_t: r
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::r'

 -- Member of lw6mat_dvec3_t: g
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::g'

 -- Member of lw6mat_dvec3_t: b
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::b'

 -- Member of lw6mat_dvec3_t: c
     *Type:* 'struct lw6mat_dvec3_t::19'

     *Definition:* 'struct lw6mat_dvec3_t::19 lw6mat_dvec3_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_dvec3_t: s
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::s'

 -- Member of lw6mat_dvec3_t: t
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::t'

 -- Member of lw6mat_dvec3_t: p
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::p'

 -- Member of lw6mat_dvec3_t: t
     *Type:* 'struct lw6mat_dvec3_t::20'

     *Definition:* 'struct lw6mat_dvec3_t::20 lw6mat_dvec3_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_dvec3_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec3_t::v[LW6MAT_VEC3_V_SIZE]'

     Accessor with array index.

 -- Member of lw6mat_dvec3_t: v2
     *Type:* 'lw6mat_dvec2_t'

     *Definition:* 'lw6mat_dvec2_t lw6mat_dvec3_t::v2'

     Accessor with smaller-sized vector, only 2 dimensions.

 -- Struct: lw6mat_dvec4_t

     Double vector with 4 elements (AKA quaternion).

 -- Member of lw6mat_dvec4_t: x
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::x'

 -- Member of lw6mat_dvec4_t: y
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::y'

 -- Member of lw6mat_dvec4_t: z
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::z'

 -- Member of lw6mat_dvec4_t: w
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::w'

 -- Member of lw6mat_dvec4_t: p
     *Type:* 'struct lw6mat_dvec4_t::21'

     *Definition:* 'struct lw6mat_dvec4_t::21 lw6mat_dvec4_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_dvec4_t: r
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::r'

 -- Member of lw6mat_dvec4_t: g
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::g'

 -- Member of lw6mat_dvec4_t: b
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::b'

 -- Member of lw6mat_dvec4_t: a
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::a'

 -- Member of lw6mat_dvec4_t: c
     *Type:* 'struct lw6mat_dvec4_t::22'

     *Definition:* 'struct lw6mat_dvec4_t::22 lw6mat_dvec4_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_dvec4_t: s
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::s'

 -- Member of lw6mat_dvec4_t: t
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::t'

 -- Member of lw6mat_dvec4_t: p
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::p'

 -- Member of lw6mat_dvec4_t: q
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::q'

 -- Member of lw6mat_dvec4_t: t
     *Type:* 'struct lw6mat_dvec4_t::23'

     *Definition:* 'struct lw6mat_dvec4_t::23 lw6mat_dvec4_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_dvec4_t: v
     *Type:* 'double'

     *Definition:* 'double lw6mat_dvec4_t::v[LW6MAT_VEC4_V_SIZE]'

     Accessor with array index.

 -- Member of lw6mat_dvec4_t: v2
     *Type:* 'lw6mat_dvec2_t'

     *Definition:* 'lw6mat_dvec2_t lw6mat_dvec4_t::v2'

     Accessor with smaller-sized vector, only 2 dimensions.

 -- Member of lw6mat_dvec4_t: v3
     *Type:* 'lw6mat_dvec3_t'

     *Definition:* 'lw6mat_dvec3_t lw6mat_dvec4_t::v3'

     Accessor with smaller-sized vector, only 3 dimensions.

 -- Struct: lw6mat_fmat2_t

     Float 2x2 matrix (AKA 2D rectangle).

 -- Member of lw6mat_fmat2_t: m
     *Type:* 'float'

     *Definition:* 'float
     lw6mat_fmat2_t::m[LW6MAT_MAT2_M_SIZE][LW6MAT_MAT2_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_fmat2_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fmat2_t::v[LW6MAT_MAT2_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_fmat3_t

     Float 3x3 matrix (AKA 3D triangle).

 -- Member of lw6mat_fmat3_t: m
     *Type:* 'float'

     *Definition:* 'float
     lw6mat_fmat3_t::m[LW6MAT_MAT3_M_SIZE][LW6MAT_MAT3_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_fmat3_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fmat3_t::v[LW6MAT_MAT3_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_fmat4_t

     Float 4x4 matrix (AKA 3D transformation/composition matrix).

 -- Member of lw6mat_fmat4_t: m
     *Type:* 'float'

     *Definition:* 'float
     lw6mat_fmat4_t::m[LW6MAT_MAT4_M_SIZE][LW6MAT_MAT4_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_fmat4_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fmat4_t::v[LW6MAT_MAT4_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_fvec2_t

     Float vector with 2 elements (AKA 2D point).

 -- Member of lw6mat_fvec2_t: x
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::x'

 -- Member of lw6mat_fvec2_t: y
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::y'

 -- Member of lw6mat_fvec2_t: p
     *Type:* 'struct lw6mat_fvec2_t::0'

     *Definition:* 'struct lw6mat_fvec2_t::0 lw6mat_fvec2_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_fvec2_t: s
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::s'

 -- Member of lw6mat_fvec2_t: t
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::t'

 -- Member of lw6mat_fvec2_t: t
     *Type:* 'struct lw6mat_fvec2_t::1'

     *Definition:* 'struct lw6mat_fvec2_t::1 lw6mat_fvec2_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_fvec2_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec2_t::v[LW6MAT_VEC2_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_fvec3_t

     Float vector with 3 elements (AKA 3D point).

 -- Member of lw6mat_fvec3_t: x
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::x'

 -- Member of lw6mat_fvec3_t: y
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::y'

 -- Member of lw6mat_fvec3_t: z
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::z'

 -- Member of lw6mat_fvec3_t: p
     *Type:* 'struct lw6mat_fvec3_t::2'

     *Definition:* 'struct lw6mat_fvec3_t::2 lw6mat_fvec3_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_fvec3_t: r
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::r'

 -- Member of lw6mat_fvec3_t: g
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::g'

 -- Member of lw6mat_fvec3_t: b
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::b'

 -- Member of lw6mat_fvec3_t: c
     *Type:* 'struct lw6mat_fvec3_t::3'

     *Definition:* 'struct lw6mat_fvec3_t::3 lw6mat_fvec3_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_fvec3_t: s
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::s'

 -- Member of lw6mat_fvec3_t: t
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::t'

 -- Member of lw6mat_fvec3_t: p
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::p'

 -- Member of lw6mat_fvec3_t: t
     *Type:* 'struct lw6mat_fvec3_t::4'

     *Definition:* 'struct lw6mat_fvec3_t::4 lw6mat_fvec3_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_fvec3_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec3_t::v[LW6MAT_VEC3_V_SIZE]'

     Accessor with array index.

 -- Member of lw6mat_fvec3_t: v2
     *Type:* 'lw6mat_fvec2_t'

     *Definition:* 'lw6mat_fvec2_t lw6mat_fvec3_t::v2'

     Accessor with smaller-sized vector, only 2 dimensions.

 -- Struct: lw6mat_fvec4_t

     Float vector with 4 elements (AKA quaternion).

 -- Member of lw6mat_fvec4_t: x
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::x'

 -- Member of lw6mat_fvec4_t: y
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::y'

 -- Member of lw6mat_fvec4_t: z
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::z'

 -- Member of lw6mat_fvec4_t: w
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::w'

 -- Member of lw6mat_fvec4_t: p
     *Type:* 'struct lw6mat_fvec4_t::5'

     *Definition:* 'struct lw6mat_fvec4_t::5 lw6mat_fvec4_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_fvec4_t: r
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::r'

 -- Member of lw6mat_fvec4_t: g
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::g'

 -- Member of lw6mat_fvec4_t: b
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::b'

 -- Member of lw6mat_fvec4_t: a
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::a'

 -- Member of lw6mat_fvec4_t: c
     *Type:* 'struct lw6mat_fvec4_t::6'

     *Definition:* 'struct lw6mat_fvec4_t::6 lw6mat_fvec4_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_fvec4_t: s
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::s'

 -- Member of lw6mat_fvec4_t: t
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::t'

 -- Member of lw6mat_fvec4_t: p
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::p'

 -- Member of lw6mat_fvec4_t: q
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::q'

 -- Member of lw6mat_fvec4_t: t
     *Type:* 'struct lw6mat_fvec4_t::7'

     *Definition:* 'struct lw6mat_fvec4_t::7 lw6mat_fvec4_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_fvec4_t: v
     *Type:* 'float'

     *Definition:* 'float lw6mat_fvec4_t::v[LW6MAT_VEC4_V_SIZE]'

     Accessor with array index.

 -- Member of lw6mat_fvec4_t: v2
     *Type:* 'lw6mat_fvec2_t'

     *Definition:* 'lw6mat_fvec2_t lw6mat_fvec4_t::v2'

     Accessor with smaller-sized vector, only 2 dimensions.

 -- Member of lw6mat_fvec4_t: v3
     *Type:* 'lw6mat_fvec3_t'

     *Definition:* 'lw6mat_fvec3_t lw6mat_fvec4_t::v3'

     Accessor with smaller-sized vector, only 3 dimensions.

 -- Struct: lw6mat_imat2_t

     Integer 2x2 matrix (AKA 2D rectangle).

 -- Member of lw6mat_imat2_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat2_t::m[LW6MAT_MAT2_M_SIZE][LW6MAT_MAT2_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_imat2_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat2_t::v[LW6MAT_MAT2_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*2+j.

 -- Struct: lw6mat_imat3_t

     Integer 3x3 matrix (AKA 3D triangle).

 -- Member of lw6mat_imat3_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat3_t::m[LW6MAT_MAT3_M_SIZE][LW6MAT_MAT3_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_imat3_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat3_t::v[LW6MAT_MAT3_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_imat4_t

     Integer 4x4 matrix (AKA 3D transformation/composition matrix).

 -- Member of lw6mat_imat4_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat4_t::m[LW6MAT_MAT4_M_SIZE][LW6MAT_MAT4_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_imat4_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_imat4_t::v[LW6MAT_MAT4_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_ivec2_t

     Integer vector with 2 elements (AKA 2D point).

 -- Member of lw6mat_ivec2_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::x'

 -- Member of lw6mat_ivec2_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::y'

 -- Member of lw6mat_ivec2_t: p
     *Type:* 'struct lw6mat_ivec2_t::8'

     *Definition:* 'struct lw6mat_ivec2_t::8 lw6mat_ivec2_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_ivec2_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::s'

 -- Member of lw6mat_ivec2_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::t'

 -- Member of lw6mat_ivec2_t: t
     *Type:* 'struct lw6mat_ivec2_t::9'

     *Definition:* 'struct lw6mat_ivec2_t::9 lw6mat_ivec2_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_ivec2_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec2_t::v[LW6MAT_VEC2_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_ivec3_t

     Integer vector with 3 elements (AKA 3D point).

 -- Member of lw6mat_ivec3_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::x'

 -- Member of lw6mat_ivec3_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::y'

 -- Member of lw6mat_ivec3_t: z
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::z'

 -- Member of lw6mat_ivec3_t: p
     *Type:* 'struct lw6mat_ivec3_t::10'

     *Definition:* 'struct lw6mat_ivec3_t::10 lw6mat_ivec3_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_ivec3_t: r
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::r'

 -- Member of lw6mat_ivec3_t: g
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::g'

 -- Member of lw6mat_ivec3_t: b
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::b'

 -- Member of lw6mat_ivec3_t: c
     *Type:* 'struct lw6mat_ivec3_t::11'

     *Definition:* 'struct lw6mat_ivec3_t::11 lw6mat_ivec3_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_ivec3_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::s'

 -- Member of lw6mat_ivec3_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::t'

 -- Member of lw6mat_ivec3_t: p
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::p'

 -- Member of lw6mat_ivec3_t: t
     *Type:* 'struct lw6mat_ivec3_t::12'

     *Definition:* 'struct lw6mat_ivec3_t::12 lw6mat_ivec3_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_ivec3_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec3_t::v[LW6MAT_VEC3_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_ivec4_t

     Integer vector with 4 elements (AKA quaternion).

 -- Member of lw6mat_ivec4_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::x'

 -- Member of lw6mat_ivec4_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::y'

 -- Member of lw6mat_ivec4_t: z
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::z'

 -- Member of lw6mat_ivec4_t: w
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::w'

 -- Member of lw6mat_ivec4_t: p
     *Type:* 'struct lw6mat_ivec4_t::13'

     *Definition:* 'struct lw6mat_ivec4_t::13 lw6mat_ivec4_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_ivec4_t: r
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::r'

 -- Member of lw6mat_ivec4_t: g
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::g'

 -- Member of lw6mat_ivec4_t: b
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::b'

 -- Member of lw6mat_ivec4_t: a
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::a'

 -- Member of lw6mat_ivec4_t: c
     *Type:* 'struct lw6mat_ivec4_t::14'

     *Definition:* 'struct lw6mat_ivec4_t::14 lw6mat_ivec4_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_ivec4_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::s'

 -- Member of lw6mat_ivec4_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::t'

 -- Member of lw6mat_ivec4_t: p
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::p'

 -- Member of lw6mat_ivec4_t: q
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::q'

 -- Member of lw6mat_ivec4_t: t
     *Type:* 'struct lw6mat_ivec4_t::15'

     *Definition:* 'struct lw6mat_ivec4_t::15 lw6mat_ivec4_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_ivec4_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_ivec4_t::v[LW6MAT_VEC4_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_xmat2_t

     Fixed Point 2x2 matrix (AKA 2D rectangle).

 -- Member of lw6mat_xmat2_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat2_t::m[LW6MAT_MAT2_M_SIZE][LW6MAT_MAT2_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_xmat2_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat2_t::v[LW6MAT_MAT2_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_xmat3_t

     Fixed Point 3x3 matrix (AKA 3D triangle).

 -- Member of lw6mat_xmat3_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat3_t::m[LW6MAT_MAT3_M_SIZE][LW6MAT_MAT3_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_xmat3_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat3_t::v[LW6MAT_MAT3_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*3+j.

 -- Struct: lw6mat_xmat4_t

     Fixed Point 4x4 matrix (AKA 3D transformation/composition matrix).

 -- Member of lw6mat_xmat4_t: m
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat4_t::m[LW6MAT_MAT4_M_SIZE][LW6MAT_MAT4_M_SIZE]'

     Accessor with 2 dimensions array index.  The convention is
     column-major mode as done in OpenGL so that m[i][j] is element at
     column i and row j.  Beware, this is not the most natural order for
     a C programmer.

 -- Member of lw6mat_xmat4_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t
     lw6mat_xmat4_t::v[LW6MAT_MAT4_V_SIZE_X_SIZE]'

     Accessor with flat array index.  To access element a column i and
     row j, use i*4+j.

 -- Struct: lw6mat_xvec2_t

     Fixed Point vector with 2 elements (AKA 2D point).

 -- Member of lw6mat_xvec2_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::x'

 -- Member of lw6mat_xvec2_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::y'

 -- Member of lw6mat_xvec2_t: p
     *Type:* 'struct lw6mat_xvec2_t::24'

     *Definition:* 'struct lw6mat_xvec2_t::24 lw6mat_xvec2_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_xvec2_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::s'

 -- Member of lw6mat_xvec2_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::t'

 -- Member of lw6mat_xvec2_t: t
     *Type:* 'struct lw6mat_xvec2_t::25'

     *Definition:* 'struct lw6mat_xvec2_t::25 lw6mat_xvec2_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_xvec2_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec2_t::v[LW6MAT_VEC2_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_xvec3_t

     Fixed Point vector with 3 elements (AKA 3D point).

 -- Member of lw6mat_xvec3_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::x'

 -- Member of lw6mat_xvec3_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::y'

 -- Member of lw6mat_xvec3_t: z
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::z'

 -- Member of lw6mat_xvec3_t: p
     *Type:* 'struct lw6mat_xvec3_t::26'

     *Definition:* 'struct lw6mat_xvec3_t::26 lw6mat_xvec3_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_xvec3_t: r
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::r'

 -- Member of lw6mat_xvec3_t: g
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::g'

 -- Member of lw6mat_xvec3_t: b
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::b'

 -- Member of lw6mat_xvec3_t: c
     *Type:* 'struct lw6mat_xvec3_t::27'

     *Definition:* 'struct lw6mat_xvec3_t::27 lw6mat_xvec3_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_xvec3_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::s'

 -- Member of lw6mat_xvec3_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::t'

 -- Member of lw6mat_xvec3_t: p
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::p'

 -- Member of lw6mat_xvec3_t: t
     *Type:* 'struct lw6mat_xvec3_t::28'

     *Definition:* 'struct lw6mat_xvec3_t::28 lw6mat_xvec3_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_xvec3_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec3_t::v[LW6MAT_VEC3_V_SIZE]'

     Accessor with array index.

 -- Struct: lw6mat_xvec4_t

     Fixed Point vector with 4 elements (AKA quaternion).

 -- Member of lw6mat_xvec4_t: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::x'

 -- Member of lw6mat_xvec4_t: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::y'

 -- Member of lw6mat_xvec4_t: z
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::z'

 -- Member of lw6mat_xvec4_t: w
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::w'

 -- Member of lw6mat_xvec4_t: p
     *Type:* 'struct lw6mat_xvec4_t::29'

     *Definition:* 'struct lw6mat_xvec4_t::29 lw6mat_xvec4_t::p'

     Accessor with named/point coords.

 -- Member of lw6mat_xvec4_t: r
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::r'

 -- Member of lw6mat_xvec4_t: g
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::g'

 -- Member of lw6mat_xvec4_t: b
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::b'

 -- Member of lw6mat_xvec4_t: a
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::a'

 -- Member of lw6mat_xvec4_t: c
     *Type:* 'struct lw6mat_xvec4_t::30'

     *Definition:* 'struct lw6mat_xvec4_t::30 lw6mat_xvec4_t::c'

     Accessor with color-like name.

 -- Member of lw6mat_xvec4_t: s
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::s'

 -- Member of lw6mat_xvec4_t: t
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::t'

 -- Member of lw6mat_xvec4_t: p
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::p'

 -- Member of lw6mat_xvec4_t: q
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::q'

 -- Member of lw6mat_xvec4_t: t
     *Type:* 'struct lw6mat_xvec4_t::31'

     *Definition:* 'struct lw6mat_xvec4_t::31 lw6mat_xvec4_t::t'

     Accessor with texture-like name.

 -- Member of lw6mat_xvec4_t: v
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6mat_xvec4_t::v[LW6MAT_VEC4_V_SIZE]'

     Accessor with array index.

5.33 libmsg
===========

5.33.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/msg/index.html>.

5.33.2 API
----------

 -- Function: char * lw6msg_cmd_generate_hello (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     Generate a HELLO command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_ticket (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t TICKET)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     TICKET: the ticket to send

     Generate a TICKET command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_foo (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int32_t KEY, int SERIAL)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     KEY: the key to identify the message

     SERIAL: serial number of latest data message

     Generate a FOO command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_bar (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int32_t KEY, int SERIAL)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     KEY: the key to identify the message

     SERIAL: serial number of latest data message

     Generate a BAR command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_join (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, int64_t SEQ, int SERIAL)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     SEQ: the current seq

     SERIAL: the serial message number to start with

     Generate a JOIN command.  The seq parameter, if 0, means we want to
     request to join to a server.  Wether this is a real server or a
     physical client acting as a server is out of consideration, 0 means
     request to join, period.  If greater than 0, means we are accepting
     a client, and then the value is our current seq, which the client
     must use to calibrate its own data.  The serial number is here to
     avoid querying messages before the join and keep the serie
     complete.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_goodbye (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to use

     Generate a GOODBYE command.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_data (lw6sys_context_t *
          SYS_CONTEXT, int SERIAL, int I, int N, int64_t SEQ, const char
          * KER_MSG)
     SYS_CONTEXT: global system context

     SERIAL: the message serial number

     I: the message index in the group

     N: the number of messages in the group

     SEQ: the message seq (round + an offset)

     KER_MSG: the actual content of the message (passed to core algo)

     Generate a DATA command.  Serial is an ever increasing number, i
     and n are most of the time 1 and 1, they are usefull only in long
     multipart messages.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_meta (lw6sys_context_t *
          SYS_CONTEXT, int SERIAL, int I, int N, int64_t SEQ, const
          lw6msg_meta_array_t * META_ARRAY)
     SYS_CONTEXT: global system context

     SERIAL: the message serial number

     I: the message index in the group

     N: the number of messages in the group

     SEQ: the message seq (round + an offset)

     META_ARRAY: the content to send

     Generate a META command.  Serial is an ever increasing number, i
     and n are most of the time 1 and 1, they are usefull only in long
     multipart messages.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_cmd_generate_miss (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t ID_FROM, u_int64_t ID_TO, int
          SERIAL_MIN, int SERIAL_MAX)
     SYS_CONTEXT: global system context

     ID_FROM: id of the node which didn't send data correctly

     ID_TO: id of the node which didn't receive data correctly

     SERIAL_MIN: minimum serial number of unsent/unreceived messages

     SERIAL_MAX: maximum serial number of unsent/unreceived messages

     Generate a MISS command.  This will request anyone who has the
     messages mentionned in stock to resent them to the one who's asking
     for them.

     *Return value:* newly allocated string.

 -- Function: int lw6msg_cmd_analyse_hello (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     MSG: the message to analyse

     Analyzes a HELLO message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_ticket (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, u_int64_t * TICKET, const
          char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     TICKET: if not NULL, will contain the ticket value on success

     MSG: the message to analyse

     Analyzes a TICKET message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_foo (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, u_int32_t * KEY, int *
          SERIAL, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     KEY: if not NULL, will contain the foo/bar key on success

     SERIAL: if not NULL, will contain the latest serial number of peer

     MSG: the message to analyse

     Analyzes a FOO message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_bar (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, u_int32_t * KEY, int *
          SERIAL, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     KEY: if not NULL, will contain the foo/bar key on success

     SERIAL: if not NULL, will contain the latest serial number of peer

     MSG: the message to analyse

     Analyzes a BAR message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_join (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, lw6nod_info_t *
          LOCAL_INFO, int64_t * SEQ, int * SERIAL, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     LOCAL_INFO: local node info to be updated (peer_id list), can be
     NULL

     SEQ: sequence used to initialize communication

     SERIAL: serial used to initialize communication

     MSG: the message to analyse

     Analyzes a JOIN message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_goodbye (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t ** INFO, const char * MSG)
     SYS_CONTEXT: global system context

     INFO: will contain (remote) node info on success

     MSG: the message to analyse

     Analyzes a GOODBYE message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_data (lw6sys_context_t *
          SYS_CONTEXT, int * SERIAL, int * I, int * N, int64_t * SEQ,
          char ** KER_MSG, const char * MSG)
     SYS_CONTEXT: global system context

     SERIAL: will contain serial number on success

     I: will contain group index on success

     N: will contain group size on success

     SEQ: will contain seq on success (round + an offset)

     KER_MSG: will contain actual message on success

     MSG: the message to analyze

     Analyzes a DATA message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_meta (lw6sys_context_t *
          SYS_CONTEXT, int * SERIAL, int * I, int * N, int64_t * SEQ,
          lw6msg_meta_array_t * META_ARRAY, const char * MSG)
     SYS_CONTEXT: global system context

     SERIAL: will contain serial number on success

     I: will contain group index on success

     N: will contain group size on success

     SEQ: will contain seq on success (round + an offset)

     META_ARRAY: will contain the content on success

     MSG: the message to analyze

     Analyzes a META message.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_miss (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t * ID_FROM, u_int64_t * ID_TO, int *
          SERIAL_MIN, int * SERIAL_MAX, const char * MSG)
     SYS_CONTEXT: global system context

     ID_FROM: will contain the id of the node which didn't send data
     correctly

     ID_TO: will contain the id of the node which didn't receive data
     correctly

     SERIAL_MIN: will contain the minimum serial number of
     unsent/unreceived messages

     SERIAL_MAX: will contain the maximum serial number of
     unsent/unreceived messages

     MSG: the message to analyze

     Analyzes a MISS message.

     *Return value:* 1 on success, 0 on failure

 -- Function: char * lw6msg_cmd_guess_from_url (lw6sys_context_t *
          SYS_CONTEXT, const char * MSG)
     SYS_CONTEXT: global system context

     MSG: the message to analyse

     Analyzes a GOODBYE message.

     *Return value:* the from url, if found (dynamically allocated)

 -- Function: char * lw6msg_envelope_generate (lw6sys_context_t *
          SYS_CONTEXT, lw6msg_envelope_mode_t MODE, const char *
          VERSION, const char * PASSWORD_CHECKSUM, u_int32_t
          PHYSICAL_TICKET_SIG, u_int32_t LOGICAL_TICKET_SIG, u_int64_t
          PHYSICAL_FROM_ID, u_int64_t PHYSICAL_TO_ID, u_int64_t
          LOGICAL_FROM_ID, u_int64_t LOGICAL_TO_ID, const char * MSG)
     SYS_CONTEXT: global system context

     MODE: mode to use (a la TELNET or URL compatible)

     VERSION: the program version to use (note: can be changed when
     testing)

     PASSWORD_CHECKSUM: the password string to send

     PHYSICAL_TICKET_SIG: the signature of the message, calculated with
     ticket + physical from/to

     LOGICAL_TICKET_SIG: the signature of the message, calculated with
     ticket + logical from/to

     PHYSICAL_FROM_ID: the sender id

     PHYSICAL_TO_ID: the receiver id

     LOGICAL_FROM_ID: the message creator id

     LOGICAL_TO_ID: the message final destination id

     MSG: the body of the message

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:* newly allocated string.

 -- Function: int lw6msg_envelope_analyse (lw6sys_context_t *
          SYS_CONTEXT, const char * ENVELOPE, lw6msg_envelope_mode_t
          MODE, const char * LOCAL_URL, const char * PASSWORD, u_int64_t
          EXPECTED_PHYSICAL_FROM_ID, u_int64_t EXPECTED_PHYSICAL_TO_ID,
          char ** MSG, u_int32_t * PHYSICAL_TICKET_SIG, u_int32_t *
          LOGICAL_TICKET_SIG, u_int64_t * PHYSICAL_FROM_ID, u_int64_t *
          PHYSICAL_TO_ID, u_int64_t * LOGICAL_FROM_ID, u_int64_t *
          LOGICAL_TO_ID, char ** PHYSICAL_FROM_URL)
     SYS_CONTEXT: global system context

     ENVELOPE: the envelope to analyse

     MODE: mode to use (a la TELNET or URL compatible)

     LOCAL_URL: the url of local server (usefull for password)

     PASSWORD: the password to check against

     EXPECTED_PHYSICAL_FROM_ID: the sender id, if NULL, no check
     performed

     EXPECTED_PHYSICAL_TO_ID: the receiver id, if NULL, no check
     performed

     MSG: if not NULL, will contain body of the message

     PHYSICAL_TICKET_SIG: if not NULL, will contain signature of
     message, calculated with ticket

     LOGICAL_TICKET_SIG: if not NULL, will contain signature of message,
     calculated with ticket

     PHYSICAL_FROM_ID: if not NULL, will contain sender id

     PHYSICAL_TO_ID: if not NULL, will contain receiver id

     LOGICAL_FROM_ID: if not NULL, will contain message creator id

     LOGICAL_TO_ID: if not NULL, will contain message final destination
     id

     PHYSICAL_FROM_URL: if not NULL and if message allows, will contain
     sender public URL

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:* newly allocated string.

 -- Function: void lw6msg_meta_array_zero (lw6sys_context_t *
          SYS_CONTEXT, lw6msg_meta_array_t * META_ARRAY)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     Fills the meta meta_array with zeroes, emptying all nodes.

     *Return value:* none

 -- Function: int lw6msg_meta_array_find (lw6sys_context_t *
          SYS_CONTEXT, const lw6msg_meta_array_t * META_ARRAY, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     NODE_ID: the ID (64-bit) of the node to seartch

     Registers a node in the meta_array.

     *Return value:* 1 if registered, 0 if not (possible error: no place
     left)

 -- Function: int lw6msg_meta_array_exists (lw6sys_context_t *
          SYS_CONTEXT, const lw6msg_meta_array_t * META_ARRAY, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     NODE_ID: the ID (64-bit) of the node to test

     Registers a node in the meta_array.

     *Return value:* 1 if registered, 0 if not (possible error: no place
     left)

 -- Function: int lw6msg_meta_array_set (lw6sys_context_t * SYS_CONTEXT,
          lw6msg_meta_array_t * META_ARRAY, u_int64_t NODE_ID, int
          SERIAL_0, int64_t SEQ_0)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     NODE_ID: the ID (64-bit) of the node to add

     SERIAL_0: base serialfor the node to add

     SEQ_0: base seq for for node to add

     Registers a node in the meta_array.

     *Return value:* 1 if registered, 0 if not (possible error: no place
     left)

 -- Function: int lw6msg_meta_array_unset (lw6sys_context_t *
          SYS_CONTEXT, lw6msg_meta_array_t * META_ARRAY, u_int64_t
          NODE_ID)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to modify

     NODE_ID: the ID (64-bit) of the node to remove

     Unregisters a node in the meta_array.

     *Return value:* 1 if node existed, 0 if it was not here

 -- Function: int lw6msg_meta_str2array (lw6sys_context_t * SYS_CONTEXT,
          lw6msg_meta_array_t * META_ARRAY, const char * STR)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to get (out param)

     STR: meta string (list of nodes) to be put in the meta_array

     Transforms a string describing the nodes and their id/serial/seq
     into a more usable C structure.

     *Return value:* 1 if parseable and success, 0 if not.

 -- Function: char * lw6msg_meta_array2str (lw6sys_context_t *
          SYS_CONTEXT, const lw6msg_meta_array_t * META_ARRAY)
     SYS_CONTEXT: global system context

     META_ARRAY: meta meta_array (list of nodes) to transform as a
     string

     Transforms a C struct describing the nodes and their id/serial/seq
     into a string transmittable on the network.

     *Return value:* dynamically allocated string

 -- Function: char * lw6msg_oob_generate_info (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node to generate info about

     Generates a standard response to the INFO question for OOB (out of
     band) messages.  The same message is sent, be it on http or tcp or
     udp, so it's factorized here.  Function will lock the info object
     when needed.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_oob_generate_list (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node to generate info about

     Generates a standard response to the LIST question for OOB (out of
     band) messages.  The same message is sent, be it on http or tcp or
     udp, so it's factorized here.  Function will lock the info object
     when needed.  There's a max length because we don't want the udp
     buffer to be saturated + too long lists do not really mean anything
     anyway.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_oob_generate_pong (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node to generate info about

     Generates a standard response to the PING question for OOB (out of
     band) messages.  The same message is sent, be it on http or tcp or
     udp, so it's factorized here.  Function will lock the info object
     when needed.

     *Return value:* newly allocated string.

 -- Function: char * lw6msg_oob_generate_request (lw6sys_context_t *
          SYS_CONTEXT, const char * COMMAND, const char * REMOTE_URL,
          const char * PASSWORD, const char * LOCAL_URL)
     SYS_CONTEXT: global system context

     COMMAND: the command to send (PING, INFO, LIST)

     REMOTE_URL: the remote URL (used to seed password)

     PASSWORD: the password, can be NULL or ""

     LOCAL_URL: the public URL to send along with the message, can be
     NULL or ""

     Generates a simple clear text OOB request, with a password if
     needed.

     *Return value:* a newly allocated string

 -- Function: int lw6msg_oob_analyse_request (lw6sys_context_t *
          SYS_CONTEXT, int * SYNTAX_OK, char ** COMMAND, int *
          PASSWORD_OK, char ** REMOTE_URL, const char * REQUEST, const
          char * LOCAL_URL, const char * PASSWORD)
     SYS_CONTEXT: global system context

     SYNTAX_OK: will contain 1 if syntax is OK, 0 if not

     COMMAND: the command (out param, needs *not* to be freed)

     PASSWORD_OK: will contain 1 if password is OK, 0 if not

     REMOTE_URL: the URL detected, if provided (out param, does needs to
     be freed)

     REQUEST: the request to analyse

     LOCAL_URL: the local url (used to seed password)

     PASSWORD: the password to check against

     Analyses a simple OOB message of the form COMMAND <passwd> <url>.

     *Return value:* 1 if OK, 0 if not.  If 0, check the value of
     password_ok.

 -- Function: char * lw6msg_oob_analyse_pong (lw6sys_context_t *
          SYS_CONTEXT, const char * TEXT)
     SYS_CONTEXT: global system context

     TEXT: the text of the message to parse

     Analyses a PONG message and gets the public_url from it, if it
     exists.

     *Return value:* newly allocated string containing public_url if OK,
     NULL on error.

 -- Function: int lw6msg_sort_str_by_seq_callback (lw6sys_context_t *
          SYS_CONTEXT, void * FUNC_DATA, const void * PTR_A, const void
          * PTR_B)
     SYS_CONTEXT: global system context

     FUNC_DATA: function specific data

     PTR_A: pointer to a string

     PTR_B: pointer to a string

     Sort callback for a list containing strings which begin by a seq
     number, will sort with lower seq number first.

     *Return value:* -1 if 'ptr_a' < 'ptr_b' , 0 if 'ptr_a' == 'ptr_b',
     1 if 'ptr_a' > 'ptr_b'

 -- Function: int lw6msg_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libmsg module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6msg_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'msg' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: u_int32_t lw6msg_ticket_calc_sig (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t TICKET, u_int64_t FROM_ID, u_int64_t
          TO_ID, const char * MSG)
     SYS_CONTEXT: global system context

     TICKET: the (private) ticket to use

     FROM_ID: the sender/creator

     TO_ID: the receiver/target

     MSG: the message to sign

     Produces a little signature, which is clearly vulnerable to
     brute-force attacks but makes it possible to be 100% sure if it's
     wrong, someone is trying to do something nasty (or there's a
     serious bug!).

     *Return value:* the sig, always non-zero

 -- Function: int lw6msg_ticket_check_sig (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t TICKET, u_int64_t FROM_ID, u_int64_t
          TO_ID, const char * MSG, u_int32_t TICKET_SIG)
     SYS_CONTEXT: global system context

     TICKET: the (private) ticket to use

     FROM_ID: the sender/creator

     TO_ID: the receiver/target

     MSG: the message to sign

     TICKET_SIG: the signature to check against

     Checks a sig is OK.

     *Return value:* 1 if they are the same, 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_ptr (lw6sys_context_t
          * SYS_CONTEXT, char ** KEY, char ** VALUE, const char * LINE)
     SYS_CONTEXT: global system context

     KEY: will contain the key detected

     VALUE: will contain the value detected

     LINE: the line to analyse

     Analyses a trivial "KEY value" line and returns the key and the
     value in the passed pointers.

     *Return value:* 1 if line OK (and in this case 'key' and 'value'
     are set), 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_assoc
          (lw6sys_context_t * SYS_CONTEXT, lw6sys_assoc_t ** ASSOC,
          const char * LINE)
     SYS_CONTEXT: global system context

     ASSOC: an assoc object which will contain the result

     LINE: the line to analyse

     Analyses a trivial "KEY value" line and sets the 'assoc' parameter
     according to detected values.  Note that 'assoc' must be set to
     contain string, and free them automatically with
     'lw6sys_free_callback' for instance.

     *Return value:* 1 if line OK (and in this case 'assoc' is updated),
     0 if not.

 -- Function: char * lw6msg_utils_get_assoc_str_with_default
          (lw6sys_context_t * SYS_CONTEXT, lw6sys_assoc_t * ASSOC, const
          char * KEY, const char * DEFAULT_VALUE)
     SYS_CONTEXT: global system context

     ASSOC: the string assoc to query

     KEY: the key to find in the assoc

     DEFAULT_VALUE: the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value.  Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over.

     *Return value:* a string, must not be freed.

 -- Function: int lw6msg_utils_get_assoc_int_with_default
          (lw6sys_context_t * SYS_CONTEXT, lw6sys_assoc_t * ASSOC, const
          char * KEY, int DEFAULT_VALUE)
     SYS_CONTEXT: global system context

     ASSOC: the string assoc to query

     KEY: the key to find in the assoc

     DEFAULT_VALUE: the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value.  Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over.  This one will returned an int
     converted with 'lw6sys_atoi'.

     *Return value:* a string, must not be freed.

 -- Function: int lw6msg_word_first (lw6sys_context_t * SYS_CONTEXT,
          lw6msg_word_t * WORD, char ** NEXT, const char * MSG)
     SYS_CONTEXT: global system context

     WORD: will contain the parsed word

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message and gets the first word.  This word is put in
     'buf' member with its length.  'next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_x (lw6sys_context_t * SYS_CONTEXT,
          lw6msg_word_t * WORD, char ** NEXT, const char * MSG)
     SYS_CONTEXT: global system context

     WORD: will contain the parsed word

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message and gets the first word.  This word is put in
     'buf' member with its length.  'next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     This special 'x' function will consider slash ("/") as valid
     separator.  It can't be used all the time but for almost every
     field but URLs, it's fine.  Internally, this one is used to parse
     integers, IDs, etc.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_base64 (lw6sys_context_t *
          SYS_CONTEXT, lw6msg_word_t * WORD, char ** NEXT, const char *
          MSG)
     SYS_CONTEXT: global system context

     WORD: will contain the parsed word

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message and gets the first word.  This word is put in
     'buf' member with its length.  'next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     The word is expected to be base64 encoded and is decoded
     on-the-fly.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_32 (lw6sys_context_t *
          SYS_CONTEXT, int32_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_32_ge0 (lw6sys_context_t *
          SYS_CONTEXT, int32_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_32_gt0 (lw6sys_context_t *
          SYS_CONTEXT, int32_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_64 (lw6sys_context_t *
          SYS_CONTEXT, int64_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_64_ge0 (lw6sys_context_t *
          SYS_CONTEXT, int64_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_64_gt0 (lw6sys_context_t *
          SYS_CONTEXT, int64_t * PARSED_VALUE, char ** NEXT, const char
          * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_16 (lw6sys_context_t *
          SYS_CONTEXT, u_int16_t * PARSED_VALUE, char ** NEXT, const
          char * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an
     16-bit id.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_32 (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * PARSED_VALUE, char ** NEXT, const
          char * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an
     32-bit id.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_64 (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t * PARSED_VALUE, char ** NEXT, const
          char * MSG)
     SYS_CONTEXT: global system context

     PARSED_VALUE: will contain the parsed value

     NEXT: if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG: the message to parse

     Analyses a message, gets the first word and interpret it as an
     64-bit id.

     *Return value:* 1 on success, 0 on failure.

 -- Function: char * lw6msg_z_encode (lw6sys_context_t * SYS_CONTEXT,
          const char * MSG, int LIMIT)
     SYS_CONTEXT: global system context

     MSG: message to encode

     LIMIT: if under this limit (length in bytes), do not encode, return
     as is

     Z-encode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     There's an optional limit *not* to encode anything, just when we
     know there are no special characters to escape and string is small,
     it's useless to fire this big artillery.

     *Return value:* newly allocated string, 0 terminated, NULL on
     error.

 -- Function: char * lw6msg_z_decode (lw6sys_context_t * SYS_CONTEXT,
          const char * MSG)
     SYS_CONTEXT: global system context

     MSG: message to decode

     Z-decode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     This decode string does it the reverse way, un64-encode the string
     then uncompress it back to a readable string.

     *Return value:* newly allocated string, 0 terminated, NULL on
     error.

 -- Struct: lw6msg_meta_array_item_s

 -- Member of lw6msg_meta_array_item_s: node_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6msg_meta_array_item_s::node_id'

 -- Member of lw6msg_meta_array_item_s: serial_0
     *Type:* 'int'

     *Definition:* 'int lw6msg_meta_array_item_s::serial_0'

 -- Member of lw6msg_meta_array_item_s: seq_0
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6msg_meta_array_item_s::seq_0'

 -- Struct: lw6msg_meta_array_s

 -- Member of lw6msg_meta_array_s: logical_from
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6msg_meta_array_s::logical_from'

 -- Member of lw6msg_meta_array_s: items
     *Type:* 'lw6msg_meta_array_item_t'

     *Definition:* 'lw6msg_meta_array_item_t
     lw6msg_meta_array_s::items[LW6MSG_NB_META_ARRAY_ITEMS]'

 -- Struct: lw6msg_word_s

     This structure is used to retrieve words from messages.  We use a
     structure here with a fixed sized buffer and a len member, this is
     to avoid mallocating too often when parsing.

 -- Member of lw6msg_word_s: len
     *Type:* 'int'

     *Definition:* 'int lw6msg_word_s::len'

     Length of word, in bytes.

 -- Member of lw6msg_word_s: buf
     *Type:* 'char'

     *Definition:* 'char lw6msg_word_s::buf[LW6MSG_MAX_WORD_SIZE+1]'

     Word data, containing a 0 char at the end, so it is safe to call
     standard C string functions on it.

5.34 libnet
===========

5.34.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/net/index.html>.

5.34.2 API
----------

 -- Function: int lw6net_is_connectable (lw6sys_context_t * SYS_CONTEXT,
          const char * IP, int PORT)
     SYS_CONTEXT: global system context

     IP: IP address

     PORT: IP port

     Tells wether we're likely to be able to connect on a given host and
     port.  This is to save ressources, any call to connect which fails
     will register an entry that says "OK this is rotten, don't try it
     before some time, you'll waste your ressources trying to do this".

     *Return value:* 1 if connectable, 0 if not.

 -- Function: void lw6net_set_connectable (lw6sys_context_t *
          SYS_CONTEXT, const char * IP, int PORT, int STATUS)
     SYS_CONTEXT: global system context

     IP: IP address

     PORT: IP port

     STATUS: status, set to 1 if connectable, 0 if not

     *Registers a destination ip:* port as connectable or not.
     Connectable means, there are chances that a connect on this might
     return true.  The information will be kept in a cache.  This is to
     avoid too many low-level calls to connect, the information will be
     kept in cache "for some time", and this way connect will return
     "can't connect" right away and not even try to connect, therefore
     saving ressources.

     *Return value:* none.

 -- Function: int lw6net_dns_is_ip (lw6sys_context_t * SYS_CONTEXT,
          const char * IP)
     IP: the string to check

     Tests if a given string is a valid IP (IPV4).  Test is only
     syntaxic, it's just to know if we're likely to need to query the
     DNS, it does not mean the IP is *really* valid.

     *Return value:* 1 if it's an IP, O if not.

 -- Function: char * lw6net_dns_gethostbyname (lw6sys_context_t *
          SYS_CONTEXT, const char * NAME)
     NAME: name of the host

     A wrapper over the standard gethostbyname function, will even
     accept an IP as an input (in this case, will copy it...)  and
     allocate a new string for the result.

     *Return value:* an IP if success, NULL on error.

 -- Function: int lw6net_dns_lock (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Locks access to dns function 'lw6net_dns_gethostbyname'.  This is
     because 'gethostbyname' isn't reentrant plus, even if we didn't use
     it but its multithreadable equivalent (which is however not
     standard and always available) other libs (such as 'libcurl' not to
     name it) might use this function too so in a general manner it's a
     good idea to use a mutex to protect multiple accesses to this.

     *Return value:* an IP if success, 0 on error.

 -- Function: int lw6net_dns_unlock (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Unlocks access to dns function 'lw6net_dns_gethostbyname'.

     *Return value:* an IP if success, 0 on error.

 -- Function: int lw6net_last_error (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Reports the last network error.  This is basically a debug
     function, designed mostly for Microsoft Winsock API, but can be
     safely called on any platform.

     *Return value:* the last error code, has no universal meaning,
     depends on the platform you're working on.

 -- Function: char * lw6net_if_guess_local (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Guess the local IP address.  This is not fool-proof, and it
     probably cannot be as we can't handle all user-specific configs
     involving multiple IP addresses, virtual private networks, and so
     on.  But this is just to provide a default public IP address when
     starting a network game, saavy users can always specify the right
     interface/address if needed.  Will return NULL if interface can't
     be guessed.

     *Return value:* the IP as a string, dynamically allocated

 -- Function: char * lw6net_if_guess_public_url (lw6sys_context_t *
          SYS_CONTEXT, const char * BIND_IP, int BIND_PORT)
     SYS_CONTEXT: global system context

     BIND_IP: the IP address used to bind on

     BIND_PORT: the IP port used to bind on

     Guess the server public url, based on 'lw6net_if_guess_local' which
     tries to find a valid local IP address which is not loopback.  This
     is only in case 'bind_ip' is 0.0.0.0 (listen on all addresses) else
     it will just use 'bind_ip' as you would expect.  Function isn't
     foolproof, that's why one can override its default with a user
     settings.

     *Return value:* the IP as a string, dynamically allocated

 -- Function: char * lw6net_recv_line_tcp (lw6sys_context_t *
          SYS_CONTEXT, int * SOCK)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a TCP socket, that is, stream oriented.  If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever.  Only if
     there's something consistent will the function return non-NULL.
     Socket descriptor is closed on the fly on connection problem.

     *Return value:* a dynamically allocated string with the content
     received.  The tailing (CR)/LF is stripped.

 -- Function: int lw6net_send_line_tcp (lw6sys_context_t * SYS_CONTEXT,
          int * SOCK, const char * LINE)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     LINE: the line to be sent, without the "\n" at the end

     Sends a line terminated by LF ("\n", chr(10)) on a TCP socket, that
     is, stream oriented.  The "\n" is automatically added, do not
     bother sending it.  Socket descriptor is closed on the fly on
     connection problem.

     *Return value:* non-zero if success

 -- Function: char * lw6net_recv_line_udp (lw6sys_context_t *
          SYS_CONTEXT, int SOCK, char ** INCOMING_IP, int *
          INCOMING_PORT)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     INCOMING_IP: the IP address of the sender (returned)

     INCOMING_PORT: the IP port of the sender (returned)

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a UDP socket, that is, datagram oriented.  If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever.  Only if
     there's something consistent will the function return non-NULL.
     By-value parameters allow the caller to know where the data come
     from.

     *Return value:* a dynamically allocated string with the content
     received.  The tailing (CR)/LF is stripped.

 -- Function: lw6sys_list_t * lw6net_recv_lines_udp (lw6sys_context_t *
          SYS_CONTEXT, int SOCK, char ** INCOMING_IP, int *
          INCOMING_PORT)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     INCOMING_IP: the IP address of the sender (returned)

     INCOMING_PORT: the IP port of the sender (returned)

     Receives several lines terminated by LF ("\n", chr(10)) or CR/LF
     ("\r\n", chr(10)chr(13)) on a UDP socket, that is, datagram
     oriented.  If there's no complete line available, function returns
     immediately with NULL. Same if socket is closed, broken, whatever.
     Only if there's something consistent will the function return
     non-NULL. By-value parameters allow the caller to know where the
     data come from.  This variant of 'lw6net_recv_line_tcp' will return
     a list of lines, this is mandatory since in UDP we can't call recv
     several times.

     *Return value:* a list of dynamically allocated strings.  The
     tailing (CR)/LF is stripped from strings.

 -- Function: int lw6net_send_line_udp (lw6sys_context_t * SYS_CONTEXT,
          int SOCK, const char * LINE, const char * IP, int PORT)
     SYS_CONTEXT: global system context

     SOCK: the socket descriptor

     LINE: the line to be sent, without the "\n" at the end

     IP: the IP address of the target

     PORT: the IP port of the target

     Sends a line terminated by LF ("\n", chr(10)) on a UDP socket, that
     is, datagram oriented.  The "\n" is automatically added, do not
     bother sending it.

     *Return value:* the number of bytes sent, 0 if failure

 -- Function: int lw6net_init (lw6sys_context_t * SYS_CONTEXT, int ARGC,
          const char * [] ARGV, int NET_LOG)
     SYS_CONTEXT: global system context

     ARGC: argc as passed to 'main'

     ARGV: argv as passed to 'main'

     NET_LOG: 1 if you want to enable net log, 0 if not

     Initializes the low-level network API, you must call this before
     calling any other network related function, for it allocates a
     dynamic context which is in turn used by every function.

     *Return value:* non-zero if success

 -- Function: void lw6net_quit (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Frees memory, joins active threads, and releases everything set up
     by network code.

     *Return value:* void

 -- Function: int lw6net_socket_set_blocking_mode (lw6sys_context_t *
          SYS_CONTEXT, int SOCK, int MODE)
     SYS_CONTEXT: global system context

     SOCK: the socket to modify

     MODE: the mode to use (1 -> blocking mode, 0 -> non-blocking)

     Sets the blocking mode of a socket, the reason we use this is that
     'ioctl' isn't portable ('ioctlsocket' on MS-Windows).

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6net_socket_is_valid (lw6sys_context_t *
          SYS_CONTEXT, int SOCK)
     SYS_CONTEXT: global system context

     SOCK: the socket to test

     Tells if a socket is valid or not.  This does not mean the socket
     is opened/connected and/or the peer is reachable, it just checks
     the socket is a valid descriptor.  In practice it's just to avoid
     copy/pasting if (sock>=0)" everywhere.

     *Return value:* 1 if valid, 0 if not

 -- Function: void lw6net_socket_close (lw6sys_context_t * SYS_CONTEXT,
          int * SOCK)
     SYS_CONTEXT: global system context

     SOCK: the socket to close

     Closes a socket, that is, stop activity and free its descriptor.
     This function will take a pointer on the socket, this is done on
     purpose, the idea is to make sure once the socket is closed it's
     never used again within the code, so we modify the pointed value in
     place.

     *Return value:* none.

 -- Function: int lw6net_tcp_listen (lw6sys_context_t * SYS_CONTEXT,
          const char * IP, int PORT)
     SYS_CONTEXT: global system context

     IP: IP address to bind to

     PORT: IP port to listen on

     Listens in TCP on a given port.

     *Return value:* >=0 on success, -1 on failure.

 -- Function: int lw6net_tcp_accept (lw6sys_context_t * SYS_CONTEXT,
          char ** INCOMING_IP, int * INCOMING_PORT, int LISTENING_SOCK,
          int DELAY_MSEC)
     SYS_CONTEXT: global system context

     INCOMING_IP: address of remote peer (out param, dynamically
     allocated)

     INCOMING_PORT: port of remote peer (out param)

     LISTENING_SOCK: socket to listen on

     DELAY_MSEC: delay, in msec, after which we stop accepting

     Accepts for a connexion on the given socket.

     *Return value:* the new socket (>=0) if accepted, else -1

 -- Function: int lw6net_tcp_connect (lw6sys_context_t * SYS_CONTEXT,
          const char * IP, int PORT, int DELAY_MSEC)
     SYS_CONTEXT: global system context

     IP: address to connect to

     PORT: port to connect to

     DELAY_MSEC: delay before we consider it's too late

     Tries to connect on a given socket.

     *Return value:* socket (>=0) on success, else -1

 -- Function: int lw6net_tcp_send (lw6sys_context_t * SYS_CONTEXT, int *
          SOCK, const char * BUF, int LEN, int DELAY_MSEC, int LOOP)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     DELAY_MSEC: delay after which we give up

     LOOP: accept to do several calls if needed

     Will send data, possibly looping until all is send, and waiting for
     a maximum time of delay_msec.  If the send reveals a socket closed
     by peer or other serious problem, socket is closed and sock set to
     -1.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6net_tcp_peek (lw6sys_context_t * SYS_CONTEXT, int *
          SOCK, char * BUF, int LEN, int DELAY_MSEC)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     DELAY_MSEC: maximum time to wait

     Tells wether data is available.  Will actually fill the buffer with
     the data, but not remove it from the fifo list.  If the peel
     reveals a socket closed by peer or other serious problem, socket is
     closed and sock set to -1.

     *Return value:* number of bytes available, 0 when nothing

 -- Function: int lw6net_tcp_recv (lw6sys_context_t * SYS_CONTEXT, int *
          SOCK, char * BUF, int LEN, int DELAY_MSEC, int LOOP)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     DELAY_MSEC: maximum time to wait

     LOOP: wether to loop or not

     If data is available, put it in buffer.  If needed, will loop until
     'delay_msec' is elapsed.  Data is removed from queue.  If the peel
     reveals a socket closed by peer or other serious problem, socket is
     closed and sock set to -1.

     *Return value:* number of bytes received, 0 when nothing

 -- Function: int lw6net_tcp_is_alive (lw6sys_context_t * SYS_CONTEXT,
          int * SOCK)
     SYS_CONTEXT: global system context

     SOCK: socket to test

     Tells wether a socket is alive and able to send data.  This
     function will attempt a write to test if it's really usable.  If
     not, will close in on the fly.

     *Return value:* 1 if alive, 0 if not.

 -- Function: int lw6net_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libnet module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6net_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'net' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6net_udp_client (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates an UDP client socket, that is, creates it and does not bind
     it to any address.

     *Return value:* socket (>=0) on success, else -1

 -- Function: int lw6net_udp_server (lw6sys_context_t * SYS_CONTEXT,
          const char * IP, int PORT)
     SYS_CONTEXT: global system context

     IP: IP address to bind to

     PORT: IP port to listen on

     Creates an UDP listening socket, that is, creates it and binds it
     on a given address.

     *Return value:* socket (>=0) on success, else -1

 -- Function: int lw6net_udp_send (lw6sys_context_t * SYS_CONTEXT, int
          SOCK, const char * BUF, int LEN, const char * IP, int PORT)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     IP: IP address to send data to

     PORT: IP port to send data to

     Sends an UDP datagram.  Size can't be longer than about 1400 bytes,
     see problems about MTU, in practice all values arround 1000 are
     quite safe, 500 is pretty much garanteed to work everywhere, and
     for various reasons 1452 is a good maximum bet.

     *Return value:* number of bytes sent

 -- Function: int lw6net_udp_peek (lw6sys_context_t * SYS_CONTEXT, int
          SOCK, char * BUF, int LEN, char ** INCOMING_IP, int *
          INCOMING_PORT)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     Peeks for a UDP datagram.  Will not remove the data from queue.

     *Return value:* number of bytes received

 -- Function: int lw6net_udp_recv (lw6sys_context_t * SYS_CONTEXT, int
          SOCK, char * BUF, int LEN, char ** INCOMING_IP, int *
          INCOMING_PORT)
     SYS_CONTEXT: global system context

     SOCK: socket to use

     BUF: data buffer

     LEN: data buffer length

     Receives a UDP datagram.  Will remove the data from queue.

     *Return value:* number of bytes received

5.35 libnod
===========

5.35.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/nod/index.html>.

5.35.2 API
----------

 -- Function: int lw6nod_info_community_add (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t ID, const char *
          URL)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     ID: ID of the new member

     URL: URL of the new member, can be NULL

     Adds a new member to the community.

     *Return value:* 1 if new member could be added, 0 if not.

 -- Function: int lw6nod_info_community_is_member (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t ID, const char *
          URL)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     ID: ID of the member we want to check

     URL: URL of the member we want to check

     Tells wether a member is already in the community.  Note that if
     there's a member with the same URL but with a different ID, or a
     member with the same ID but a different URL, the function will
     fail, we need URLs and IDs to both be different for the peer to be
     added.  Not respecting this would lead to confusion, while sharing
     an ID is conceivable over the whole network, it can't be tolerated
     within a community.  Same for the URL.

     *Return value:* 1 if new member could be added, 0 if not.

 -- Function: int lw6nod_info_community_has_id (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t ID)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     ID: ID of the member we want to check

     Tells wether a member exists with this ID. Will test both ourselves
     and remote peers.

     *Return value:* 1 if ID is already taken, 0 if available.

 -- Function: int lw6nod_info_community_has_id_without_url
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO,
          u_int64_t ID)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     ID: ID of the member we want to check

     Tells wether a member exists with this ID, but for which we don't
     know the URL, that is, url is NULL.

     *Return value:* 1 if ID is already taken and has NULL url, 0 else.

 -- Function: int lw6nod_info_community_has_url (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, const char * URL)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     URL: URL of the member we want to check

     Tells wether a member exists with this URL. Will test both
     ourselves and remote peers.

     *Return value:* 1 if URL is already taken, 0 if available.

 -- Function: int64_t lw6nod_info_community_get_id_from_url
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO, const
          char * URL)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     URL: URL of the member we want to check

     Returns the id of the node with this URL, if it's known to us.

     *Return value:* id if it's the community, else 0

 -- Function: char * lw6nod_info_community_get_url_from_id
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO, int64_t
          ID)
     SYS_CONTEXT: global system context

     INFO: node info object to test

     ID: ID of the member we want to check

     Returns the id of the node with this URL, if it's known to us.

     *Return value:* url if it's the community else NULL, must be freed

 -- Function: int lw6nod_info_community_remove_by_id (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, u_int64_t ID)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     ID: ID of the member we want to remove

     Removes a community member by ID.

     *Return value:* 1 if successfully removed, 0 if was not present.

 -- Function: int lw6nod_info_community_remove_by_url (lw6sys_context_t
          * SYS_CONTEXT, lw6nod_info_t * INFO, const char * URL)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     URL: URL of the member we want to remove

     Removes a community member by URL.

     *Return value:* 1 if successfully removed, 0 if was not present.

 -- Function: int lw6nod_info_community_count (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     Tells how many members there are in a community.  This include
     ourselves so this can never be 0, should at least be 1.  Note that
     this is pretty much the same as the nb_nodes member of dyn_info,
     but this one is calculated dynamically from peer list, while the
     other one is updated from time to time from game_state information.

     *Return value:* number of community members, including this node
     (us).

 -- Function: void lw6nod_info_community_reset (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: node info object to modify

     Resets all peers, set community to only one member, ourselves.

     *Return value:* none.

 -- Function: char * lw6nod_info_community_get_peer_id_list_str
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: node to query

     Builds a string containing all peer ids, separated by a separator.

     *Return value:* newly allocated string

 -- Function: void lw6nod_info_community_set_peer_id_list_str
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO, const
          char * PEER_ID_LIST_STR)
     SYS_CONTEXT: global system context

     INFO: node to modify

     PEER_ID_LIST_STR: new value

     Interprets a peer_id_list_str and puts it into the node data
     structures.  Note that this function won't really copy the list,
     instead it will populate the dyn_info struct with the right values.

     *Return value:* none

 -- Function: void lw6nod_info_community_id_without_url_map
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO,
          lw6nod_id_callback_func_t FUNC, void * FUNC_DATA)
     SYS_CONTEXT: global system context

     INFO: node to process

     FUNC: function to use as a callback

     FUNC_DATA: data passed along with the function

     Applies function func to all the members of the community which
     have an id but not an URL...

     *Return value:* none.

 -- Function: void lw6nod_dyn_info_free (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_dyn_info_t * DYN_INFO)
     SYS_CONTEXT: global system context

     DYN_INFO: the dyn info struct to free

     Frees a dyn info object, to be used after a call to
     'lw6nod_info_dup_dyn' for instance.

     *Return value:* none

 -- Function: lw6nod_info_t * lw6nod_info_new (lw6sys_context_t *
          SYS_CONTEXT, const char * PROGRAM, const char * VERSION, const
          char * CODENAME, int STAMP, u_int64_t ID, const char * URL,
          const char * TITLE, const char * DESCRIPTION, const char *
          PASSWORD, int BENCH, int OPEN_RELAY, int UPTIME, int
          IDLE_SCREENSHOT_SIZE, void * IDLE_SCREENSHOT_DATA)
     SYS_CONTEXT: global system context

     PROGRAM: the program (normally it's liquidwar6)

     VERSION: the version

     CODENAME: the codename

     STAMP: the stamp

     ID: the node id

     URL: the node public url

     TITLE: the node title

     DESCRIPTION: the node description

     PASSWORD: the node password

     BENCH: the node bench

     OPEN_RELAY: open relay or not

     UPTIME: uptime in seconds

     IDLE_SCREENSHOT_SIZE: the size (bytes) of the image to display when
     game is idle

     IDLE_SCREENSHOT_DATA: the data (jpeg) of the image to display when
     game is idle

     Creates a node info object.  The arguments correspond to the
     immutable node attributes, other properties such as how many
     players are connected or set in other functions like
     'lw6nod_info_update' which can be called later.

     *Return value:* newly allocated object, NULL on error.

 -- Function: void lw6nod_info_free (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to free

     Frees a node info object.

     *Return value:* none

 -- Function: int lw6nod_info_lock (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO)
     INFO: the node info to lock

     Locks a node info object, this is usefull for some members,
     typically list of servers, can be accessed by separated threads,
     one reading, many writing, and these objects (chained lists)
     certainly do not want to be modified while being read.

     *Return value:* 1 if ok, 0 if not.

 -- Function: int lw6nod_info_unlock (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to unlock

     Unlocks a node info object, this is the compation of the
     'lw6nod_info_lock' function.

     *Return value:* 1 if ok, 0 if not.

 -- Function: void lw6nod_info_idle (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to modify

     Clears a node info object and sets all its variable attributes to
     NULL/default values.  This is what we want when the node is idle,
     not playing.

     *Return value:* none.

 -- Function: int lw6nod_info_update (lw6sys_context_t * SYS_CONTEXT,
          lw6nod_info_t * INFO, u_int64_t COMMUNITY_ID, int ROUND, const
          char * LEVEL, int REQUIRED_BENCH, int NB_COLORS, int
          MAX_NB_COLORS, int NB_CURSORS, int MAX_NB_CURSORS, int
          NB_NODES, int MAX_NB_NODES, const char * PEER_ID_LIST, int
          GAME_SCREENSHOT_SIZE, void * GAME_SCREENSHOT_DATA)
     SYS_CONTEXT: global system context

     INFO: the node info to update

     COMMUNITY_ID: the id of the community the node belongs to

     ROUND: the current round (can have an offset with real round
     number)

     LEVEL: the name of the current level (map)

     REQUIRED_BENCH: the bench required to connect

     NB_COLORS: number of colors playing

     MAX_NB_COLORS: max number of colors allowed

     NB_CURSORS: number of cursors playing

     MAX_NB_CURSORS: max number of cursors allowed

     NB_NODES: number of nodes playing

     MAX_NB_NODES: max number of nodes allowed

     PEER_ID_LIST: list of peers ids, can be NULL

     GAME_SCREENSHOT_SIZE: size of screenshot (bytes)

     GAME_SCREENSHOT_DATA: screenshot data (byte buffer, contains JPEG)

     Set a node info object variable attributes.  Call this whenever the
     node has changed some parameter.  Not too often for it's not needed
     and some operations such as modying the screenshot, can be time
     consuming.

     *Return value:* 1 if OK, 0 if error.

 -- Function: lw6nod_dyn_info_t * lw6nod_info_dup_dyn (lw6sys_context_t
          * SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info containing the dyn info to duplicate

     Extracts the dynamic part of an info struct and duplicates it, this
     is to avoid protection fault error when concurrent threads access
     this info.

     *Return value:* newly allocated object, must be freed.

 -- Function: lw6sys_hash_t * lw6nod_info_new_discovered_nodes
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a new hash, to be used as a discovered nodes list.  Using
     this function has the advantage of setting the hash options to
     their defaults.  We use a hash to avoid having uselessly long lists
     containing always the same node due to multiple detections.

     *Return value:* an empty hash

 -- Function: int lw6nod_info_add_discovered_node (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, const char * PUBLIC_URL)
     SYS_CONTEXT: global system context

     INFO: the node info to update

     PUBLIC_URL: the address of the discovered node

     Registers a new server, and queues it as something that should be
     checked later because it's interesting.  We can't insert in the
     database all the servers we suspect to exist so network threads
     should use this, then main thread will process discovered servers
     afterwards.  This is also a good way to avoid trivial DOS attacks.

     *Return value:* 1 if OK, O if error.

 -- Function: lw6sys_list_t * lw6nod_info_pop_discovered_nodes
          (lw6sys_context_t * SYS_CONTEXT, lw6nod_info_t * INFO)
     SYS_CONTEXT: global system context

     INFO: the node info to query

     Returns a list of all discovered nodes (their public URL) and
     empties the current queue as well.

     *Return value:* a list of dynamically allocated strings.

 -- Function: lw6sys_list_t * lw6nod_info_new_verified_nodes
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a new list, to be filled with nodes and typically passed to
     'lw6nod_info_set_verified_nodes'.  Using this function has the
     advantage of setting the listh options to their defaults.

     *Return value:* an empty list

 -- Function: int lw6nod_info_set_verified_nodes (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, lw6sys_list_t * LIST)
     SYS_CONTEXT: global system context

     INFO: the node info to modify

     LIST: the list of verified nodes, will be freed by this function

     Sets the list of verified nodes, that is, the list of nodes we are
     sure to exist, this is typically the list we will display later on
     a web page.  We can't directly display any discovered node, one
     needs to filter them through main thread.  Something very important
     about this function is that 'list' will be freed by function, that
     is, if you call this, then you can (you should) forget your object,
     it will disappear any time soon.

     *Return value:* 1 if OK, 0 on error.

 -- Function: void lw6nod_info_map_verified_nodes (lw6sys_context_t *
          SYS_CONTEXT, lw6nod_info_t * INFO, lw6sys_list_callback_func_t
          FUNC, void * FUNC_DATA)
     SYS_CONTEXT: global system context

     INFO: the node info concerned

     FUNC: the function to apply

     FUNC_DATA: arbitrary pointer holding data to pass to function

     Calls 'lw6sys_hash_map' with 'func' on every member of the list of
     verified nodes.  The reason there's a function for this is that it
     is very important that list object is locked when doing this.  This
     function does perform a lock/unlock so it is safe.

     *Return value:* none.

 -- Function: int lw6nod_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libnod module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6nod_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'nod' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6nod_const_info_s

     Constant informations about a node, these are informations that do
     not vary through the node's life, so they are set object creation
     then left unchanged.

 -- Member of lw6nod_const_info_s: program
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::program'

     Program, this should be set to liquidwar6.

 -- Member of lw6nod_const_info_s: version
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::version'

     The version of the program.

 -- Member of lw6nod_const_info_s: codename
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::codename'

     The codename of the program.

 -- Member of lw6nod_const_info_s: stamp
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::stamp'

     The stamp of the program.

 -- Member of lw6nod_const_info_s: ref_info
     *Type:* 'lw6nod_ref_info_t'

     *Definition:* 'lw6nod_ref_info_t lw6nod_const_info_s::ref_info'

     Reference information, how to uniquely identify node.

 -- Member of lw6nod_const_info_s: title
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::title'

     The title of the node, its readable short name.

 -- Member of lw6nod_const_info_s: description
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::description'

     More details about the node.

 -- Member of lw6nod_const_info_s: has_password
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::has_password'

     Wether the node is password protected or not.

 -- Member of lw6nod_const_info_s: password
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_const_info_s::password'

     The password used, cleartext.

 -- Member of lw6nod_const_info_s: bench
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::bench'

     The node bench.

 -- Member of lw6nod_const_info_s: open_relay
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::open_relay'

     Wether the node acts as an open relay or not.

 -- Member of lw6nod_const_info_s: creation_timestamp
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6nod_const_info_s::creation_timestamp'

     The node creation timestamp.

 -- Member of lw6nod_const_info_s: idle_screenshot_size
     *Type:* 'int'

     *Definition:* 'int lw6nod_const_info_s::idle_screenshot_size'

     Size of the screenshot (in bytes) when in idle mode.

 -- Member of lw6nod_const_info_s: idle_screenshot_data
     *Type:* 'void *'

     *Definition:* 'void* lw6nod_const_info_s::idle_screenshot_data'

     Idle mode screenshot data.  This is just a plain JPEG buffer, which
     will be used as a fallback if there's no real screenshot available.

 -- Struct: lw6nod_dyn_info_s

     Dynamic informations about a node, these are informations that vary
     through the node's life, so they are unset at object creation and
     can then be updated from game context.

 -- Member of lw6nod_dyn_info_s: community_id_int
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6nod_dyn_info_s::community_id_int'

     The ID of the community this node belongs to, as a 64-bit unsigned
     integer.

 -- Member of lw6nod_dyn_info_s: community_id_str
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_dyn_info_s::community_id_str'

     The ID of the community this node belongs to, as a string (64-bit
     integer converted to hexa).

 -- Member of lw6nod_dyn_info_s: community_peers
     *Type:* 'lw6nod_ref_info_t'

     *Definition:* 'lw6nod_ref_info_t
     lw6nod_dyn_info_s::community_peers[LW6NOD_MAX_NB_PEERS]'

     The list of community members, you need to refer to the nb_nodes
     member to know quickly how many members they are but actually, in
     practice, there can be holes in this array, you need to check each
     slot, for instance 0 can be filled, 2 can be filled too, but 1 be
     empty.  Note that we don't count ourselves in this list.

 -- Member of lw6nod_dyn_info_s: round
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::round'

     The current round.

 -- Member of lw6nod_dyn_info_s: level
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_dyn_info_s::level'

     The current level.

 -- Member of lw6nod_dyn_info_s: required_bench
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::required_bench'

     The required bench to connect to this node.

 -- Member of lw6nod_dyn_info_s: nb_colors
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::nb_colors'

     Number of colors playing.

 -- Member of lw6nod_dyn_info_s: max_nb_colors
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::max_nb_colors'

     Maximum number of colors allowed to play.

 -- Member of lw6nod_dyn_info_s: nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::nb_cursors'

     Number of cursors playing.

 -- Member of lw6nod_dyn_info_s: max_nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::max_nb_cursors'

     Maximum number of cursors allowed to play.

 -- Member of lw6nod_dyn_info_s: nb_nodes
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::nb_nodes'

     Number of nodes playing.

 -- Member of lw6nod_dyn_info_s: max_nb_nodes
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::max_nb_nodes'

     Maximum number of nodes allowed to play.

 -- Member of lw6nod_dyn_info_s: game_screenshot_size
     *Type:* 'int'

     *Definition:* 'int lw6nod_dyn_info_s::game_screenshot_size'

     Size of the screenshot, in bytes.

 -- Member of lw6nod_dyn_info_s: game_screenshot_data
     *Type:* 'void *'

     *Definition:* 'void* lw6nod_dyn_info_s::game_screenshot_data'

     Game screenshot data.  This is just a plain JPEG buffer, which will
     be served when peers and/or web clients want to gather informations
     about the game.  This can be NULL, in that the fallback constant
     data will be used.

 -- Struct: lw6nod_info_s

     Informations about a node.  Note that in practice this structure is
     just used to describe our current node, there might be several
     instances of this if a program instanciates several nodes, but
     another data structure is used to store information about
     peers.typedef struct lw6nod_info_s

 -- Member of lw6nod_info_s: mutex
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6nod_info_s::mutex'

     Mutex used to access dynamic informations.

 -- Member of lw6nod_info_s: const_info
     *Type:* 'lw6nod_const_info_t'

     *Definition:* 'lw6nod_const_info_t lw6nod_info_s::const_info'

     Constant informations, never changes.

 -- Member of lw6nod_info_s: dyn_info
     *Type:* 'lw6nod_dyn_info_t'

     *Definition:* 'lw6nod_dyn_info_t lw6nod_info_s::dyn_info'

     Dynamic informations, can be updated.  Do not modify this directly,
     instead use appropriate functions which will use mutexes properly.

 -- Member of lw6nod_info_s: discovered_nodes
     *Type:* 'lw6sys_hash_t *'

     *Definition:* 'lw6sys_hash_t* lw6nod_info_s::discovered_nodes'

     List of discovered nodes, do not access this directly, instead use
     proper query functions which, in turn, will use mutexes properly.

 -- Member of lw6nod_info_s: verified_nodes
     *Type:* 'lw6sys_list_t *'

     *Definition:* 'lw6sys_list_t* lw6nod_info_s::verified_nodes'

     List of verified nodes, do not access this directly, instead use
     proper query functions which, in turn, will use mutexes properly.

 -- Struct: lw6nod_ref_info_s

     Reference information about a node, this is all you need to
     uniquely identify a node.  In theory, only the ID are only the URL
     are enough, in practice it's not that bad to have some redundancy,
     plus it makes it easier and faster to connect to them and transmit
     informations.

 -- Member of lw6nod_ref_info_s: id_int
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6nod_ref_info_s::id_int'

     The id of the node, as an integer (64-bit unsigned).

 -- Member of lw6nod_ref_info_s: id_str
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_ref_info_s::id_str'

     The id of the node, as a string (64-bit converted to hexa).

 -- Member of lw6nod_ref_info_s: url
     *Type:* 'char *'

     *Definition:* 'char* lw6nod_ref_info_s::url'

     The public URL of the node.

5.36 libp2p
===========

5.36.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/p2p/index.html>.

5.36.2 API
----------

 -- Function: lw6p2p_db_t * lw6p2p_db_open (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          NAME)
     SYS_CONTEXT: global system context

     ARGC: number of args, as passed to 'main'

     ARGV: args array, as passed to 'main'

     NAME: the database name

     Creates a new database object.  Normally there's only one object
     like this at a given time, it can be shared among various nodes.
     The database name is appended to user directory path, this allows
     different databases to be created, in theory.

     *Return value:* a pointer on the newly created object.

 -- Function: void lw6p2p_db_close (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_db_t * DB)
     SYS_CONTEXT: global system context

     DB: the db to close

     Closes a db object, memory ressources will be freed.

     *Return value:* none.

 -- Function: char * lw6p2p_db_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6p2p_db_t * DB)
     SYS_CONTEXT: global system context

     DB: the db to work on

     Gives a readable representation of the db

     *Return value:* a dynamically allocated string

 -- Function: int lw6p2p_db_reset (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV, const char * NAME)
     SYS_CONTEXT: global system context

     ARGC: number of args, as passed to 'main'

     ARGV: args array, as passed to 'main'

     NAME: the database name

     Clears the database.  Simply removes the db file, in fact.  Do not
     call while database is used...

     *Return value:* 1 on success, 0 if failed.

 -- Function: char * lw6p2p_db_default_name (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default database name, should be p2p.db (this is a
     relative path, not an absolute path, will be appended to user dir).

     *Return value:* the default database name, need not (must not) be
     freed.

 -- Function: int _lw6p2p_db_timestamp (lw6sys_context_t * SYS_CONTEXT,
          _lw6p2p_db_t * DB, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     DB: the db object concerned (used to calculate time origin)

     TIMESTAMP: the timestamp as returned by lw6sys_get_timestamp

     Returns a timestamp suitable for db usage (seconds since object
     creation), set to the timestamp passed as an argument
     (milliseconds).  The reason we don't use regular timestamps is that
     they are 1) too accurate (msec is useless for what's involved here)
     and 2) too big and likely to be negative in signed mode even if
     converted to seconds.

     *Return value:* a timestamp, 0 means "beginning of program" (think
     of it as uptime)

 -- Function: int _lw6p2p_db_now (lw6sys_context_t * SYS_CONTEXT,
          _lw6p2p_db_t * DB)
     SYS_CONTEXT: global system context

     DB: the db object concerned (used to calculate time origin)

     Returns a timestamp suitable for db usage, (seconds since object
     creation) set to the current moment.  The reason we don't use
     regular timestamps is that they are 1) too accurate (msec is
     useless for what's involved here) and 2) too big and likely to be
     negative in signed mode even if converted to seconds.

     *Return value:* a timestamp, 0 means "beginning of program" (think
     of it as uptime)

 -- Function: lw6p2p_entry_t * lw6p2p_entry_new (lw6sys_context_t *
          SYS_CONTEXT, int CREATION_TIMESTAMP, char * VERSION, char *
          CODENAME, int STAMP, char * ID, char * URL, char * TITLE, char
          * DESCRIPTION, int HAS_PASSWORD, int BENCH, int OPEN_RELAY,
          char * COMMUNITY_ID, int ROUND, char * LEVEL, int
          REQUIRED_BENCH, int NB_COLORS, int MAX_NB_COLORS, int
          NB_CURSORS, int MAX_NB_CURSORS, int NB_NODES, int
          MAX_NB_NODES, char * IP, int PORT, int LAST_PING_TIMESTAMP,
          int PING_DELAY_MSEC, int AVAILABLE)
     SYS_CONTEXT: global system context

     CREATION_TIMESTAMP: when it has been created, UNIX timestamp

     VERSION: version of the node

     CODENAME: codename of the node

     STAMP: stamp of the node

     ID: id of the node (string representation)

     URL: public url of the node

     TITLE: title of the node

     DESCRIPTION: description of the node

     HAS_PASSWORD: wether node is password protected or not

     BENCH: node bench

     OPEN_RELAY: wether the node is in open relay mode or not

     ROUND: current round

     LEVEL: current level played

     REQUIRED_BENCH: current bench

     NB_COLORS: number of colors playing

     MAX_NB_COLORS: maximum number of colors

     NB_CURSORS: number of cursors playing

     MAX_NB_CURSORS: maximum number of cursors

     NB_NODES: number of nodes playing

     MAX_NB_NODES: maximum number of nodes

     IP: node ip (string representation)

     PORT: node port

     LAST_PING_TIMESTAMP: UNIX timestamp of last contact with node

     PING_DELAY_MSEC: ping delay, in milliseconds

     AVAILABLE: wether node is available, wether we can connect to it

     Creates a new p2p entry.  Will accept NULL parameters for strings
     as well as arbitrary long strings, will simply cut them short if
     there aren't already limited to max size.

     *Return value:* newly allocated object

 -- Function: void lw6p2p_entry_free (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_entry_t * ENTRY)
     SYS_CONTEXT: global system context

     ENTRY: entry to free

     Frees a p2p entry.

     *Return value:* none.

 -- Function: char * lw6p2p_entry_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6p2p_entry_t * ENTRY)
     SYS_CONTEXT: global system context

     ENTRY: entry to represent

     Gives a human-readable representation of the entry

     *Return value:* dynamically allocated string

 -- Function: lw6p2p_node_t * lw6p2p_node_new (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, lw6p2p_db_t * DB,
          char * CLIENT_BACKENDS, char * SERVER_BACKENDS, char *
          BIND_IP, int BIND_PORT, int BROADCAST, u_int64_t NODE_ID, char
          * PUBLIC_URL, char * TITLE, char * DESCRIPTION, char *
          PASSWORD, int BENCH, int OPEN_RELAY, char * KNOWN_NODES, int
          NETWORK_RELIABILITY, int TROJAN)
     SYS_CONTEXT: global system context

     ARGC: number of args, as passed to 'main'

     ARGV: args array, as passed to 'main'

     DB: the database to use

     CLIENT_BACKENDS: the list of client backends to use

     SERVER_BACKENDS: the list of server backends to use

     BIND_IP: the IP address to bind on

     BIND_PORT: the IP port to listen on

     BROADCAST: wether broadcast is allowed on this node

     NODE_ID: the node id

     PUBLIC_URL: the public URL we want to show

     TITLE: the title of the node

     DESCRIPTION: the description of the node

     PASSWORD: the password to use

     BENCH: the bench of the node (its power)

     OPEN_RELAY: act as an open relay or not

     KNOWN_NODES: list of already known nodes

     NETWORK_RELIABILITY: drop 1 packet out of X

     TROJAN: act as a stupid trojan to test out automatic kick-off

     Creates a new "pear to pear" node.  This will fire the server and
     allow client access, on demand.  A lot of stuff can be done in the
     background once this is called.

     *Return value:* a pointer on the newly created objects.

 -- Function: void lw6p2p_node_free (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the node to free

     Frees a node object, all network communications will be shut.

     *Return value:* none.

 -- Function: char * lw6p2p_node_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the node to work on

     Gives a readable representation of the node

     *Return value:* a dynamically allocated string

 -- Function: int lw6p2p_node_poll (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_node_t * NODE, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     NODE: the node to poll

     PROGRESS: progress indicator to show the advancement

     Polls a p2p node.  This must be called on a regular basis, else
     network communication is stalled.

     *Return value:* 1 on success, 0 on error.

 -- Function: void lw6p2p_node_close (lw6sys_context_t * SYS_CONTEXT,
          lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the node to close

     Closes a p2p node.  Closing is necessary in some contexts, for
     instance scheme/smob instanciation when you want to release the
     object ressources (sockets, ports, threads...)  *before* it is
     deleted by, for instance, a garbage collector.

     *Return value:* 1 on success, 0 on error.

 -- Function: u_int64_t lw6p2p_node_get_id (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the node to query

     Returns the node id, an id which is supposed to uniquely identify
     the node at run-time.

     *Return value:* numerical id.

 -- Function: lw6sys_list_t * lw6p2p_node_get_entries (lw6sys_context_t
          * SYS_CONTEXT, lw6p2p_node_t * NODE, int SKIP_LOCAL)
     SYS_CONTEXT: global system context

     NODE: node to query

     SKIP_LOCAL: wether to skip local node, 1 to skip, 0 to keep

     Returns a list of all known nodes, this is a plain table dump,
     sorted so that the most likely to be interesting to connect oneself
     to are listed *last*, this is just a (little) optimization, since
     we know we'll need to parse this list to construct a Guile object,
     we reverse the order.

     *Return value:* list object containing 'lw6p2p_entry_t' objects

 -- Function: int lw6p2p_node_server_start (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, int64_t SEQ_0)
     SYS_CONTEXT: global system context

     NODE: node to start

     SEQ_0: seq when starting the server

     Starts a node in server mode, if node was previously connected to
     other nodes, disconnect it from any peer.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6p2p_node_client_join (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, u_int64_t REMOTE_ID, const
          char * REMOTE_URL, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     NODE: node to use

     REMOTE_ID: id of remote node to join

     REMOTE_URL: url of remote node to join

     PROGRESS: progress indicator to show end-user the advancement of
     process

     Starts a node in client mode, joins the given node, if node was
     previously connected to other nodes, disconnect it from any peer.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6p2p_node_refresh_peer (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, u_int64_t REMOTE_ID, const
          char * REMOTE_URL)
     SYS_CONTEXT: global system context

     NODE: node to use

     REMOTE_ID: id of remote node to refresh

     REMOTE_URL: url of remote node to refresh

     Forces a refresh of a remote node, that is, try and get more
     up-to-date informations from it, not waiting for the standard
     update schedule.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6p2p_node_disconnect (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: node to disconnect

     Disconnects a node, if node was previously connected to other
     nodes, disconnect it from any peer.  Note that this does not affect
     out-of-band connections, only real game-related links.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6p2p_node_update_info (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, int ROUND, const char *
          LEVEL, int NB_COLORS, int MAX_NB_COLORS, int NB_CURSORS, int
          MAX_NB_CURSORS, int NB_NODES, int MAX_NB_NODES, int
          GAME_SCREENSHOT_SIZE, void * GAME_SCREENSHOT_DATA)
     SYS_CONTEXT: global system context

     NODE: node to update

     ROUND: the current round (can have an offset with real round
     number)

     LEVEL: the name of the current level (map)

     NB_COLORS: number of colors playing

     MAX_NB_COLORS: max number of colors allowed

     NB_CURSORS: number of cursors playing

     MAX_NB_CURSORS: max number of cursors allowed

     NB_NODES: number of nodes playing

     MAX_NB_NODES: max number of nodes allowed

     GAME_SCREENSHOT_SIZE: size of screenshot (bytes)

     GAME_SCREENSHOT_DATA: screenshot data (byte buffer, contains JPEG)

     Updates node info, that is, all the data/metadata which can be
     displayed to other peers and are, by nature, dynamic.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6p2p_node_calibrate (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, int64_t TIMESTAMP, int64_t
          SEQ)
     SYS_CONTEXT: global system context

     NODE: the object to calibrate

     TIMESTAMP: the current ticks setting (1000 ticks per second)

     SEQ: the round expected to be returned with this ticks value

     Calibrates the node, so that sequence numbering is consistent
     accross nodes.

     *Return value:* none.

 -- Function: int64_t lw6p2p_node_get_local_seq_0 (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the reference local seq_0 for this node, the information is
     taken from the warehouse, even if node->calibrate_seq should
     probably return the same value.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_local_seq_last (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the local seq_last for this node, the information is taken
     from the warehouse, which has parsed the messages and this
     information can in return be used to avoid maintaining outside of
     the node the information about what was the last seq used for a
     local message.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_seq_min (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the minimum seq registered, not of utmost importance but
     interesting for debugging purpose, to check what's in the
     warehouse.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_seq_max (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the maximum seq registered, this is typically used for
     guessing which seq might make sense for this node, but in a real
     example one should rely on algorithm/ker-side kept values.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_seq_draft (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the seq of the current draft as the warehouse understands it.
     Note that it's the responsibility of the caller to update the pilot
     according to this, this information is just about what is in the
     warehouse, not necessarly what is in the pilot / game_state.

     *Return value:* the seq.

 -- Function: int64_t lw6p2p_node_get_seq_reference (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: the object to query

     Gets the seq of the current reference as the warehouse understands
     it.  Note that it's the responsibility of the caller to update the
     pilot according to this, this information is just about what is in
     the warehouse, not necessarly what is in the pilot / game_state.

     *Return value:* the seq.

 -- Function: int lw6p2p_node_is_peer_connected (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, u_int64_t PEER_ID)
     SYS_CONTEXT: global system context

     NODE: the object to query

     PEER_ID: id of the peer we want to check

     Tests wether the node is connected to us.  This is a different
     question from being registered, being connected means there's a
     tentacle connected to the peer, but it does not necessarly means
     this peer actively takes part in the game.

     *Return value:* 1 if connected, 0 if not.

 -- Function: int lw6p2p_node_is_peer_registered (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, u_int64_t PEER_ID)
     SYS_CONTEXT: global system context

     NODE: the object to query

     PEER_ID: id of the peer we want to check

     Tests wether the node is registered within the warehouse.  This is
     a different question from being connected, being registered means
     we received a message (possibly from another peer) that means "this
     peer is part of the game" regardless of the fact it's connected or
     not.  Returns true if test is performed with the local id.

     *Return value:* 1 if registered, 0 if not.

 -- Function: int lw6p2p_node_is_seed_needed (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: node to query

     Returns true (1) if the local node needs to send a SEED message.  A
     SEED message will basically be sent at the beginning of a session
     when a client connects to a server.  Basically this message is of
     no use but it's interesting to have a short message (not DUMP) to
     start with.

     *Return value:* 1 if SEED must be sent.

 -- Function: int lw6p2p_node_is_dump_needed (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE)
     SYS_CONTEXT: global system context

     NODE: node to query

     Returns true (1) if the local node needs to send a DUMP message.  A
     DUMP message will basically reset level, game struct, game state,
     it's typically sent when a new player is connected.  This function
     will return true once then always 0 so one should really act and do
     something whenever it's called and returns 1.

     *Return value:* 1 if DUMP must be sent.

 -- Function: int lw6p2p_node_put_local_msg (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, const char * MSG)
     SYS_CONTEXT: global system context

     NODE: node object to use

     MSG: message

     Puts a message in the object.  The message will be splitted into
     several atoms if needed, it can be arbitrary long.

     *Return value:* 1 on success, 0 on error

 -- Function: char * lw6p2p_node_get_next_reference_msg
          (lw6sys_context_t * SYS_CONTEXT, lw6p2p_node_t * NODE,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     NODE: node to query

     PROGRESS: progress indicator (read/write)

     Get the next waiting reference msg.  This is used to maintain the
     stable reference game state we can rely upon.  One is supposed to
     call this until it returns NULL, then switch draft messages.

     *Return value:* newly allocated string, must be freed.

 -- Function: char * lw6p2p_node_get_next_draft_msg (lw6sys_context_t *
          SYS_CONTEXT, lw6p2p_node_t * NODE, lw6sys_progress_t *
          PROGRESS)
     SYS_CONTEXT: global system context

     NODE: node to query

     PROGRESS: progress indicator (read/write)

     Get the next waiting draft msg.  This is used to maintain the
     anticipated draft game state we use for drawing.  One is supposed
     to call this after all reference messages have been treated.

     *Return value:* newly allocated string, must be freed.

 -- Function: int lw6p2p_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libp2p module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6p2p_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'p2p' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6p2p_db_s

     Handler on a database connection, this must be used to pass order
     to store/retrieve persistent informations about peers.

 -- Member of lw6p2p_db_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6p2p_db_s::id'

     The first member, id, is the same as the internal _lw6p2p_db_t
     structure.  The rest of it is hidden.  The program will cast from
     lw6p2p_db_t to _lw6p2p_db_t internally.

 -- Struct: lw6p2p_entry_s

     This entry object matches as close as possible the corresponding
     (node) entry in the database.

 -- Member of lw6p2p_entry_s: creation_timestamp
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::creation_timestamp'

     Node creation timestamp.

 -- Member of lw6p2p_entry_s: version
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::version[LW6P2P_VERSION_SIZE+1]'

     Node version.

 -- Member of lw6p2p_entry_s: codename
     *Type:* 'char'

     *Definition:* 'char
     lw6p2p_entry_s::codename[LW6P2P_CODENAME_SIZE+1]'

     Node codename.

 -- Member of lw6p2p_entry_s: stamp
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::stamp'

     Node stamp.

 -- Member of lw6p2p_entry_s: id
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::id[LW6P2P_ID_SIZE+1]'

     Node id, 64-bit integer as an hexa string.

 -- Member of lw6p2p_entry_s: url
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::url[LW6P2P_URL_SIZE+1]'

     Node URL, the public URL it displays to others.

 -- Member of lw6p2p_entry_s: title
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::title[LW6P2P_TITLE_SIZE+1]'

     Node title, the short readable name for the node.

 -- Member of lw6p2p_entry_s: description
     *Type:* 'char'

     *Definition:* 'char
     lw6p2p_entry_s::description[LW6P2P_DESCRIPTION_SIZE+1]'

     Node description, mode details about this node.

 -- Member of lw6p2p_entry_s: has_password
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::has_password'

     Wether it requires a password or not.

 -- Member of lw6p2p_entry_s: bench
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::bench'

     Node bench, reflects how powerfull it is.

 -- Member of lw6p2p_entry_s: open_relay
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::open_relay'

     Wether this node acts as an open relay or not.

 -- Member of lw6p2p_entry_s: community_id
     *Type:* 'char'

     *Definition:* 'char
     lw6p2p_entry_s::community_id[LW6P2P_COMMUNITY_ID_SIZE+1]'

     Community id, 64-bit integer as an hexa string.

 -- Member of lw6p2p_entry_s: round
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::round'

     Current round.

 -- Member of lw6p2p_entry_s: level
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::level[LW6P2P_LEVEL_SIZE+1]'

     Level used.

 -- Member of lw6p2p_entry_s: required_bench
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::required_bench'

     Required bench to connect to this community.

 -- Member of lw6p2p_entry_s: nb_colors
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::nb_colors'

     Number of colors playing.

 -- Member of lw6p2p_entry_s: max_nb_colors
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::max_nb_colors'

     Maximum number of colors allowed to play.

 -- Member of lw6p2p_entry_s: nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::nb_cursors'

     Number of cursors playing.

 -- Member of lw6p2p_entry_s: max_nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::max_nb_cursors'

     Maximum number of cursors allowed to play.

 -- Member of lw6p2p_entry_s: nb_nodes
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::nb_nodes'

     Number of nodes playing.

 -- Member of lw6p2p_entry_s: max_nb_nodes
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::max_nb_nodes'

     Maximum number of nodes playing.

 -- Member of lw6p2p_entry_s: ip
     *Type:* 'char'

     *Definition:* 'char lw6p2p_entry_s::ip[LW6P2P_IP_SIZE+1]'

     IP addess of node.

 -- Member of lw6p2p_entry_s: port
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::port'

     IP port of node.

 -- Member of lw6p2p_entry_s: last_ping_timestamp
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::last_ping_timestamp'

     Last time this node has been pinged.

 -- Member of lw6p2p_entry_s: ping_delay_msec
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::ping_delay_msec'

     Ping delay, in milliseconds.

 -- Member of lw6p2p_entry_s: available
     *Type:* 'int'

     *Definition:* 'int lw6p2p_entry_s::available'

     Wether this node is ready to accept connections.

 -- Struct: lw6p2p_node_s

     Node object, the main network object, this one will encaspulate
     everything else, the node can connect to other peers, listen on the
     network, it's the high-level interface.

 -- Member of lw6p2p_node_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6p2p_node_s::id'

     The first member, id, is the same as the internal _lw6p2p_node_t
     structure.  The rest of it is hidden.  The program will cast from
     lw6p2p_node_t to _lw6p2p_node_t internally.

5.37 libpil
===========

5.37.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/pil/index.html>.

5.37.2 API
----------

 -- Function: int lw6pil_bench (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV, float * BENCH_RESULT,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: args passed to main

     BENCH_RESULT: pointer to float, will contain the bench result

     PROGRESS: to inform the caller of the process advancement

     Runs a standard, normalized bench on a default map.  Results can be
     interpreted as an estimated speed/power of your computer.

     *Return value:* 1 on success, 0 if failure

 -- Function: lw6pil_command_t * lw6pil_command_new (lw6sys_context_t *
          SYS_CONTEXT, const char * COMMAND_TEXT, int64_t SEQ_0, int
          ROUND_0)
     SYS_CONTEXT: global system context

     COMMAND_TEXT: readable text of the command

     SEQ_0: sequence offset reference (to calculate difference between
     sequence and rounds)

     ROUND_0: round offset reference (to calculate difference between
     sequence and rounds)

     Creates a new command from its text representation.

     *Return value:* newly allocated object

 -- Function: lw6pil_command_t * lw6pil_command_dup (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     COMMAND: object to duplicate

     Creates a copy of a command struct.

     *Return value:* newly allocated object.

 -- Function: void lw6pil_command_free (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     COMMAND: command to free

     Frees a command struct, with all its members.

     *Return value:* none.

 -- Function: char * lw6pil_command_repr (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     COMMAND: command to represent

     Gives a readable representation of a command.

     *Return value:* dynamically allocated string.

 -- Function: int lw6pil_command_execute (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_dump_t * DUMP, int64_t TIMESTAMP,
          lw6ker_game_state_t * GAME_STATE, lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     DUMP: pointer on dump structure (out param, can be NULL)

     TIMESTAMP: current timestamp (can be 0 if dump is NULL)

     GAME_STATE: game state to work on, can be NULL (usefull for DUMP)

     COMMAND: command to process

     Interprets a command and runs it against game_state.  If dump and
     timestamp are set, then any DUMP command will fill the dump
     structure with the right values.  If not running from a pilot
     context, this is useless, use NULL and 0LL.

     *Return value:* 1 if ok, 0 if failed.

 -- Function: int lw6pil_command_execute_text (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_dump_t * DUMP, int64_t TIMESTAMP,
          lw6ker_game_state_t * GAME_STATE, const char * COMMAND_TEXT,
          int64_t SEQ_0)
     SYS_CONTEXT: global system context

     DUMP: pointer on dump structure (out param, can be NULL)

     TIMESTAMP: current timestamp (can be 0 if dump is NULL)

     GAME_STATE: game state to work on, can be NULL (typically for DUMP)

     COMMAND_TEXT: command text to process

     SEQ_0: reference seq_0, used to genereate consistent dumps if
     needed

     Interprets a command text and runs it against game_state.  If dump
     and timestamp are set, then any DUMP command will fill the dump
     structure with the right values.  If not running from a pilot
     context, this is useless, use NULL and 0LL.

     *Return value:* 1 if ok, 0 if failed.

 -- Function: int lw6pil_command_execute_local (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS,
          lw6pil_command_t * COMMAND)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: local cursors information

     COMMAND: command to execute

     Executes a local command, typically a cursor move, on the
     local_cursor struct, without changing any game state.

     *Return value:* 1 if success, 0 if failure.

 -- Function: int lw6pil_command_execute_local_text (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, const
          char * COMMAND_TEXT)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: local cursors information

     COMMAND_TEXT: command text to execute

     Executes a local command text, typically a cursor move, on the
     local_cursor struct, without changing any game state.

     *Return value:* 1 if success, 0 if failure.

 -- Function: void lw6pil_coords_fix (lw6sys_context_t * SYS_CONTEXT,
          lw6map_rules_t * RULES, lw6sys_whd_t * SHAPE, float * X, float
          * Y, float * Z)
     SYS_CONTEXT: global system context

     RULES: the set of rules to use (defines polarity)

     SHAPE: the shape of the map (logical part)

     X: the x coord to fix

     Y: the y coord to fix

     Z: the z coord to fix

     Similar to 'lw6map_coords_fix' but using floats, this function can
     be used to check cursor position boundaries.  Any float pointer can
     be NULL.

     *Return value:* none.

 -- Function: void lw6pil_coords_fix_x10 (lw6sys_context_t *
          SYS_CONTEXT, lw6map_rules_t * RULES, lw6sys_whd_t * SHAPE,
          float * X, float * Y, float * Z)
     SYS_CONTEXT: global system context

     RULES: the set of rules to use (defines polarity)

     SHAPE: the shape of the map (logical part)

     X: the x coord to fix

     Y: the y coord to fix

     Z: the z coord to fix

     Similar to 'lw6pil_coords_fix' but does use a wider range, say 10
     times the actual size of the map, this is not to contain the cursor
     within the map but just to avoid overflow errors.

     *Return value:* none.

 -- Function: void lw6pil_dump_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_dump_t * DUMP)
     SYS_CONTEXT: global system context

     DUMP: object to initialize

     Fills a dump object with zero, regardless of what was there before.

     *Return value:* none.

 -- Function: void lw6pil_dump_clear (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_dump_t * DUMP)
     SYS_CONTEXT: global system context

     DUMP: object to clear

     Clears a dump object, that is, frees all existing object if they
     are here, and sets pointers to NULL.

     *Return value:* none.

 -- Function: int lw6pil_dump_exists (lw6sys_context_t * SYS_CONTEXT,
          const lw6pil_dump_t * DUMP)
     SYS_CONTEXT: global system context

     DUMP: object to test

     Tests wether there's actually a dump in the structure, or if it's
     empty.

     *Return value:* 1 if there's a dump, 0 if all fields set to NULL.

 -- Function: char * lw6pil_dump_command_generate (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, u_int64_t SERVER_ID,
          int64_t SEQ)
     SYS_CONTEXT: global system context

     PILOT: the pilot to transform as a DUMP.

     SERVER_ID: ID of server issuing the command

     SEQ: seq at which the dump should be generated

     Creates the DUMP command for a given pilot, that is, a command that
     describes the whole data and state.  One must give a sequence
     number since the dump would otherwise typically be *always* late by
     at least one round (or seq).  We give the seq as we would for any
     message generated, to make it fit well within the standard message
     queue.

     *Return value:* newly allocated string

 -- Function: int lw6pil_dump_command_execute (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_dump_t * DUMP, int64_t TIMESTAMP,
          lw6pil_command_t * COMMAND, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     DUMP: will contain the dump data, pilot and game state, struct, and
     level

     TIMESTAMP: current timestamp

     COMMAND: the command to execute

     PROGRESS: progress object to show the advancement of process

     Interprets a DUMP command.  A new pilot will be returned, along
     with game state, game struct and level.  Old objects won't be
     deleted, but you could (should) get rid of them at they are useless
     now.

     *Return value:* newly allocated string

 -- Function: void lw6pil_local_cursors_reset (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to reset

     Resets a local cursors struct.  Note that this need not be called
     very often, in fact the local cursors can cope with "dead" cursors
     easily.  In practise, in a local game, there are only 4 of them,
     great maximum.

     *Return value:* none.

 -- Function: lw6pil_local_cursor_t * lw6pil_local_cursors_get_cursor
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_local_cursors_t *
          LOCAL_CURSORS, u_int16_t CURSOR_ID)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to query

     CURSOR_ID: the id of the cursor to query

     Returns a pointer on the cursor with the given id.

     *Return value:* a pointer (must *not* be freed) which is NULL is
     cursor does not exist.

 -- Function: int lw6pil_local_cursors_get_info (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, int * X,
          int * Y, int * MOUSE_CONTROLLED, u_int16_t CURSOR_ID)
     LOCAL_CURSORS: the structure to query

     X: a pointer to the x position, may be NULL

     Y: a pointer to the y position, may be NULL

     MOUSE_CONTROLLED: a pointer to the mouse_controlled flag, may be
     NULL

     CURSOR_ID: the id of the cursor to query

     Gets the x,y position of the cursor, and tells if it's mouse
     controlled.

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_local_cursors_set_xy (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t
          CURSOR_ID, int X, int Y)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to modify

     CURSOR_ID: the id of the cursor to modify

     X: the x position

     Y: the y position

     Sets the position of a cursor in the local cursors struct.  If
     cursor does not exists, it's appended to the list.

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_local_cursors_set_mouse_controlled
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_local_cursors_t *
          LOCAL_CURSORS, u_int16_t CURSOR_ID, int MOUSE_CONTROLLED)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to modify

     CURSOR_ID: the id of the cursor to modify

     MOUSE_CONTROLLED: the mouse_controlled attribute

     Sets which cursor is mouse controlled.  If mouse_controlled is 1,
     the flag is set for this cursor and cleared for all others.  If set
     to 0, only this cursor's flag is cleared.

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_local_cursors_get_main_info (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t
          * CURSOR_ID, int * X, int * Y, int * MOUSE_CONTROLLED)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to query

     CURSOR_ID: the id of the main cursor, may be NULL

     X: a pointer to the x position, may be NULL

     Y: a pointer to the y position, may be NULL

     MOUSE_CONTROLLED: a pointer to the mouse_controlled flag, may be
     NULL

     Gets the x,y position of the main cursor, and tells if it's mouse
     controlled.

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_local_cursors_set_main (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t
          CURSOR_ID)
     SYS_CONTEXT: global system context

     LOCAL_CURSORS: the structure to modify

     CURSOR_ID: the id of the cursor to be labelled as main cursor

     Sets the main cursor attribute, the main cursor is later used, for
     instance, to decide how to display the map (centered on it, for
     instance).

     *Return value:* 1 on success (cursor exists), 0 on failure (no such
     cursor).

 -- Function: int lw6pil_nopilot_poll_dump (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_dump_t * DUMP, const char * COMMAND_TEXT,
          int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     DUMP: will contain the dump information if needed, can be NULL

     COMMAND_TEXT: the command received from the network.

     TIMESTAMP: timestamp, used to initialize the pilot

     Normally, it's the commit function of the pilot which will
     automatically return a dump if needed.  But...  when a client
     connects, at first, it has absolutely no pilot/map whatsoever yet,
     so this is just to bootstrap the process, this function will take
     network messages, any message, and if it's about a dump -> it will
     create the dump.

     *Return value:* 1 on success, 0 on failure.

 -- Function: lw6pil_pilot_t * lw6pil_pilot_new (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE, int64_t SEQ_0,
          int64_t TIMESTAMP, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     GAME_STATE: the game state we're going to work on

     SEQ_0: the start sequence to use, that is, the seq at round=0

     TIMESTAMP: the current ticks (1000 ticks per sec, used to
     calibrate)

     PROGRESS: object used to show the advancement of the process

     Initializes a 'pilot' object, this object is responsible for
     interpreting messages, transform them into low-level 'ker' module
     function calls, and handle all the thread-spooky stuff.

     *Return value:* a working pilot object.  May be NULL on memory
     failure.

 -- Function: void lw6pil_pilot_free (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to free.

     Frees a 'pilot' object, note that this might involve joining some
     threads, so it can 'take some time'.

     *Return value:* none.

 -- Function: int lw6pil_pilot_send_command (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, const char *
          COMMAND_TEXT, int VERIFIED)
     SYS_CONTEXT: global system context

     PILOT: the object to send commands to.

     COMMAND_TEXT: the text of the command, as received form network

     VERIFIED: wether we're sure this message is valid.

     Sends a command and handles it internally.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_local_command (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, const char *
          COMMAND_TEXT)
     SYS_CONTEXT: global system context

     PILOT: the object to apply the local command on

     COMMAND_TEXT: the command text

     This function is used to fix the annoying fact that by only sending
     commands a limited number of times per sec to the game state, the
     display always reflect an outdated position for cursors.  But
     players do not want to see this, they want to see the cursor in the
     right place.  So what we do is that the pilot can process "local"
     commands which have absolutely no effect on the game but simply
     update a local cursor state, only used for display.  It's here in
     the pil module for it's where the command interpreting code is, and
     the fact that there's this lag is directly linked with the pilot
     way of doing things.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6pil_pilot_commit (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_dump_t * DUMP, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     DUMP: will contain the dump information if needed, can be NULL

     PILOT: the object to commit.

     Commits all commands sent and actually send them to the
     corresponding threads.  This commit system allows better
     performance by sending, for instance, all the commands for a given
     round together.

     *Return value:* none.

 -- Function: int lw6pil_pilot_make_backup (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to perform the backup on

     Makes a new backup in the pilot, that is, copy 'reference' to
     'backup'.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_can_sync (lw6sys_context_t * SYS_CONTEXT,
          lw6ker_game_state_t * TARGET, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     TARGET: the target game_state we would sync on

     PILOT: the object to perform the backup on

     Tests wether sync functions are callable with a given game state.
     It verifies if the internal game_state and the target look the
     same.

     *Return value:* 1 if sync functions can be called, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_backup (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * TARGET, lw6pil_pilot_t *
          PILOT)
     SYS_CONTEXT: global system context

     TARGET: the game_state structure which will get the informations.

     PILOT: the object to get informations from.

     Gets the backup from the pilot object.  This is the last snapshot
     taken by 'make_backup' or, by default, the game_state the pilot was
     constructed with.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_reference (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * TARGET, lw6pil_pilot_t *
          PILOT)
     SYS_CONTEXT: global system context

     TARGET: the game_state structure which will get the informations.

     PILOT: the object to get informations from.

     Gets the latest reference game_state, that is, a stable snapshot of
     the game, with no inconsistency, a game position that exists and
     that we can rely on.  Note that getting this can take time since a
     global mutex is required, and computations must end before you get
     the data.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_draft (lw6sys_context_t *
          SYS_CONTEXT, lw6ker_game_state_t * TARGET, lw6pil_pilot_t *
          PILOT, int DIRTY_READ)
     SYS_CONTEXT: global system context

     TARGET: the game_state structure which will get the informations.

     PILOT: the object to get informations from.

     DIRTY_READ: wether to allow dirty read or not

     Gets the informations from the pilot object, not being worried
     about game consistency, this one will just return the latest
     version available.  It might even be in an inconsistent state, the
     position could reflect a position which will never exist.  Still,
     the data returned will not correspond to a half-spread or
     half-moved game_state if dirty_read is set to 0.  In this case the
     data has at least some basic consistency and getting this does
     require some mutex lock, however wait time should be fairly small
     (max.  a round).  But, in a general manner, this function is only
     used for display, and we do not care much if there's a small
     glitch, we prefer fast & smooth display.

     *Return value:* 1 if OK, 0 if not.

 -- Function: lw6ker_game_state_t * lw6pil_pilot_dirty_read
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to get informations from.

     Returns a direct access to the most up-to-date game_state, without
     locking anything whatsoever.  This is clearly to implement a dirty
     read mode as the name of the function suggests.

     *Return value:* 1 if OK, 0 if not.

 -- Function: char * lw6pil_pilot_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     Returns a string describing the pilot.  This is a very short
     description, use it for logs, and to debug stuff.  By no means it's
     a complete exhaustive description.  Still, the string returned
     should be unique.

     *Return value:* a dynamically allocated string.

 -- Function: void lw6pil_pilot_calibrate (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, int64_t TIMESTAMP,
          int64_t SEQ)
     SYS_CONTEXT: global system context

     PILOT: the object to calibrate

     TIMESTAMP: the current ticks setting (1000 ticks per second)

     SEQ: the round expected to be returned with this ticks value

     Calibrates the pilot, that is, initializes it so that subsequent
     calls to 'lw6pil_pilot_get_round' return consistent values.

     *Return value:* none.

 -- Function: void lw6pil_pilot_speed_up (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, int SEQ_INC)
     SYS_CONTEXT: global system context

     PILOT: the pilot to speed up

     SEQ_INC: the number of seqs

     Re-calibrates the pilot so that it speeds up a bit.  This will
     basically increase next_seq by seq_inc.

     *Return value:* none.

 -- Function: void lw6pil_pilot_slow_down (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, int SEQ_DEC)
     SYS_CONTEXT: global system context

     PILOT: the pilot to speed up

     SEQ_DEC: the number of seqs

     Re-calibrates the pilot so that it slows down a bit.  This will
     basically decrease next_seq by seq_inc.

     *Return value:* none.

 -- Function: int lw6pil_pilot_get_round_0 (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: pilot object to query

     Get the initial round (the one passed at object construction) which
     says what the round was at object creation, it's just an offset.

     *Return value:* 64-bit integer

 -- Function: int64_t lw6pil_pilot_get_seq_0 (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: pilot object to query

     Get the initial seq (the one passed at object construction) which
     says what the seq was at round=0, it's just an offset.

     *Return value:* 64-bit integer

 -- Function: int lw6pil_pilot_seq2round (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT, int64_t SEQ)
     SYS_CONTEXT: global system context

     PILOT: pilot object to work on

     SEQ: the seq to convert

     Converts a seq (64-bit) to a round (32-bit).  64-bit seqs are used
     to avoid out-of-range errors on very long games, OTOH a round is
     32-bit to garantee the atomicity of its affection, even on
     platforms which are not native 64-bit.

     *Return value:* the round (32-bit integer)

 -- Function: int64_t lw6pil_pilot_round2seq (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT, int ROUND)
     SYS_CONTEXT: global system context

     PILOT: pilot object to work on

     ROUND: the round to convert

     Converts a round (32-bit) to a seq (64-bit).  64-bit seqs are used
     to avoid out-of-range errors on very long games, OTOH a round is
     32-bit to garantee the atomicity of its affection, even on
     platforms which are not native 64-bit.

     *Return value:* the seq (64-bit integer)

 -- Function: int64_t lw6pil_pilot_get_next_seq (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     TIMESTAMP: the current ticks setting (1000 ticks per second)

     Returns the seq one should use to generate new events/commands at a
     given time (given in ticks).

     *Return value:* none.

 -- Function: int64_t lw6pil_pilot_get_last_commit_seq (lw6sys_context_t
          * SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Returns the seq of the last commit (reference game_state) for this
     object.

     *Return value:* the commit seq (reference object)

 -- Function: int64_t lw6pil_pilot_get_reference_target_seq
          (lw6sys_context_t * SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Returns the seq which is targetted in the reference game_state,
     this is 'how far computation will go in the reference game_state if
     no new commands are issued'.  Note that there can always be some
     commands which are not yet processed, so you should not rely on
     this too heavily, however it gives a good idea of how things are
     going.

     *Return value:* the target seq (reference object)

 -- Function: int64_t lw6pil_pilot_get_reference_current_seq
          (lw6sys_context_t * SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Returns the current seq in the reference game_state.  There's no
     lock on this call so don't rely on this too heavily, it just gives
     you an idea of wether the pilot is very late on its objectives or
     just on time.

     *Return value:* the current seq (reference object)

 -- Function: int64_t lw6pil_pilot_get_max_seq (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Returns the max current seq in the reference or draft game states.
     No lock on this call so don't rely on this too heavily, it just
     gives you an idea of computation state.

     *Return value:* the current seq (reference object)

 -- Function: int lw6pil_pilot_is_over (lw6sys_context_t * SYS_CONTEXT,
          const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Tells wether the game is over or not.

     *Return value:* 1 if over, 0 if not

 -- Function: int lw6pil_pilot_did_cursor_win (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT, u_int16_t
          CURSOR_ID)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     CURSOR_ID: the cursor_id concerned

     Tells wether a given cursor was winner or not.

     *Return value:* 1 if over, 0 if not

 -- Function: int lw6pil_pilot_get_winner (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Gets the winner color.

     *Return value:* a team color, -1 if no winner and/or error.

 -- Function: int lw6pil_pilot_get_looser (lw6sys_context_t *
          SYS_CONTEXT, const lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: the object to query

     Gets the looser color.

     *Return value:* a team color, -1 if no looser and/or error.

 -- Function: lw6pil_local_cursors_t * lw6pil_pilot_get_local_cursors
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_pilot_t * PILOT)
     SYS_CONTEXT: global system context

     PILOT: object to query

     Returns a pointer on the local_cursors struct used within the
     object.  Beware, this is the *real* pointer, not a copy...

     *Return value:* pointer on internal object

 -- Function: void lw6pil_pilot_checksum_log_set_interval
          (lw6sys_context_t * SYS_CONTEXT, lw6pil_pilot_t * PILOT, int
          CHECKSUM_LOG_INTERVAL)
     SYS_CONTEXT: global system context

     PILOT: the pilot to track

     CHECKSUM_LOG_INTERVAL: dump interval, if 0, feature is disabled

     Debugging function used to set automatically an interval at which
     engine will log a checksum automatically.  This is typically to
     track down where and when there starts to be a difference between
     two game_states that have evolved separately.  This function will
     propagate the parameter to all the game_states handled by the
     pilot, each will log its informations separately.

     *Return value:* none

 -- Function: char * lw6pil_seed_command_generate (lw6sys_context_t *
          SYS_CONTEXT, lw6pil_pilot_t * PILOT, u_int64_t SERVER_ID,
          int64_t SEQ)
     SYS_CONTEXT: global system context

     PILOT: the pilot to transform as a SEED.

     SERVER_ID: ID of server issuing the command

     SEQ: seq at which the dump should be generated

     Creates the SEED command for a given pilot, that is, a command that
     contains macro informations about the game state such as current
     seq.  It should be followed by a dump.

     *Return value:* newly allocated string

 -- Function: int64_t lw6pil_seq_random_0 (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Gets a pseudo-random start seq, why do we use this?  Just to make
     sure even in non-network situations, seq are always very high and
     random, this way this is one less bug to check in networked
     context.

     *Return value:* random integer value, always greater than INT_MAX

 -- Function: int lw6pil_suite_init (lw6sys_context_t * SYS_CONTEXT,
          lw6pil_dump_t * DUMP, int64_t TIMESTAMP)
     SYS_CONTEXT: global system context

     DUMP: dump to use as a base to init the suite (out param)

     TIMESTAMP: timestamp used for pilot creation (should be "now")

     Build the objects used by the test suite.  The idea is to wrap all
     this in a single function since it requires to be exactly the same
     every time as the test suite is very pedantic about checksums.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int64_t lw6pil_suite_get_seq_0 (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Get the base seq_0 for the reference test suite.

     *Return value:* 64-bit integer.

 -- Function: u_int64_t lw6pil_suite_get_node_id (lw6sys_context_t *
          SYS_CONTEXT, int NODE_INDEX)
     SYS_CONTEXT: global system context

     NODE_INDEX: index of the node we want informations about

     Get the node_id associated to an index, typically a 64-bit unique.
     The index is just a simple integer which is 0 for node A, 1 for
     node B, etc.

     *Return value:* the node id, as an unsigned 64-bit integer

 -- Function: const char * lw6pil_suite_get_command_by_node_index
          (lw6sys_context_t * SYS_CONTEXT, int NODE_INDEX, int STAGE,
          int STEP)
     SYS_CONTEXT: global system context

     NODE_INDEX: index of the node (not its id)

     STAGE: major stage of the test suite

     STEP: minor step of the test suite

     Get the reference test suite message by node_index, stage and step.

     *Return value:* static string, must not be freed.

 -- Function: const char * lw6pil_suite_get_command_by_stage
          (lw6sys_context_t * SYS_CONTEXT, int STAGE, int STEP)
     SYS_CONTEXT: global system context

     STAGE: major stage of the test suite

     STEP: minor step of the test suite

     Get the reference test suite message by stage and step.  Messages
     from various nodes are mixed and sorted.

     *Return value:* static string, must not be freed.

 -- Function: const char * lw6pil_suite_get_command_by_step
          (lw6sys_context_t * SYS_CONTEXT, int STEP)
     SYS_CONTEXT: global system context

     STEP: minor step of the test suite

     Get the reference test suite message by step.  Messages from
     various nodes and stages are mixed and sorted.

     *Return value:* static string, must not be freed.

 -- Function: void lw6pil_suite_get_checkpoint (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * GAME_STATE_CHECKSUM, int64_t * SEQ,
          int * ROUND, int STAGE)
     SYS_CONTEXT: global system context

     GAME_STATE_CHECKSUM: expected checksum for the given checkpoint
     (out param)

     SEQ: expected seq for the given checkpoint (out param)

     ROUND: expected round for the given checkpoint (out param)

     STAGE: stage to query checksum and other info about

     Gives the values which are expected for a given checkpoint.  If the
     right messages have been feeded, then these values are expected.

     *Return value:* none, everything in out params

 -- Function: int lw6pil_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libpil module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6pil_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'pil' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6pil_add_args_s

     Arguments passed to the ADD command.

 -- Member of lw6pil_add_args_s: cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6pil_add_args_s::cursor_id'

     Cursor ID (16-bit non-zero unsigned int).

 -- Member of lw6pil_add_args_s: team_color
     *Type:* 'int'

     *Definition:* 'int lw6pil_add_args_s::team_color'

     Team color (0 to 9).

 -- Struct: lw6pil_command_s

     Command structure, contains both full-text version and parsed
     information.

 -- Member of lw6pil_command_s: seq
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6pil_command_s::seq'

     The sequence number, a very large 64-bit integer.  The sequence is
     here because the round wouldn't be able to stand multiple games for
     long as it is only 32-bit.  OTOH making round a 64-bit would cause
     multithread problems because of non-atomicity of 64-bit affectation
     on truely 32-bit platforms.

 -- Member of lw6pil_command_s: round
     *Type:* 'int'

     *Definition:* 'int lw6pil_command_s::round'

     The game round.

 -- Member of lw6pil_command_s: node_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6pil_command_s::node_id'

     The node ID issuing that command.

 -- Member of lw6pil_command_s: code
     *Type:* 'lw6pil_command_code_t'

     *Definition:* 'lw6pil_command_code_t lw6pil_command_s::code'

     The command code.

 -- Member of lw6pil_command_s: args
     *Type:* 'lw6pil_command_args_t'

     *Definition:* 'lw6pil_command_args_t lw6pil_command_s::args'

     The command arguments, parsed.

 -- Member of lw6pil_command_s: text
     *Type:* 'char *'

     *Definition:* 'char* lw6pil_command_s::text'

     The original full text of the command.

 -- Struct: lw6pil_dump_args_s

     Arguments passed to the DUMP command.

 -- Member of lw6pil_dump_args_s: level_hexa
     *Type:* 'char *'

     *Definition:* 'char* lw6pil_dump_args_s::level_hexa'

     Hexa dump of level.

 -- Member of lw6pil_dump_args_s: game_struct_hexa
     *Type:* 'char *'

     *Definition:* 'char* lw6pil_dump_args_s::game_struct_hexa'

     Hexa dump of game struct.

 -- Member of lw6pil_dump_args_s: game_state_hexa
     *Type:* 'char *'

     *Definition:* 'char* lw6pil_dump_args_s::game_state_hexa'

     Hexa dump of game state.

 -- Struct: lw6pil_dump_s

     Stores the information contained in a dump, this is just an utility
     struct used to hold all the data (level, game struct, game state
     and pilot) together

 -- Member of lw6pil_dump_s: level
     *Type:* 'lw6map_level_t *'

     *Definition:* 'lw6map_level_t* lw6pil_dump_s::level'

     Will hold the new level if a dump is received.

 -- Member of lw6pil_dump_s: game_struct
     *Type:* 'lw6ker_game_struct_t *'

     *Definition:* 'lw6ker_game_struct_t* lw6pil_dump_s::game_struct'

     Will hold the new game struct if a dump is received.

 -- Member of lw6pil_dump_s: game_state
     *Type:* 'lw6ker_game_state_t *'

     *Definition:* 'lw6ker_game_state_t* lw6pil_dump_s::game_state'

     Will hold the new game state if a dump is received.

 -- Member of lw6pil_dump_s: pilot
     *Type:* 'lw6pil_pilot_p'

     *Definition:* 'lw6pil_pilot_p lw6pil_dump_s::pilot'

     Will hold the new pilot if a dump is received.

 -- Struct: lw6pil_local_cursors_s

     Contains information about all local cursors, which will override
     information from game state.

 -- Member of lw6pil_local_cursors_s: main_cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6pil_local_cursors_s::main_cursor_id'

     Main cursor ID (16-bit non-zero unsigned int).  By main, we usually
     mean the mouse-driven one but necessarily.  But still, this is a
     cursor which will have a special role, it will be used to center
     the map if needed, among other things.

 -- Member of lw6pil_local_cursors_s: main_i
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursors_s::main_i'

     Main cursor index.

 -- Member of lw6pil_local_cursors_s: nb_cursors
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursors_s::nb_cursors'

     Number of cursors.

 -- Member of lw6pil_local_cursors_s: cursors
     *Type:* 'lw6pil_local_cursor_t'

     *Definition:* 'lw6pil_local_cursor_t
     lw6pil_local_cursors_s::cursors[LW6MAP_MAX_NB_CURSORS]'

     The cursors array.

 -- Struct: lw6pil_local_cursor_s

     Stores informations about local cursors.  This is usefull for user
     feedback.  Indeed there can be some delay between, for instance, a
     mouse move or a keyboard press, and the time this information makes
     it through the whole pipeline.  Players wouldn't understand such a
     lag so for local cursors we override the information from the game
     state with that information we get right from the GUI.

 -- Member of lw6pil_local_cursor_s: cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6pil_local_cursor_s::cursor_id'

     Cursor ID (16-bit non-zero unsigned int).

 -- Member of lw6pil_local_cursor_s: x
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursor_s::x'

     X position (map coords).

 -- Member of lw6pil_local_cursor_s: y
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursor_s::y'

     Y position (map coords).

 -- Member of lw6pil_local_cursor_s: mouse_controlled
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursor_s::mouse_controlled'

     Wether this cursor is mouse controlled.  If yes, then information
     will be taken directly from the mouse driver.

 -- Member of lw6pil_local_cursor_s: is_main
     *Type:* 'int'

     *Definition:* 'int lw6pil_local_cursor_s::is_main'

     Wether this cursor is the main cursor.

 -- Struct: lw6pil_pilot_s

     Pilot is a container for several game states, a reference state
     which we can rely upon and a draft state which is anticipated to
     provide interactive feedback but reflects non-validated
     informations.  The first member, id, is the same as the internal
     _lw6pil_pilot_t structure.  The rest of it is hidden.  The program
     will cast from lw6pil_pilot_t to _lw6pil_pilot_t internally.

 -- Member of lw6pil_pilot_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6pil_pilot_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Struct: lw6pil_remove_args_s

     Arguments passed to the REMOVE command.

 -- Member of lw6pil_remove_args_s: cursor_id
     *Type:* 'u_int16_t'

     *Definition:* 'u_int16_t lw6pil_remove_args_s::cursor_id'

     Cursor ID (16-bit non-zero unsigned int).

 -- Struct: lw6pil_set_args_s

     Arguments passed to the SET command.

 -- Member of lw6pil_set_args_s: cursor_id
     *Type:* 'u_int64_t'

     *Definition:* 'u_int64_t lw6pil_set_args_s::cursor_id'

     Cursor ID (16-bit non-zero unsigned int).

 -- Member of lw6pil_set_args_s: x
     *Type:* 'int'

     *Definition:* 'int lw6pil_set_args_s::x'

     X position (map coords).

 -- Member of lw6pil_set_args_s: y
     *Type:* 'int'

     *Definition:* 'int lw6pil_set_args_s::y'

     Y position (map coords).

 -- Member of lw6pil_set_args_s: fire
     *Type:* 'int'

     *Definition:* 'int lw6pil_set_args_s::fire'

     Wether to activate primary weapon.

 -- Member of lw6pil_set_args_s: fire2
     *Type:* 'int'

     *Definition:* 'int lw6pil_set_args_s::fire2'

     Wether to activate secondary weapon.

 -- Struct: lw6pil_worker_s

     Worker thread data, used to calculate stuff in a separate thread.
     The principle is simple, it tries to keep up with a given target
     round, whenever this round isn't reached, it computes more and more
     rounds.

 -- Member of lw6pil_worker_s: run
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::run'

     Wether this thread should run, 0 will stop it.

 -- Member of lw6pil_worker_s: verified
     *Type:* 'int'

     *Definition:* 'int lw6pil_worker_s::verified'

     Wether this is running in verified mode or not.

 -- Member of lw6pil_worker_s: current_round
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::current_round'

     Current game round.

 -- Member of lw6pil_worker_s: target_round
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::target_round'

     Round up to which we should compute stuff.

 -- Member of lw6pil_worker_s: computed_rounds
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::computed_rounds'

     How many rounds where computed since object creation.

 -- Member of lw6pil_worker_s: over
     *Type:* 'int'

     *Definition:* 'volatile int lw6pil_worker_s::over'

     Wether the game is over or not.

 -- Member of lw6pil_worker_s: compute_thread
     *Type:* 'lw6sys_thread_handler_t *'

     *Definition:* 'lw6sys_thread_handler_t*
     lw6pil_worker_s::compute_thread'

     The thread that does the job.

 -- Member of lw6pil_worker_s: global_mutex
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6pil_worker_s::global_mutex'

     Global data mutex.

 -- Member of lw6pil_worker_s: compute_mutex
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6pil_worker_s::compute_mutex'

     Mutex used for the computing thread.

 -- Member of lw6pil_worker_s: game_state
     *Type:* 'lw6ker_game_state_t *'

     *Definition:* 'lw6ker_game_state_t* lw6pil_worker_s::game_state'

     Game state the computing thread is working on.

 -- Member of lw6pil_worker_s: commands
     *Type:* 'lw6sys_list_r_t *'

     *Definition:* 'lw6sys_list_r_t* lw6pil_worker_s::commands'

     List of commands to be processed.

 -- Member of lw6pil_worker_s: dump
     *Type:* 'lw6pil_dump_t'

     *Definition:* 'lw6pil_dump_t lw6pil_worker_s::dump'

     Dump information.

 -- Struct: lw6pil_command_args_u

     Arguments passed to various commands.

 -- Member of lw6pil_command_args_u: add
     *Type:* 'lw6pil_add_args_t'

     *Definition:* 'lw6pil_add_args_t lw6pil_command_args_u::add'

     Arguments when command is ADD.

 -- Member of lw6pil_command_args_u: remove
     *Type:* 'lw6pil_remove_args_t'

     *Definition:* 'lw6pil_remove_args_t lw6pil_command_args_u::remove'

     Arguments when command is REMOVE.

 -- Member of lw6pil_command_args_u: set
     *Type:* 'lw6pil_set_args_t'

     *Definition:* 'lw6pil_set_args_t lw6pil_command_args_u::set'

     Arguments when command is SET.

 -- Member of lw6pil_command_args_u: dump
     *Type:* 'lw6pil_dump_args_t'

     *Definition:* 'lw6pil_dump_args_t lw6pil_command_args_u::dump'

     Arguments when command is DUMP.

5.38 libscm
===========

5.38.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/scm/index.html>.

5.38.2 API
----------

 -- Function: lw6sys_hash_t * lw6scm_coverage_new (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_t * FUNCS)
     SYS_CONTEXT: global system context

     FUNCS: list of functions, used as an input to size the hash
     correctly

     Creates a new coverage hash, this is a simple hash containing
     pointers to integers.  At startup hash is empty, whenever a scheme
     user function is called, if the entry exists it's incremented, else
     it's created with an initial value of 1 (one call).

     *Return value:* newly allocated hash

 -- Function: void lw6scm_coverage_call (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_hash_t * COVERAGE, const char * FUNC)
     SYS_CONTEXT: global system context

     COVERAGE: the hash to use to store the update

     FUNC: the name of the function (its callable scheme name)

     Registers a call on a given function.

     *Return value:* none.

 -- Function: void lw6scm_coverage_log (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_hash_t * COVERAGE)
     SYS_CONTEXT: global system context

     COVERAGE: the hash containing the call data

     Logs the information about which function has been called, and how
     many times.  This is only about scheme functions.

     *Return value:* none

 -- Function: int lw6scm_coverage_check (lw6sys_context_t * SYS_CONTEXT,
          int * PERCENT, lw6sys_hash_t * COVERAGE, lw6sys_list_t *
          FUNCS)
     SYS_CONTEXT: global system context

     PERCENT: if not NULL, will contain the percentage of coverage

     COVERAGE: object to query, containing coverage information

     FUNCS: list of functions to check

     Checks wether the script code coverage is fine, that is, wether all
     functions are called at least once.  For each function listed (as a
     string) in funcs, it will look in coverage and check wether the
     entry exists and was called.  Note that this function assumes that
     in c functions are defined with _scm_my_function (prefixed with
     _scm_ and using underscore) while in scm functions are defined with
     c-my-function (prefixed with c- and using minus).

     *Return value:* 1 if OK, 0 if KO.

 -- Function: char * lw6scm_funcname_scm2c (lw6sys_context_t *
          SYS_CONTEXT, const char * FUNCNAME)
     SYS_CONTEXT: global system context

     FUNCNAME: function name to change

     Transforms a function name of the form c-my-func to _scm_my_func.

     *Return value:* new allocated string.

 -- Function: char * lw6scm_funcname_c2scm (lw6sys_context_t *
          SYS_CONTEXT, const char * FUNCNAME)
     SYS_CONTEXT: global system context

     FUNCNAME: function name to change

     Transforms a function name of the form _scm_my_func to c-my-func.

     *Return value:* new allocated string.

 -- Function: SCM lw6scm_gettext (lw6sys_context_t * SYS_CONTEXT, SCM
          STRING)
     SYS_CONTEXT: global system context

     STRING: SCM object to convert

     For a GNU gettext-like behavior of scheme code, exported with a
     name such as _ then calling function _ from Guile will just do the
     same as _ in C.

     *Return value:* SCM value, the translated string

 -- Function: int lw6scm_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libscm module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6scm_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'scm' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: char * lw6scm_utils_to_0str (lw6sys_context_t *
          SYS_CONTEXT, SCM STRING)
     SYS_CONTEXT: global system context

     STRING: SCM object to convert

     Helper function, creates a 0 terminated string from a Guile string.
     A very common task.  This function is just a wrapper that performs
     type checking, memory allocation around standard Guile function.

     *Return value:* newly allocated string, pointer must be freed.

 -- Function: SCM lw6scm_utils_to_scm_str_list (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_t * C_LIST)
     SYS_CONTEXT: global system context

     C_LIST: list object to convert

     Transform a C list containing strings to a Guile list containing
     those strings.

     *Return value:* Guile object, a list of strings

 -- Function: SCM lw6scm_utils_to_scm_str_assoc (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_assoc_t * C_ASSOC)
     SYS_CONTEXT: global system context

     C_ASSOC: assoc object to convert

     Transform a C assoc containing strings to a Guile assoc containing
     those strings.

     *Return value:* Guile object, an assoc of strings

 -- Function: lw6sys_list_t * lw6scm_utils_to_sys_str_list
          (lw6sys_context_t * SYS_CONTEXT, SCM LIST)
     SYS_CONTEXT: global system context

     LIST: SCM object to convert

     Creates a C list from an SCM list containing strings.  Beware of
     types, function will fail if members are not all strings, it won't
     convert them.

     *Return value:* new C list object

 -- Function: lw6sys_assoc_t * lw6scm_utils_to_sys_str_assoc
          (lw6sys_context_t * SYS_CONTEXT, SCM ASSOC)
     SYS_CONTEXT: global system context

     ASSOC: SCM object to convert

     Creates a C assoc from an SCM assoc containing strings.  Beware of
     types, function will fail if members are not all strings, it won't
     convert them.

     *Return value:* new C assoc object

 -- Function: int lw6scm_c_define_gsubr (lw6sys_context_t * SYS_CONTEXT,
          const char * NAME, int REQ, int OPT, int RST, lw6scm_func_t
          FCN)
     SYS_CONTEXT: global system context

     NAME: name of the function when called from guile

     REQ: required parameters

     OPT: optional parameters

     RST: ?  should RTFM to find that out

     FCN: the function itself (pointer on the C executable code)

     Wrapper on 'scm_c_define_gsubr', one of the value of this function
     is that it does check wether it's documented before registering it.
     So if you try to register something not documented, it will fire a
     warning, which is a very nice code-quality tool.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6scm_c_primitive_load (lw6sys_context_t *
          SYS_CONTEXT, const char * FILENAME)
     SYS_CONTEXT: global system context

     FILENAME: file to execute

     Loads and executes a script.  Will add a log message while doing
     it.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void * lw6scm_with_guile (lw6sys_context_t * SYS_CONTEXT,
          lw6scm_callback_t FUNC, void * DATA)
     SYS_CONTEXT: global system context

     FUNC: callback to use

     DATA: data to pass to callback

     Initializes Guile and calls function within it.

     *Return value:* callback return value.

5.39 libsim
===========

5.39.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/sim/index.html>.

5.39.2 API
----------

 -- Function: void lw6sim_print (lw6sys_context_t * SYS_CONTEXT,
          lw6sim_results_t * RESULTS, FILE * F)
     SYS_CONTEXT: global system context

     RESULTS: data to print

     F: file to print data to

     Pretty prints results on standard output.

     *Return value:* none.

 -- Function: void lw6sim_results_zero (lw6sys_context_t * SYS_CONTEXT,
          lw6sim_results_t * RESULTS)
     SYS_CONTEXT: global system context

     RESULTS: out param, will be cleared

     Fills the struct with zeroes.

     *Return value:* none.

 -- Function: int lw6sim_results_update_percents (lw6sys_context_t *
          SYS_CONTEXT, lw6sim_results_t * RESULTS)
     SYS_CONTEXT: global system context

     RESULTS: results set to work on (in/out param)

     Updates the structure so that the percent members are up to date.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6sim_simulate (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV, lw6sim_results_t * RESULTS, int
          NB_TEAMS, char * BOT_BACKEND)
     SYS_CONTEXT: global system context

     ARGC: argc as passed to 'main'

     ARGV: argv as passed to 'main'

     RESULTS: out param, results of the simulation

     NB_TEAMS: number of teams

     BOT_BACKEND: bot backend to use

     Runs a simulation of several battle/games on the default map using
     different team settings.  Will test teams up to the given number,
     for instance if you give 3 as an argument, will run tests with
     teams 0, 1 and 2 (that's to say a total of 3 teams).

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6sim_simulate_basic (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV, lw6sim_results_t * RESULTS)
     SYS_CONTEXT: global system context

     ARGC: argc as passed to 'main'

     ARGV: argv as passed to 'main'

     RESULTS: out param, results of the simulation

     Runs a simulation of several battle/games on the default map using
     different team settings.  Will test the most common colors only,
     with the most popular bot.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6sim_simulate_full (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV, lw6sim_results_t * RESULTS)
     SYS_CONTEXT: global system context

     ARGC: argc as passed to 'main'

     ARGV: argv as passed to 'main'

     RESULTS: out param, results of the simulation

     Runs a simulation of several battle/games on the default map using
     different team settings.  Will test all colors, with the most
     popular bot.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6sim_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libsim module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6sim_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'sim' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6sim_results_s

     Results for the game simulation, contains basic statistics about
     who won the games.

 -- Member of lw6sim_results_s: nb_teams
     *Type:* 'int'

     *Definition:* 'int lw6sim_results_s::nb_teams'

     Number of teams that were tested.

 -- Member of lw6sim_results_s: absolute
     *Type:* 'int'

     *Definition:* 'int lw6sim_results_s::absolute[LW6MAP_MAX_NB_TEAMS]'

     Absolute score.  The unit is arbitrary and depends on the game
     type, the number of games.  Well, it means nothing in itself, each
     team needs to be compared to the other ones.

 -- Member of lw6sim_results_s: percent
     *Type:* 'float'

     *Definition:* 'float
     lw6sim_results_s::percent[LW6MAP_MAX_NB_TEAMS]'

     Score as a percentage.  This is based on several games played, the
     higher it is the stronger the team is.

5.40 libsnd
===========

5.40.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/snd/index.html>.

5.40.2 API
----------

 -- Function: int lw6snd_play_fx (lw6sys_context_t * SYS_CONTEXT,
          lw6snd_backend_t * BACKEND, int FX_ID)
     SYS_CONTEXT: global system context

     BACKEND: sound backend to use

     FX_ID: sound fx id

     Plays a sound fx.

     *Return value:* 1 on success, 0 on error

 -- Function: int lw6snd_is_music_file (lw6sys_context_t * SYS_CONTEXT,
          lw6snd_backend_t * BACKEND, char * MAP_DIR, char * MUSIC_PATH,
          char * MUSIC_FILE)
     SYS_CONTEXT: global system context

     BACKEND: sound backend to use

     MAP_DIR: map directory, to search additionnal files

     MUSIC_PATH: config entry containing multiple paths

     MUSIC_FILE: relative/local name of a music file

     Tells wether a file is a valid music file, typicallly based on file
     existence and extension.  Not bullet proof, file might actually not
     be loadable, but chances are 99%.

     *Return value:* 1 if music file, 0 if not

 -- Function: int lw6snd_play_music_file (lw6sys_context_t *
          SYS_CONTEXT, lw6snd_backend_t * BACKEND, char * MAP_DIR, char
          * MUSIC_PATH, char * MUSIC_FILE)
     BACKEND: sound backend to use

     MAP_DIR: map directory, to search additionnal files

     MUSIC_PATH: config entry containing multiple paths

     MUSIC_FILE: relative/local name of a music file

     Plays a music file.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6snd_play_music_random (lw6sys_context_t *
          SYS_CONTEXT, lw6snd_backend_t * BACKEND, char * MUSIC_PATH,
          char * MUSIC_FILTER, char * MUSIC_EXCLUDE)
     SYS_CONTEXT: global system context

     BACKEND: sound backend to use

     MUSIC_PATH: config entry containing multiple paths

     MUSIC_FILTER: string filter, must be present

     MUSIC_EXCLUDE: string filter, must not be present

     Plays a random music file.  The filter and exclude mecanisms are
     not complete regex filters, only a quick and dirty feature which
     should still help in some cases, such as sorting musics for the
     menus and for the rest.

     *Return value:* 1 if OK, 0 if not.

 -- Function: void lw6snd_stop_music (lw6sys_context_t * SYS_CONTEXT,
          lw6snd_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: sound backend to use

     Stops the music.

     *Return value:* none.

 -- Function: int lw6snd_init (lw6sys_context_t * SYS_CONTEXT,
          lw6snd_backend_t * BACKEND, float FX_VOLUME, float
          WATER_VOLUME, float MUSIC_VOLUME)
     SYS_CONTEXT: global system context

     BACKEND: the graphical backend to use

     FX_VOLUME: sound fx volume

     WATER_VOLUME: water sounds volume

     MUSIC_VOLUME: music volume

     Sets up the sound backend for good, initializing a playback engine
     ready to play sounds and set to defaults.  This call can typically
     fail if there's no device available, if the user doesn't have
     enough rights to access the hardware, and so on.

     *Return value:* 1 on success, 0 if not

 -- Function: void lw6snd_set_fx_volume (lw6sys_context_t * SYS_CONTEXT,
          lw6snd_backend_t * BACKEND, float VOLUME)
     SYS_CONTEXT: global system context

     BACKEND: sound backend to use

     VOLUME: sound fx volume

     Changes sound fx volume.

     *Return value:* none.

 -- Function: void lw6snd_set_water_volume (lw6sys_context_t *
          SYS_CONTEXT, lw6snd_backend_t * BACKEND, float VOLUME)
     SYS_CONTEXT: global system context

     BACKEND: sound backend to use

     VOLUME: water sounds volume

     Changes water sounds volume.

     *Return value:* none.

 -- Function: void lw6snd_set_music_volume (lw6sys_context_t *
          SYS_CONTEXT, lw6snd_backend_t * BACKEND, float VOLUME)
     SYS_CONTEXT: global system context

     BACKEND: sound backend to use

     VOLUME: music volume

     Changes music volume.

     *Return value:* none.

 -- Function: void lw6snd_poll (lw6sys_context_t * SYS_CONTEXT,
          lw6snd_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: sound backend to use

     Polling function, must be called on a regular basis.

     *Return value:* none.

 -- Function: void lw6snd_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6snd_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: the backend to quit

     Uninitializes the backend, that is, releases resources, stops
     playback.

     *Return value:* none.

 -- Function: char * lw6snd_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6snd_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: the backend to represent

     Returns a readable version of the backend object.

     *Return value:* a newly allocated pointer.

 -- Function: lw6sys_assoc_t * lw6snd_get_backends (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     List available snd backends.  The hash contains pairs with id and
     name for each backend.  The id is the technical key you can use to
     load the backend, the name is something more readable you can
     display in an interface.  The backend objects themselves are not
     instanciated by this (in fact, they are, but released on the fly)
     you need to load and initialize them afterwards.

     *Return value:* hash containing id/name pairs.

 -- Function: lw6snd_backend_t * lw6snd_create_backend (lw6sys_context_t
          * SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          NAME)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     NAME: string containing snd key, typically got from
     'lw6snd_get_backends'

     Creates a snd backend, this is just about loading the dynamic
     library if needed, and/or check snd engine is available, and
     connect to it.  It does not perform initialization.

     *Return value:* snd backend.

 -- Function: void lw6snd_destroy_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6snd_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: snd backend to destroy

     Frees the ressources associated to a snd, which must have been
     properly uninitialized before.

     *Return value:* none.

 -- Function: int lw6snd_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libsnd module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6snd_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'snd' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6snd_backend_s

     The snd backend is the first argument passed to any snd function,
     it contains reference to all the functions which can be used as
     well as a pointer on associated data.  In OO, this would just be an
     object, with members and methods, using polymorphism through opaque
     pointers.

 -- Member of lw6snd_backend_s: dl_handle
     *Type:* 'lw6dyn_dl_handle_t *'

     *Definition:* 'lw6dyn_dl_handle_t* lw6snd_backend_s::dl_handle'

     Handle on dynamic library (if it makes sense).

 -- Member of lw6snd_backend_s: snd_context
     *Type:* 'void *'

     *Definition:* 'void* lw6snd_backend_s::snd_context'

     Snd specific data, what is behind this pointer really depends on
     the snd engine.

 -- Member of lw6snd_backend_s: argc
     *Type:* 'int'

     *Definition:* 'int lw6snd_backend_s::argc'

     The argc value passed to main.

 -- Member of lw6snd_backend_s: argv
     *Type:* 'const char **'

     *Definition:* 'const char** lw6snd_backend_s::argv'

     The argv value passed to main.

 -- Member of lw6snd_backend_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6snd_backend_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6snd_backend_s: play_fx
     *Type:* 'int(*'

     *Definition:* 'int(* lw6snd_backend_s::play_fx)(lw6sys_context_t
     *sys_context, void *snd_context, int fx_id)'

     Pointer on lw6snd_play_fx callback code.

 -- Member of lw6snd_backend_s: is_music_file
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6snd_backend_s::is_music_file)(lw6sys_context_t *sys_context,
     void *snd_context, char *music_file)'

     Pointer on lw6snd_is_music_file callback code.

 -- Member of lw6snd_backend_s: play_music_file
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6snd_backend_s::play_music_file)(lw6sys_context_t *sys_context,
     void *snd_context, char *music_file)'

     Pointer on lw6snd_play_music_file callback code.

 -- Member of lw6snd_backend_s: play_music_random
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6snd_backend_s::play_music_random)(lw6sys_context_t *sys_context,
     void *snd_context, char *music_path, char *music_filter, char
     *music_exclude)'

     Pointer on lw6snd_play_music_randomcallback code.

 -- Member of lw6snd_backend_s: stop_music
     *Type:* 'void(*'

     *Definition:* 'void(*
     lw6snd_backend_s::stop_music)(lw6sys_context_t *sys_context, void
     *snd_context)'

     Pointer on lw6snd_stop_music callback code.

 -- Member of lw6snd_backend_s: init
     *Type:* 'void *(*'

     *Definition:* 'void*(* lw6snd_backend_s::init)(lw6sys_context_t
     *sys_context, int argc, const char *argv[], float fx_volume, float
     water_volume, float music_volume)'

     Pointer on lw6snd_init callback code.

 -- Member of lw6snd_backend_s: set_fx_volume
     *Type:* 'void(*'

     *Definition:* 'void(*
     lw6snd_backend_s::set_fx_volume)(lw6sys_context_t *sys_context,
     void *snd_context, float volume)'

     Pointer on lw6snd_set_fx_volume callback code.

 -- Member of lw6snd_backend_s: set_water_volume
     *Type:* 'void(*'

     *Definition:* 'void(*
     lw6snd_backend_s::set_water_volume)(lw6sys_context_t *sys_context,
     void *snd_context, float volume)'

     Pointer on lw6snd_set_water_volume callback code.

 -- Member of lw6snd_backend_s: set_music_volume
     *Type:* 'void(*'

     *Definition:* 'void(*
     lw6snd_backend_s::set_music_volume)(lw6sys_context_t *sys_context,
     void *snd_context, float volume)'

     Pointer on lw6snd_set_music_volume callback code.

 -- Member of lw6snd_backend_s: poll
     *Type:* 'void(*'

     *Definition:* 'void(* lw6snd_backend_s::poll)(lw6sys_context_t
     *sys_context, void *snd_context)'

     Pointer on lw6snd_poll callback code.

 -- Member of lw6snd_backend_s: quit
     *Type:* 'void(*'

     *Definition:* 'void(* lw6snd_backend_s::quit)(lw6sys_context_t
     *sys_context, void *snd_context)'

     Pointer on lw6snd_quit callback code.

 -- Member of lw6snd_backend_s: repr
     *Type:* 'char *(*'

     *Definition:* 'char*(* lw6snd_backend_s::repr)(lw6sys_context_t
     *sys_context, void *snd_context, u_int32_t id)'

     Pointer on lw6snd_repr callback code.

5.41 mod-csound
===============

5.41.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/snd/mod-csound/index.html>.

5.41.2 API
----------

 -- Function: void mod_csound_is_GPL_compatible ()

     Defined to tell mod_csound is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: void mod_csound_is_dlclose_safe ()

     Defined to tell mod_csound has no dlclose issue, once can safely
     call lt_dlclose on it when done with it, without risking any
     segfault.  Some other LW6 modules/shared libraries do have this
     problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_csound_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-csound, giving details about the
     module, including name, description, licence, date/time of
     compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6snd_backend_t * mod_csound_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-csound backend.

     *Return value:* backend pointer.

5.42 mod-ogg
============

5.42.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/snd/mod-ogg/index.html>.

5.42.2 API
----------

 -- Function: void mod_ogg_is_GPL_compatible ()

     Defined to tell mod_ogg is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: void mod_ogg_is_dlclose_safe ()

     Defined to tell mod_ogg has no dlclose issue, once can safely call
     lt_dlclose on it when done with it, without risking any segfault.
     Some other LW6 modules/shared libraries do have this problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_ogg_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-ogg, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6snd_backend_t * mod_ogg_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-ogg backend.

     *Return value:* backend pointer.

5.43 libsrv
===========

5.43.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/srv/index.html>.

5.43.2 API
----------

 -- Function: int lw6srv_init (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6srv_listener_t * LISTENER)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     LISTENER: listener object to use when constructing the backend.

     Initializes a server backend.  Must be performed before any other
     call.

     *Return value:* 1 on success, 0 on failure

 -- Function: void lw6srv_quit (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: unitialize a srv backend

     Closes a srv, but does not free all ressources.

 -- Function: int lw6srv_analyse_tcp (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6srv_tcp_accepter_t *
          TCP_ACCEPTER, lw6nod_info_t * NODE_INFO, u_int64_t *
          REMOTE_ID, char ** REMOTE_URL)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     TCP_ACCEPTER: TCP mode accepter

     NODE_INFO: this node information

     REMOTE_ID: remote host id (out param)

     REMOTE_URL: remote host URL (out param, dynamically allocated)

     Analyzes new TCP messages, typically handled within the accepter
     object.  The result is a combination of bitwise flags, namely
     namely 'LW6SRV_ANALYSE_DEAD', 'LW6SRV_ANALYSE_UNDERSTANDABLE', and
     'LW6SRV_ANALYSE_OOB' which helps knowing what to do with message.

     *Return value:* bitwise flag.

 -- Function: int lw6srv_analyse_udp (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6srv_udp_buffer_t * UDP_BUFFER,
          lw6nod_info_t * NODE_INFO, u_int64_t * REMOTE_ID, char **
          REMOTE_URL)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     UDP_BUFFER: UDP buffer

     NODE_INFO: this node information

     REMOTE_ID: remote host id (out param)

     REMOTE_URL: remote host URL (out param, dynamically allocated)

     Analyzes an UDP buffer, received on a socket.  The result is a
     combination of bitwise flags, namely namely 'LW6SRV_ANALYSE_DEAD',
     'LW6SRV_ANALYSE_UNDERSTANDABLE', and 'LW6SRV_ANALYSE_OOB' which
     helps knowing what to do with message.

     *Return value:* bitwise flag.

 -- Function: int lw6srv_process_oob (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6nod_info_t * NODE_INFO,
          lw6srv_oob_data_t * OOB_DATA)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     NODE_INFO: this node information

     OOB_DATA: OOB data received

     Processes an OOB message sent from a client.

     *Return value:* 1 if OK, 0 if not.

 -- Function: lw6cnx_connection_t * lw6srv_open (lw6sys_context_t *
          SYS_CONTEXT, lw6srv_backend_t * BACKEND, lw6srv_listener_t *
          LISTENER, const char * LOCAL_URL, const char * REMOTE_URL,
          const char * REMOTE_IP, int REMOTE_PORT, const char *
          PASSWORD, u_int64_t LOCAL_ID, u_int64_t REMOTE_ID, int DNS_OK,
          int NETWORK_RELIABILITY)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     LOCAL_URL: local url to use (to send to peer)

     REMOTE_URL: remote url to communicate with

     REMOTE_IP: remote ip to communicate with

     REMOTE_PORT: remote port to communicate with

     PASSWORD: password to use (the real password, not a hash)

     LOCAL_ID: the local 64-bit id

     REMOTE_ID: the remove 64-bit id

     DNS_OK: 1 if no DNS mismatch, 0 if situation is unclear

     NETWORK_RELIABILITY: the greater, the more reliable it is

     Opens a server connection.  One might wonder, clients open
     connections, but servers?  To some extent, this is the equivalent
     of 'accept' in the socket API, it will actually create an object
     one can then use to communicate.  Be carefull with the
     implementation of the callback, keep in mind it can be called any
     time in multithreaded mode, you need to set up locks when accessing
     shared objects, including, but not limited to, your own data
     buffers.

     *Return value:* new connection object.

 -- Function: int lw6srv_feed_with_tcp (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION,
          lw6srv_tcp_accepter_t * TCP_ACCEPTER)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     CONNECTION: connection to use

     TCP_ACCEPTER: TCP accepter holding data

     When data is receivedm feeds the server object with data.  Will
     typically fire the callback receive function if there are actually
     some data stuff.

     *Return value:* 1 some data processed, else 0

 -- Function: int lw6srv_feed_with_udp (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION,
          lw6srv_udp_buffer_t * UDP_BUFFER)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     CONNECTION: connection to use

     When data is receivedm feeds the server object with data.  Will
     typically fire the callback receive function if there are actually
     some data stuff.

     *Return value:* 1 some data processed, else 0

 -- Function: void lw6srv_close (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     CONNECTION: connection to close

     Closes a connection, will also free it.

     *Return value:* none.

 -- Function: int lw6srv_send (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION,
          int64_t NOW, u_int32_t PHYSICAL_TICKET_SIG, u_int32_t
          LOGICAL_TICKET_SIG, u_int64_t LOGICAL_FROM_ID, u_int64_t
          LOGICAL_TO_ID, const char * MESSAGE)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     CONNECTION: connection to use

     NOW: current timestamp

     PHYSICAL_TICKET_SIG: physical ticket

     LOGICAL_TICKET_SIG: logical ticket

     LOGICAL_FROM_ID: logical id of sender

     LOGICAL_TO_ID: logical id of receiver

     MESSAGE: string with the message to send

     Sends a message.  The added value with a plain send is that it
     handles all the special ticket fields.

     *Return value:* 1 on success, 0 if not

 -- Function: int lw6srv_can_send (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     CONNECTION: connection to use

     Tells wether a server connection can technically send messages.
     This does not garantee send will succeed, but if it's not OK at
     this stage, it's not even worth trying.

     *Return value:* 1 if it can be used to send messages, 0 if not
     ready.

 -- Function: void lw6srv_poll (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     BACKEND: server backend to use

     CONNECTION: connection to use

     Polling function, to be called on a regular basis.

     *Return value:* none.

 -- Function: char * lw6srv_repr (lw6sys_context_t * SYS_CONTEXT, const
          lw6srv_backend_t * BACKEND, lw6cnx_connection_t * CONNECTION)
     SYS_CONTEXT: global system context

     BACKEND: backend to use

     CONNECTION: connection to represent

     Gives a human readable representation of the connection.

     *Return value:* dynamically allocated string.

 -- Function: lw6srv_listener_t * lw6srv_start (lw6sys_context_t *
          SYS_CONTEXT, const char * IP, int PORT)
     SYS_CONTEXT: global system context

     IP: ip address to listen on

     PORT: port IP to bind to

     Starts a server, binds the socket(s) and returns a listener object
     which can in turn be used to create connections.

     *Return value:* new listener object.

 -- Function: void lw6srv_stop (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_listener_t * LISTENER)
     SYS_CONTEXT: global system context

     LISTENER: listener to stop

     Stops a listener object, and frees it.

     *Return value:* none.

 -- Function: lw6srv_oob_t * lw6srv_oob_new (lw6sys_context_t *
          SYS_CONTEXT, const char * REMOTE_IP, int REMOTE_PORT, int
          SOCK, const char * FIRST_LINE)
     SYS_CONTEXT: global system context

     REMOTE_IP: remote IP address

     REMOTE_PORT: remote port

     SOCK: the socket handler (either TCP or UDP)

     FIRST_LINE: the first line of data (can be NULL)

     Create a new OOB structure, copying required objects.  We need to
     make copies for this is for usage in a separate thread.  The thread
     member is not set here since the right way to do things is first to
     set up data then to fire the thread.

     *Return value:* new object

 -- Function: void lw6srv_oob_free (lw6sys_context_t * SYS_CONTEXT,
          lw6srv_oob_t * OOB)
     SYS_CONTEXT: global system context

     OOB: the object to free

     Frees an OOB structure.

     *Return value:* none

 -- Function: char * lw6srv_default_backends (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the list of the default srv backends.

     *Return value:* comma separated string, must not be freed.

 -- Function: lw6sys_assoc_t * lw6srv_get_backends (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     List available srv backends.  The hash contains pairs with id and
     name for each backend.  The id is the technical key you can use to
     load the backend, the name is something more readable you can
     display in an interface.  The backend objects themselves are not
     instanciated by this (in fact, they are, but released on the fly)
     you need to load and initialize them afterwards.

     *Return value:* hash containing id/name pairs.

 -- Function: lw6srv_backend_t * lw6srv_create_backend (lw6sys_context_t
          * SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          NAME)
     SYS_CONTEXT: global system context

     ARGC: argc, as passed to 'main'

     ARGV: argv, as passed to 'main'

     NAME: string containing srv key, typically got from
     'lw6srv_get_backends'

     Creates a srv backend, this is just about loading the dynamic
     library if needed, and/or check srv engine is available, and
     connect to it.  It does not perform initialization.

     *Return value:* srv backend.

 -- Function: void lw6srv_destroy_backend (lw6sys_context_t *
          SYS_CONTEXT, lw6srv_backend_t * BACKEND)
     SYS_CONTEXT: global system context

     BACKEND: backend to destroy

     Destroys a srv backend.

     *Return value:* none.

 -- Function: lw6srv_tcp_accepter_t * lw6srv_tcp_accepter_new
          (lw6sys_context_t * SYS_CONTEXT, char * CLIENT_IP, int
          CLIENT_PORT, int SOCK)
     CLIENT_IP: the client ip, will be freed when accepter is freed, do
     not copy it

     CLIENT_PORT: the client port

     SOCK: the socket used

     Creates a tcp_accepter object.

     *Return value:* none

 -- Function: void lw6srv_tcp_accepter_free (lw6sys_context_t *
          SYS_CONTEXT, lw6srv_tcp_accepter_t * TCP_ACCEPTER)
     TCP_ACCEPTER: the object to free

     Frees a tcp_accepter object.

     *Return value:* none

 -- Function: int lw6srv_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libsrv module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6srv_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'srv' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: lw6srv_udp_buffer_t * lw6srv_udp_buffer_new
          (lw6sys_context_t * SYS_CONTEXT, char * CLIENT_IP, int
          CLIENT_PORT, char * LINE)
     SYS_CONTEXT: global system context

     CLIENT_IP: the client ip, will be freed when object is freed, do
     not free it

     CLIENT_PORT: the client port

     LINE: the line received, will be freed when object is freed, do not
     free it

     Creates an udp_buffer object.

     *Return value:* none

 -- Function: void lw6srv_udp_buffer_free (lw6sys_context_t *
          SYS_CONTEXT, lw6srv_udp_buffer_t * UDP_BUFFER)
     SYS_CONTEXT: global system context

     UDP_BUFFER: the object to free

     Frees a udp_buffer object.

     *Return value:* none

 -- Struct: lw6srv_backend_s

     The srv backend is the first argument passed to any srv function,
     it contains reference to all the functions which can be used as
     well as a pointer on associated data.  In OO, this would just be an
     object, with members and methods, using polymorphism through opaque
     pointers.

 -- Member of lw6srv_backend_s: dl_handle
     *Type:* 'lw6dyn_dl_handle_t *'

     *Definition:* 'lw6dyn_dl_handle_t* lw6srv_backend_s::dl_handle'

     Handle on dynamic library (if it makes sense).

 -- Member of lw6srv_backend_s: srv_context
     *Type:* 'void *'

     *Definition:* 'void* lw6srv_backend_s::srv_context'

     Srv specific data, what is behind this pointer really depends on
     the srv engine.

 -- Member of lw6srv_backend_s: argc
     *Type:* 'int'

     *Definition:* 'int lw6srv_backend_s::argc'

     The argc value passed to main.

 -- Member of lw6srv_backend_s: argv
     *Type:* 'const char **'

     *Definition:* 'const char** lw6srv_backend_s::argv'

     The argv value passed to main.

 -- Member of lw6srv_backend_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6srv_backend_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6srv_backend_s: name
     *Type:* 'char *'

     *Definition:* 'char* lw6srv_backend_s::name'

     Module name.

 -- Member of lw6srv_backend_s: properties
     *Type:* 'lw6cnx_properties_t'

     *Definition:* 'lw6cnx_properties_t lw6srv_backend_s::properties'

     General backend properties.

 -- Member of lw6srv_backend_s: info
     *Type:* 'lw6nod_info_t *'

     *Definition:* 'lw6nod_info_t* lw6srv_backend_s::info'

     Information about local node.

 -- Member of lw6srv_backend_s: init
     *Type:* 'void *(*'

     *Definition:* 'void*(* lw6srv_backend_s::init)(lw6sys_context_t
     *sys_context, int argc, const char *argv[], lw6cnx_properties_t
     *properties, lw6srv_listener_t *listener)'

     Pointer on lw6srv_init callback code.

 -- Member of lw6srv_backend_s: quit
     *Type:* 'void(*'

     *Definition:* 'void(* lw6srv_backend_s::quit)(lw6sys_context_t
     *sys_context, void *srv_context)'

     Pointer on lw6srv_quit callback code.

 -- Member of lw6srv_backend_s: analyse_tcp
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6srv_backend_s::analyse_tcp)(lw6sys_context_t *sys_context, void
     *srv_context, lw6srv_tcp_accepter_t *tcp_accepter, lw6nod_info_t
     *node_info, u_int64_t *remote_id, char **remote_url)'

     Pointer on lw6srv_analyse_tcp callback code.

 -- Member of lw6srv_backend_s: analyse_udp
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6srv_backend_s::analyse_udp)(lw6sys_context_t *sys_context, void
     *srv_context, lw6srv_udp_buffer_t *udp_buffer, lw6nod_info_t
     *node_info, u_int64_t *remote_id, char **remote_url)'

     Pointer on lw6srv_analyse_udp callback code.

 -- Member of lw6srv_backend_s: process_oob
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6srv_backend_s::process_oob)(lw6sys_context_t *sys_context, void
     *srv_context, lw6nod_info_t *node_info, lw6srv_oob_data_t
     *oob_data)'

     Pointer on lw6srv_process_oob callback code.

 -- Member of lw6srv_backend_s: open
     *Type:* 'lw6cnx_connection_t *(*'

     *Definition:* 'lw6cnx_connection_t*(*
     lw6srv_backend_s::open)(lw6sys_context_t *sys_context, void
     *srv_context, lw6srv_listener_t *listener, const char *local_url,
     const char *remote_url, const char *remote_ip, int remote_port,
     const char *password, u_int64_t local_id, u_int64_t remote_id, int
     dns_ok, int network_reliability)'

     Pointer on lw6srv_open callback code.

 -- Member of lw6srv_backend_s: feed_with_tcp
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6srv_backend_s::feed_with_tcp)(lw6sys_context_t *sys_context,
     void *srv_context, lw6cnx_connection_t *connection,
     lw6srv_tcp_accepter_t *tcp_accepter)'

     Pointer on lw6srv_feed_with_tcp callback code.

 -- Member of lw6srv_backend_s: feed_with_udp
     *Type:* 'int(*'

     *Definition:* 'int(*
     lw6srv_backend_s::feed_with_udp)(lw6sys_context_t *sys_context,
     void *srv_context, lw6cnx_connection_t *connection,
     lw6srv_udp_buffer_t *udp_buffer)'

     Pointer on lw6srv_feed_with_udp callback code.

 -- Member of lw6srv_backend_s: close
     *Type:* 'void(*'

     *Definition:* 'void(* lw6srv_backend_s::close)(lw6sys_context_t
     *sys_context, void *srv_context, lw6cnx_connection_t *connection)'

     Pointer on lw6srv_close callback code.

 -- Member of lw6srv_backend_s: send
     *Type:* 'int(*'

     *Definition:* 'int(* lw6srv_backend_s::send)(lw6sys_context_t
     *sys_context, void *srv_context, lw6cnx_connection_t *connection,
     int64_t now, u_int32_t physical_ticket_sig, u_int32_t
     logical_ticket_sig, u_int64_t logical_from_id, u_int64_t
     logical_to_id, const char *message)'

     Pointer on lw6srv_send callback code.

 -- Member of lw6srv_backend_s: can_send
     *Type:* 'int(*'

     *Definition:* 'int(* lw6srv_backend_s::can_send)(lw6sys_context_t
     *sys_context, void *srv_context, lw6cnx_connection_t *connection)'

     Pointer on lw6srv_can_send callback code.

 -- Member of lw6srv_backend_s: poll
     *Type:* 'void(*'

     *Definition:* 'void(* lw6srv_backend_s::poll)(lw6sys_context_t
     *sys_context, void *srv_context, lw6cnx_connection_t *connection)'

     Pointer on lw6srv_poll callback code.

 -- Member of lw6srv_backend_s: repr
     *Type:* 'char *(*'

     *Definition:* 'char*(* lw6srv_backend_s::repr)(lw6sys_context_t
     *sys_context, void *srv_context, lw6cnx_connection_t *connection)'

     Pointer on lw6srv_repr callback code.

 -- Struct: lw6srv_client_id_s

     Parsed client ID, this is not the numerical 64-bit ID but an
     IP:port pair which uniquely and physically identifies the peer.

 -- Member of lw6srv_client_id_s: client_ip
     *Type:* 'char *'

     *Definition:* 'char* lw6srv_client_id_s::client_ip'

     Client IP address, as a string.

 -- Member of lw6srv_client_id_s: client_port
     *Type:* 'int'

     *Definition:* 'int lw6srv_client_id_s::client_port'

     Client IP port.

 -- Struct: lw6srv_listener_s

     The listener is the object which listens on the network and can
     create tcp accepters or udp buffers depending on what is received.

 -- Member of lw6srv_listener_s: ip
     *Type:* 'char *'

     *Definition:* 'char* lw6srv_listener_s::ip'

     IP address we are binded to.

 -- Member of lw6srv_listener_s: port
     *Type:* 'int'

     *Definition:* 'int lw6srv_listener_s::port'

     IP port we are binded to.

 -- Member of lw6srv_listener_s: tcp_sock
     *Type:* 'int'

     *Definition:* 'int lw6srv_listener_s::tcp_sock'

     TCP socket, binded in listening mode.

 -- Member of lw6srv_listener_s: tcp_accepters
     *Type:* 'lw6sys_list_t *'

     *Definition:* 'lw6sys_list_t* lw6srv_listener_s::tcp_accepters'

     List of lw6srv_tcp_accepter_t objects, created when data is
     received.

 -- Member of lw6srv_listener_s: udp_sock
     *Type:* 'int'

     *Definition:* 'int lw6srv_listener_s::udp_sock'

     UDP socket, binded.

 -- Member of lw6srv_listener_s: udp_buffers
     *Type:* 'lw6sys_list_t *'

     *Definition:* 'lw6sys_list_t* lw6srv_listener_s::udp_buffers'

     List of lw6srv_udp_buffer_t objects, created when data is received.

 -- Struct: lw6srv_oob_data_s

     Used to store out of band data.  Typically, when data is recognized
     as out of band, it's treated in a separate thread, and not
     mainstream.  This is both because out-of-band data is the default
     (anything not recognized and/or not trusted is OOB) and because
     this can easily be treated separately as all we need is to server
     nearly static informations.

 -- Member of lw6srv_oob_data_s: creation_timestamp
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6srv_oob_data_s::creation_timestamp'

     Date of the request.

 -- Member of lw6srv_oob_data_s: do_not_finish
     *Type:* 'int'

     *Definition:* 'volatile int lw6srv_oob_data_s::do_not_finish'

     Used to interrupt the OOB process before it's over.

 -- Member of lw6srv_oob_data_s: remote_ip
     *Type:* 'char *'

     *Definition:* 'char* lw6srv_oob_data_s::remote_ip'

     IP address of peer.

 -- Member of lw6srv_oob_data_s: remote_port
     *Type:* 'int'

     *Definition:* 'int lw6srv_oob_data_s::remote_port'

     IP port of peer.

 -- Member of lw6srv_oob_data_s: sock
     *Type:* 'int'

     *Definition:* 'int lw6srv_oob_data_s::sock'

     Socket used, can either be TCP or UDP, depends on backend.

 -- Member of lw6srv_oob_data_s: first_line
     *Type:* 'char *'

     *Definition:* 'char* lw6srv_oob_data_s::first_line'

     First line of data.

 -- Struct: lw6srv_oob_s

     Used to handle OOB requests.  This is a container over the OOB data
     and its treatment thread.

 -- Member of lw6srv_oob_s: thread
     *Type:* 'lw6sys_thread_handler_t *'

     *Definition:* 'lw6sys_thread_handler_t* lw6srv_oob_s::thread'

     Thread use to handle the data.

 -- Member of lw6srv_oob_s: data
     *Type:* 'lw6srv_oob_data_t'

     *Definition:* 'lw6srv_oob_data_t lw6srv_oob_s::data'

     The OOB data, what we received from the network.

 -- Struct: lw6srv_tcp_accepter_s

     A TCP accepter is an object which is created after a listening
     socket received some random information (in TCP mode, hence its
     name).  Itprovides basic support to accept/reject requests and
     choose the right protocol/backend for the answer.

 -- Member of lw6srv_tcp_accepter_s: client_id
     *Type:* 'lw6srv_client_id_t'

     *Definition:* 'lw6srv_client_id_t lw6srv_tcp_accepter_s::client_id'

     Where the data does come from.

 -- Member of lw6srv_tcp_accepter_s: sock
     *Type:* 'int'

     *Definition:* 'int lw6srv_tcp_accepter_s::sock'

     Socket returned by the accept POSIX function, this is the one we
     can use to reply and send data back.

 -- Member of lw6srv_tcp_accepter_s: first_line
     *Type:* 'char'

     *Definition:* 'char
     lw6srv_tcp_accepter_s::first_line[LW6SRV_PROTOCOL_BUFFER_SIZE+1]'

     First line received over the network.  This is "peeked" so it's
     still available for the actual backend, in fact that's the very
     thing we need an object for, with the information "these bytes came
     from ip:port" one can take a decision on what to do with the
     request.

 -- Member of lw6srv_tcp_accepter_s: creation_timestamp
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6srv_tcp_accepter_s::creation_timestamp'

     Timestamp of accepter creation.  This is more or less the same that
     the instant we received data on the network.  There's a small lag,
     but not that bad.  This is mostly used for timeout.

 -- Struct: lw6srv_udp_buffer_s

     A UDP datagram, this structure contains both the data and
     information about who sent it.

 -- Member of lw6srv_udp_buffer_s: client_id
     *Type:* 'lw6srv_client_id_t'

     *Definition:* 'lw6srv_client_id_t lw6srv_udp_buffer_s::client_id'

     Where the data does come from.

 -- Member of lw6srv_udp_buffer_s: line
     *Type:* 'char *'

     *Definition:* 'char* lw6srv_udp_buffer_s::line'

     The data itself.  This is typically a C-string with a 0 char at the
     end, anything else will be rejected anyway.

5.44 mod-httpd
==============

5.44.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/srv/mod-httpd/index.html>.

5.44.2 API
----------

 -- Function: void mod_httpd_is_GPL_compatible ()

     Defined to tell mod_httpd is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: void mod_httpd_is_dlclose_safe ()

     Defined to tell mod_httpd has no dlclose issue, once can safely
     call lt_dlclose on it when done with it, without risking any
     segfault.  Some other LW6 modules/shared libraries do have this
     problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_httpd_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-httpd, giving details about the
     module, including name, description, licence, date/time of
     compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6srv_backend_t * mod_httpd_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-httpd backend.

     *Return value:* backend pointer.

5.45 mod-tcpd
=============

5.45.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/srv/mod-tcpd/index.html>.

5.45.2 API
----------

 -- Function: void mod_tcpd_is_GPL_compatible ()

     Defined to tell mod_tcpd is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: void mod_tcpd_is_dlclose_safe ()

     Defined to tell mod_tcpd has no dlclose issue, once can safely call
     lt_dlclose on it when done with it, without risking any segfault.
     Some other LW6 modules/shared libraries do have this problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_tcpd_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-tcpd, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6srv_backend_t * mod_tcpd_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-tcpd backend.

     *Return value:* backend pointer.

5.46 mod-udpd
=============

5.46.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/srv/mod-udpd/index.html>.

5.46.2 API
----------

 -- Function: void mod_udpd_is_GPL_compatible ()

     Defined to tell mod_udpd is compatible with GNU General Public
     License Of course it is.  This function does nothing, but the fact
     it's declared makes its GPL compatibility obvious.  Having this
     declared is required.

     *Return value:* none

 -- Function: void mod_udpd_is_dlclose_safe ()

     Defined to tell mod_udpd has no dlclose issue, once can safely call
     lt_dlclose on it when done with it, without risking any segfault.
     Some other LW6 modules/shared libraries do have this problem.

     *Return value:* none

 -- Function: lw6sys_module_pedigree_t * mod_udpd_get_pedigree
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the pedigree for mod-udpd, giving details about the module,
     including name, description, licence, date/time of compilation.

     *Return value:* dynamically allocated object.

 -- Function: lw6srv_backend_t * mod_udpd_create_backend
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a mod-udpd backend.

     *Return value:* backend pointer.

5.47 libsys
===========

5.47.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/sys/index.html>.

5.47.2 API
----------

 -- Function: int lw6sys_arg_match (lw6sys_context_t * SYS_CONTEXT,
          const char * KEYWORD, const char * ARGV_STRING)
     SYS_CONTEXT: global system context

     KEYWORD: the option to match, without the prefix "-" or "-"

     ARGV_STRING: the argv value, for instance argv[1]

     This is an utility function which allow the program to handle
     options in a uniform manner.  Key comparison is insensitive, that
     is, -option and -OPTION are equivalent.  Besides, -option and
     -OPTION are equivalent too.  Liquid War 6 documentation mentions
     options in lowercase with a double dash (-option) by default, but
     it's a fact, the program supports variants.  This is just for
     convenience, the philosophy behind this behavior is "be as
     permissive as possible when interpreting input, and as strict as
     possible when generating output".  In fact, it's even said that
     Liquid War 6 will accept the argument without any prefix dash as
     being valid...  This is to say running "liquidwar6 -option" is the
     same as running "liquidwar6 option".  But, this is a secret 8-)

     *Return value:* non zero if it matches, 0 if it doesn't.

 -- Function: int lw6sys_arg_exists (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV, const char * KEYWORD)
     SYS_CONTEXT: global system context

     ARGC: the number of arguments, as passed to 'main'

     ARGV: an array of arguments, as passed to 'main'

     KEYWORD: the keyword to match

     Parses all command-line arguments, searching for one precise
     "-key[=...]"  entry.

     *Return value:* 1 if key is present, 0 if not.

 -- Function: char * lw6sys_arg_get_value (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          KEYWORD)
     ARGC: the number of arguments, as passed to 'main'

     ARGV: an array of arguments, as passed to 'main'

     KEYWORD: the keyword to match

     Parses all command-line arguments, searching for one precise
     "-key=value" pair, and returns the value.

     *Return value:* a pointer to the value.  May be NULL. Must be
     freed.

 -- Function: char * lw6sys_arg_get_value_with_env (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV, const char *
          KEYWORD)
     SYS_CONTEXT: global system context

     ARGC: the number of arguments, as passed to 'main'

     ARGV: an array of arguments, as passed to 'main'

     KEYWORD: the keyword to match

     Parses all command-line arguments, searching for one precise
     "-key=value" pair, and returns the value.  If a corresponding
     environment variable is available, but no command-line parameter
     was passed, the environment variable is intepreted.  Such
     environment variables are uppercased, prefixed by "LW6_" and "_"
     replaces "-".  The environment variable will be overriden if the
     command-line parameter is present.

     *Return value:* a pointer to the value.  May be NULL. Must be
     freed.

 -- Function: int lw6sys_arg_test_mode (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc as passed to main

     ARGV: argv as passed to main

     Chooses between the two test modes "check" or "test" and also
     reports wether one should run "batch" or "interactive" tests.  This
     is done by using the bit mask defined in LW6SYS_TEST_MODE_FULL_TEST
     and LW6SYS_TEST_MODE_INTERACTIVE.

     *Return value:* a bit mask one can pass to test functions

 -- Function: lw6sys_assoc_t * lw6sys_assoc_new (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_free_func_t FREE_FUNC)
     SYS_CONTEXT: global system context

     FREE_FUNC: optional callback used to free memory when stored date
     is a pointer.  Can be NULL when one stores non dynamically
     allocated data, such as an integer or a static array.

     Creates an empty assoc.  There's a difference between NULL and an
     empty assoc.  The empty assoc would (in Scheme) be '() whereas NULL
     corresponds to undefined "is not a assoc and will generate errors
     if you ever call assoc functions on it".  Such created assoc are
     not performant hash tables but slowish "strcmp me for each key"
     associative arrays, the key being a "char *" string and the value a
     "void *" pointer.

     *Return value:* a pointer to the newly allocated associative array.
     Must be freed with 'lw6sys_assoc_free'.

 -- Function: void lw6sys_assoc_free (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_assoc_t * ASSOC)
     SYS_CONTEXT: global system context

     ASSOC: the assoc to be freed.

     The function will cascade delete all elements, using (if not
     NULL...) the callback passed when first creating the assoc.

     *Return value:* void

 -- Function: int lw6sys_assoc_has_key (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_assoc_t * ASSOC, const char * KEY)
     SYS_CONTEXT: global system context

     ASSOC: the assoc to test

     KEY: the key to search

     Not a very fast function, since on a "big" assoc, strcmp will be
     called internally until the key is found.

     *Return value:* non-zero if there's an entry with the corresponding
     key.

 -- Function: void * lw6sys_assoc_get (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_assoc_t * ASSOC, const char * KEY)
     SYS_CONTEXT: global system context

     ASSOC: the assoc to query

     KEY: the key of which we want the value

     *Return value:* a void pointer to the data contained in the assoc.
     Note that the pointer on the actual data is returned, that is, if
     it's static data, you must not try to free it...  As long as memory
     management is concerned, destroying the assoc will actually free
     the data if needed.

 -- Function: void lw6sys_assoc_set (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_assoc_t ** ASSOC, const char * KEY, void * VALUE)
     SYS_CONTEXT: global system context

     ASSOC: the assoc to modify

     KEY: the key we want to updated

     VALUE: the new value

     Sets a value in an associative array.  The key pointer need not be
     persistent, it can be freed after affectation.  In fact a new
     string will be created internally.  This is not true for the value,
     it's hard to find way to copy "any object".  So if you want an
     associative array of strings, key can disappear after calling this
     function, but not value.  The function passed as free_func when
     creating the assoc will be used to free stuff whenever needed
     (unset or free).

     *Return value:* void

 -- Function: void lw6sys_assoc_unset (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_assoc_t * ASSOC, const char * KEY)
     SYS_CONTEXT: global system context

     ASSOC: the assoc concerned

     KEY: the key to unset

     Clears an entry in an associative array.  The callback passed when
     creating the assoc will be called if needed, to free the data
     automatically.

     *Return value:* void

 -- Function: lw6sys_list_t * lw6sys_assoc_keys (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_assoc_t * ASSOC)
     SYS_CONTEXT: global system context

     ASSOC: the assoc to work on

     Returns a list containing all the keys of the assoc.  The list must
     be free with lw6sys_list_free by the caller.  This list copies all
     the keys of the assoc, so it is safe to use it once the assoc is
     deleted.  However the keys will of course be of little interest in
     this case.  But the program won't segfault.

     *Return value:* the list of keys.

 -- Function: void lw6sys_assoc_map (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_assoc_t * ASSOC, lw6sys_assoc_callback_func_t FUNC,
          void * FUNC_DATA)
     SYS_CONTEXT: global system context

     ASSOC: the assoc to work on

     FUNC: a callback to call on each entry

     FUNC_DATA: a pointer on some data which will be passed to the
     callback

     Executes a function on all assoc items.  The func_data parameter
     allows you to pass extra values to the function, such as a file
     handler or any variable which can not be inferred from list item
     values, and you of course do not want to make global...

     *Return value:* void

 -- Function: void lw6sys_assoc_sort_and_map (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_assoc_t * ASSOC,
          lw6sys_assoc_callback_func_t FUNC, void * FUNC_DATA)
     SYS_CONTEXT: global system context

     ASSOC: the assoc to work on

     FUNC: a callback to call on each entry, may be NULL

     FUNC_DATA: a pointer on some data which will be passed to the
     callback

     Executes a function on all assoc items, like
     'lw6sys_assoc_sort_and_map' but befor doing so, sorts all entries
     in alphabetical order.

     *Return value:* void

 -- Function: lw6sys_assoc_t * lw6sys_assoc_dup (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_assoc_t * ASSOC, lw6sys_dup_func_t
          DUP_FUNC)
     SYS_CONTEXT: global system context

     ASSOC: the assoc to duplicate, can be NULL

     DUP_FUNC: the function which will be called to duplicate data

     Duplicates an assoc.  All keys will be copied so that if the first
     assoc is deleted, the duplicated one is fine.  Additionnaly,
     dup_func will be called with all data fields.  If dup_func is NULL,
     then data values will simply be copied.  This is likely to be
     usefull when data is not dynamically allocated.

     *Returned value:* a newly allocated assoc.

 -- Function: char * lw6sys_backtrace (lw6sys_context_t * SYS_CONTEXT,
          int SKIP, int DETAILED)
     SYS_CONTEXT: global system context

     SKIP: number of calls to skip

     DETAILED: 0 for light output, 1 for complete, detailed messages

     Returns the current backtrace as a comma separated list.  This can
     typically be used for debugging purposes.  Not available on some
     platforms, including mingw32, it requires backtrace_symbols to be
     defined.  Note that this function calls internal string functions
     so it makes usage of the sys module in many ways, therefore should
     be used only in other modules, it can't be used for debugging of
     internal memory functions for instance.  To debug those, use
     backtrace_symbols_fd directly (or maybe just gdb...).  The skip
     parameter allows you to skip caller's stack, 0 will display
     everything but 'lw6sys_backtrace' itself.

     *Return value:* dynamically allocated string

 -- Function: int lw6sys_default_memory_bazooka (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Will set up a default memory bazooka, a slow yet convenient tool to
     track down and hopefully kill memory leaks.  Named bazooka after a
     night wasted to track down an unfoundable leak...  BAZOOOOOOKA!!!

     *Return value:* 1 if success, 0 if failed.

 -- Function: void lw6sys_clear_memory_bazooka (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Clears the memory bazooka.

     *Return value:* none.

 -- Function: int lw6sys_set_memory_bazooka_size (lw6sys_context_t *
          SYS_CONTEXT, int SIZE)
     SYS_CONTEXT: global system context

     SIZE: number of items (calls to malloc) to keep

     Resizes, the memory bazooka.  What's this?  It's an inelegant yet
     efficient tool to track down memory leak.  Memory bazooka will keep
     track of every call to malloc, keeping a trace of what has been
     malloced, where it has been called (from which file, which line),
     how much memory was allocated, it will even show you what's at the
     address in a 0-terminated string-friendly fashion.  Of course this
     slows down the program, so in production, you might set this to 0,
     but for debugging, a million bazooka is worth the megabytes and CPU
     cycles it wastes.

     *Return value:* 1 if success, 0 if failure.

 -- Function: int lw6sys_get_memory_bazooka_size (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     The companion of 'lw6sys_set_memory_bazooka_size'.  This function
     will return how many calls to malloc can be traced.  A return value
     of 0 indicates that feature is disabled.

     *Return value:* size of the bazooka array.

 -- Function: int lw6sys_set_memory_bazooka_eraser (lw6sys_context_t *
          SYS_CONTEXT, int STATE)
     SYS_CONTEXT: global system context

     STATE: the state of the eraser

     Sets the memory bazooka eraser state.  Note that to really work, it
     requires the memory bazooka to be "big enough".

     *Return value:* 1 if activated, 0 if not.  Note that the main
     reason for it not to be activated is if the memory bazooka has zero
     size.

 -- Function: int lw6sys_get_memory_bazooka_malloc_count
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Provided you have always called the 'LW6SYS_MALLOC' an
     'LW6SYS_CALLOC' to allocate memory, this function will tell you how
     many times 'malloc' has been called.

     *Return value:* the number of calls to 'lw6sys_malloc' or
     'lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_free_count (lw6sys_context_t
          * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Provided you have always called the 'LW6SYS_FREE' macro to free
     memory, this function will tell you how many times 'free' has been
     called.

     *Return value:* the number of calls to 'lw6sys_free' since program
     was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_current_count
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Provided you have always called the 'LW6SYS_MALLOC' an
     'LW6SYS_CALLOC' to allocate memory, this function will tell you the
     current number of pointer returned by 'LW6SYS_MALLOC' an
     'LW6SYS_CALLOC', currently alive on the heap.

     *Return value:* the number of calls to 'lw6sys_malloc' or
     'lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_max_count
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Provided you have always called the 'LW6SYS_MALLOC' an
     'LW6SYS_CALLOC' to allocate memory, this function will tell you the
     maximum of pointers returned by 'malloc' that were present at the
     same time on the heap.

     *Return value:* the number of calls to 'lw6sys_malloc' or
     'lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_megabytes
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Provided you have always called the 'LW6SYS_MALLOC' an
     'LW6SYS_CALLOC' to allocate memory, this function will tell you how
     many bytes 'malloc' has reserved.

     *Return value:* the number of calls to 'lw6sys_malloc' or
     'lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_free_megabytes
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Provided you have always called the 'LW6SYS_FREE' macro to free
     memory, this function will tell you how many bytes 'free' has
     freed.

     *Return value:* the number of calls to 'lw6sys_free' since program
     was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_current_bytes
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Provided you have always called the 'LW6SYS_MALLOC' an
     'LW6SYS_CALLOC' to allocate memory, this function will tell you the
     current number of bytes returned by 'LW6SYS_MALLOC' an
     'LW6SYS_CALLOC', currently alive on the heap.

     *Return value:* the number of calls to 'lw6sys_malloc' or
     'lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_max_bytes
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Provided you have always called the 'LW6SYS_MALLOC' an
     'LW6SYS_CALLOC' to allocate memory, this function will tell you the
     maximum bytes returned by 'malloc' that were present at the same
     time on the heap.

     *Return value:* the number of calls to 'lw6sys_malloc' or
     'lw6sys_calloc' since program was started.

 -- Function: int lw6sys_is_memory_bazooka_trustable (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns true if memory bazooka data are perfectly trustable, that
     is, it has never been resetted or resized.

     *Return value:* 1 if trustable, 0 if not.

 -- Function: int lw6sys_memory_bazooka_report (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Reports memory bazooka diagnostics on the console.  Carefull, this
     one is not reentrant, call at the end of your program when all
     threads are joined.

     *Return value:* 1 if no allocated stuff left, 0 if there are still
     malloc'ed stuff

 -- Function: char * lw6sys_build_get_package_tarname ()

     Returns the name of the package.  This is the 'PACKAGE_TARNAME'
     constant defined by the GNU Autoconf ./configure script.  While
     it's always possible to use the defined constant directly, using
     this function will return the value defined when compiling the
     binary, not the one you're using when compiling another program
     relying on Liquid War as a library.

     *Return value:* a non-NULL string "liquidwar6", must not be freed.

 -- Function: char * lw6sys_build_get_package_name ()

     Returns the name of the package, in a user friendly form, which can
     include spaces, for instance.  This is the 'PACKAGE_NAME' constant
     defined by the GNU Autoconf ./configure script.  While it's always
     possible to use the defined constant directly, using this function
     will return the value defined when compiling the binary, not the
     one you're using when compiling another program relying on Liquid
     War as a library.

     *Return value:* a non-NULL string "Liquid War 6", must not be
     freed.

 -- Function: char * lw6sys_build_get_package_string ()

     Returns the description of the package.  This is the
     'PACKAGE_STRING' constant defined by the GNU Autoconf ./configure
     script.  It's the concatenation of 'PACKAGE_NAME' and 'VERSION'.
     While it's always possible to use the defined constant directly,
     using this function will return the value defined when compiling
     the binary, not the one you're using when compiling another program
     relying on Liquid War as a library.

     *Return value:* a non-NULL string "Liquid War 6 <version>", must
     not be freed.

 -- Function: char * lw6sys_build_get_package_id ()

     Returns the id of the package.  This is not an autotools standard
     ID, in fact it's just 'PACKAGE_TARNAME' concatenated with
     'VERSION', that is liquidwar6-<version>.

     *Return value:* a non-NULL string "liquidwar6-<version>", must not
     be freed.

 -- Function: char * lw6sys_build_get_version ()

     Returns the version of the program.  This is the 'VERSION' constant
     defined by the GNU Autoconf ./configure script.  Same as
     'PACKAGE_VERSION'.  Note that while using a function to get
     'PACKAGE_TARNAME' might seem useless, having both ways to get the
     version, that is, a function and a constant, is very usefull.
     Think, for instance, that a dynamically loaded shared library might
     need to check its own version against the version of the core
     program.

     *Return value:* a non-NULL string, which must not be freed.

 -- Function: char * lw6sys_build_get_codename ()

     Returns the the program codename.  This is the little name of the
     version.  It's been decided that all LW6 releases would take the
     name of a famous general, warrior, whatever.  For instance, it
     could be "Napoleon".

     *Return value:* a non-NULL string, traditionnally the name of a
     famous general, someone which has been involved in war.  Must not
     be freed (I mean, the string, not the general).

 -- Function: char * lw6sys_build_get_version_base ()

     Returns the program base version number.  If version is X.Y.Z, this
     is X.Y, think of it as MAJOR.MINOR and globally determines the
     level of compatibility of the program.  Two program exposing the
     same version should be network compatible and also be able to use
     the same ressource files (graphics, maps, sounds...)  as well as
     being capable of using the same binary modules (graphics backends,
     bots and so on).

     *Return value:* a non-NULL string, typically "0.1" (beta release)
     or "6.0" (stable).  Must not be freed.

 -- Function: char * lw6sys_build_get_version_major ()

     Returns the program major version number.  If version is X.Y.Z,
     this is X. It's mainly used to make the difference between
     alpha/beta releases (with "0" here) and stable releases using "6"
     as we are talking about LW6, after all.

     *Return value:* a non-NULL string, typically "0" (beta release) or
     "6" (stable).  Must not be freed.

 -- Function: char * lw6sys_build_get_version_minor ()

     Returns the program minor version number.  If version is X.Y.Z,
     this is Y. This one should increase manually at each
     significant/public release of the game.

     *Return value:* a non-NULL string like "42", which must not be
     freed.

 -- Function: char * lw6sys_build_get_stamp ()

     Returns the program stamp.  This is like a serial number.  It's is
     not the same as the version.  The version is meant to be set to
     something readable.  This is just a cryptic thing, incremented at
     each ./configure or each developper's "I feel like it needs to be
     incremented".  The idea is just to keep (one more...)  track of
     which source code is build.  Ideally, this would be plugged to the
     source revision control system but this has some drawbacks,
     including that it would require it to modify files before commiting
     them, which is not safe, and almost impossible if you sign
     archives.  One more point: this is a string.  It's true the return
     value is actually a string containing the representation of an
     integer, but because all other build parameters are strings, and
     because we don't know what the future reserves, it's a string.  If
     version is X.Y.Z, this is Z. Also called revision.

     *Return value:* a non-NULL string like "666", which must not be
     freed.

 -- Function: char * lw6sys_build_get_md5sum ()

     Returns an md5 checkum which is caculated from C (.c and .h) source
     files.  This is complementary with the build stamp.  By default the
     stamp will be enough to check what has been compiled, but one can
     always imagine a case where Bob compiles something a little
     different than Alice, with the same stamp, incremented by 1 from a
     common source tree.  They apply their own patches, for instance.
     This md5sum double-checks that two binaries have been built from
     the same sources.  Note that this is not the md5 checksum of the
     generated binary.  Nor does it include any information about scheme
     scripts and data.

     *Return value:* a non-NULL string, which must not be freed.

 -- Function: char * lw6sys_build_get_copyright ()

     Returns a (very) short copyright information about the program.

     *Return value:* a non-NULL string, single line whithout '\n' at the
     end.  Must not be freed.

 -- Function: char * lw6sys_build_get_license ()

     Returns the license for the program (GNU GPL v3 or later).

     *Return value:* a non-NULL string, single line whithout '\n' at the
     end.  Must not be freed.

 -- Function: char * lw6sys_build_get_home_url ()

     Returns the URL of the game, its homepage.

     *Return value:* a non-NULL string, single line whithout '\n' at the
     end.  Must not be freed.

 -- Function: char * lw6sys_build_get_bugs_url ()

     Returns the URL for bugs, the bug reports page.

     *Return value:* a non-NULL string, single line whithout '\n' at the
     end.  Must not be freed.

 -- Function: char * lw6sys_build_get_configure_args ()

     Returns the arguments passed to the GNU Autoconf ./configure script
     when buildling the game.  Very usefull to know how the binary was
     generated, that is, what kind of optimizations are peculiar
     settings it uses.

     *Return value:* a non-NULL string, which, passed to ./configure
     again, would hopefully generate the same binary.  Must not be
     freed.

 -- Function: char * lw6sys_build_get_gcc_version ()

     Returns __VERSION__ GCC preprocessor value, that is, the human
     readable version of the compiler.

     *Return value:* a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_cflags ()

     Returns the arguments which would allow another program to use
     liquidwar6 as a library.  Typically, pass this to gcc when
     compiling your sources.  Basically contains "-I" switches which
     tell where the headers are.

     *Return value:* a non-NULL string, which must not be freed.

 -- Function: char * lw6sys_build_get_ldflags ()

     Returns the arguments which would allow another program to link
     against liquidwar6.  Pass this to gcc or libtool when compiling
     your program.  Basically contains a "-L" option which says where
     the library is.  Note that this will only allow you to link against
     the main libliquidwar6 library, but not the dynamically loaded
     modules.

     *Return value:* a non-NULL string, which must not be freed.

 -- Function: char * lw6sys_build_get_hostname ()

     Returns the value return by the standard shell 'hostname' command
     on the machine where the game has been built.  Usefull to track
     binaries and know where do they come from.

     *Return value:* a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_date ()

     Returns the compilation date.  While this information can easily be
     obtained with the C '__DATE__' macro, having this function is
     convenient for it returns a value which is the same for the whole
     program, and does not possibly change in every file.

     *Return value:* a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_time ()

     Returns the compilation date.  While this information can easily be
     obtained with the C '__TIME__' macro, having this function is
     convenient for it returns a value which is the same for the whole
     program, and does not possibly change in every file.

     *Return value:* a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_host_cpu ()

     Returns the CPU this program is designed for.  Convenient on i386
     compatible CPUs to know which flavor (i386, i586...)  the binary is
     made for.

     *Return value:* a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_endianness (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the endianness of the computer.

     *Return value:* 'little' (x86-like) or 'big' (ppc-like), as a
     string.  Must not be freed.

 -- Function: int lw6sys_build_get_pointer_size ()

     Returns the system pointer size, in bytes.

     *Return value:* 4 for 32-bit, 8 for 64-bit.

 -- Function: int lw6sys_build_is_x86 ()

     Tells wether CPU belongs to x86 family or not.

     *Return value:* 1 if x86, 0 if not

 -- Function: int lw6sys_build_is_amd64 ()

     Tells wether CPU belongs to amd64 family or not.

     *Return value:* 1 if amd64, 0 if not

 -- Function: char * lw6sys_build_get_host_os ()

     Returns the OS this program is designed for.  Usefull for bug
     reports.

     *Return value:* a non-NULL string, must not be freed.

 -- Function: int lw6sys_build_is_gnu ()

     Tells wether the program was compiled for a GNU system, or not.

     *Return value:* 1 if compiled on windows, 0 if not

 -- Function: int lw6sys_build_is_unix ()

     Tells wether the program was compiled for a UNIX system, or not.

     *Return value:* 1 if compiled on windows, 0 if not

 -- Function: int lw6sys_build_is_ms_windows ()

     Tells wether the program was compiled for Microsoft Windows, or
     not.

     *Return value:* 1 if compiled on windows, 0 if not

 -- Function: int lw6sys_build_is_mac_os_x ()

     Tells wether the program was compiled for Mac OS X, or not.

     *Return value:* 1 if compiled on OS X, 0 if not

 -- Function: int lw6sys_build_is_gp2x ()

     Tells wether the program was compiled for GP2X, or not.

     *Return value:* 1 if compiled on OS X, 0 if not

 -- Function: char * lw6sys_build_get_top_srcdir (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the top source directory, when the game was built.  This
     can seem useless and non relevant on the end-user's machine, but...
     it's a must-have for developpers and packagers.  Without this,
     binaries would never find their associated data, especially when
     building outside the source tree.  Or, testing the game would be
     impossible without installing it, given the fact that most of the
     code is in scripts that are stored in /usr/local by default, this
     would be painfull.  So this function is here to help finding data
     within the source tree when the game is not installed yet.  Note
     that the function is rather clever, since it will automatically try
     to remove useless '../' sequences at the beginning of a possibly
     relative path.  Note that the equivalent abs_srcdir function is
     somewhat more reliable.

     *Return value:* a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_abs_srcdir ()

     Returns top_srcdir as an absolute path, this is most of the time
     more usable than the relative path.

     *Return value:* a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_prefix ()

     Returns the 'prefix' value as given to the GNU Autoconf ./configure
     script.  Used to deduce the path to other directories and files.

     *Return value:* a non-NULL string, "/usr/local" by default.  Must
     not be freed.

 -- Function: char * lw6sys_build_get_datadir ()

     Returns the 'datadir' value defined by the GNU Autoconf ./configure
     script.  This is not the value which can be overriden by the Liquid
     War 6 specific.  "-data-dir" option.  'datadir' is usually
     something like "/usr/local/share" while the actual Liquid War 6
     defined data dir is a more profound path which includes the name of
     the package, its version, and so on.

     *Return value:* a non-NULL string, "/usr/local/share" by default.
     Must not be freed.

 -- Function: char * lw6sys_build_get_libdir ()

     Returns the 'libdir' value defined by the GNU Autoconf ./configure
     script.  This is not the value which can be overriden by the Liquid
     War 6 specific.  "-mod-dir" option.  'libdir' is usually something
     like "/usr/local/lib" while the actual Liquid War 6 defined module
     dir is a more profound path which includes the name of the package,
     its version, and so on.

     *Return value:* a non-NULL string, "/usr/local/lib" by default.
     Must not be freed.

 -- Function: char * lw6sys_build_get_includedir ()

     Returns the 'includedir' value defined by the GNU Autoconf
     ./configure script.  As for other options, it's interesting to have
     this value, this enables the program to inform people who want to
     hack the game of the place headers are supposed to be installed.

     *Return value:* a non-NULL string, "/usr/local/include" by default.
     Must not be freed.

 -- Function: char * lw6sys_build_get_localedir ()

     Returns the 'localedir' value defined by the GNU Autoconf
     ./configure script.  Used as an argument for gettext / libintl
     functions.

     *Return value:* a non-NULL string, "/usr/local/share/locale" by
     default.  Must not be freed.

 -- Function: char * lw6sys_build_get_docdir ()

     Returns the 'docdir' value defined by the GNU Autoconf ./configure
     script.  Used to write consistent XML file headers.

     *Return value:* a non-NULL string,
     "/usr/local/share/doc/liquidwar6" by default.  Must not be freed.

 -- Function: char * lw6sys_build_get_enable_console ()

     Tells wether console is enabled or not.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_gtk ()

     Tells wether gtk is enabled or not.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_gl1 ()

     Tells wether the graphical mod-gl1 backend was compiled.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_gles2 ()

     Tells wether the graphical mod-gles2 backend was compiled.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_soft ()

     Tells wether the graphical mod-soft backend was compiled.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_caca ()

     Tells wether the graphical mod-caca backend was compiled.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_csound ()

     Tells wether the audio mod-csound backend was compiled.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_ogg ()

     Tells wether the audio mod-ogg backend was compiled.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_http ()

     Tells wether the network mod-http backend was compiled.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_openmp ()

     Tells wether the game was compiled with openmp support.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_optimize ()

     Tells wether the game was compiled in optimize mode.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_allinone ()

     Tells wether the game was compiled in allinone mode.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_fullstatic ()

     Tells wether the game was compiled in fullstatic mode.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_paranoid ()

     Tells wether the game was compiled with paranoid memory management.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_gprof ()

     Tells wether the game was compiled with suitable informations for
     gprof.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_instrument ()

     Tells wether the game was compiled with the
     '-finstrument-fonctions' GCC flag.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_profiler ()

     Tells wether the game was compiled for later use with Google
     Profiler support.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_gcov ()

     Tells wether the game was compiled with suitable informations for
     gcov.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_valgrind ()

     Tells wether the game was compiled for later use with valgrind.

     *Return value:* "yes" or "no", must no be freed.

 -- Function: int lw6sys_build_get_bin_id (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the internal bin-id value, which does not mean anything but
     changes at each build.

     *Return value:* an integer

 -- Function: void lw6sys_build_log_all (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Dumps in the log file the whole program pedigree, host, modules,
     that is, what are the values of all the build options.  Usefull for
     bug reports.

     *Return value:* none.

 -- Function: lw6sys_cache_t * lw6sys_cache_new (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_free_func_t FREE_FUNC, int SIZE, int
          DELAY_MSEC)
     SYS_CONTEXT: global system context

     FREE_FUNC: optional callback used to free memory when stored date
     is a pointer.  Can be NULL when one stores non dynamically
     allocated data, such as an integer or a static array.

     SIZE: the estimated size of the cache table.  This is required
     because, internally, the object uses a hash.  Note that this is an
     estimation only.  You could theorically fit 1000000 objects in a
     3-sized cache.  Problem -> this is inefficient, you'd better use an
     assoc or a bigger cache.  If you store 3 elements in a
     1000000-sized cache, you'll waste memory.  It might be wise to use
     a prime number as the estimated size.  421 is prime ;)

     Creates an empty cache.  There's a difference between NULL and an
     empty cache.

     *Return value:* a pointer to the newly allocated cache table.  Must
     be freed with 'lw6sys_cache_free'.

 -- Function: void lw6sys_cache_free (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_cache_t * CACHE)
     SYS_CONTEXT: global system context

     CACHE: the cache to be freed.

     The function will cascade delete all elements, using (if not
     NULL...) the callback passed when first creating the cache.

     *Return value:* void

 -- Function: void lw6sys_cache_free_callback (lw6sys_context_t *
          SYS_CONTEXT, void * DATA)
     SYS_CONTEXT: global system context

     DATA: data to free, this is normally an cache item

     This is a wrapper, used as the actual free callback for the
     internal hash.  What it does is that it just runs the real free
     callback (the one given by the user) on the member value.  This
     indirection is required since we use the intermediate item object
     to store the timestamp along with the key and data.

     *Return value:* none.

 -- Function: int lw6sys_cache_has_key (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_cache_t * CACHE, const char * KEY)
     SYS_CONTEXT: global system context

     CACHE: the cache to test

     KEY: the key to search

     Tells wether the key is present or not.  If key is here but too old
     (expired) then will return 0 and key will be deleted on the fly.

     *Return value:* non-zero if there's an entry with the corresponding
     key.

 -- Function: void * lw6sys_cache_get (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_cache_t * CACHE, const char * KEY)
     SYS_CONTEXT: global system context

     CACHE: the cache to query

     KEY: the key of which we want the value

     Gets the value corresponding to a given key.  Note that the value
     might be NULL, even if the key exists.  If the key has expired,
     NULL will be returned, and the entry deleted on the fly.

     *Return value:* a void pointer to the data contained in the cache.
     Note that the pointer on the actual data is returned, that is, if
     it's static data, you must not try to free it...  As long as memory
     management is concerned, destroying the cache will actually free
     the data if needed.

 -- Function: void lw6sys_cache_set (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_cache_t * CACHE, const char * KEY, void * VALUE)
     CACHE: the cache to modify

     KEY: the key we want to updated

     VALUE: the new value

     Sets a value in a cache table.  The key pointer need not be
     persistent, it can be freed after affectation.  In fact a new
     string will be created internally.  This is not true for the value,
     it's hard to find way to copy "any object".  So if you want a cache
     of strings, key can disappear after calling this function, but not
     value.  The function passed as free_func when creating the cache
     will be used to free stuff whenever needed (unset or free).

     *Return value:* void

 -- Function: void lw6sys_cache_unset (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_cache_t * CACHE, const char * KEY)
     SYS_CONTEXT: global system context

     CACHE: the cache concerned

     KEY: the key to unset

     Clears an entry in a cache table.  The callback passed when
     creating the cache will be called if needed, to free the data
     automatically.

     *Return value:* void

 -- Function: u_int32_t lw6sys_checksum (lw6sys_context_t * SYS_CONTEXT,
          unsigned char * DATA, int LEN)
     SYS_CONTEXT: global system context

     DATA: the data to process

     LEN: the length, in bytes, of the data to process

     Creates a checksum from a byte array.  This could be mapped on any
     standard CRC-32 and/or MD5 algorithm, but licence issues for those
     are such a headache that for the sake of simplicity, it's wrapped
     here.  In LW6 context, we do not really really fear any attack for
     these checksums are used internally to track bugs and check, for
     instance, that two game states are actually the same on two distant
     computers in a network game.  Data encryption and security of
     network links is another debate.  Additionnally, this function
     returns an integer, easier to handle in standard C than any
     malloc'ed stuff.

     *Return value:* the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_str (lw6sys_context_t *
          SYS_CONTEXT, const char * VALUE)
     SYS_CONTEXT: global system context

     VALUE: the string to process

     Creates a checksum from a string.  This is a convenience function
     to save the programmer the hassle of calling strlen before any
     checksum calculation.

     *Return value:* the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_int32 (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t VALUE)
     SYS_CONTEXT: global system context

     VALUE: the integer to process

     Creates a checksum from an integer.  This is a convenience function
     to save the programmer the hassle of passing a pointer to the
     integer with the size of it each time there's a checksum to do.
     Additionnally, with this one you can pass an int8 or an int16, and
     function will work just the same indenpendantly of endianness.

     *Return value:* the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_int64 (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t VALUE)
     VALUE: the integer to process

     Creates a checksum from an integer.  This is a convenience function
     to save the programmer the hassle of passing a pointer to the
     integer with the size of it each time there's a checksum to do.
     This function handles 64-bit long long integers..

     *Return value:* the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_whd (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_whd_t * WHD)
     SYS_CONTEXT: global system context

     WHD: a pointer to the wh struct to be processed

     Creates a checksum from the given structure.  Convenience function
     to save the hassle of passing a pointer to and the size of the
     'lw6sys_wh_t' struct each time, knowing that there are very often
     checksums calculated on it.  Also avoids endianess issues.

     *Return value:* the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_xyz (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_xyz_t * XYZ)
     SYS_CONTEXT: global system context

     XYZ: a pointer to the xy struct to be processed

     Creates a checksum from the given structure.  Convenience function
     to save the hassle of passing a pointer to and the size of the
     'lw6sys_xy_t' struct each time, knowing that there are very often
     checksums calculated on it.  Also avoids endianess issues.

     *Return value:* the checksum, as an integer.

 -- Function: void lw6sys_checksum_update (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * CHECKSUM, unsigned char * DATA, int
          LEN)
     SYS_CONTEXT: global system context

     CHECKSUM: a pointer to the previous checksum

     DATA: the data to process

     LEN: the length, in bytes, of the data to process

     Creates a checksum from the given data.  The difference with
     'lw6sys_checksum' is that this one updates an existing checksum,
     thus enabling the programmer to call it sequentially and get a
     global checksum on different sources.

     *Return value:* none.

 -- Function: void lw6sys_checksum_update_str (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * CHECKSUM, const char * VALUE)
     SYS_CONTEXT: global system context

     CHECKSUM: a pointer to the previous checksum

     VALUE: the string to process

     Creates a checksum from the given string.  The difference with
     'lw6sys_checksum_str' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:* none.

 -- Function: void lw6sys_checksum_update_int32 (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * CHECKSUM, int32_t VALUE)
     SYS_CONTEXT: global system context

     CHECKSUM: a pointer to the previous checksum

     VALUE: the integer to process

     Creates a checksum from the given integer.  The difference with
     'lw6sys_checksum_int32' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:* none.

 -- Function: void lw6sys_checksum_update_int64 (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * CHECKSUM, int64_t VALUE)
     SYS_CONTEXT: global system context

     CHECKSUM: a pointer to the previous checksum

     VALUE: the integer to process

     Creates a checksum from the given integer.  The difference with
     'lw6sys_checksum_int64' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:* none.

 -- Function: void lw6sys_checksum_update_whd (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * CHECKSUM, const lw6sys_whd_t * WHD)
     SYS_CONTEXT: global system context

     CHECKSUM: a pointer to the previous checksum

     WHD: a pointer to the wh struct to be processed

     Creates a checksum from the given structure.  The difference with
     'lw6sys_checksum_whd' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:* none.

 -- Function: void lw6sys_checksum_update_xyz (lw6sys_context_t *
          SYS_CONTEXT, u_int32_t * CHECKSUM, const lw6sys_xyz_t * XYZ)
     SYS_CONTEXT: global system context

     CHECKSUM: a pointer to the previous checksum

     XYZ: a pointer to the xy struct to be processed

     Creates a checksum from the given structure.  The difference with
     'lw6sys_checksum_xyz' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:* none.

 -- Function: u_int8_t lw6sys_color_float2char (float F)
     F: the value to convert, from 0.0f to 1.0f

     Converts a floating point value between 0.0f and 1.0f to its 8-bit
     equivalent between 0 and 255.  Usefull in color conversion.

     *Return value:* an integer between 0 and 255.

 -- Function: float lw6sys_color_char2float (u_int8_t I)
     I: the value to convert, from 0 to 255

     Converts an 8-bit value between 0 and 255 to its floating-point
     equivalent between 0.0f and 1.0f.  Usefull in color conversion.

     *Return value:* a float between 0.0f and 1.0f.

 -- Function: lw6sys_color_8_t lw6sys_color_f_to_8 (const
          lw6sys_color_f_t * COLOR_F)
     COLOR_F: the color to convert

     Converts a color from floating point format to the integer "0 to
     255" common format.  All fields (RGBA) are converted.

     *Return value:* the color in 8-bit format.

 -- Function: void lw6sys_color_8_to_f (lw6sys_color_f_t * COLOR_F,
          lw6sys_color_8_t COLOR_8)
     COLOR_F: the converted color (pointer must point to writable
     memory)

     COLOR_8: the color to convert

     Converts a color from the integer "0 to 255" common format to
     floating point format.  All fields (RGBA) are converted.

     *Return value:* none.

 -- Function: u_int32_t lw6sys_color_f_to_irgba (const lw6sys_color_f_t
          * COLOR_F)
     COLOR_F: the color to convert

     Converts a color from floating point format to a single integer,
     where all fields (RGBA) are serialized.  This serialization is
     endianess independant.  Could be used directly by low-level
     libraries such as SDL.

     *Return value:* the color serialized in an integer.

 -- Function: u_int32_t lw6sys_color_f_to_ibgra (const lw6sys_color_f_t
          * COLOR_F)
     COLOR_F: the color to convert

     Converts a color from floating point format to a single integer,
     where all fields (BGRA) are serialized.  This serialization is
     endianess independant.  Could be used directly by low-level
     libraries such as SDL.

     *Return value:* the color serialized in an integer.

 -- Function: u_int32_t lw6sys_color_f_to_iargb (const lw6sys_color_f_t
          * COLOR_F)
     COLOR_F: the color to convert

     Converts a color from floating point format to a single integer,
     where all fields (ARGB) are serialized.  This serialization is
     endianess independant.  Could be used directly by low-level
     libraries such as SDL.

     *Return value:* the color serialized in an integer.

 -- Function: u_int32_t lw6sys_color_f_to_iabgr (const lw6sys_color_f_t
          * COLOR_F)
     COLOR_F: the color to convert

     Converts a color from floating point format to a single integer,
     where all fields (ABGR) are serialized.  This serialization is
     endianess independant.  Could be used directly by low-level
     libraries such as SDL.

     *Return value:* the color serialized in an integer.

 -- Function: u_int32_t lw6sys_color_8_to_irgba (lw6sys_color_8_t
          COLOR_8)
     COLOR_8: the color to convert

     Converts a color from common "0 to 255" structured format to a
     single integer, where all fields (RGBA) are serialized.  This
     serialization is endianess independant.  Could be used directly by
     low-level libraries such as SDL.

     *Return value:* the color serialized in an integer.

 -- Function: u_int32_t lw6sys_color_8_to_ibgra (lw6sys_color_8_t
          COLOR_8)
     COLOR_8: the color to convert

     Converts a color from common "0 to 255" structured format to a
     single integer, where all fields (BGRA) are serialized.  This
     serialization is endianess independant.  Could be used directly by
     low-level libraries such as SDL.

     *Return value:* the color serialized in an integer.

 -- Function: u_int32_t lw6sys_color_8_to_iargb (lw6sys_color_8_t
          COLOR_8)
     COLOR_8: the color to convert

     Converts a color from common "0 to 255" structured format to a
     single integer, where all fields (ARGB) are serialized.  This
     serialization is endianess independant.  Could be used directly by
     low-level libraries such as SDL.

     *Return value:* the color serialized in an integer.

 -- Function: u_int32_t lw6sys_color_8_to_iabgr (lw6sys_color_8_t
          COLOR_8)
     COLOR_8: the color to convert

     Converts a color from common "0 to 255" structured format to a
     single integer, where all fields (ABGR) are serialized.  This
     serialization is endianess independant.  Could be used directly by
     low-level libraries such as SDL.

     *Return value:* the color serialized in an integer.

 -- Function: void lw6sys_color_irgba_to_f (lw6sys_color_f_t * COLOR_F,
          u_int32_t COLOR_I)
     COLOR_F: the converted color (point must point to writable memory)

     COLOR_I: the color to convert

     Converts a color from a serialized integer format (RGBA) to a
     floating point structure.

     *Return value:* none.

 -- Function: void lw6sys_color_ibgra_to_f (lw6sys_color_f_t * COLOR_F,
          u_int32_t COLOR_I)
     COLOR_F: the converted color (point must point to writable memory)

     COLOR_I: the color to convert

     Converts a color from a serialized integer format (BGRA) to a
     floating point structure.

     *Return value:* none.

 -- Function: void lw6sys_color_iargb_to_f (lw6sys_color_f_t * COLOR_F,
          u_int32_t COLOR_I)
     COLOR_F: the converted color (point must point to writable memory)

     COLOR_I: the color to convert

     Converts a color from a serialized integer format (ARGB) to a
     floating point structure.

     *Return value:* none.

 -- Function: void lw6sys_color_iabgr_to_f (lw6sys_color_f_t * COLOR_F,
          u_int32_t COLOR_I)
     COLOR_F: the converted color (point must point to writable memory)

     COLOR_I: the color to convert

     Converts a color from a serialized integer format (ABGR) to a
     floating point structure.

     *Return value:* none.

 -- Function: lw6sys_color_8_t lw6sys_color_irgba_to_8 (u_int32_t
          COLOR_I)
     COLOR_I: the color to convert

     Converts a color from a serialized integer format (RGBA) to a "0 to
     255" based structure.

     *Return value:* the converted color (structure).

 -- Function: lw6sys_color_8_t lw6sys_color_ibgra_to_8 (u_int32_t
          COLOR_I)
     COLOR_I: the color to convert

     Converts a color from a serialized integer format (BGRA) to a "0 to
     255" based structure.

     *Return value:* the converted color (structure).

 -- Function: lw6sys_color_8_t lw6sys_color_iargb_to_8 (u_int32_t
          COLOR_I)
     COLOR_I: the color to convert

     Converts a color from a serialized integer format (ARGB) to a "0 to
     255" based structure.

     *Return value:* the converted color (structure).

 -- Function: lw6sys_color_8_t lw6sys_color_iabgr_to_8 (u_int32_t
          COLOR_I)
     COLOR_I: the color to convert

     Converts a color from a serialized integer format (ABGR) to a "0 to
     255" based structure.

     *Return value:* the converted color (structure).

 -- Function: lw6sys_color_8_t lw6sys_color_a_to_8 (lw6sys_context_t *
          SYS_CONTEXT, const char * ASCII)
     SYS_CONTEXT: global system context

     ASCII: the color to convert

     Converts a color from a human readable string to a "0 to 255" based
     structure.  The string must be of the form "#RRGGBBAA" or "#RGB",
     in a general manner any HTML-valid value should work.

     *Return value:* the converted color (structure).

 -- Function: void lw6sys_color_a_to_f (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_color_f_t * COLOR_F, const char * ASCII)
     SYS_CONTEXT: global system context

     COLOR_F: the converted color (pointer must point to writable
     memory)

     ASCII: the color to convert

     Converts a color from a human readable string to a float based
     structure.  The string must be of the form "#RRGGBBAA" or "#RGB",
     in a general manner any HTML-valid value should work.

     *Return value:* none.

 -- Function: char * lw6sys_color_8_to_a (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_color_8_t COLOR_8)
     SYS_CONTEXT: global system context

     COLOR_8: the color to convert

     Converts a color from a "0 - 255" integer based structure to its
     readable form "#RRGGBBAA". If alpha is 255 (0xFF), that is, if it's
     opaque, then the "AA" part is ommitted.

     *Return value:* a newly allocated string.

 -- Function: void lw6sys_color_rgb_to_hsv (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_color_hsv_t * COLOR_HSV, lw6sys_color_8_t
          COLOR_8)
     SYS_CONTEXT: global system context

     COLOR_HSV: the target color, in HSV format

     COLOR_8: the source color, in RGB 256 format

     Converts from HSV to RGB. Usefull for color manipulation, since
     most colors are stored in RGB but HSV is convenient for
     transformation.  Alpha layer is kept as is.

     *Return value:* none.

 -- Function: lw6sys_color_8_t lw6sys_color_hsv_to_rgb (lw6sys_context_t
          * SYS_CONTEXT, const lw6sys_color_hsv_t * COLOR_HSV)
     SYS_CONTEXT: global system context

     COLOR_HSV: the source color, in HSV format

     Converts from RGB to HSV. Usefull to make colors transformed in HSV
     format usable again by all display routines, which consume RGB.
     Alpha layer is kept as is.

     *Return value:* the RGB color.

 -- Function: void lw6sys_color_hsv_invert (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_color_hsv_t * COLOR_HSV, int INVERT_H, int
          INVERT_S, int INVERT_V)
     SYS_CONTEXT: global system context

     COLOR_HSV: the source color, in HSV format

     INVERT_H: wether to invert the hue

     INVERT_S: wether to invert the saturation

     INVERT_V: wether to invert the value

     Inverts an HSV color, calling it with 1,0,0 the color will become a
     color with opposite hue but same saturation and same value.

     *Return value:* none.

 -- Function: int lw6sys_color_is_grey (lw6sys_color_8_t COLOR)
     COLOR: the color to test

     Tells wether a color is pure grey or not.  This is interesting for
     such colors have no hue and sometimes need special handling.

     *Return value:* 1 if grey, 0 if colored

 -- Function: lw6sys_color_8_t lw6sys_color_average (lw6sys_context_t *
          SYS_CONTEXT, int SIZE, const lw6sys_color_8_t * COLORS)
     SYS_CONTEXT: global system context

     SIZE: number of the color array (number of items)

     COLORS: the colors to compute

     Tries to find out the "average" color from an array of colors.  The
     algorithm is far from perfect, but should output a color which
     reflects the colors passed in.

     *Return value:* the (inexact) average color.

 -- Function: lw6sys_color_8_t lw6sys_color_ponderate (lw6sys_context_t
          * SYS_CONTEXT, lw6sys_color_8_t COLOR1, lw6sys_color_8_t
          COLOR2, float COEFF)
     SYS_CONTEXT: global system context

     COLOR1: first color

     COLOR2: second color

     COEFF: the ponderation coefficient

     Tries to find a color between the two colors passed as an argument.
     The coefficient can be used, to set the relative weight of each
     color.  Using 0 will return color1, 1 will return color2 and 0.5
     will make an average between the two colors.  Any value between 0
     and 1 can be used.

     *Return value:* the (inexact) ponderated color.

 -- Function: float lw6sys_color_distance (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_color_8_t COLOR1, lw6sys_color_8_t COLOR2)
     SYS_CONTEXT: global system context

     COLOR1: first color

     COLOR2: second color

     Calculates the distance between two colors.  The unit is arbitrary,
     a big value means "colors are different", 0 means they are the
     same.  A distance of 1 corresponds to colors which have barely
     anything in common, but the result can still be greater than 1.
     Alpha layer is not taken in account.

     *Return value:* the distance.

 -- Function: int lw6sys_color_is_same (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_color_8_t COLOR1, lw6sys_color_8_t COLOR2)
     SYS_CONTEXT: global system context

     COLOR1: the first color to compare

     COLOR2: the second color to compare

     Compares two colors.

     *Return value:* 1 if they are the same, 0 if not.

 -- Function: void lw6sys_color_8_solid (lw6sys_color_8_t * COLOR)
     COLOR: the color to modify

     Make a color "solid" that is make it not transparent at all.

     *Return value:* none.

 -- Function: void lw6sys_color_f_solid (lw6sys_color_f_t * COLOR)
     COLOR: the color to modify

     Make a color "solid" that is make it not transparent at all.

     *Return value:* none.

 -- Function: lw6sys_context_t * lw6sys_context_new ()

     Create a new global system context.  This is normally called only
     once during a program execution and is wrapped in
     lw6sys_context_init.

     *Return value:* newly allocated context

 -- Function: void lw6sys_context_free (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Frees a global system context.  Called only once during a program
     execution and is wrapped in lw6sys_context_quit.

     *Return value:* none

 -- Function: void lw6sys_context_begin (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Performs all initializations required for lw6sys functions to
     behave correctly, this includes locale settings, timer
     initialization, memory management related stuff.  This is wrapped
     into lw6sys_context_init.

     *Return value:* none

 -- Function: int lw6sys_context_end (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Performs all cleanup required after all lw6sys functions have been
     called.  Once this has been called, do not call any function that
     requires a valid context, except maybe lw6sys_context_free.  This
     is wrapped into lw6sys_context_quit.

     *Return value:* 1 on success, 0 on failure.  A failure can reveal a
     problem that occured way upstream, typically some memory not
     cleanly freed.

 -- Function: lw6sys_context_t * lw6sys_context_init ()

     Create a new global system context, and initalizes it, so that it's
     ready for general use.

     *Return value:* newly allocated and valid context

 -- Function: int lw6sys_context_quit (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Performs all cleanup required after all lw6sys functions have been
     called, and frees the object.

     *Return value:* 1 on success, 0 on failure.  A failure can reveal a
     problem that occured way upstream, typically some memory not
     cleanly freed.

 -- Function: int lw6sys_atoi (lw6sys_context_t * SYS_CONTEXT, const
          char * STR)
     SYS_CONTEXT: global system context

     STR: string to convert

     Just a plain wrapper on 'atoi', it's here for API consistency.
     Will check if str is NULL (and in this case return 0).

     *Return value:* an integer.

 -- Function: int64_t lw6sys_atoll (lw6sys_context_t * SYS_CONTEXT,
          const char * STR)
     SYS_CONTEXT: global system context

     STR: string to convert

     Wrapper on 'atoll', it's here for API consistency.  Will check if
     str is NULL (and in this case return 0).

     *Return value:* a 64-bit integer.

 -- Function: int lw6sys_atob (lw6sys_context_t * SYS_CONTEXT, const
          char * STR)
     SYS_CONTEXT: global system context

     STR: string to convert

     Transform a string into a boolean value.  Accepts "0"/"1" in input,
     but also y/n, yes/no, true/false, on/off.  Will check if str is
     NULL (and in this case return 0).

     *Return value:* an integer, 0 or 1.

 -- Function: float lw6sys_atof (lw6sys_context_t * SYS_CONTEXT, const
          char * STR)
     SYS_CONTEXT: global system context

     STR: string to convert

     A wrapper on 'atof', makes sure the locale used is C (default) and
     won't change the decimal separator whatsoever.  Usefull for
     serialization for instance.  Will check if str is NULL (and in this
     case return 0).

     *Return value:* a float.

 -- Function: char * lw6sys_itoa (lw6sys_context_t * SYS_CONTEXT, int
          VALUE)
     SYS_CONTEXT: global system context

     VALUE: the integer to convert

     Converts an integer to a string, the advantage of this function is
     it allocates memory, and does the dirty job.

     *Return value:* a newly allocated pointer, must be freed, may be
     NULL.

 -- Function: char * lw6sys_lltoa (lw6sys_context_t * SYS_CONTEXT,
          int64_t VALUE)
     VALUE: the integer to convert

     Converts a 64-bit integer to a string, the advantage of this
     function is it allocates memory, and does the dirty job.

     *Return value:* a newly allocated pointer, must be freed, may be
     NULL.

 -- Function: char * lw6sys_btoa (lw6sys_context_t * SYS_CONTEXT, int
          VALUE)
     SYS_CONTEXT: global system context

     VALUE: the boolean to convert

     Converts a boolean to a string, the advantage of this function is
     it allocates memory, and does the dirty job.

     *Return value:* a newly allocated pointer, must be freed, may be
     NULL.

 -- Function: char * lw6sys_ftoa (lw6sys_context_t * SYS_CONTEXT, float
          VALUE)
     SYS_CONTEXT: global system context

     VALUE: the float to convert

     Converts a float to a string, the advantage of this function is it
     allocates memory, and does the dirty job.

     *Return value:* a newly allocated pointer, must be freed, may be
     NULL.

 -- Function: int lw6sys_cunit_run_tests (lw6sys_context_t *
          SYS_CONTEXT, int MODE)
     SYS_CONTEXT: global system context

     MODE: mode passed to program (bit mask)

     Run all registered suites and their tests, will interpret mode and
     call the right CUnit function (Batch, Console, NCurses...).

     *Return value:* 1 if tests or OK, 0 if not.

 -- Function: void lw6sys_cunit_clear (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Clears the global CUnit related lock.

     *Return value:* none.

 -- Function: int lw6sys_cunit_lock (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Locks a global CUnit related lock, this is to allow the use of test
     macro LW6SYS_TEST_ACK in multithreaded environment, as CUnit does
     not, by default garantee that concurrent accesses to its API will
     work.  Just to be sure...  we lock.

     *Return value:* 1 if locked, 0 on failure.

 -- Function: int lw6sys_cunit_unlock (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Unlocks the global CUnit related lock, this is to allow the use of
     test macro LW6SYS_TEST_ACK in multithreaded environment, as CUnit
     does not, by default garantee that concurrent accesses to its API
     will work.  Just to be sure...  we lock.

     *Return value:* 1 if unlocked, 0 on failure.

 -- Function: char * lw6sys_daemon_pid_file (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc as passed to 'main'

     ARGV: argv as passed to 'main'

     Get the default pid file, used to lock daemon and avoid 2 daemons
     running at the same time.

     *Return value:* newly allocated string

 -- Function: int lw6sys_daemon_start (lw6sys_context_t * SYS_CONTEXT,
          char * PID_FILE)
     SYS_CONTEXT: global system context

     PID_FILE: the pid file used for the daemon

     Calls 'fork' internally to put the process in the program, make it
     a daemon.  Note this won't work on all platforms, for instance it
     won't work on MS-Windows but this is rarely an issue as MS-Windows
     users are rarely concerned with detaching a program from a tty.
     Note that this isn't a wrapper on 'fork', the return value is
     different,

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6sys_daemon_stop (lw6sys_context_t * SYS_CONTEXT,
          char * PID_FILE)
     SYS_CONTEXT: global system context

     PID_FILE: the pid file used for the daemon

     Removes the daemon pid file.  Can be called safely even if daemon
     wasn't started.

     *Return value:* 1 on success, 0 on failure

 -- Function: int lw6sys_debug_get (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Gets the debug mode.

 -- Function: void lw6sys_debug_set (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: the debug mode, 1 if set, 0 if not.

     Sets the debug mode.

 -- Function: void lw6sys_dump_clear (lw6sys_context_t * SYS_CONTEXT,
          char * USER_DIR)
     SYS_CONTEXT: global system context

     USER_DIR: the user directory, where user can write data.

     Clears the dump file.  That is, resets it to a "0 byte" file.

     *Return value:* none.

 -- Function: int lw6sys_dump (lw6sys_context_t * SYS_CONTEXT, char *
          USER_DIR, char * CONTENT)
     SYS_CONTEXT: global system context

     USER_DIR: the user directory, where user can write data.

     CONTENT: the content to be written in the dump file.

     Writes the dump file onto the disk.  The dump is used for special
     error messages which do not really fit in the standard log, and
     require a special treatment.  In pratice, it's used to log fatal
     script (Guile) errors.

     *Return value:* 1 if success, 0 if failure.

 -- Function: char lw6sys_env_separator_char ()

     Gets the ENV separator, that is, for instance, the character used
     to separate paths in environment variables.  Typically, this would
     be ":" on GNU and ";" on Microsft platforms.

     *Return value:* the ascii character code.

 -- Function: char * lw6sys_env_separator_str ()

     Gets the ENV separator, that is, for instance, the character used
     to separate paths in environment variables.  Typically, this would
     be ":" on GNU and ";" on Microsft platforms.

     *Return value:* a pointer to a single 0-terminated character string
     which contains the character.  Must not be freed.

 -- Function: char * lw6sys_env_concat (lw6sys_context_t * SYS_CONTEXT,
          const char * VALUE1, const char * VALUE2)
     SYS_CONTEXT: global system context

     VALUE1: the left part to be concatenated

     VALUE2: the right part to be concatenated

     Concatenates two values and puts the ENV separator, as returned by
     'lw6sys_env_separator_char' between them.

     *Return value:* the concatenated string, must be freed.

 -- Function: int lw6sys_env_exists_prefixed (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword to be searched in the environment variables.

     Searches environment variables for the given keyword.  The keyword
     will be fixed so that all dashes "-" characters are replaced by
     underscores "_" characters.  Characters will be changed to
     uppercase.  Any non alphanumeric character will be replaced by "_".
     Finally, an "LW6_" prefix will be added.  That is to say, calling
     this function with "my-param" will search for the "LW6_MY_PARAM"
     environment variable.

     *Return value:* 1 if the environment variable exists, 0 if not.

 -- Function: char * lw6sys_getenv (lw6sys_context_t * SYS_CONTEXT,
          const char * KEY)
     SYS_CONTEXT: global system context

     KEY: the environment variable to get.

     Searches environment variables for the given value.  This is a
     wrapper over the standard C getenv, the difference is it will
     return a dynamically allocated pointer, and on some platforms will
     query specific OS functions.

     *Return value:* the value for the given keyword.  May be NULL. Must
     be freed.

 -- Function: char * lw6sys_getenv_prefixed (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword to be searched in the environment variables.

     Searches environment variables for the given value.  The keyword
     will be fixed so that all dashes "-" characters are replaced by
     underscores "_" characters.  Characters will be changed to
     uppercase.  Any non alphanumeric character will be replaced by "_".
     Finally, an "LW6_" prefix will be added.  That is to say, calling
     this function with "my-param" will search for the "LW6_MY_PARAM"
     environment variable.

     *Return value:* the value for the given keyword.  May be NULL. Must
     be freed.

 -- Function: int lw6sys_setenv (lw6sys_context_t * SYS_CONTEXT, const
          char * KEYWORD, const char * VALUE)
     KEYWORD: the environment variable to set

     VALUE: the value of the environment variable to set

     Sets the environment variable to a given value.  If value is NULL,
     variable is unset.  Note that unlike lw6sys_getenv_prefixed, this
     function does not transform the keyword into "LW6_..."  before
     setting the value, so it's your responsability to call
     "lw6sys_keyword_as_env" if needed.

     *Return value:* 1 if success, 0 if failed

 -- Function: int lw6sys_setenv_prefixed (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD, const char * VALUE)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword to be searched in the environment variables.

     VALUE: the value of the environment variable to set

     Sets the environment variable to the given value.  The keyword will
     be fixed so that all dashes "-" characters are replaced by
     underscores "_" characters.  Characters will be changed to
     uppercase.  Any non alphanumeric character will be replaced by "_".
     Finally, an "LW6_" prefix will be added.  That is to say, calling
     this function with "my-param" will set the "LW6_MY_PARAM"
     environment variable.

     *Return value:* 1 if success, 0 if failure

 -- Function: lw6sys_list_t * lw6sys_env_split (lw6sys_context_t *
          SYS_CONTEXT, const char * VALUE)
     SYS_CONTEXT: global system context

     VALUE: the value, a list of item separated by...  the separator

     Splits the environment value into a list of strings containing each
     element.  All strings are dynamically allocated, but they will be
     freed automatically when the list is freed.

     *Return value:* a list of strings.

 -- Function: char * lw6sys_get_home (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Gets the home directory of the user.  Used internally to calculate
     the 'user'-dir value.  Note that Liquid War 6, by default, never
     stores files under '$HOME', instead it put things in
     '$HOME/.liquidwar6', that is 'user-dir'.  If the environment
     variable 'HOME' is not set, will return '.'.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_get_username (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Gets the name of the current user.  Difference with the standard
     function 'getlogin' is that this function will returned a
     dynamically allocated pointer, and provide a default value if it's
     undefined.  Also, if will look at the content of the 'LOGNAME'
     environment variable if needed, and will even provide a default
     value.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_get_hostname (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Gets the name of the current host.  The name of the computer.
     Might not work perfectly, this function is just used to provide
     default values for player names and such things.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_escape_http_uri (lw6sys_context_t *
          SYS_CONTEXT, const char * SRC)
     SYS_CONTEXT: global system context

     SRC: the string to escape

     Transforms a string so that it does not contain any non-valid URL
     chars, it will mostly convert chars over 128 into their an
     hexadecimal code which replaces them in URLs.  Note that this
     function is non really standard compliant for it won't encode '%'
     but keep it the same.  This is to allow using it several times on
     the same string and avoid double-triple encoding of '%'.  In
     practice it's not recommended to have public_url for nodes with '%'
     in them, and the program will never generate such url when guessing
     urls.

     *Return value:* newly allocated string.

 -- Function: char * lw6sys_escape_html_attribute (lw6sys_context_t *
          SYS_CONTEXT, const char * SRC)
     SYS_CONTEXT: global system context

     SRC: the string to escape

     Transforms a string so that it can fit in a html field, this is
     typically for alt="" or title="" fields so it will convert a double
     quote into its equivalent escaped char.

     *Return value:* newly allocated string.

 -- Function: char * lw6sys_escape_sql_value (lw6sys_context_t *
          SYS_CONTEXT, const char * SRC)
     SYS_CONTEXT: global system context

     SRC: the string to escape

     Transforms a string so that it can fit as an SQL parameter, it will
     get rid URL chars, it will mostly convert chars over 128 into an
     hexadecimal form which replaces them in URLs.

     *Return value:* newly allocated string.

 -- Function: char * lw6sys_exec_find_myself (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: array of args as passed to main

     Finds the path of the program currently run, this is typically to
     pass it to 'lw6sys_exec_again' and run it again.

     *Return value:* the path (newly allocated string).

 -- Function: int lw6sys_is_executed_again (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: array of args as passed to main

     Tells wether the program is already executed by itself by
     'lw6sys_exec_again' function.  Based on environment and command
     switches.

     *Return value:* 1 if executed again, 0 if not.

 -- Function: int lw6sys_exec_again (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: array of args as passed to main

     Runs the program from itsef, that is fires a new program (the same
     running) and ends up the current one.  This is used to fix some
     environment variable issues.  If LW6_EXECUTED_AGAIN (environment
     variable) is set, will not run the program so this is not really
     like 'exec' as in the C standard library, this function will
     actually return and be successfull even if no other process was
     started.  It's just designed to bootstrap/launch the process once.

     *Return value:* 1 on success, 0 on failure (always fail)

 -- Function: int lw6sys_exec_restart (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: array of args as passed to main

     Restart the program with exactly the same arguments it was given
     the first time.

     *Return value:* 1 on success, 0 on failure (always fail)

 -- Function: int lw6sys_clear_file (lw6sys_context_t * SYS_CONTEXT,
          const char * FILENAME)
     SYS_CONTEXT: global system context

     FILENAME: absolute or relative filename

     Clears a file, that is, make it a 0 byte file, empty, ready to be
     filled if needed.  If this function is called successfully, program
     can reasonnably assume file will be writable during its execution.

     *Return value:* 1 if success, 0 if failure.

 -- Function: char * lw6sys_read_file_content (lw6sys_context_t *
          SYS_CONTEXT, const char * FILENAME)
     SYS_CONTEXT: global system context

     FILENAME: absolute or relative filename

     Reads the content of a file, and returns it as a string.  Note that
     content might or might not be ascii or binary, the function will
     however put a tailing 0 character at the end so that low-level
     standard C functions do not segfault when used with the returned
     value.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: void * lw6sys_read_file_content_bin (lw6sys_context_t *
          SYS_CONTEXT, int * FILESIZE, const char * FILENAME)
     SYS_CONTEXT: global system context

     FILESIZE: will contain the file size, in bytes

     FILENAME: absolute or relative filename

     Reads the content of a file, and returns it as a binary buffer.
     Even if not ascii or binary, the function will however put a
     tailing 0 character at the end so that low-level standard C
     functions do not segfault when used with the returned value.  This
     0 character is not included in 'filesize' so if there are 4 bytes
     in the file the 5 bytes will be allocated, this is just for string
     functions not to explode if called by accident.  The 'filesize' can
     be NULL, in that case function is just like the
     'lw6sys_read_file_content' function.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: int lw6sys_write_file_content (lw6sys_context_t *
          SYS_CONTEXT, const char * FILENAME, const char * CONTENT)
     SYS_CONTEXT: global system context

     FILENAME: absolute or relative filename

     CONTENT: the content to be written.

     Writes the content into the file.  Content is assumed to be a
     string, function will segfault if it's not correctly 0 terminated
     as in C string convention.  So this function will not allow you to
     write down arbitrary binary data, however LW6 uses mostly text
     files to store information, and opaque binary data usage is not
     recommended.

 -- Function: lw6sys_hash_t * lw6sys_hash_new (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_free_func_t FREE_FUNC, int SIZE)
     SYS_CONTEXT: global system context

     FREE_FUNC: optional callback used to free memory when stored date
     is a pointer.  Can be NULL when one stores non dynamically
     allocated data, such as an integer or a static array.

     SIZE: the estimated size of the hash table.  Note that this is an
     estimation only.  You could theorically fit 1000000 objects in a
     3-sized hash.  Problem -> this is inefficient, you'd better use an
     assoc or a bigger hash.  If you store 3 elements in a 1000000-sized
     hash, you'll waste memory.  It might be wise to use a prime number
     as the estimated size.  421 is prime ;)

     Creates an empty hash.  There's a difference between NULL and an
     empty hash.

     *Return value:* a pointer to the newly allocated hash table.  Must
     be freed with 'lw6sys_hash_free'.

 -- Function: void lw6sys_hash_free (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_hash_t * HASH)
     SYS_CONTEXT: global system context

     HASH: the hash to be freed.

     The function will cascade delete all elements, using (if not
     NULL...) the callback passed when first creating the hash.

     *Return value:* void

 -- Function: int lw6sys_hash_has_key (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_hash_t * HASH, const char * KEY)
     SYS_CONTEXT: global system context

     HASH: the hash to test

     KEY: the key to search

     Tells wether the key is present or not.

     *Return value:* non-zero if there's an entry with the corresponding
     key.

 -- Function: void * lw6sys_hash_get (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_hash_t * HASH, const char * KEY)
     SYS_CONTEXT: global system context

     HASH: the hash to query

     KEY: the key of which we want the value

     Gets the value corresponding to a given key.  Not that the value
     can be NULL, even if the key exitsts.

     *Return value:* a void pointer to the data contained in the hash.
     Note that the pointer on the actual data is returned, that is, if
     it's static data, you must not try to free it...  As long as memory
     management is concerned, destroying the hash will actually free the
     data if needed.

 -- Function: void lw6sys_hash_set (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_hash_t * HASH, const char * KEY, void * VALUE)
     SYS_CONTEXT: global system context

     HASH: the hash to modify

     KEY: the key we want to updated

     VALUE: the new value

     Sets a value in a hash table.  The key pointer need not be
     persistent, it can be freed after affectation.  In fact a new
     string will be created internally.  This is not true for the value,
     it's hard to find way to copy "any object".  So if you want a hash
     table of strings, key can disappear after calling this function,
     but not value.  The function passed as free_func when creating the
     hash will be used to free stuff whenever needed (unset or free).

     *Return value:* void

 -- Function: void lw6sys_hash_unset (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_hash_t * HASH, const char * KEY)
     SYS_CONTEXT: global system context

     HASH: the hash concerned

     KEY: the key to unset

     Clears an entry in a hash table.  The callback passed when creating
     the hash will be called if needed, to free the data automatically.

     *Return value:* void

 -- Function: lw6sys_list_t * lw6sys_hash_keys (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hash_t * HASH)
     SYS_CONTEXT: global system context

     HASH: the hash to work on

     Returns a list containing all the keys of the hash.  The list must
     be free with lw6sys_list_free by the caller.  This list copies all
     the keys of the hash, so it is safe to use it once the hash is
     deleted.  However the keys will sometimes be of little interest in
     this case.  But the program won't segfault.

     *Return value:* the list of keys.

 -- Function: void lw6sys_hash_map (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_hash_t * HASH, lw6sys_assoc_callback_func_t FUNC, void
          * FUNC_DATA)
     SYS_CONTEXT: global system context

     HASH: the hash to work on

     FUNC: a callback to call on each entry

     FUNC_DATA: a pointer on some data which will be passed to the
     callback

     Executes a function on all hash items.  The func_data parameter
     allows you to pass extra values to the function, such as a file
     handler or any variable which can not be inferred from list item
     values, and you of course do not want to make global...

     *Return value:* void

 -- Function: void lw6sys_hash_sort_and_map (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hash_t * HASH,
          lw6sys_assoc_callback_func_t FUNC, void * FUNC_DATA)
     SYS_CONTEXT: global system context

     HASH: the hash to work on

     FUNC: a callback to call on each entry, may be NULL

     FUNC_DATA: a pointer on some data which will be passed to the
     callback

     Executes a function on all hash items, like
     'lw6sys_hash_sort_and_map' but befor doing so, sorts all entries in
     alphabetical order.

     *Return value:* void

 -- Function: lw6sys_hash_t * lw6sys_hash_dup (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hash_t * HASH, lw6sys_dup_func_t DUP_FUNC)
     SYS_CONTEXT: global system context

     HASH: the hash to duplicate, can be NULL

     DUP_FUNC: the function which will be called to duplicate data

     Duplicates an hash.  All keys will be copied so that if the first
     hash is deleted, the duplicated one is fine.  Additionnaly,
     dup_func will be called with all data fields.  If dup_func is NULL,
     then data values will simply be copied.  This is likely to be
     usefull when data is not dynamically allocated.

     *Returned value:* a newly allocated hash.

 -- Function: lw6sys_hexa_serializer_t * lw6sys_hexa_serializer_new
          (lw6sys_context_t * SYS_CONTEXT, const char * HEXA_STRING)
     SYS_CONTEXT: global system context

     HEXA_STRING: an initialization string, can be NULL.

     Creates an hexa serializer object.  It can be initialized or not,
     if an initialization string is provided it must of course be valid
     hexadecimal ascii code, and all serialized content will simply be
     appended to it.

     *Return value:* a newly allocated object.

 -- Function: void lw6sys_hexa_serializer_free (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     Frees an hexa serializer object.

     *Return value:* none.

 -- Function: void lw6sys_hexa_serializer_rewind (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     Rewinds the serializer pointer, that is, make it point to start.
     Usefull before calling pop functions, when one wants to be sure to
     get the first object.

     *Return value:* none.

 -- Function: int lw6sys_hexa_serializer_eof (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     Tests wether we're at EOF. Usefull when one wants to know if
     there's still some data or if all objects have been correctly
     popped.

     *Return value:* 1 if at end of file, 0 if not.

 -- Function: char * lw6sys_hexa_serializer_as_string (lw6sys_context_t
          * SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     Exports the current content of the serializer as a string.  String
     can then safely be sent on the network, for instance.  String is
     copied from internal value, so it's safe to use it after serializer
     has been freed or modified.

     *Return value:* a newly allocated string, must be freed.

 -- Function: int lw6sys_hexa_serializer_push_int64 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          int64_t VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to push

     Pushes a 64 bit integer in the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_int32 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          int32_t VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to push

     Pushes a 32 bit integer in the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_int16 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          int16_t VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to push

     Pushes a 16 bit integer in the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_int8 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          int8_t VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to push

     Pushes an 8 bit integer in the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_float (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER, float
          VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to push

     Pushes a floating point value in the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_str (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER, const
          char * VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to push

     Pushes a string in the serializer object.  Note that the string is
     not directly copied in the serializer, instead all its characters
     are converted to their ASCII equivalent, then appended.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_xyz (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          lw6sys_xyz_t VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to push

     Pushes a lw6sys_xyz_t structure in the serializer object.  Calling
     this avoids calling push for 2 integers separately.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_whd (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          lw6sys_whd_t VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to push

     Pushes a lw6sys_whd_t structure in the serializer object.  Calling
     this avoids calling push for 2 integers separately.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_color (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          lw6sys_color_8_t VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to push

     Pushes a color structure in the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_int64 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          int64_t * VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to pop (returned value)

     Pops a 64 bit integer from the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_int32 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          int32_t * VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to pop (returned value)

     Pops a 32 bit integer from the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_int16 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          int16_t * VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to pop (returned value)

     Pops a 16 bit integer from the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_int8 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          int8_t * VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to pop (returned value)

     Pops an 8 bit integer from the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_float (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER, float
          * VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to pop (returned value)

     Pops a floating point value from the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_str (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER, char
          ** VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to pop (returned value)

     Pops a string from the serializer object.  The returned value is a
     newly allocated pointer, which must be freed, you don't need to
     provide a buffer, just a valid pointer on a NULL pointer.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_xyz (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          lw6sys_xyz_t * VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to pop (returned value)

     Pops a lw6sys_xyz_t structure from the serializer object.  Avoids
     calling two integer pops.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_whd (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          lw6sys_whd_t * VALUE)
     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to pop (returned value)

     Pops a lw6sys_whd_t structure from the serializer object.  Avoids
     calling two integer pops.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_color (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_hexa_serializer_t * HEXA_SERIALIZER,
          lw6sys_color_8_t * VALUE)
     SYS_CONTEXT: global system context

     HEXA_SERIALIZER: an hexa serializer object

     VALUE: value to pop (returned value)

     Pops a color from the serializer object.

     *Return value:* 1 if success, 0 if failure

 -- Function: int lw6sys_hexa_str_to_buf (lw6sys_context_t *
          SYS_CONTEXT, void * BUF, int SIZE, const char * STR)
     SYS_CONTEXT: global system context

     BUF: binary buffer to convert

     SIZE: binary buffer length

     STR: the source string

     Converts the stringified hexa representation of a string to its
     source binary buffer.  Buffer must be exactly 'strlen'(str)/2

     *Return value:* 1 on success

 -- Function: char * lw6sys_hexa_buf_to_str (lw6sys_context_t *
          SYS_CONTEXT, void * BUF, int SIZE)
     SYS_CONTEXT: global system context

     BUF: the buffer to stringify

     SIZE: the length of the buffer

     Transforms a binary buffer into its hexa representation.

     *Return value:* newly allocated string.

 -- Function: void * lw6sys_hexa_str_to_ptr (lw6sys_context_t *
          SYS_CONTEXT, const char * STR)
     SYS_CONTEXT: global system context

     STR: the string containing an hexa representation of pointer

     Transforms a string into a pointer, this is typically used to store
     pointers in temporary agnostic storage such as a database.  Beware
     not to use that to exchange data with other computers and/or use it
     for persistent data.  This is a high-risk function as it lets you
     do real dirty stuff but it really does save time compared to using
     a key returned by the database engine and then search this key in a
     user-space hash table.  Direct pointer access is definitely faster.

     *Return value:* the pointer, or NULL is str is invalid.

 -- Function: char * lw6sys_hexa_ptr_to_str (lw6sys_context_t *
          SYS_CONTEXT, void * PTR)
     SYS_CONTEXT: global system context

     PTR: pointer to convert into string representation

     Transforms a pointer into a string, this is typically used to store
     pointers in temporary agnostic storage such as a database.  Beware
     not to use that to exchange data with other computers and/or use it
     for persistent data.  This is a high-risk function as it lets you
     do real dirty stuff but it really does save time compared to using
     a key returned by the database engine and then search this key in a
     user-space hash table.  Direct pointer access is definitely faster.

     *Return value:* the string, can be NULL on errror, must be freed.

 -- Function: void lw6sys_history_init (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Initializes the history system.  Not initializing won't cause any
     segfault, but data will be inconsistent.

     *Return value:* none.

 -- Function: void lw6sys_history_register (lw6sys_context_t *
          SYS_CONTEXT, char * MSG)
     SYS_CONTEXT: global system context

     MSG: the message to register.

     Registers a message in the history log, that is, adds it.

     *Return value:* none.

 -- Function: char_ptr_t * lw6sys_history_get (lw6sys_context_t *
          SYS_CONTEXT, int64_t TIMEOUT)
     SYS_CONTEXT: global system context

     TIMEOUT: the message age limit.

     Get all the messages that are younger than timeout (in seconds).

     *Return value:* a pointer on string pointers.  May be NULL. Last
     pointer is NULL too, that's how you know the array is over.

 -- Function: void lw6sys_history_free (lw6sys_context_t * SYS_CONTEXT,
          char ** HISTORY)
     SYS_CONTEXT: global system context

     HISTORY: the data to free

     Frees a pointer returned by 'lw6sys_history_get'.

     *Return value:* none.

 -- Function: char * lw6sys_locale_to_utf8 (lw6sys_context_t *
          SYS_CONTEXT, const char * STRING)
     SYS_CONTEXT: global system context

     STRING: the string to convert

     Used to force strings into UTF-8 mode, this is basically to match
     the TTF font settings used when displaying stuff on OpenGL. Indeed,
     in this case, the standard _ gettext function won't work, we need
     to force UTF-8 mode.  If the locale is UTF-8, then function does
     nothing, but at least it's transparent usage won't hurt.

     *Returned value:* a newly allocated string, always in UTF-8 no
     matter what the locale is.

 -- Function: u_int16_t lw6sys_generate_id_16 (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Long 16-bit ID generator, calls the random function internally.  As
     usual, those are not perfect random numbers, however the function
     implementation emphasizes more on 'real randomness' rather than
     relying on performance.  Generating twice the same number should be
     fairly rare.

 -- Function: u_int32_t lw6sys_generate_id_32 (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Long 32-bit ID generator, calls the random function internally.  As
     usual, those are not perfect random numbers, however the function
     implementation emphasizes more on 'real randomness' rather than
     relying on performance.  Generating twice the same number should be
     fairly rare.

 -- Function: u_int64_t lw6sys_generate_id_64 (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Long 64-bit ID generator, calls the random function internally.  As
     usual, those are not perfect random numbers, however the function
     implementation emphasizes more on 'real randomness' rather than
     relying on performance.  Generating twice the same number should be
     fairly rare.

 -- Function: int lw6sys_check_id_16 (lw6sys_context_t * SYS_CONTEXT,
          u_int16_t ID_16)
     SYS_CONTEXT: global system context

     ID_16: the id to check

     Checks wether the given id is a valid 16-bit id.

     *Return value:* 1 if OK, 0 if not a valid id.

 -- Function: int lw6sys_check_id_32 (lw6sys_context_t * SYS_CONTEXT,
          u_int32_t ID_32)
     SYS_CONTEXT: global system context

     ID_32: the id to check

     Checks wether the given id is a valid 32-bit id.

     *Return value:* 1 if OK, 0 if not a valid id.

 -- Function: int lw6sys_check_id_64 (lw6sys_context_t * SYS_CONTEXT,
          u_int64_t ID_64)
     SYS_CONTEXT: global system context

     ID_64: the id to check

     Checks wether the given id is a valid 64-bit id.

     *Return value:* 1 if OK, 0 if not a valid id.

 -- Function: int lw6sys_check_id (lw6sys_context_t * SYS_CONTEXT,
          u_int64_t ID)
     SYS_CONTEXT: global system context

     ID: the id to check

     Checks wether the given id is a valid id (16, 32 or 64-bit).

     *Return value:* 1 if OK, 0 if not a valid id.

 -- Function: char * lw6sys_id_ltoa (lw6sys_context_t * SYS_CONTEXT,
          u_int64_t ID)
     SYS_CONTEXT: global system context

     ID: the id to convert

     Transform an id into its string representation.  Error checking is
     done, if the id is invalid, returned value is NULL. All ids (16, 32
     and 64-bit) are handled.

     *Return value:* a newly allocated string, might be NULL.

 -- Function: u_int64_t lw6sys_id_atol (lw6sys_context_t * SYS_CONTEXT,
          char * ID)
     SYS_CONTEXT: global system context

     ID: the id to convert

     Transform an id into a long integer.  Error checking is done, if
     the id is invalid, returned value is 0.  All ids (16, 32 and
     64-bit) are handled.

     *Return value:* the id as a long integer, 0 if incorrect source id.

 -- Function: char * lw6sys_keyword_as_key (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword to transform

     Transforms a keyword into a "key", that is, removes all heading
     dashes, switches to lowercase, and other stuff.  This is used
     internally to match options and config file parameters, for
     instance.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_keyword_as_arg (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword to transform

     Transforms a keyword into a command-line parameter to be matched.
     Does the same as 'lw6sys_keyword_as_key', and adds a "-" prefix.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_keyword_as_env (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     KEYWORD: the keyword to transform

     Transforms a keyword into the corresponding environment variable
     name.  It will uppercase the name, replace "-" by "_", and add a
     "LW6_" prefix.  "my-param" will become "LW6_MY_PARAM".

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_keyword_as_xml (lw6sys_context_t *
          SYS_CONTEXT, const char * KEYWORD)
     SYS_CONTEXT: global system context

     KEYWORD: the keyword to transform

     Transforms a keyword into the corresponding config file entry.  In
     practice, just the same as 'lw6sys_keyword_as_key'.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: lw6sys_list_t * lw6sys_list_new (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_free_func_t FREE_FUNC)
     SYS_CONTEXT: global system context

     FREE_FUNC: a callback which will be called on data when freeing the
     list

     Creates an empty list.  There's a difference between NULL and an
     empty list.  The empty list would (in Scheme) be '() whereas NULL
     corresponds to undefined "is not a list and will generate errors if
     you ever call list functions on it".

     *Return value:* a pointer to the created object, may be NULL.

 -- Function: void lw6sys_list_free (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t * LIST)
     SYS_CONTEXT: global system context

     LIST: the list to delete.

     Delete a list, this will cascade delete all the following items in
     the list.

     *Return value:* none.

 -- Function: lw6sys_list_t * lw6sys_list_next (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_t * LIST)
     SYS_CONTEXT: global system context

     LIST: the current position in the list

     It's safer to call this rather than dig right into the internals of
     the list.

     *Return value:* a new position in the list, may be NULL.

 -- Function: int lw6sys_list_is_empty (lw6sys_context_t * SYS_CONTEXT,
          const lw6sys_list_t * LIST)
     SYS_CONTEXT: global system context

     LIST: the list we want informations about

     Checks wether the list is empty or not.  Note that being empty and
     being NULL is not the same.  An empty list is a valid pointer on a
     list where there's no item, a NULL pointer is not a list at all.
     Do *NOT* call this function on NULL.

     *Return value:* 1 if empty, 0 if there is at list one item.

 -- Function: int lw6sys_list_length (lw6sys_context_t * SYS_CONTEXT,
          const lw6sys_list_t * LIST)
     SYS_CONTEXT: global system context

     LIST: the list we want informations about

     Calculates the length of the list.  This is a performance killer
     for lists are inadapted to this.  But it can still be usefull.

     *Return value:* the number of elements, 0 is none (empty list).

 -- Function: void lw6sys_list_map (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t * LIST, lw6sys_list_callback_func_t FUNC, void *
          FUNC_DATA)
     SYS_CONTEXT: global system context

     LIST: the list where elements will be taken

     FUNC: the function which will be executed

     FUNC_DATA: additionnal data to be passed to 'func'

     Executes a function on all list items.  The 'func_data' parameter
     allows you to pass extra values to the function, such as a file
     handler or any variable which can not be inferred from list item
     values, and you of course do not want to make global...  Not as
     convenient as a real "for each" construct as can be found in any
     modern langage, but does the job.  No return value, if you really
     want one, pass a structure in 'func_data' and modify something in
     it on success, failure, whatever.

     *Return value:* none.

 -- Function: void lw6sys_list_filter (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST, lw6sys_list_filter_func_t FUNC, void *
          FUNC_DATA)
     SYS_CONTEXT: global system context

     LIST: the list where elements will be taken

     FUNC: the function which will be executed

     FUNC_DATA: additionnal data to be passed to 'func'

     Executes a function on all list items and keeps only those for
     which the function returned non zero (true).  The 'func_data'
     parameter allows you to pass extra values to the function, such as
     a file handler or any variable which can not be inferred from list
     item values, and you of course do not want to make global...

     *Return value:* none.

 -- Function: void lw6sys_list_push_front (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_t ** LIST, void * DATA)
     SYS_CONTEXT: global system context

     LIST: a pointer to the list (pointer on pointer, read/write value)

     DATA: the data to be pushed

     Pushes data on the list.  The 'free_func' function is copied from
     the previous element.  The pointer on the list is changed "in
     place" (in/out).  Note that if there's a 'malloc' problem it might
     end-up being NULL... This should be rare but it *can* happen.  You
     cannot push something else than a pointer, pushing an int is a very
     bad idea.  Push a pointer on the integer, and ensure it's always
     there, or 'malloc' it and pass 'lw6sys_free_callback' when creating
     the list.  If you think you can cast an integer into a pointer,
     think 64-bit machines...

     *Return value:* none.

 -- Function: void * lw6sys_list_pop_front (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_t ** LIST)
     SYS_CONTEXT: global system context

     LIST: a pointer to the list (pointer on pointer, read/write value)

     Pops data from the list, the returned value is what was passed to
     list_push.  The pointer on the list is changed "in place" (in/out).
     When data is popped, that needs some freeing (i.e.  free_func was
     not NULL when creating the list) then it's the responsibility of
     the caller to free it when popping it.  One popped it's not freed,
     but it's out of the list scope.  Of course the lw6sys_list_t is
     freed, but not the data.  If you happen to store non-NULL data in
     your list, you can call this function without bothering calling
     'lw6sys_list_is_empty' and assume that when you get NULL, there's
     no data left.  At this stage, the list won't exist anymore BTW, you
     won't even need to free it.  The idea is: popping a list which has
     no elements left (empty list) destroys the list and returns NULL.

     *Return value:* a pointer on the popped data, whatever you pushed.

 -- Function: void lw6sys_list_push_back (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_t ** LIST, void * DATA)
     SYS_CONTEXT: global system context

     LIST: a pointer to the list (pointer on pointer, read/write value)

     DATA: the data to be pushed

     Pushes data on the list.  The 'free_func' function is copied from
     the previous element.  The pointer on the list is changed "in
     place" (in/out).  Note that if there's a 'malloc' problem it might
     end-up being NULL... This should be rare but it *can* happen.  You
     cannot push something else than a pointer, pushing an int is a very
     bad idea.  Push a pointer on the integer, and ensure it's always
     there, or 'malloc' it and pass 'lw6sys_free_callback' when creating
     the list.  If you think you can cast an integer into a pointer,
     think 64-bit machines...

     *Return value:* none.

 -- Function: void * lw6sys_list_pop_back (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_t ** LIST)
     SYS_CONTEXT: global system context

     LIST: a pointer to the list (pointer on pointer, read/write value)

     Pops data from the list, the returned value is what was passed to
     list_push.  The pointer on the list is changed "in place" (in/out).
     When data is popped, that needs some freeing (i.e.  free_func was
     not NULL when creating the list) then it's the responsibility of
     the caller to free it when popping it.  One popped it's not freed,
     but it's out of the list scope.  Of course the lw6sys_list_t is
     freed, but not the data.  If you happen to store non-NULL data in
     your list, you can call this function without bothering calling
     'lw6sys_list_is_empty' and assume that when you get NULL, there's
     no data left.  At this stage, the list won't exist anymore BTW, you
     won't even need to free it.  The idea is: popping a list which has
     no elements left (empty list) destroys the list and returns NULL.

     *Return value:* a pointer on the popped data, whatever you pushed.

 -- Function: void lw6sys_lifo_push (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST, void * DATA)
     SYS_CONTEXT: global system context

     LIST: a pointer to the list (pointer on pointer, read/write value)

     Pops data to a list, in last-in first-out mode (AKA LIFO). This is
     equivalent t 'lw6sys_list_push_front'.

     *Return value:* none.

 -- Function: void * lw6sys_lifo_pop (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST)
     SYS_CONTEXT: global system context

     LIST: a pointer to the list (pointer on pointer, read/write value)

     Pops the first element of a list, in last-in first-out mode (AKA
     LIFO). This is equivalent to 'lw6sys_list_pop_front'.

     *Return value:* a pointer on the popped data, whatever you pushed.

 -- Function: void lw6sys_fifo_push (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST, void * DATA)
     SYS_CONTEXT: global system context

     LIST: a pointer to the list (pointer on pointer, read/write value)

     Pops data to a list, in first-in first-out mode (AKA FIFO). This is
     equivalent t 'lw6sys_list_push_front'.

     *Return value:* none.

 -- Function: void * lw6sys_fifo_pop (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST)
     SYS_CONTEXT: global system context

     LIST: a pointer to the list (pointer on pointer, read/write value)

     Pops the first element of a list, in last-in first-out mode (AKA
     FIFO). This is equivalent to 'lw6sys_list_pop_back'.  It can be
     quite time-consuming on big lists.

     *Return value:* a pointer on the popped data, whatever you pushed.

 -- Function: lw6sys_list_t * lw6sys_list_dup (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_t * LIST, lw6sys_dup_func_t DUP_FUNC)
     SYS_CONTEXT: global system context

     LIST: the list to duplicate, can be NULL

     DUP_FUNC: the function which will be called to duplicate data

     Duplicates a list.  All data will be copied so that if the first
     list is deleted, the duplicated one is fine.  Addtionnally,
     dup_func will be called to filter all data, and possibly allocated
     new pointers if needed, for instance.  If dup_func is NULL, then
     data values will simply be copied.  This is likely to be usefull
     when data is not dynamically allocated.

     *Returned value:* a newly allocated list.

 -- Function: lw6sys_list_r_t * lw6sys_list_r_new (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_free_func_t FREE_FUNC)
     SYS_CONTEXT: global system context

     FREE_FUNC: a callback which will be called on data when freeing the
     list

     Creates an empty reentrant list.  This is different from a regular
     list in the sense that here the object is a holder with both a
     mutex and the list itself.

     *Return value:* a pointer to the created object, may be NULL.

 -- Function: void lw6sys_list_r_free (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_r_t * LIST_R)
     SYS_CONTEXT: global system context

     LIST_R: the list to delete.

     Delete a reentrant list, this will cascade delete all the items in
     the list.

     *Return value:* none.

 -- Function: int lw6sys_list_r_is_empty (lw6sys_context_t *
          SYS_CONTEXT, const lw6sys_list_r_t * LIST_R)
     SYS_CONTEXT: global system context

     LIST_R: the list we want informations about

     Checks wether the reentrant list is empty or not.  Note there's a
     slight difference with basic lists, here it can't / should not be
     NULL, as the list_r is really a list container.

     *Return value:* 1 if empty, 0 if there is at list one item.

 -- Function: int lw6sys_list_r_length (lw6sys_context_t * SYS_CONTEXT,
          const lw6sys_list_r_t * LIST_R)
     SYS_CONTEXT: global system context

     LIST_R: the list we want informations about

     Calculates the length of the reentrant list.  This is a performance
     killer for lists are inadapted to this.  But it can still be
     usefull.

     *Return value:* the number of elements, 0 is none (empty list).

 -- Function: void lw6sys_list_r_map (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_r_t * LIST_R, lw6sys_list_callback_func_t FUNC,
          void * FUNC_DATA)
     SYS_CONTEXT: global system context

     LIST_R: the list where elements will be taken

     FUNC: the function which will be executed

     FUNC_DATA: additionnal data to be passed to 'func'

     Executes a function on all reentrant list items.  This is a wrapper
     on 'lw6sys_list_map'.

     *Return value:* none.

 -- Function: void lw6sys_list_r_filter (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_r_t * LIST_R, lw6sys_list_filter_func_t FUNC, void
          * FUNC_DATA)
     SYS_CONTEXT: global system context

     LIST_R: the list where elements will be taken

     FUNC: the function which will be executed

     FUNC_DATA: additionnal data to be passed to 'func'

     Executes a function on all reentrant list items.  Ths is a wrapper
     on 'lw6sys_list_filter'.

     *Return value:* none.

 -- Function: void lw6sys_list_r_push_front (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_r_t * LIST_R, void * DATA)
     SYS_CONTEXT: global system context

     LIST_R: a pointer to the list (pointer on pointer, read/write
     value)

     DATA: the data to be pushed

     Wapper on lw6sys_list_push_front, reentrant version.

     *Return value:* none.

 -- Function: void * lw6sys_list_r_pop_front (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_r_t * LIST_R)
     SYS_CONTEXT: global system context

     Wrapper on lw6sys_list_pop_front, reentrant version.

     *Return value:* a pointer on the popped data, whatever you pushed.

 -- Function: void lw6sys_list_r_push_back (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_r_t * LIST_R, void * DATA)
     SYS_CONTEXT: global system context

     LIST_R: a pointer to the list (pointer on pointer, read/write
     value)

     DATA: the data to be pushed

     Wapper on lw6sys_list_push_back, reentrant version.

     *Return value:* none.

 -- Function: void * lw6sys_list_r_pop_back (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_r_t * LIST_R)
     SYS_CONTEXT: global system context

     Wrapper on lw6sys_list_pop_back, reentrant version.

     *Return value:* a pointer on the popped data, whatever you pushed.

 -- Function: void lw6sys_lifo_r_push (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_r_t * LIST_R, void * DATA)
     SYS_CONTEXT: global system context

     LIST_R: a pointer to the list (pointer on pointer, read/write
     value)

     DATA: the data to be pushed

     Wapper on lw6sys_lifo_r_push_, reentrant version.

     *Return value:* none.

 -- Function: void * lw6sys_lifo_r_pop (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_r_t * LIST_R)
     SYS_CONTEXT: global system context

     Wrapper on lw6sys_lifo_r_pop, reentrant version.

     *Return value:* a pointer on the popped data, whatever you pushed.

 -- Function: void lw6sys_fifo_r_push (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_r_t * LIST_R, void * DATA)
     SYS_CONTEXT: global system context

     LIST_R: a pointer to the list (pointer on pointer, read/write
     value)

     DATA: the data to be pushed

     Wapper on lw6sys_fifo_r_push, reentrant version.

     *Return value:* none.

 -- Function: void * lw6sys_fifo_r_pop (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_r_t * LIST_R)
     SYS_CONTEXT: global system context

     Wrapper on lw6sys_fifo_r_pop, reentrant version.

     *Return value:* a pointer on the popped data, whatever you pushed.

 -- Function: lw6sys_list_r_t * lw6sys_list_r_dup (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_r_t * LIST_R, lw6sys_dup_func_t
          DUP_FUNC)
     SYS_CONTEXT: global system context

     LIST_R: the reentrant list to duplicate

     DUP_FUNC: the function which will be called to duplicate data

     Duplicates a reentrant list.  This is a wrapper on
     'lw6sys_list_dup', but is reentrant and works on a list_r type.

     *Returned value:* a newly allocated reentrant list.

 -- Function: lw6sys_list_t * lw6sys_list_r_transfer_to
          (lw6sys_context_t * SYS_CONTEXT, lw6sys_list_r_t * LIST_R)
     SYS_CONTEXT: global system context

     LIST_R: the reentrant list to transfer

     Transfers the contents of a reentrant list to a regular list.
     Basically, this locks the list, extracts informations from it, then
     releases the lock and leaves the list_r empty.  This is convenient
     in multithreaded contexts, typical pattern is a thread that pushes
     items, then another thread does massive transfers and processes
     each item separately with local pops on the regular list.  This
     limits the amount of locking.

     *Returned value:* a standard list, must be freed.

 -- Function: void lw6sys_list_r_transfer_from (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_list_r_t * LIST_R, lw6sys_list_t ** LIST)
     SYS_CONTEXT: global system context

     LIST_R: the reentrant list where to put data

     LIST: the list to get data from

     Transfers the contents of a regular list to a reentrant list.
     Basically, this locks the list, then appends all contents from the
     source standard list, then releases the lock.  The source list
     pointer is set to an empty list, if it's NULL it means an error
     happened.  This is convenient in multithreaded contexts, typical
     pattern is a thread that pushes items in a bulked mode, this has
     the advantage of less lock/unlock, plus the side effect of having
     more atomicity, one can indeed garantee that a whole packet of
     items are sent at once.  There's no garantee on the order, you'd
     better sort them afterwards if order does matter, by default the
     function does what is fastest/easiest to do.

     *Returned value:* none, but check if *list is not null.

 -- Function: const char * lw6sys_log_errno_str (lw6sys_context_t *
          SYS_CONTEXT, int ERRNO_INT)
     SYS_CONTEXT: global system context

     ERRNO_INT: the error code, typically errno

     Convenience fonction which returns the "macro" corresponding to an
     errno code.  I find it easier to use this than bothering declaring
     a buffer for strerror_r...  Besides LW6b has its own error
     messages.  Wil never return NULL, if error does not exists just
     returns "?".

     *Return value:* static string, must not be freed

 -- Function: void lw6sys_log_set_file (lw6sys_context_t * SYS_CONTEXT,
          const char * FILENAME)
     SYS_CONTEXT: global system context

     FILENAME: the name of the log file.

     Sets up the log file.  Until you call this function, messages all
     logged to the default log file, as returned by the
     'lw6sys_get_default_log_file' function.

     *Return value:* void

 -- Function: void lw6sys_log_clear (lw6sys_context_t * SYS_CONTEXT,
          const char * FILENAME)
     SYS_CONTEXT: global system context

     FILENAME: the name of the log file.

     Clears the log file, this function would typically be called at the
     beginning of the program.  If filename is NULL, then the default
     log file is cleared.

     *Return value:* void

 -- Function: int lw6sys_log_set_dialog_timeout (lw6sys_context_t *
          SYS_CONTEXT, int TIMEOUT_SEC)
     SYS_CONTEXT: global system context

     TIMEOUT_SEC: number of seconds to wait before alert dialogs
     disappear

     By default, alert boxes will stay out forever unless one clicks on
     them, however, this parameter will force the dialog shutdown after
     some time.  Mostly used for testing, to allow tests being blocked
     on a dialog.

     *Return value:* 1 if timeout is supported on platform, 0 if not

 -- Function: void lw6sys_log (lw6sys_context_t * SYS_CONTEXT, int
          LEVEL_ID, const char * FILE, int LINE, const char * FUNC,
          const char * FMT, ...)
     SYS_CONTEXT: global system context

     LEVEL_ID: the log level to use.  Possible values are, by order,
     LW6SYS_LOG_ERROR_ID (0), LW6SYS_LOG_WARNING_ID (1),
     LW6SYS_LOG_NOTICE_ID (2), LW6SYS_LOG_INFO_ID (3),
     LW6SYS_LOG_DEBUG_ID (4) and LW6SYS_LOG_TMP_ID (5).

     FILE: the name of the source file where the function is called, one
     can use __FILE__

     LINE: the line in the source file where the function is called, one
     can use __LINE__

     FUNC: the name of the function where this log line was called, on
     can use __FUNCTION__

     FMT: a printf-like format string ...: printf-like arguments,
     corresponding to 'fmt'.

     This function is usually called with the first three arguments
     packed into a single macro.  For instance the 'LW6SYS_LOG_WARNING'
     macro expands and fills the first 3 args, so there's no need to
     type __FILE__ and __LINE__ again and again.  Note that this
     function will reset errno.  The idea is to call it whenever there's
     something to do with errno (if you deal with errno, it's a good
     habit to log it) then errno is cleared so that it won't interfere
     with next log messages.

 -- Function: void lw6sys_log_critical (lw6sys_context_t * SYS_CONTEXT,
          const char * FMT, ...)
     SYS_CONTEXT: global system context

     FMT: a printf-like format string ...: printf-like arguments,
     corresponding to 'fmt'.

     This function is a special log function which will dump
     informations on the console only, without opening any log file
     whatsoever.  The idea is that it's a "never fail" function.
     Additionnally, it will never return but quit the program.  This can
     be used as an ultimate emergency function, use it when the program
     won't run for sure, and displaying an immediate error message is
     the only issue.

 -- Function: int lw6sys_log_get_level (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Get the current log level.

 -- Function: void lw6sys_log_set_level (lw6sys_context_t * SYS_CONTEXT,
          int LEVEL)
     SYS_CONTEXT: global system context

     LEVEL: the log level, integer between 0 & 4.  4 is very verbose
     (debug), 0 displays errors only.

     Set the current log level.

 -- Function: int lw6sys_log_get_backtrace_mode (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Gets the current backtrace mode.

 -- Function: void lw6sys_log_set_backtrace_mode (lw6sys_context_t *
          SYS_CONTEXT, int BACKTRACE_MODE)
     SYS_CONTEXT: global system context

     BACKTRACE_MODE: the backtrace mode, LW6SYS_LOG_BACKTRACE_MODE_FULL
     or LW6SYS_LOG_BACKTRACE_MODE_FUNC.

     Sets the current backtrace mode.

     *Return value :* none

 -- Function: int lw6sys_log_get_console_state (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Get the console output state.  This is important, for instance to
     set the console "back in the state it was" after setting it on or
     off.

     *Return value:* 1 if enabled, 0 if not.

 -- Function: void lw6sys_log_set_console_state (lw6sys_context_t *
          SYS_CONTEXT, int STATE)
     SYS_CONTEXT: global system context

     STATE: 1 to activate console output, 0 to disable it.

     Enables or disables console output.  By console output, we
     basically mean stderr (and possibly stdout).  If console output is
     enabled (the default) all output is copied to stderr.  If it's
     disabled, only the log file will contain the information.

     *Return value:* none.

 -- Function: void lw6sys_math_poly_wy1y2s1 (lw6sys_context_t *
          SYS_CONTEXT, float * Y, float * S, float X, float W, float Y1,
          float Y2, float S1)
     SYS_CONTEXT: global system context

     Y: the return value (position, may be NULL)

     S: the return value (speed, may be NULL)

     X: the x parameter, the value to iterate on

     W: the width, that is, the x value after which output is constant

     Y1: the initial value, when v is s1 and x=0

     Y2: the target value, when v=0 and x>=w

     S1: the initial speed, that is dy/dx at x=0

     A function which can be used to implement smooth moving.  It will
     extrapolate, for values of x>=0, an y position with a continuous
     derivate (dy/dx is continuous, function is 2nd order polynom) and
     which ends up at x=w with a constant value, that is dy/dx=v=0.
     Typically an item set with an initial speed of v with this function

 -- Function: float lw6sys_math_angle_360 (lw6sys_context_t *
          SYS_CONTEXT, int X, int Y)
     SYS_CONTEXT: global system context

     X: x coordinate

     Y: y coordinate

     This is a wrapper over the standard 'atan' function which will
     handle internally the special x == 0 case and the various
     positive/negative values of 'x' and 'y'.

     *Return value:* the angle, in degrees

 -- Function: float lw6sys_math_heartbeat (lw6sys_context_t *
          SYS_CONTEXT, int64_t X, int PERIOD, float Y1, float Y2)
     SYS_CONTEXT: global system context

     X: the parameter (typically a timestamp)

     PERIOD: the period (typically something like 1000 milliseconds)

     Y1: the low value (heart at rest)

     Y2: the high value (when bumping)

     A heartbeat function, typically usefull to power up eye-candy, but
     it could do something else.

 -- Function: int lw6sys_math_blink (lw6sys_context_t * SYS_CONTEXT,
          int64_t X, int PERIOD)
     SYS_CONTEXT: global system context

     X: the parameter (typically a timestamp)

     PERIOD: the period (typically something like 1000 milliseconds)

     This function will alternatively return 1 or 0, usefull to handle
     blinking for instance.

     *Return value:* 0 or 1

 -- Function: float lw6sys_math_lin2log (lw6sys_context_t * SYS_CONTEXT,
          int LIN_VALUE, int BASE)
     SYS_CONTEXT: global system context

     LIN_VALUE: value on a linear scale

     BASE: the base to use, 10 for decibel-like scale

     Converts a linar-scale value to a logarithmic one.  The scale is
     done so that base in linear mode is base in scaled mode, and it
     uses a log-base conversion, so that with a base 10 it behaves the
     way the decibel sound-volume unit works.

     *Return value:* value on a logarithmic scale.

 -- Function: int lw6sys_math_log2lin (lw6sys_context_t * SYS_CONTEXT,
          float LOG_VALUE, int BASE)
     SYS_CONTEXT: global system context

     BASE: the base to use, 10 for decibel-like scale

     Converts a linar-scale value to a logarithmic one.  The scale is
     done so that 10 in linear mode is 10 in scaled mode, and it uses a
     log-base conversion, so that with a base 10 it behaves the way the
     decibel sound-volume unit works.

     *Return value:* value on a linear scale.

 -- Function: float lw6sys_math_deg2rad (float DEG)
     DEG: angle in degrees

     Converts an angle from degrees to radians.

     *Return value:* angle in radians.

 -- Function: float lw6sys_math_rad2deg (float RAD)
     RAD: angle in radians

     Converts an angle from radians to degrees.

     *Return value:* angle in degrees.

 -- Function: void * lw6sys_malloc (lw6sys_context_t * SYS_CONTEXT, int
          SIZE, const char * FILE, int LINE, const char * FUNC)
     SYS_CONTEXT: global system context

     SIZE: number of bytes to allocate.

     FILE: name of the file calling the function, use '__FILE__'

     LINE: line in the file calling the function, use '__LINE__'

     FUNC: name of the caller function, use '__FUNCTION__'

     This is a wrapper over the standard 'malloc' function.
     Additionnally it will keep track of the call with an internal
     program-wide counter, thus enabling memory leak checks.  You should
     not use this function directly but use the macro 'LW6SYS_MALLOC'
     which has the same syntax, without the last two parameters, which
     are automatically provided by macro expansion.

     *Return value:* the newly allocated pointer.  Data is not
     initialized.

 -- Function: void * lw6sys_calloc (lw6sys_context_t * SYS_CONTEXT, int
          SIZE, const char * FILE, int LINE, const char * FUNC)
     SYS_CONTEXT: global system context

     SIZE: number of bytes to allocate.

     FILE: name of the file calling the function, use '__FILE__'

     LINE: line in the file calling the function, use '__LINE__'

     FUNC: name of the caller function, use '__FUNCTION__'

     This is a wrapper over the standard 'calloc' function.
     Additionnally it will keep track of the call with an internal
     program-wide counter, thus enabling memory leak checks.  You should
     not use this function directly but use the macro 'LW6SYS_CALLOC'
     which has the same syntax, without the last two parameters, which
     are automatically provided by macro expansion.

     *Return value:* the newly allocated pointer.  Data is filled with
     zeros.

 -- Function: void * lw6sys_realloc (lw6sys_context_t * SYS_CONTEXT,
          void * PTR, int SIZE, const char * FILE, int LINE, const char
          * FUNC)
     SYS_CONTEXT: global system context

     PTR: the pointer to reallocate.

     SIZE: number of bytes to allocate.

     FILE: name of the file calling the function, use '__FILE__'

     LINE: line in the file calling the function, use '__LINE__'

     FUNC: name of the caller function, use '__FUNCTION__'

     This is a wrapper over the standard 'realloc' function.  You should
     not use this function directly but use the macro 'LW6SYS_REALLOC'
     which has the same syntax, without the last two parameters, which
     are automatically provided by macro expansion.

     *Return value:* the newly allocated pointer.

 -- Function: void lw6sys_free (lw6sys_context_t * SYS_CONTEXT, void *
          PTR, const char * FILE, int LINE, const char * FUNC)
     SYS_CONTEXT: global system context

     PTR: the pointer to free.

     FILE: name of the file calling the function, use '__FILE__'

     LINE: line in the file calling the function, use '__LINE__'

     FUNC: name of the caller function, use '__FUNCTION__'

     This is a wrapper over the standard 'free' function.  Additionnally
     it will keep track of the call with an internal program-wide
     counter, thus enabling memory leak checks.  You should not use this
     function directly but use the macro 'LW6SYS_FREE' which has the
     same syntax, without the last two parameters, which are
     automatically provided by macro expansion.

     *Return value:* none.

 -- Function: void lw6sys_free_callback (lw6sys_context_t * SYS_CONTEXT,
          void * PTR)
     SYS_CONTEXT: global system context

     PTR: the pointer to free.

     This is a callback to be used when the 'lw6sys_free' does not fit.
     A good example is a list, which, to free its elements, requires you
     to provide a callback that only takes 1 arg, the pointer to free.
     Problem, 'lw6sys_free' takes 3 args.  And the 'LW6SYS_FREE' macro
     is not usable in such a context.  And you can't use standard 'free'
     either for it would mess up the 'malloc' / 'free' automatical count
     which is so convenient to track memory leaks.  So this callback is
     here, it's only drawback is that in case of an error, the error
     will not be reported with the real file and line parameters.  It's
     still better than nothing.

     *Return value:* none.

 -- Function: int lw6sys_megabytes_available (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Gives a raw approximation of available memory, in megabytes.  Value
     is to be taken with distance, but it can give good hints when
     system is running short of ressources.

     *Return value:* number of megabytes (physical memory) available.

 -- Function: int lw6sys_is_big_endian (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Checks the endianess of the machine.  PPC is big endian, for
     instance.

     *Return value:* 1 if system is big endian, 0 if little endian.

 -- Function: int lw6sys_is_little_endian (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Checks the endianess of the machine.  x86 is little endian, for
     instance.

     *Return value:* 1 if system is little endian, 0 if big endian.

 -- Function: int lw6sys_check_types_size (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Checks of common types and usefull structures, this is a debugging
     function which helps finding compiler strange behaviors and
     programmer's bad intuitions.

     *Return value:* 1 if everything is OK, 0 if error.

 -- Function: lw6sys_mutex_t * lw6sys_mutex_create (lw6sys_context_t *
          SYS_CONTEXT, const char * FILE, int LINE, const char * FUNC)
     SYS_CONTEXT: global system context

     FILE: the name of the source file where the function is called, one
     can use __FILE__

     LINE: the line in the source file where the function is called, one
     can use __LINE__

     FUNC: the name of the function where this log line was called, on
     can use __FUNCTION__

     Creates a mutex object.

     *Return value:* newly allocated pointer.

 -- Function: void lw6sys_mutex_destroy (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_mutex_t * MUTEX, const char * FILE, int LINE, const
          char * FUNC)
     SYS_CONTEXT: global system context

     MUTEX: the mutex to destroy.

     FILE: the name of the source file where the function is called, one
     can use __FILE__

     LINE: the line in the source file where the function is called, one
     can use __LINE__

     FUNC: the name of the function where this log line was called, on
     can use __FUNCTION__

     Destroys a mutex object.

     *Return value:* none.

 -- Function: int lw6sys_mutex_lock (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_mutex_t * MUTEX, const char * FILE, int LINE, const
          char * FUNC)
     SYS_CONTEXT: global system context

     MUTEX: the mutex to use

     FILE: the name of the source file where the function is called, one
     can use __FILE__

     LINE: the line in the source file where the function is called, one
     can use __LINE__

     FUNC: the name of the function where this log line was called, on
     can use __FUNCTION__

     Locks the mutex.  Note that this should never fail unless there's a
     serious initialization problem, instead, function will wait forever
     until mutex is released.

     *Return value:* 1 if success, 0 if failure.

 -- Function: int lw6sys_mutex_trylock (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_mutex_t * MUTEX, const char * FILE, int LINE, const
          char * FUNC)
     SYS_CONTEXT: global system context

     MUTEX: the mutex to use

     FILE: the name of the source file where the function is called, one
     can use __FILE__

     LINE: the line in the source file where the function is called, one
     can use __LINE__

     FUNC: the name of the function where this log line was called, on
     can use __FUNCTION__

     Tries to locks the mutex.  That is, tells wether mutex can be
     locked immediately or not.  Note that this does not mean there's
     100% chance next call to lock will terminated immediately, since
     lock can still be acquired by another thread.

     *Return value:* 1 if mutex unlocked, 0 if locked or error.

 -- Function: int lw6sys_mutex_unlock (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_mutex_t * MUTEX, const char * FILE, int LINE, const
          char * FUNC)
     SYS_CONTEXT: global system context

     MUTEX: the mutex to use

     FILE: the name of the source file where the function is called, one
     can use __FILE__

     LINE: the line in the source file where the function is called, one
     can use __LINE__

     FUNC: the name of the function where this log line was called, on
     can use __FUNCTION__

     Unlocks a mutex.

     *Return value:* 1 if sucess, 0 if error.

 -- Function: int lw6sys_get_mutex_lock_count (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns how many mutexes have been locked since program start.
     Usefull for sanity checking when debugging.

     *Return value:* number of calls to lock

 -- Function: int lw6sys_get_mutex_unlock_count (lw6sys_context_t *
          SYS_CONTEXT)

     Returns how many mutexes have been unlocked since program start.
     Usefull for sanity checking when debugging.

     *Return value:* number of calls to unlock

 -- Function: int lw6sys_check_mutex_count (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Checks wether unlock has been called as many times as lock.
     Usefull for sanity checking when debugging.

     *Return value:* 1 if OK, 0 if inconsistency.

 -- Function: int lw6sys_true ()

     Function which returns always true, that is, something different
     than 0.

 -- Function: int lw6sys_false ()

     Function which returns always false, that is, 0.  This can seem
     totally useless but it does have some utility.  It's used for
     instance to "fool" the compiler and force it to compile and link
     functions in binaries, so that, afterwards, dynamically loaded .so
     files can find in the main binary some functions which would
     otherwise be stripped during the final link.

 -- Function: int lw6sys_openmp_get_num_procs (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Wrapper on 'omp_get_num_procs' the advantage of this is that it's
     always defined, wether OpenMP supported is compiled in or not, will
     returned 1 if no OpenMP support.

     *Return value:* number of procs

 -- Function: char * lw6sys_get_cwd (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the current working directory (absolute path).

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_user_dir (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default user directory.  Note that this value is not
     static, it can depend, for instance, of the environment variable
     'HOME'.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_config_file (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default config file.  Note that this value is not
     static, it can depend, for instance, of the environment variable
     'HOME'.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_log_file (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default log file.  Note that this value is not static,
     it can depend, for instance, of the environment variable 'HOME'.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_prefix (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default prefix, could be /usr/local for instance.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_mod_dir (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default module directory (dynamically loaded
     libraries).

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_data_dir (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default data directory.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_music_dir (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default music directory.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_music_path (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default music path, which can be composed of several
     directories.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_map_dir (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default map directory.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_map_path (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default map path, which can be composed of several
     directories.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_default_script_file (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the default script file.

     *Return value:* a newly allocated string.

 -- Function: void lw6sys_options_log_defaults (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Logs all default values to log file.  Usefull for debugging, to
     know where the program is searching for its informations.

 -- Function: char * lw6sys_get_run_dir (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the binary directory, that is, the directory the binary is
     stored in.  This is calculated dynamically, by interpreting
     command-line arguments.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_user_dir (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the user dir, taking in account command-line and
     environment variables.  However config file content has no impact
     on the result.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_config_file (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the config file, taking in account command-line and
     environment variables.  However config file content has no impact
     on the result.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_log_file (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the log file, taking in account command-line and
     environment variables.  However config file content has no impact
     on the result.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_prefix (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the prefix, taking in account command-line and environment
     variables.  However config file content has no impact on the
     result.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_mod_dir (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the mod dir (modules, shared .so), taking in account
     command-line and environment variables.  However config file
     content has no impact on the result.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_data_dir (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the data dir, taking in account command-line and
     environment variables.  However config file content has no impact
     on the result.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_music_dir (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the music dir, taking in account command-line and
     environment variables.  However config file content has no impact
     on the result.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_music_path (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the music path, taking in account command-line and
     environment variables.  However config file content has no impact
     on the result.  Music path can contain several directories.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_map_dir (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the map dir, taking in account command-line and environment
     variables.  However config file content has no impact on the
     result.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_map_path (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the map path, taking in account command-line and
     environment variables.  However config file content has no impact
     on the result.  Map path can contain several directories.

     *Return value:* a newly allocated string.

 -- Function: char * lw6sys_get_script_file (lw6sys_context_t *
          SYS_CONTEXT, int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Returns the script file, taking in account command-line and
     environment variables.  However config file content has no impact
     on the result.

     *Return value:* a newly allocated string.

 -- Function: void lw6sys_options_log (lw6sys_context_t * SYS_CONTEXT,
          int ARGC, const char * [] ARGV)
     SYS_CONTEXT: global system context

     ARGC: argc, number of arguments, as given to 'main'

     ARGV: argv, pointer to arguments, as given to 'main'

     Logs all the main options values which are not config-file
     dependant but depend on built-in defaults, command-line arguments
     and environment variables.  Usefull to debug and know where the
     program is searching for things.

 -- Function: int lw6sys_file_exists (lw6sys_context_t * SYS_CONTEXT,
          const char * FILENAME)
     SYS_CONTEXT: global system context

     FILENAME: the file to test

     Tests the existence of a file on the filesystem.  File is
     considered to exists if it's at least readable.

     *Return value:* 1 if OK, 0 if file doesn't exist or can't be read.

 -- Function: int lw6sys_dir_exists (lw6sys_context_t * SYS_CONTEXT,
          const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory to test

     Tests the existence of a directory on the filesystem.

     *Return value:* 1 if OK, 0 if directory doesn't exist.

 -- Function: int lw6sys_dir_exists_with_readme (lw6sys_context_t *
          SYS_CONTEXT, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory to test

     Tests the existence of a directory on the filesystem, will also
     validate that it contains a README or readme.txt file.

     *Return value:* 1 if OK, 0 if directory doesn't exist.

 -- Function: int lw6sys_dir_exists_with_readme_containing_text
          (lw6sys_context_t * SYS_CONTEXT, const char * DIRNAME, const
          char * NEEDLE)
     SYS_CONTEXT: global system context

     DIRNAME: the directory to test

     NEEDLE: string to search, can be NULL

     Tests the existence of a directory on the filesystem, with a README
     or readme.txt file, which contains the string needle.

     *Return value:* 1 if OK, 0 if directory doesn't exist.

 -- Function: int lw6sys_create_dir (lw6sys_context_t * SYS_CONTEXT,
          const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory to create

     Creates a directory, performing sanity checks such as verifying the
     directory really exists after being created.

     *Return value:* 1 if OK, 0 if error.

 -- Function: int lw6sys_create_dir_silent (lw6sys_context_t *
          SYS_CONTEXT, const char * DIRNAME)
     SYS_CONTEXT: global system context

     DIRNAME: the directory to create

     Creates a directory like 'lw6sys_create_dir' but this function is
     silent in the sense that it won't log any error.  Usefull to create
     the log directory itself, for instance, and avoid infinite loops on
     error.

     *Return value:* 1 if OK, 0 if error.

 -- Function: char * lw6sys_path_add_slash (lw6sys_context_t *
          SYS_CONTEXT, const char * PATH)
     SYS_CONTEXT: global system context

     PATH: a path

     Adds a slash, or in a general manner, a directory separator, at the
     end of a path, if needed.  So /foo/bar will become /foo/bar/ but
     /bar/foo/ will remain /bar/foo/.

     *Return value:* a newly allocated string, must be freed.

 -- Function: char * lw6sys_path_strip_slash (lw6sys_context_t *
          SYS_CONTEXT, const char * PATH)
     SYS_CONTEXT: global system context

     PATH: a path

     Strips the slash, or in a general manner, the directory separator,
     at the end of a path, if needed.  So /foo/bar/ will become /foo/bar
     but /bar/foo will remain /bar/foo.

     *Return value:* a newly allocated string, must be freed.

 -- Function: char * lw6sys_path_concat (lw6sys_context_t * SYS_CONTEXT,
          const char * PATH1, const char * PATH2)
     SYS_CONTEXT: global system context

     PATH1: left part of the path

     PATH2: right part of the path

     Concatenates 2 parts of a path.  Function will try to avoid stupid
     "double-slash" when concatenating /foo/ with /bar/ and conversely
     insert a directory separator when concatenating /foo with bar/.

     *Return value:* a newly allocated string, must be freed.

 -- Function: lw6sys_list_t * lw6sys_path_split (lw6sys_context_t *
          SYS_CONTEXT, const char * PATH)
     SYS_CONTEXT: global system context

     PATH: a path

     Splits a path into all its parts.  For instance /boo/bar/foo2/bar2
     returns a 4 elements list.  This is more than a plain split, for
     heading and tailing slashes will be ignored, and various path
     separators will be interpreted (depends on platform).

     *Return value:* a list containing 0-terminated strings.

 -- Function: char * lw6sys_path_file_only (lw6sys_context_t *
          SYS_CONTEXT, const char * PATH)
     SYS_CONTEXT: global system context

     PATH: a path

     Returns the file name only, without heading directories.

     *Return value:* file name, must be freed

 -- Function: int lw6sys_path_is_relative (lw6sys_context_t *
          SYS_CONTEXT, const char * PATH)
     SYS_CONTEXT: global system context

     PATH: a path

     Checks wether a path is relative or absolute.

     *Return value:* 1 if relative, 0 if absolute.

 -- Function: int lw6sys_path_is_cwd (lw6sys_context_t * SYS_CONTEXT,
          const char * PATH)
     SYS_CONTEXT: global system context

     PATH: a path

     Checks wether a path is "."  or not.  Will also trap "" and "./".

     *Return value:* 1 if relative, 0 if absolute.

 -- Function: char * lw6sys_path_parent (lw6sys_context_t * SYS_CONTEXT,
          const char * PATH)
     SYS_CONTEXT: global system context

     PATH: a path

     Returns the parent path.  That will return /foo when given /foo/bar
     in input.

     *Return value:* a newly allocated string, must be freed.

 -- Function: char * lw6sys_path_unparent (lw6sys_context_t *
          SYS_CONTEXT, const char * PATH)
     SYS_CONTEXT: global system context

     PATH: a path

     Given the ../foo/bar path, will return foo/bar.  Usefull to get rid
     of heading ../ when a path is known to start with it.

     *Return value:* a newly allocated string, must be freed.

 -- Function: char * lw6sys_path_unparent_no_malloc (lw6sys_context_t *
          SYS_CONTEXT, char * PATH)
     SYS_CONTEXT: global system context

     PATH: a path

     Given the ../foo/bar path, will return foo/bar.  Usefull to get rid
     of heading ../ when a path is known to start with it.  This is
     different from 'lw6sys_path_unparent' just because the result is
     not dynamically allocated and copied from source.

     *Return value:* a pointer which points somewhere within the string
     passed as an argument.

 -- Function: lw6sys_list_t * lw6sys_dir_list (lw6sys_context_t *
          SYS_CONTEXT, const char * DIR, lw6sys_dir_list_filter_func_t
          FILTER_FUNC, void * FUNC_DATA, int * N)
     SYS_CONTEXT: global system context

     DIR: the path of the directory to list

     FILTER_FUNC: a function which will filter entries, can be NULL

     FUNC_DATA: additionnal data passed to filter_func

     N: will contain the number of items found

     This list a directory.  The filter will be passed the file path as
     an argument.  If it returns 1, the file is kept, if it returns 0
     it's suppressed from the list.

     *Return value:* a list containing strings (file paths).

 -- Function: lw6sys_list_t * lw6sys_path_list (lw6sys_context_t *
          SYS_CONTEXT, const char * PATH, lw6sys_dir_list_filter_func_t
          FILTER_FUNC, void * FUNC_DATA, int * N)
     SYS_CONTEXT: global system context

     PATH: the path of the path to list

     FILTER_FUNC: a function which will filter entries, can be NULL

     FUNC_DATA: additionnal data passed to filter_func

     N: will contain the number of items found

     This list a directory.  By path we mean here a list of separated
     directories, separated by : for instance.  The filter will be
     passed the file path as an argument.  If it returns 1, the file is
     kept, if it returns 0 it's suppressed from the list.  It's like
     performing a call to 'lw6sys_dir_list' on each of the path members.

     *Return value:* a list containing strings (file paths).

 -- Function: char * lw6sys_find_in_dir_and_path (lw6sys_context_t *
          SYS_CONTEXT, const char * DIR, const char * PATH, const char *
          FILE)
     SYS_CONTEXT: global system context

     DIR: a directory, when to search the file first

     PATH: the path to search too, a separated list of dirs

     FILE: the filename to search for

     Tries to find a file in the given paths.  The function is typically
     used to find music files.  First it tries to find the file in dir,
     then it tries to find it in each dir of path.  'file' must be only
     a file name and not contain any directory.  The function will use
     the filename only anyway.

     *Return value:* the full path of the found file.

 -- Function: void lw6sys_print_xml_header (lw6sys_context_t *
          SYS_CONTEXT, FILE * F, char * COMMENT)
     SYS_CONTEXT: global system context

     F: file to output content to

     Prints a standard Liquid War compliant XML header in the given
     file.

     *Return value:* none.

 -- Function: void lw6sys_print_xml_footer (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to output content to

     Prints a standard Liquid War 6 compliant XML footer in the given
     file.

     *Return value:* none.

 -- Function: int lw6sys_process_is_fully_supported (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Tells wether functions related to fork and pids are likely to work
     allright or not.  Typically, those functions will return false (0)
     systematically if called on a platform that does not support them
     fully.  In practice this is only for a few tests, so it's not that
     bad if it does not really work.  Would be better if, but well, it's
     OK.

     *Return value:* 1 if supported, 0 if not.

 -- Function: u_int64_t lw6sys_process_fork_and_call (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_fork_func_t FUNC, void * DATA)
     SYS_CONTEXT: global system context

     DATA: pointer on arbitrary data used by func

     This is not a standard fork function, it will return to the caller
     (parent) with something >0 if a child has been created, or 0 if
     failed.  On the child it will launch the callback func, run it and
     exit right away.

     *Return value:* a process ID on success, 0 on failure.

 -- Function: int lw6sys_process_kill_1_9 (lw6sys_context_t *
          SYS_CONTEXT, u_int64_t PID)
     SYS_CONTEXT: global system context

     PID: pid to kill

     Kills a process with the given PID. The kill will first use a
     signal 1 SIGTERM the a signal 9 SIGKILL. This is mostly for
     testing, the idea is to be sure to vaccum after we're done.  We use
     64-bit for PIDs, yes, they are very likely 32 only, but had to
     choose (and pid_t is a pain because for logging one would needed to
     check the length before calling printf like functions...).

     *Return value:* 1 on success, 0 if failed

 -- Function: int lw6sys_profiler_check (lw6sys_context_t * SYS_CONTEXT,
          int VERBOSE)
     SYS_CONTEXT: global system context

     VERBOSE: wether to display informations on the console

     Checks wether Google Profiler support has been built, and if it's
     set, outputs the log file.  If CPUPROFILE is defined but binary has
     no support for it, will display a warning message.

     *Return value:* 1 if google profile enabled and activated, 0 if not

 -- Function: void lw6sys_progress_bind (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_progress_t * PROGRESS, float * VALUE)
     SYS_CONTEXT: global system context

     PROGRESS: the progress struct to initialize

     VALUE: the value to point to

     Sets a progress struct to default values, that is, ranging from
     0.0f to 1.0f, does not touch the value.

     *Return value:* none.

 -- Function: void lw6sys_progress_default (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_progress_t * PROGRESS, float * VALUE)
     SYS_CONTEXT: global system context

     PROGRESS: the progress struct to initialize

     VALUE: the value to point to

     Sets a progress struct to default values, that is, ranging from
     0.0f to 1.0f.  This function won't touch the value, one needs to
     call begin or update or end to do that.

     *Return value:* none.

 -- Function: void lw6sys_progress_update (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_progress_t * PROGRESS, int MIN, int MAX,
          int VALUE)
     SYS_CONTEXT: global system context

     PROGRESS: the progress struct to update

     MIN: the min value

     MAX: the max value

     VALUE: the current value

     Updates a progress struct.  This is typically the function used by
     a callback to show the progress of a process.  Note that this is
     note an initializer.  Rather, the progress struct was initialized
     before, and this call is done in a loop with min being 0, max being
     the last value in the loop, and value the current index in the
     loop.  NULL pointers correctly handled internally, so call this
     with any parameters, it's safe.

     *Return value:* none.

 -- Function: void lw6sys_progress_split (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_progress_t * PROGRESS1, lw6sys_progress_t
          * PROGRESS2, lw6sys_progress_t * PROGRESS_SRC)
     SYS_CONTEXT: global system context

     PROGRESS1: the first part of the splitted progress

     PROGRESS2: the second part of the splitted progress

     PROGRESS_SRC: the progress to split

     Utility function to split a progress struct, that is, if a progress
     was ranging from a to b, make 2 progress structs, ranging from a to
     c and from c to b, c being between a and b.

     *Return value:* none

 -- Function: void lw6sys_progress_split_here (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_progress_t * PROGRESS1, lw6sys_progress_t
          * PROGRESS2, lw6sys_progress_t * PROGRESS_SRC, float HERE)
     SYS_CONTEXT: global system context

     PROGRESS1: the first part of the splitted progress

     PROGRESS2: the second part of the splitted progress

     PROGRESS_SRC: the progress to split

     HERE: where to split

     Utility function to split a progress struct, that is, if a progress
     was ranging from a to b, make 2 progress structs, ranging from a to
     c and from c to b, c being between a and b.  The here value
     controls what c is.  If here=0, then c=a.  If here=1, then c=b.

     *Return value:* none

 -- Function: void lw6sys_progress_split3 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_progress_t * PROGRESS1, lw6sys_progress_t
          * PROGRESS2, lw6sys_progress_t * PROGRESS3, lw6sys_progress_t
          * PROGRESS_SRC)
     SYS_CONTEXT: global system context

     PROGRESS1: the first part of the splitted progress

     PROGRESS2: the second part of the splitted progress

     PROGRESS3: the third part of the splitted progress

     PROGRESS_SRC: the progress to split

     Utility function to split a progress struct, this one will split it
     into 3 equal parts.

     *Return value:* none

 -- Function: void lw6sys_progress_split4 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_progress_t * PROGRESS1, lw6sys_progress_t
          * PROGRESS2, lw6sys_progress_t * PROGRESS3, lw6sys_progress_t
          * PROGRESS4, lw6sys_progress_t * PROGRESS_SRC)
     SYS_CONTEXT: global system context

     PROGRESS1: the first part of the splitted progress

     PROGRESS2: the second part of the splitted progress

     PROGRESS3: the third part of the splitted progress

     PROGRESS4: the fourth part of the splitted progress

     PROGRESS_SRC: the progress to split

     Utility function to split a progress struct, this one will split it
     into 4 equal parts.

     *Return value:* none

 -- Function: void lw6sys_progress_split5 (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_progress_t * PROGRESS1, lw6sys_progress_t
          * PROGRESS2, lw6sys_progress_t * PROGRESS3, lw6sys_progress_t
          * PROGRESS4, lw6sys_progress_t * PROGRESS5, lw6sys_progress_t
          * PROGRESS_SRC)
     SYS_CONTEXT: global system context

     PROGRESS1: the first part of the splitted progress

     PROGRESS2: the second part of the splitted progress

     PROGRESS3: the third part of the splitted progress

     PROGRESS4: the fourth part of the splitted progress

     PROGRESS5: the fourth part of the splitted progress

     PROGRESS_SRC: the progress to split

     Utility function to split a progress struct, this one will split it
     into 5 equal parts.

     *Return value:* none

 -- Function: void lw6sys_progress_begin (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     PROGRESS: the progress to update

     Sets the progress to its min value, NULL values correctly handled.

     *Return value:* none

 -- Function: void lw6sys_progress_half (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     PROGRESS: the progress to update

     Sets the progress to the average between min and max, NULL values
     correctly handled.

     *Return value:* none

 -- Function: void lw6sys_progress_end (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_progress_t * PROGRESS)
     SYS_CONTEXT: global system context

     PROGRESS: the progress to update

     Sets the progress to its max value, NULL values correctly handled.

     *Return value:* none

 -- Function: u_int32_t lw6sys_random (lw6sys_context_t * SYS_CONTEXT,
          u_int32_t RANGE)
     SYS_CONTEXT: global system context

     RANGE: the high limit for random generated numbers.  If you want
     random numbers between 0 and 5, set this to 6.

     Wrapper over standard random function.  This one is thread safe.
     This idea is not to provide cryptographic-proof random numbers,
     rather generate sequences which are random enough to generate
     unique server ids and such things.  The function is initialized on
     its first call, and results depend on timestamp, host name, user
     name, and memory available.

 -- Function: float lw6sys_random_float (lw6sys_context_t * SYS_CONTEXT,
          float MIN, float MAX)
     SYS_CONTEXT: global system context

     MIN: the min value, as a float

     MAX: the max value, as a float

     Returns a random float number between min & max.  Can be equal to
     min or max.

 -- Function: int lw6sys_sdl_register (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Function used to avoid initializing SDL several times in a program.
     AFAIK Allegro has a 'was_init' function, but SDL doesn't.  With
     this function - which every LW6 sub-module should use - one can
     know globally, for the whole program, wether SDL has been
     initialized or not.  Note that this function uses the global system
     context, and can therefore be buggy when used in multithreaded /
     reentrant mode.  So in some cases, that is, with two different
     contexts, SDL could be called twice.  This is a limitation of
     current SDL implementations, should it have a per-thread /
     per-handler context, the problem would be solved.  Fundamentally,
     the idea is that SDL does have a global static state, you've been
     warned.

 -- Function: int lw6sys_sdl_unregister (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Call this whenever you are done with SDL and exit it, so that the
     'lw6sys_sdl_register' function works correctly.

     *Return value:* 1 if SDL needs to be unregistered, that is, if it
     has already been initialized, else 0.

 -- Function: void lw6sys_serialize_int64 (lw6sys_context_t *
          SYS_CONTEXT, unsigned char * DATA, int64_t VALUE)
     SYS_CONTEXT: global system context

     DATA: pointer to the data, must contain at least 8 bytes of
     writable space

     VALUE: the integer to serialize

     Serializes a 64-bit integer in a byte buffer.  Result is not
     dependant on machine endianess.  Typically used for checksums or
     high-level serializations.

 -- Function: int64_t lw6sys_unserialize_int64 (lw6sys_context_t *
          SYS_CONTEXT, unsigned char * DATA)
     SYS_CONTEXT: global system context

     DATA: pointer to the data, must contain at least 8 bytes

     Recovers a 64-bit integer from a byte buffer created, for instance,
     with 'lw6sys_serialize_int64'.

 -- Function: void lw6sys_serialize_int32 (lw6sys_context_t *
          SYS_CONTEXT, unsigned char * DATA, int32_t VALUE)
     SYS_CONTEXT: global system context

     DATA: pointer to the data, must contain at least 4 bytes of
     writable space

     VALUE: the integer to serialize

     Serializes a 32-bit integer in a byte buffer.  Result is not
     dependant on machine endianess.  Typically used for checksums or
     high-level serializations.

 -- Function: int32_t lw6sys_unserialize_int32 (lw6sys_context_t *
          SYS_CONTEXT, unsigned char * DATA)
     SYS_CONTEXT: global system context

     DATA: pointer to the data, must contain at least 4 bytes

     Recovers a 32-bit integer from a byte buffer created, for instance,
     with 'lw6sys_serialize_int32'.

 -- Function: void lw6sys_serialize_int16 (lw6sys_context_t *
          SYS_CONTEXT, unsigned char * DATA, int16_t VALUE)
     SYS_CONTEXT: global system context

     DATA: pointer to the data, must contain at least 2 bytes of
     writable space

     VALUE: the integer to serialize

     Serializes a 16-bit integer in a byte buffer.  Result is not
     dependant on machine endianess.  Typically used for checksums or
     high-level serializations.

 -- Function: int16_t lw6sys_unserialize_int16 (lw6sys_context_t *
          SYS_CONTEXT, unsigned char * DATA)
     SYS_CONTEXT: global system context

     DATA: pointer to the data, must contain at least 2 bytes

     Recovers a 16-bit integer from a byte buffer created, for instance,
     with 'lw6sys_serialize_int16'.

 -- Function: int lw6sys_shape_check_min_max_whd (lw6sys_context_t *
          SYS_CONTEXT, const lw6sys_whd_t * SHAPE, const lw6sys_whd_t *
          MIN, const lw6sys_whd_t * MAX)
     SYS_CONTEXT: global system context

     SHAPE: the dimensions to control

     MIN: the minimum shape allowed

     MAX: the maximum shape allowed

     Will check wether the given shape respects some basic constraints,
     being not to small and not too big.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6sys_shape_check_pos (lw6sys_context_t *
          SYS_CONTEXT, const lw6sys_whd_t * SHAPE, const lw6sys_xyz_t *
          POS)
     SYS_CONTEXT: global system context

     SHAPE: the boundary box

     POS: the position

     Checks wether position is within the given boundary box.

     *Return value:* 1 if OK, 0 if not.

 -- Function: int lw6sys_shape_is_same (lw6sys_context_t * SYS_CONTEXT,
          const lw6sys_whd_t * SHAPE_A, const lw6sys_whd_t * SHAPE_B)
     SYS_CONTEXT: global system context

     SHAPE_A: the first shape to compare

     SHAPE_B: the other shape to compare

     Compares two shapes.

     *Return value:* 1 if same, 0 if not.

 -- Function: int lw6sys_shape_is_same_xy (lw6sys_context_t *
          SYS_CONTEXT, const lw6sys_whd_t * SHAPE_A, const lw6sys_whd_t
          * SHAPE_B)
     SYS_CONTEXT: global system context

     SHAPE_A: the first shape to compare

     SHAPE_B: the other shape to compare

     Compares two shapes, but ignores the z (d) parameter.

     *Return value:* 1 if same_xy, 0 if not.

 -- Function: int lw6sys_shape_volume_whd (lw6sys_context_t *
          SYS_CONTEXT, const lw6sys_whd_t * SHAPE)
     SYS_CONTEXT: global system context

     SHAPE: the shape to query

     Gives the volume (w * h * d) for a given shape.

     *Return value:* the volume.

 -- Function: int lw6sys_shape_surface_wh (lw6sys_context_t *
          SYS_CONTEXT, const lw6sys_whd_t * SHAPE)
     SYS_CONTEXT: global system context

     SHAPE: the shape to query

     Gives the surface (w * h) for a given shape.

     *Return value:* the surface.

 -- Function: void lw6sys_signal_custom (lw6sys_context_t * SYS_CONTEXT,
          int TRAP_ERRORS)
     SYS_CONTEXT: global system context

     TRAP_ERRORS: set to 1 if you want to trap SIGSEGV and SIGFPE

     Set up our signal handlers.  This will probably be overrided later
     by other libs such as libSDL, but at least in pure server mode it
     gives a way to treat SIGTERM the right way.  The callbacks will use
     the 'sys_context' passed here, ignoring whatever thread and/or
     whatever value for this context was used when the error was
     detected.  However, one needs at least one context, for instance to
     log messages.

     *Return value:* none.

 -- Function: void lw6sys_signal_default (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Restore default signal handlers for those modified by
     'lw6sys_signal_custom'.

     *Return value:* none.

 -- Function: void lw6sys_signal_term_handler (int SIGNUM)
     SIGNUM: SIGTERM

     The own TERM signal handler, will basically call the
     'lw6sys_signal_send_quit' function, which will set a flag used
     later by 'lw6sys_signal_poll_quit'.

     *Return value:* none.

 -- Function: void lw6sys_signal_int_handler (int SIGNUM)
     SIGNUM: SIGINT

     The own INT signal handler, will basically call the
     'lw6sys_signal_send_quit' function, which will set a flag used
     later by 'lw6sys_signal_poll_quit'.

     *Return value:* none.

 -- Function: void lw6sys_signal_hup_handler (int SIGNUM)
     SIGNUM: SIGTERM

     The own HUP signal handler, will basically do something that shows
     the program is alive, typically display a NOTICE message.

     *Return value:* none.

 -- Function: void lw6sys_signal_segv_handler (int SIGNUM)
     SIGNUM: SIGTERM

     The own SEGV signal handler, will display a backtrace and exit.

     *Return value:* none.

 -- Function: void lw6sys_signal_fpe_handler (int SIGNUM)
     SIGNUM: SIGTERM

     The own FPE signal handler, will display a backtrace and exit.

     *Return value:* none.

 -- Function: void lw6sys_signal_send_quit (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Sets the quit flag to 1, so that 'lw6sys_signal_poll_quit' returns
     true, that is, tells the polling loop to stop.

     *Return value:* none.

 -- Function: int lw6sys_signal_poll_quit (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Tests wether we need to stop right now.

     *Return value:* 1 if we need to stop now, 0 if program can
     continue.

 -- Function: int lw6sys_sort_int_callback (lw6sys_context_t *
          SYS_CONTEXT, void * FUNC_DATA, const void * PTR_A, const void
          * PTR_B)
     SYS_CONTEXT: global system context

     FUNC_DATA: function specific data

     PTR_A: pointer to an int item

     PTR_B: pointer to an int item

     A typicall sort callback function, can be passed to 'lw6sys_sort'
     to sort a list of integers.

     *Return value:* -1 if 'ptr_a' < 'ptr_b' , 0 if 'ptr_a' == 'ptr_b',
     1 if 'ptr_a' > 'ptr_b'

 -- Function: int lw6sys_sort_int_desc_callback (lw6sys_context_t *
          SYS_CONTEXT, void * FUNC_DATA, const void * PTR_A, const void
          * PTR_B)
     SYS_CONTEXT: global system context

     FUNC_DATA: function specific data

     PTR_A: pointer to an int item

     PTR_B: pointer to an int item

     A typicall sort callback function, can be passed to 'lw6sys_sort'
     to sort a list of integers.  This one will sort in reverse mode.

     *Return value:* 1 if 'ptr_a' < 'ptr_b' , 0 if 'ptr_a' == 'ptr_b',
     -1 if 'ptr_a' > 'ptr_b'

 -- Function: int lw6sys_sort_float_callback (lw6sys_context_t *
          SYS_CONTEXT, void * FUNC_DATA, const void * PTR_A, const void
          * PTR_B)
     SYS_CONTEXT: global system context

     FUNC_DATA: function specific data

     PTR_A: pointer to a float item

     PTR_B: pointer to a float item

     A typicall sort callback function, can be passed to 'lw6sys_sort'
     to sort a list of floating point numbers.

     *Return value:* -1 if 'ptr_a' < 'ptr_b' , 0 if 'ptr_a' == 'ptr_b',
     1 if 'ptr_a' > 'ptr_b'

 -- Function: int lw6sys_sort_float_desc_callback (lw6sys_context_t *
          SYS_CONTEXT, void * FUNC_DATA, const void * PTR_A, const void
          * PTR_B)
     SYS_CONTEXT: global system context

     FUNC_DATA: function specific data

     PTR_A: pointer to a float item

     PTR_B: pointer to a float item

     A typicall sort callback function, can be passed to 'lw6sys_sort'
     to sort a list of floating point numbers.  This one will sort in
     reverse mode.

     *Return value:* 1 if 'ptr_a' < 'ptr_b' , 0 if 'ptr_a' == 'ptr_b',
     -1 if 'ptr_a' > 'ptr_b'

 -- Function: int lw6sys_sort_str_callback (lw6sys_context_t *
          SYS_CONTEXT, void * FUNC_DATA, const void * PTR_A, const void
          * PTR_B)
     SYS_CONTEXT: global system context

     FUNC_DATA: function specific data

     PTR_A: pointer to a string item

     PTR_B: pointer to a string item

     A typicall sort callback function, can be passed to 'lw6sys_sort'
     to sort a list of 0-terminated strings.

     *Return value:* -1 if 'ptr_a' < 'ptr_b' , 0 if 'ptr_a' == 'ptr_b',
     1 if 'ptr_a' > 'ptr_b'

 -- Function: int lw6sys_sort_str_desc_callback (lw6sys_context_t *
          SYS_CONTEXT, void * FUNC_DATA, const void * PTR_A, const void
          * PTR_B)
     SYS_CONTEXT: global system context

     FUNC_DATA: function specific data

     PTR_A: pointer to a string item

     PTR_B: pointer to a string item

     A typicall sort callback function, can be passed to 'lw6sys_sort'
     to sort a list of 0-terminated strings.  This one will sort in
     reverse mode.

     *Return value:* 1 if 'ptr_a' < 'ptr_b' , 0 if 'ptr_a' == 'ptr_b',
     -1 if 'ptr_a' > 'ptr_b'

 -- Function: void lw6sys_sort (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t ** LIST, lw6sys_sort_callback_func_t SORT_FUNC,
          void * FUNC_DATA)
     SYS_CONTEXT: global system context

     LIST: the list to sort, might be modified by the function

     SORT_FUNC: the callback function used to sort

     FUNC_DATA: function specific data

     A general sorting function.  Internally, will use the glibc 'qsort'
     function, but this one is adapted to the LW6 specific data
     structures, more exactly, the 'lw6sys_list' structure.  Several
     default sort callbacks are defined, but one is free to use any
     callback, provided it has the right prototype.

 -- Function: lw6sys_spinlock_t * lw6sys_spinlock_create
          (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Creates a spinlock object.

     *Return value:* newly allocated pointer.

 -- Function: void lw6sys_spinlock_destroy (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_spinlock_t * SPINLOCK)
     SYS_CONTEXT: global system context

     SPINLOCK: the spinlock to destroy.

     Destroys a spinlock object.

     *Return value:* none.

 -- Function: int lw6sys_spinlock_lock (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_spinlock_t * SPINLOCK)
     SYS_CONTEXT: global system context

     SPINLOCK: the spinlock to use

     Locks the spinlock.  Note that this should never fail unless
     there's a serious initialization problem, instead, function will
     wait forever until spinlock is released.

     *Return value:* 1 if success, 0 if failure.

 -- Function: int lw6sys_spinlock_trylock (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_spinlock_t * SPINLOCK)
     SYS_CONTEXT: global system context

     SPINLOCK: the spinlock to use

     Tries to locks the spinlock.  That is, tells wether spinlock can be
     locked immediately or not.  Note that this does not mean there's
     100% chance next call to lock will terminated immediately, since
     lock can still be acquired by another thread.

     *Return value:* 1 if spinlock unlocked, 0 if locked or error.

 -- Function: int lw6sys_spinlock_unlock (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_spinlock_t * SPINLOCK)
     SYS_CONTEXT: global system context

     SPINLOCK: the spinlock to use

     Unlocks a spinlock.

     *Return value:* 1 if sucess, 0 if error.

 -- Function: char * lw6sys_str_copy (lw6sys_context_t * SYS_CONTEXT,
          const char * SRC)
     SYS_CONTEXT: global system context

     SRC: the string to copy

     Duplicate a string, creating a new pointer on it, which must be
     freed afterwards.  The main difference with 'strdup' is that here
     we use the LW6SYS_MALLOC macro to track down possible memory leaks.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_str_concat (lw6sys_context_t * SYS_CONTEXT,
          const char * STR1, const char * STR2)
     SYS_CONTEXT: global system context

     STR1: the left part to be concatenated

     STR2: the right part to be concatenated

     Concatenate 2 strings, and put the result in a newly allocated
     string.  Unlike 'strcat' which uses the same pointer.

     *Return value:* a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_new_sprintf (lw6sys_context_t * SYS_CONTEXT,
          const char * FMT, ...)
     SYS_CONTEXT: global system context

     FMT: a format string, like the one you would pass to 'printf' ...:
     optional arguments, like the ones you would pass to 'printf'

     An sprintf like function, except it allocates a new string
     automatically, with "enough space".  This is not a highly optimized
     function, it will allocate plenty of memory, possibly several
     times, and thus consume time and resources.  But it has the great
     advantage of freeing the programmer of the dirty work of guessing
     "how log will the sprintf'ed string be?"  before even generating
     it.  So it's a time saver for the programmer.  Additionnally, helps
     avoiding memory leaks and buffer overflows.

     *Return value:* a new allocated string, must be freed.

 -- Function: int lw6sys_buf_sprintf (lw6sys_context_t * SYS_CONTEXT,
          char * BUF, int LEN, const char * FMT, ...)
     SYS_CONTEXT: global system context

     BUF: a buffer of len+1 chars

     LEN: the max length of string

     FMT: a format string, like the one you would pass to 'printf' ...:
     optional arguments, like the ones you would pass to 'printf'

     Almost like snprintf except that it will *always* append a char 0
     ('\0') at the end of the string.  Therefore buf must be of size
     len+1.

     *Return value:* 1 if success, 0 if failed.

 -- Function: int lw6sys_str_is_blank (lw6sys_context_t * SYS_CONTEXT,
          const char * STR)
     SYS_CONTEXT: global system context

     STR: the string to test

     Tests wether a string is blank, that is, if it's composed of space,
     tabs, or carriage returns only.

     *Return value:* 1 if blank, 0 if not.

 -- Function: int lw6sys_str_is_null_or_empty (lw6sys_context_t *
          SYS_CONTEXT, const char * STR)
     SYS_CONTEXT: global system context

     STR: the string to test

     Tests wether a string is NULL or empty (string with 0 chars "").

     *Return value:* 1 if NULL or empty, 0 if contains something.

 -- Function: const char * lw6sys_str_empty_if_null (lw6sys_context_t *
          SYS_CONTEXT, const char * STR)
     SYS_CONTEXT: global system context

     STR: the string to test

     Returns always a non-NULL string, if string is NULL, returns "" The
     argument 'str' is not passed as const else this function would
     equate to a disguised cast from const to non-const.

     *Return value:* source string or "" if it was NULL

 -- Function: int lw6sys_str_is_same (lw6sys_context_t * SYS_CONTEXT,
          const char * STR_A, const char * STR_B)
     SYS_CONTEXT: global system context

     STR_A: 1st string to compare, can be NULL

     STR_B: 2nd string to compare, can be NULL

     Compares two strings for equality.  Difference with strcmp is that
     this one won't check for alphabetical order and return -1 or +1,
     but will check for NULL args.  of space, tabs, or carriage returns
     only.

     *Return value:* 1 if same, 0 if not.

 -- Function: int lw6sys_str_is_same_no_case (lw6sys_context_t *
          SYS_CONTEXT, const char * STR_A, const char * STR_B)
     SYS_CONTEXT: global system context

     STR_A: 1st string to compare, can be NULL

     STR_B: 2nd string to compare, can be NULL

     Compares two strings for equality.  Difference with strcmp is that
     this one won't check for alphabetical order and return -1 or +1,
     but will check for NULL args.  of space, tabs, or carriage returns
     only.  This function is not case sensitive.

     *Return value:* 1 if same, 0 if not.

 -- Function: int lw6sys_str_starts_with (lw6sys_context_t *
          SYS_CONTEXT, const char * STR, const char * BEGINNING)
     SYS_CONTEXT: global system context

     STR: the string to analyse

     BEGINNING: the pattern to search

     Tells wether string starts with a given beginning.

     *Return value:* 1 if 'str' starts with 'beginning', 0 if not

 -- Function: int lw6sys_str_starts_with_no_case (lw6sys_context_t *
          SYS_CONTEXT, const char * STR, const char * BEGINNING)
     SYS_CONTEXT: global system context

     STR: the string to analyse

     BEGINNING: the pattern to search

     Tells wether string starts with a given beginning.  This function
     is not case sensitive.

     *Return value:* 1 if 'str' starts with 'beginning', 0 if not

 -- Function: int lw6sys_skip_blanks (lw6sys_context_t * SYS_CONTEXT,
          char ** STR_PTR)
     SYS_CONTEXT: global system context

     STR_PTR: a pointer to a string pointer (read/write parameter).

     Skips blanks at the beginning of a string.  The passed parameter is
     modifed in place.  Usefull for parsing.

     *Return value:* 1 if blanks were found, else 0.

 -- Function: void lw6sys_str_cleanup (lw6sys_context_t * SYS_CONTEXT,
          char * STR)
     STR: a pointer to the string, which will be modified in-place.

     Used to clean up some strings, for instance if they come from the
     network, we don't necessarly want system chars to be displayed on
     the console.  Basically it removes all characters with an ASCII
     code inferior to 32, that is, all system characters.  This way,
     there won't be any tab, linefeed, or any of such characters left.

     *Return value:* none.

 -- Function: void lw6sys_str_cleanup_ascii7 (lw6sys_context_t *
          SYS_CONTEXT, char * STR)
     SYS_CONTEXT: global system context

     STR: a pointer to the string, which will be modified in-place.

     Used to clean up some strings, for instance if they come from the
     network, we don't necessarly want system chars to be displayed on
     the console.  Basically it removes all characters with an ASCII
     code inferior to 32, that is, all system characters.  This way,
     there won't be any tab, linefeed, or any of such characters left.
     This function will even remove any character above ASCII 127.

     *Return value:* none.

 -- Function: char * lw6sys_str_reformat (lw6sys_context_t *
          SYS_CONTEXT, const char * STR, const char * PREFIX, int
          NB_COLUMNS)
     SYS_CONTEXT: global system context

     STR: a pointer to the string we want to modify

     PREFIX: a prefix to put before each line

     Reformats a string, that is, insert newline characters in the right
     places to that it fits in a given number of columns.  A prefix is
     appended at the beginning of each line.  Will not handle strings
     which already contain newline characters perfectly.

     *Return value:* a newly allocated string, must be freed.

 -- Function: void lw6sys_str_reformat_this (lw6sys_context_t *
          SYS_CONTEXT, char * STR, int NB_COLUMNS)
     SYS_CONTEXT: global system context

     STR: a pointer to the string we want to modify

     Reformats a string, that is, insert newline characters in the right
     places to that it fits in a given number of columns.  This function
     will modify the buffer so 'str' must be writeable.  Will not handle
     strings which already contain newline characters perfectly.

     *Return value:* none

 -- Function: char * lw6sys_eol (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the value of EOL, that is, the "end of line" sequence.
     Will simply return "\n" on UNIX and "\r\n" on Microsoft platforms.
     Note that while this is convenient to write config and example
     files, for instance, it's a bad idea to use this to generate
     network messages, because this kind of message needs to be platform
     independant.  Thus any network protocol oriented string would use
     chr(10) and char(13) directly.

     *Return value:* the EOL string, must not be freed.

 -- Function: lw6sys_list_t * lw6sys_str_split (lw6sys_context_t *
          SYS_CONTEXT, const char * STR, char C)
     SYS_CONTEXT: global system context

     STR: a string

     C: the delimiter to split with

     Splits a string, for instance 'foo,bar' splited with 'o' will
     return 'f', " and ',bar'.

     *Return value:* a list containing 0-terminated strings.

 -- Function: lw6sys_list_t * lw6sys_str_split_no_0 (lw6sys_context_t *
          SYS_CONTEXT, const char * STR, char C)
     SYS_CONTEXT: global system context

     STR: a string

     C: the delimiter to split with

     Splits a string, ignoring empty '0-length' members.  For instance
     'foo,bar' splited with 'o' will return 'f' and ',bar'.

     *Return value:* a list containing 0-terminated strings.

 -- Function: lw6sys_list_t * lw6sys_str_split_config_item
          (lw6sys_context_t * SYS_CONTEXT, const char * STR)
     SYS_CONTEXT: global system context

     STR: a string

     Splits a string, ignoring empty '0-length' members, and using the
     comma ',' as a separator.  This is typically usefull for config
     elements such as backend lists.  Only paths need another separator
     (platform-dependant).

     *Return value:* a list containing 0-terminated strings.

 -- Function: char * lw6sys_str_join (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_list_t * LIST, const char * GLUE)
     SYS_CONTEXT: global system context

     LIST: list of strings to join

     GLUE: string to add in-between

     Companion function of 'lw6sys_str_split' which will do the contrary
     and join the string.  Here we use a string as the glue/separator,
     more flexible than a simple char in this case.

     *Return value:* dynamically allocated string

 -- Function: void lw6sys_str_toupper (lw6sys_context_t * SYS_CONTEXT,
          char * STR)
     SYS_CONTEXT: global system context

     STR: the string to modify

     Transforms a string to upper case, the pointer must point to
     modifiable data.

     *Return value:* none, 'str' pointed data modified in-place

 -- Function: void lw6sys_str_tolower (lw6sys_context_t * SYS_CONTEXT,
          char * STR)
     SYS_CONTEXT: global system context

     STR: the string to modify

     Transforms a string to lower case, the pointer must point to
     modifiable data.

     *Return value:* none, 'str' pointed data modified in-place

 -- Function: void lw6sys_str_truncate (lw6sys_context_t * SYS_CONTEXT,
          char * STR, int LEN)
     SYS_CONTEXT: global system context

     STR: the string to truncate

     LEN: the new length

     Truncates a string to the max given length.  If truncated to 3,
     "abcdef" becomes "abc".

     *Return value:* none, 'str' pointed data modified in-place

 -- Function: void lw6sys_str_truncate_middle (lw6sys_context_t *
          SYS_CONTEXT, char * STR, int LEN, const char * MIDDLE)
     SYS_CONTEXT: global system context

     STR: the string to truncate

     LEN: the new length

     MIDDLE: the string to add in the middle

     Truncates a string to the max given length, by truncating the
     middle of the string, and putting the string middle at this place.
     Calling it with "abcdefghijk",5,"X" will give "abXjk".

     *Return value:* none, 'str' pointed data modified in-place

 -- Function: char * lw6sys_str_random (lw6sys_context_t * SYS_CONTEXT,
          int LEN)
     SYS_CONTEXT: global system context

     LEN: the length of the random string to generate.

     Generates a random string, this is usefull for testing.

     *Return value:* newly allocated string

 -- Function: char * lw6sys_str_random_words (lw6sys_context_t *
          SYS_CONTEXT, int LEN)
     SYS_CONTEXT: global system context

     LEN: the length of the random string to generate.

     Generates a random string, this is usefull for testing.  This
     version only generates words with alpha-numerical content (letters
     and digits plus spaces).

     *Return value:* newly allocated string

 -- Function: char * lw6sys_str_random_word (lw6sys_context_t *
          SYS_CONTEXT, int LEN)
     SYS_CONTEXT: global system context

     LEN: the length of the random string to generate.

     Generates a random string, this is usefull for testing.  This
     version generates on single word with alpha-numerical content
     (letters and digits but no spaces).

     *Return value:* newly allocated string

 -- Function: int lw6sys_str_is_bin (lw6sys_context_t * SYS_CONTEXT,
          const char * BUF, int LEN)
     SYS_CONTEXT: global system context

     BUF: the buffer to test

     LEN: the length of the buffer

     Tests wether a buffer is likely to contain a string.  This is not a
     bulletproof function, just a simple heuristic based estimator.

     *Return value:* 1 if probably binary, 0 if probably text

 -- Function: char * lw6sys_stream_file_to_str (lw6sys_context_t *
          SYS_CONTEXT, FILE * F)
     SYS_CONTEXT: global system context

     F: file to get input from, typically stdin

     Will read file/stream and return it as a string.  This is not for
     serious stream operation since it will return only when stream is
     closed, and read all file into memory before doing anything.  It's
     also limited in size since it uses a fixed length buffer, so this
     is just for quick testing, typically used by command line switches
     which are used to test encoding/decoding functions.  Do not use it
     to read a filesystem file, 'lw6sys_read_file_content' is much
     better.

     *Return value:* newly allocated string.

 -- Function: void lw6sys_stream_str_to_file (lw6sys_context_t *
          SYS_CONTEXT, FILE * F, char * STR)
     SYS_CONTEXT: global system context

     F: file to receive the string

     STR: the string to output

     Here only for API consistency, will just put string to file (just a
     simple fprint).

     *Return value:* none.

 -- Function: int32_t lw6sys_test_and_set (volatile int32_t *
          TEST_AND_SET)
     TEST_AND_SET: pointer to the value used to test and set

     Low level function which performs an atomic exchange to implement a
     spinlock.  This one is just a wrapper to help debugging asm calls.

     *Return value:* 1 when lock is acquired.

 -- Function: int64_t lw6sys_test_and_set (volatile int64_t *
          TEST_AND_SET)
     TEST_AND_SET: pointer to the value used to test and set

     Low level function which performs an atomic exchange to implement a
     spinlock.  This one is just a wrapper to help debugging asm calls.

     *Return value:* 1 when lock is acquired.

 -- Function: int lw6sys_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libsys module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6sys_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'sys' module test suite, testing most (if not all...)
     functions.  Note that some tests perform file system operations and
     might therefore fail on a read-only filesystem, or if user
     permissions are not sufficient.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6sys_test_exec (lw6sys_context_t * SYS_CONTEXT, int
          ARGC, const char * [] ARGV, int MODE)
     SYS_CONTEXT: global system context

     ARGC: number of args as passed to main

     ARGV: array of args as passed to main

     MODE: 0 for check only, 1 for full test

     Runs the 'sys' module test which is specific to exec functions,
     these ones require 'argc' and 'argv' to be correctly set so the
     extra argument justifies putting it outside 'lw6sys_test'.
     Additionnally, it's not fool proof...  Moreover, it should be run
     at the beginning of the program, running it afterwards could give
     unpredictable results.  So it's safer to use it outside the CUnit
     standard mechanisms.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: lw6sys_thread_handler_t * lw6sys_thread_create
          (lw6sys_context_t * SYS_CONTEXT, lw6sys_thread_callback_func_t
          CALLBACK_FUNC, lw6sys_thread_callback_func_t CALLBACK_JOIN,
          void * CALLBACK_DATA)
     SYS_CONTEXT: global system context

     CALLBACK_FUNC: the main callback, the function that will run the
     thread

     CALLBACK_JOIN: function which will be called when joining, at the
     end

     CALLBACK_DATA: data which will be passed to the callback

     Creates a thread.  All threads must be joined.  This is because we
     really do not want the game to leak, and detached threads are
     typically the kind of thing that leaves stuff in the heap.  Note
     that callback_func is just something which will be called when
     joining it can be NULL. The idea is to put in it free & delete
     functions, which you can't call before joining when you want the
     main thread to get the results of the callback_func.

     *Return value:* an opaque pointer on the thread.  Can be NULL if
     failed.

 -- Function: int lw6sys_thread_is_callback_done (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_thread_handler_t * THREAD_HANDLER)
     SYS_CONTEXT: global system context

     THREAD_HANDLER: thread to work on

     Tells wether the callback is done, that is to say, wether the
     results are available, and we can join.

     *Return value:* 1 if done, else 0.

 -- Function: int lw6sys_thread_wait_callback_done (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_thread_handler_t * THREAD_HANDLER)
     SYS_CONTEXT: global system context

     THREAD_HANDLER: thread to work on

     Waits until the callback of the thread is done, this does not
     necessarly mean it's freed, in fact it's not at this stage, the
     join callback can still be yet to call, but at least the main stuff
     is done.

     *Return value:* 1 if done, 0 on error

 -- Function: int lw6sys_thread_get_id (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_thread_handler_t * THREAD_HANDLER)
     SYS_CONTEXT: global system context

     THREAD_HANDLER: thread to query

     Returns the id of the thread, this is an internal value, unique for
     each process, which can help identifying the thread.

     *Return value:* the id, should be >0.

 -- Function: void * lw6sys_thread_get_data (lw6sys_context_t *
          SYS_CONTEXT, lw6sys_thread_handler_t * THREAD_HANDLER)
     SYS_CONTEXT: global system context

     THREAD_HANDLER: thread to query

     Returns the data associated to the thread, that is, the pointer
     which was passed to the callback function.

     *Return value:* a pointer.

 -- Function: void lw6sys_thread_join (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_thread_handler_t * THREAD_HANDLER)
     SYS_CONTEXT: global system context

     THREAD_HANDLER: thread to end

     Joins the thread, that's to say wait until the thread is over, and
     destroys the ressources associated to it.  Note that if the thread
     is looping forever, this function will just wait forever.  This is
     the only way to end a thread.

     *Return value:* none.

 -- Function: int lw6sys_get_thread_create_count (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Utility function used to check how many threads where created and
     joined.

     *Return value:* how many threads were created.

 -- Function: int lw6sys_get_thread_join_count (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Utility function used to check how many threads where created and
     joined.

     *Return value:* how many threads were joined.

 -- Function: int lw6sys_check_thread_count (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Utility function used to check how many threads where created and
     joined.  This one will compare the results of
     'lw6sys_get_thread_create_count' and
     'lw6sys_get_thread_join_count'.

     *Return value:* 1 if both are equals, 0 if not (error...).

 -- Function: int64_t lw6sys_get_timestamp (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns a 64-bit timestamp, for general purpose.  The unit is
     milliseconds, should return the number of milliseconds since EPOCH.
     Don't use this for accurate date handling, but rather to technical
     stamp events.

     *Return value:* the timestamp.

 -- Function: int64_t lw6sys_get_uptime (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns the number of milliseconds since program was started.
     Milliseconds are often referred to as 'ticks'.

     *Return value:* the number of milliseconds (64-bit)

 -- Function: int32_t lw6sys_get_cycle (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns a 32-bit timestamp, which is likely to "loop" and have
     twice the same value during a single program execution.  The idea
     here is just to provide a 32-bit value, not too big, for animation
     purposes.  The idea is that with 64-bit values, numbers are too big
     and if the goal is just to animate a cursor or spin a sphere, one
     does not care if every ten hours there's a display glitch because
     value became zero again.  Besides, those values are often used for
     their "rest" in a module operation, to translate textures for
     instance, and having too big numbers causes floating point
     imprecisions.  In fact those values or even only 20-bit.  The
     function is based on 'lw6sys_get_uptime' so it will return 0 at
     game startup.

     *Return value:* the cycle value, a 20-bit integer.

 -- Function: void lw6sys_timer_update (lw6sys_context_t * SYS_CONTEXT,
          int64_t * TIMESTAMP, int64_t * UPTIME, int32_t * CYCLE)
     SYS_CONTEXT: global system context

     TIMESTAMP: the timestamp in msec since EPOCH (output), can be NULL

     UPTIME: the uptime in msec since startup (output), can be NULL

     CYCLE: a 20-bit value for animation purpose.

     Returns timestamp & uptime with only one system call.

     *Return value:* none (parameters modified).

 -- Function: void lw6sys_sleep (lw6sys_context_t * SYS_CONTEXT, float
          SECONDS)
     SYS_CONTEXT: global system context

     SECONDS: the number of seconds to wait, fractions allowed

     Will sleep for the given amount of seconds.  Same as 'lw6sys_delay'
     only input is provided as a floating number of seconds instead of
     ticks.

 -- Function: void lw6sys_delay (lw6sys_context_t * SYS_CONTEXT, int
          MSEC)
     SYS_CONTEXT: global system context

     MSEC: the number of milliseconds (ticks) to wait

     Will sleep for the given amount of seconds.  Provides accurate
     timing and has "about-millisecond" precision, since it uses
     'usleep' or 'select' internally.  Might however be interrupted in
     some cases, so consider function can always return quicker than
     specified.  A common usage of this function is polling loops, where
     you don't care if 2 polls are very close, but simply want to avoid
     polling continuously, therefore consumming 100% of the CPU for
     nothing.

 -- Function: void lw6sys_idle (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Will sleep for a minimal amount of time, just giving the OS a
     chance to let other threads/processes execute themselves.  This can
     make a big difference in polling loops between a process that eats
     100% CPU and a process that has a very moderate load.  of ticks.

 -- Function: void lw6sys_snooze (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Will sleep for some time, like 'lw6sys_idle', except it's a
     "longer" time, use this when you don't really care about reactivity
     but are more concerned about saving CPU, not running uselessly the
     same polling code.

 -- Function: void lw6sys_time_init (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Global initializations required to handle time properly.

 -- Function: char * lw6sys_date_rfc1123 (lw6sys_context_t *
          SYS_CONTEXT, int SECONDS_FROM_NOW)
     SYS_CONTEXT: global system context

     SECONDS_FROM_NOW: an offset to add to current time

     Gives the date according to RFC1123, this is typically usefull for
     HTTP protocol.

     *Return value:* newly allocated string.

 -- Function: char * lw6sys_date_clf (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Gives the date in a format which is compatible with Apache CLF
     Common Log Format.

     *Return value:* newly allocated string.

 -- Function: char * lw6sys_readable_uptime (lw6sys_context_t *
          SYS_CONTEXT, int64_t TIMESTAMP_DELTA)
     SYS_CONTEXT: global system context

     TIMESTAMP_DELTA: the duration to show, in msec

     Returns a readable form of an uptime, typically 1d 12:34:06 for one
     day, 12 hours, 34 min, 6 sec or 7:03:45 for 7 hours, 3 minutes 45
     sec.

     *Return value:* newly allocated string

 -- Function: extern char * lw6sys_url_http_from_ip_port
          (lw6sys_context_t * SYS_CONTEXT, const char * IP, int PORT)
     SYS_CONTEXT: global system context

     IP: IP address

     PORT: IP port

     *Returns an http URL pointing to ip:* port that is, adds a heading
     http:// and a trailing /, and treats port 80 as default.  This is
     used to create public_url in net modules.

     *Return value:* a newly allocated string, NULL on error.

 -- Function: lw6sys_url_t * lw6sys_url_parse (lw6sys_context_t *
          SYS_CONTEXT, const char * URL)
     SYS_CONTEXT: global system context

     URL: the URL to parse

     Parses a URL, this is not a complete RFC compliant parser, it's
     only used to transform URLs into their 'canonical' form as well as
     getting basic info such as on which port one should connect.

     *Return value:* a newly allocated struct, NULL on error

 -- Function: void lw6sys_url_free (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_url_t * URL)
     SYS_CONTEXT: global system context

     URL: the url struct to free

     Frees a URL struct and all its members.

     *Return value:* none.

 -- Function: char * lw6sys_url_canonize (lw6sys_context_t *
          SYS_CONTEXT, const char * URL)
     SYS_CONTEXT: global system context

     URL: the url to check & transform

     Checks if a given URL is correct and, if it is, transforms it into
     its canonical form.  This is mostly to get rid of typesettings
     error, add a tailing /, transform all domain into lowercase, among
     other things.  A canonized url passed into this function should
     come out exactly the same.

     *Return value:* a newly allocated string.

 -- Function: int lw6sys_url_is_canonized (lw6sys_context_t *
          SYS_CONTEXT, const char * URL)
     SYS_CONTEXT: global system context

     URL: the URL to check

     Checks wether an URL is in its canonized form.

     *Return value:* 1 if OK (canonized form), 0 if not

 -- Function: int lw6sys_version_is_compatible (lw6sys_context_t *
          SYS_CONTEXT, const char * VERSION_A, const char * VERSION_B)
     SYS_CONTEXT: global system context

     VERSION_A: 1st version to compare

     VERSION_B: 2nd version to compare

     Compares two versions and tells wether they are compatible or not.
     Actually, it only checks that MAJOR.MINOR is the same in both
     cases.  As a side not, it's not case sensitive.  In most LW6
     relevant cases, it's a moot issue since MAJOR.MINOR is a number,
     but well, just in case.

     *Return value:* 1 if compatible, 0 if not

 -- Function: int lw6sys_vthread_run (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_thread_callback_func_t CALLBACK_FUNC,
          lw6sys_thread_callback_func_t CALLBACK_JOIN, void *
          CALLBACK_DATA)
     SYS_CONTEXT: global system context

     CALLBACK_FUNC: the main callback, the function that will run the
     thread

     CALLBACK_JOIN: function which will be called when joining, at the
     end

     CALLBACK_DATA: data which will be passed to the callback

     This function is similar to 'lw6sys_thread_create', but it's
     dedicated to creating a unique (one per process only) thread,
     which, in turn, will be able to run commands in the main thread
     itself.  This is a hack to allow apparently spawned child threads
     to be actually handled by main.  This is because some libraries,
     which LW6 uses in threads, need to be actually called in the main
     thread.  SDL, for instance.  Note that after running this you loose
     control on the main thread, this one will only wait for possible
     commands from the spawned thread, typically sent with the
     'lw6sys_vthread_create' function.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6sys_vthread_is_running (lw6sys_context_t *
          SYS_CONTEXT)
     SYS_CONTEXT: global system context

     Returns true if 'lw6sys_vthread_run' has been called.  Note that
     this is not bullet proof, it will return true in a correct manner
     only if you call it from the vthread itself.  In practise this
     shouldn't be a problem, the idea is just to write portable code for
     the main control thread and be able to decide on the fly wether to
     create a thread we should prefer the 'lw6sys_thread_create' or its
     equivalent the 'lw6sys_vthread_create' function.

     *Return value:* 1 on success, 0 on failure.

 -- Function: int lw6sys_vthread_create (lw6sys_context_t * SYS_CONTEXT,
          lw6sys_thread_callback_func_t CALLBACK_FUNC,
          lw6sys_thread_callback_func_t CALLBACK_JOIN, void *
          CALLBACK_DATA)
     SYS_CONTEXT: global system context

     CALLBACK_FUNC: the main callback, the function that will run the
     thread

     CALLBACK_JOIN: function which will be called when joining, at the
     end

     CALLBACK_DATA: data which will be passed to the callback

     The equivalent of 'lw6sys_thread_create' but for the vthread
     infrastructure.  The idea is to pretend firing a spawned thread,
     but in fact it's the main thread that runs the code.  This function
     must imperatively be called within the 'lw6sys_vthread_run'
     function, else it will fail or be buggy.

     *Return value:* 1 on success, 0 on failure.

 -- Function: void lw6sys_vthread_join (lw6sys_context_t * SYS_CONTEXT)
     SYS_CONTEXT: global system context

     The equivalent of 'lw6sys_thread_join' but for the vthread
     infrastructure.  The idea is to pretend firing a spawned thread,
     but in fact it's the main thread that runs the code.  This function
     must imperatively be called within the 'lw6sys_vthread_run'
     function, else it will fail or be buggy.

     *Return value:* none.

 -- Struct: lw6sys_assoc_s

     Assoc is a basic key/pair structure where key is a string.  Use it
     for basic associations, it's not fast when there are many keys, in
     that case, prefer a hash.

 -- Member of lw6sys_assoc_s: key
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_assoc_s::key'

     The key, a 0 terminated standard C string.

 -- Member of lw6sys_assoc_s: value
     *Type:* 'void *'

     *Definition:* 'void* lw6sys_assoc_s::value'

     The value, pointer to arbitrary data.

 -- Member of lw6sys_assoc_s: free_func
     *Type:* 'lw6sys_free_func_t'

     *Definition:* 'lw6sys_free_func_t lw6sys_assoc_s::free_func'

     This function will be called whenever the element is deleted.  You
     can set it to NULL in that case no callback will be called on
     deletion.

 -- Member of lw6sys_assoc_s: next_item
     *Type:* 'lw6sys_assoc_p'

     *Definition:* 'lw6sys_assoc_p lw6sys_assoc_s::next_item'

     Pointer on the next item, will be NULL on last element, there's a
     difference between a NULL pointer and a valid assoc with only one
     item being EOL.

 -- Struct: lw6sys_cache_item_s

     Cache item is the object used to hold data within hash, to
     implement cache features.  It basically stores a pointer to the
     actual data, and a timestamp which marks the expiration time.  In
     practice, a cache is just an hash which contains this kind of data.

 -- Member of lw6sys_cache_item_s: expiration_timestamp
     *Type:* 'int64_t'

     *Definition:* 'int64_t lw6sys_cache_item_s::expiration_timestamp'

     Expiration time, after this time, key is considered invalid.

 -- Member of lw6sys_cache_item_s: real_free_func
     *Type:* 'lw6sys_free_func_t'

     *Definition:* 'lw6sys_free_func_t
     lw6sys_cache_item_s::real_free_func'

     OK, now this requires some explanation : to use standard hash /
     assoc function we need the cache hash to behave like a real hash.
     So the trick is to store within the data structure the pointer on
     the real free callback.  This way the special cache_free callback
     will have a way to call the genuine free function before destroying
     the cache container.  This duplicates the pointer, but avoids code
     duplication.  In practice caches shouldn't be that big anyway, so
     it won't eat up all your memory anyway.

 -- Member of lw6sys_cache_item_s: value
     *Type:* 'void *'

     *Definition:* 'void* lw6sys_cache_item_s::value'

     The actual value.

 -- Struct: lw6sys_cache_s

     Cache is an object based on which works pretty much the same but
     adds the possiblity to give an expiration time to a key.  Any key
     with an expiration time in the past will be removed on query and
     appear as non-existing to callers.

 -- Member of lw6sys_cache_s: delay_msec
     *Type:* 'int'

     *Definition:* 'int lw6sys_cache_s::delay_msec'

     Delay in milliseconds before a key expires.

 -- Member of lw6sys_cache_s: real_free_func
     *Type:* 'lw6sys_free_func_t'

     *Definition:* 'lw6sys_free_func_t lw6sys_cache_s::real_free_func'

     The real free_func to call on objects.

 -- Member of lw6sys_cache_s: data
     *Type:* 'lw6sys_hash_t *'

     *Definition:* 'lw6sys_hash_t* lw6sys_cache_s::data'

     The actual data.

 -- Struct: lw6sys_color_8_s

     Used to store colors when representing them in RGBA mode with
     integers ranging from 0 to 255.

 -- Member of lw6sys_color_8_s: r
     *Type:* 'u_int8_t'

     *Definition:* 'u_int8_t lw6sys_color_8_s::r'

     Red [0 ...  255].

 -- Member of lw6sys_color_8_s: g
     *Type:* 'u_int8_t'

     *Definition:* 'u_int8_t lw6sys_color_8_s::g'

     Green [0 ...  255].

 -- Member of lw6sys_color_8_s: b
     *Type:* 'u_int8_t'

     *Definition:* 'u_int8_t lw6sys_color_8_s::b'

     Blue [0 ...  255].

 -- Member of lw6sys_color_8_s: a
     *Type:* 'u_int8_t'

     *Definition:* 'u_int8_t lw6sys_color_8_s::a'

     Alpha [0 ...  255].  255 is opaque, 0 is transparent.

 -- Struct: lw6sys_color_f_s

     Used to store colors when representing them in RGBA mode with
     floats ranging from 0.0f to 1.0f.

 -- Member of lw6sys_color_f_s: r
     *Type:* 'float'

     *Definition:* 'float lw6sys_color_f_s::r'

     Red [0 ...  1.0f].

 -- Member of lw6sys_color_f_s: g
     *Type:* 'float'

     *Definition:* 'float lw6sys_color_f_s::g'

     Green [0 ...  1.0f].

 -- Member of lw6sys_color_f_s: b
     *Type:* 'float'

     *Definition:* 'float lw6sys_color_f_s::b'

     Blue [0 ...  1.0f].

 -- Member of lw6sys_color_f_s: a
     *Type:* 'float'

     *Definition:* 'float lw6sys_color_f_s::a'

     Alpha [0 ...  1.0f].  1.0f is opaque, 0.0f is transparent.

 -- Struct: lw6sys_color_hsv_s

     Used to store colors when representing them in HSV mode with floats
     ranging from 0.0f to 1.0f.  An alpha channel has been added so this
     is more HSVA than HSV.

 -- Member of lw6sys_color_hsv_s: h
     *Type:* 'float'

     *Definition:* 'float lw6sys_color_hsv_s::h'

     Hue [0 ...  360.0f].  0.0f is red, 120.0f is green, 240.0f is blue.

 -- Member of lw6sys_color_hsv_s: s
     *Type:* 'float'

     *Definition:* 'float lw6sys_color_hsv_s::s'

     Saturation [0 ...  1.0f].

 -- Member of lw6sys_color_hsv_s: v
     *Type:* 'float'

     *Definition:* 'float lw6sys_color_hsv_s::v'

     Value [0 ...  1.0f].

 -- Member of lw6sys_color_hsv_s: a
     *Type:* 'float'

     *Definition:* 'float lw6sys_color_hsv_s::a'

     Alpha [0 ...  1.0f].  1.0f is opaque, 0.0f is transparent.

 -- Struct: lw6sys_context_s

     Global context, used by pretty much any function, this is used to
     avoid storing global static variables, and allow all code to be
     used in a multithreaded context.  In practice some libraries the
     program relies on might still use globals but at least the
     limitation is not induced by Liquid War 6 itself.  Note that this
     structure is a wrapper over the internal structure which contains
     the real members, the first two members need be the same as it is
     casted internally.

 -- Member of lw6sys_context_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6sys_context_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Struct: lw6sys_hash_s

     Hash is a basic hash structure, relying on assoc for
     implementation.  Actually, what it does is storing an array of
     assoc, the number of assoc elements is given at construction.  Then
     when accessing a member, a quick checksum is made from the key,
     which enables finding out which assoc must be queried.  If the hash
     is properly sized, then once one has found the right assoc, finding
     the right key is fast, since there are only a few of them in each
     assoc, and it avoids scanning for for all keys, which is the very
     purpose of the hash.

 -- Member of lw6sys_hash_s: size
     *Type:* 'int'

     *Definition:* 'int lw6sys_hash_s::size'

     Number of assoc used for this hash, passed at construction.

 -- Member of lw6sys_hash_s: entries
     *Type:* 'lw6sys_assoc_t **'

     *Definition:* 'lw6sys_assoc_t** lw6sys_hash_s::entries'

     Array of assoc holding the actual data.

 -- Member of lw6sys_hash_s: free_func
     *Type:* 'lw6sys_free_func_t'

     *Definition:* 'lw6sys_free_func_t lw6sys_hash_s::free_func'

     This function will be called whenever the element is deleted.  You
     can set it to NULL in that case no callback will be called on
     deletion.

 -- Struct: lw6sys_hexa_serializer_s

     The hexa (for hexadecimal) serializer is a tool used to simplify
     serialization processes, you can just push/pop basic data types on
     it, it will concatenate the string, allocate memory, do all this
     dirty stuff without requiring you to plan the size of the buffer,
     among other things.

 -- Member of lw6sys_hexa_serializer_s: buf
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_hexa_serializer_s::buf'

     Data buffer.

 -- Member of lw6sys_hexa_serializer_s: buf_size
     *Type:* 'int'

     *Definition:* 'int lw6sys_hexa_serializer_s::buf_size'

     Size of data buffer, in bytes.

 -- Member of lw6sys_hexa_serializer_s: pos
     *Type:* 'int'

     *Definition:* 'int lw6sys_hexa_serializer_s::pos'

     Current position within the buffer, this is, typically, the place
     where data will be appended at the next push call, or where it will
     be fetched from at the next pop call.

 -- Struct: lw6sys_list_r_s

     List_r is a list system based on list plus a mutex that ensures you
     can safely call functions on it, without worrying about
     concurrency.  All functions with list_r_ in in their name do lock
     the list_r before using it, and release it afterwards.  Else, the
     API is pretty much the same, except some functions that take a **
     with a list take a simple * with a list_r.

 -- Member of lw6sys_list_r_s: mutex
     *Type:* 'lw6sys_mutex_t *'

     *Definition:* 'lw6sys_mutex_t* lw6sys_list_r_s::mutex'

     Mutex used to avoid multiple accesses.  Locked / unlocked on each
     member function call except new and free.

 -- Member of lw6sys_list_r_s: list
     *Type:* 'lw6sys_list_t *'

     *Definition:* 'lw6sys_list_t* lw6sys_list_r_s::list'

     List containing the data.  Basically, the list_r is just a wrapper
     on this, bundled with the mutex.

 -- Member of lw6sys_list_r_s: free_func
     *Type:* 'lw6sys_free_func_t'

     *Definition:* 'lw6sys_free_func_t lw6sys_list_r_s::free_func'

     This function will be called whenever the element is deleted.  You
     can set it to NULL in that case no callback will be called on
     deletion.

 -- Struct: lw6sys_list_s

     List is a basic list system, with a void * pointer to hold
     arbitrary data and a callback function for deletion.  Provides
     basic functions to push, pop, walk, any array-like call will of
     course be very slow.  As of current implementation, front
     operations are fast, but back operations are slow.

 -- Member of lw6sys_list_s: data
     *Type:* 'void *'

     *Definition:* 'void* lw6sys_list_s::data'

     Opaque pointer on element data.

 -- Member of lw6sys_list_s: free_func
     *Type:* 'lw6sys_free_func_t'

     *Definition:* 'lw6sys_free_func_t lw6sys_list_s::free_func'

     This function will be called whenever the element is deleted.  You
     can set it to NULL in that case no callback will be called on
     deletion.

 -- Member of lw6sys_list_s: next_item
     *Type:* 'lw6sys_list_p'

     *Definition:* 'lw6sys_list_p lw6sys_list_s::next_item'

     Pointer on the next item, will be NULL on last element, there's a
     difference between a NULL pointer and a valid list with only one
     item being EOL. Other way to state it: NULL and empty list are two
     different things.

 -- Struct: lw6sys_module_pedigree_s

     Structure used to store informations about a module.  This
     describes the module, its author license, this is both a legal
     check and a technical check, to maximize the chances the code we're
     running is the right one, and to trace it.

 -- Member of lw6sys_module_pedigree_s: id
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_module_pedigree_s::id'

     Module id, for instance, could be "gl1".

 -- Member of lw6sys_module_pedigree_s: category
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_module_pedigree_s::category'

     Module category, for instance, could be "gfx".

 -- Member of lw6sys_module_pedigree_s: name
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_module_pedigree_s::name'

     Module name, readable (displayable) name.

 -- Member of lw6sys_module_pedigree_s: readme
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_module_pedigree_s::readme'

     Module readme text.

 -- Member of lw6sys_module_pedigree_s: version
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_module_pedigree_s::version'

     Module version.

 -- Member of lw6sys_module_pedigree_s: copyright
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_module_pedigree_s::copyright'

     Module (short) copyright information.

 -- Member of lw6sys_module_pedigree_s: license
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_module_pedigree_s::license'

     Module (short) license.

 -- Member of lw6sys_module_pedigree_s: date
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_module_pedigree_s::date'

     Date of module compilation.

 -- Member of lw6sys_module_pedigree_s: time
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_module_pedigree_s::time'

     Time of module compilation.

 -- Struct: lw6sys_mutex_s

     Mutex is our own wrapper on the pthread mutex object.  Why not use
     the pthread mutex directly?  For debugging, this allows us to place
     and instrument hooks if needed.

 -- Member of lw6sys_mutex_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6sys_mutex_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Struct: lw6sys_progress_s

     Structure used to store progress information.  The idea is that is
     that must be usable in polling mode or in multithreaded mode, and
     we must be able to truncate a progress indicator into several
     stages.  So this structure contains a range start, a range end, and
     its value between those two, which is meant to be written by the
     code executing the operation and read by the caller/rendering
     thread.

 -- Member of lw6sys_progress_s: min
     *Type:* 'float'

     *Definition:* 'float lw6sys_progress_s::min'

     Where the progress operation starts.

 -- Member of lw6sys_progress_s: max
     *Type:* 'float'

     *Definition:* 'float lw6sys_progress_s::max'

     Where the progress operation ends.

 -- Member of lw6sys_progress_s: value
     *Type:* 'float *'

     *Definition:* 'volatile float* lw6sys_progress_s::value'

     Somewhere between min and max.

 -- Struct: lw6sys_spinlock_s

     Spinlock is our own wrapper on a spinlock based mutex.  Why not use
     the pthread spinlock directly?  For debugging, this allows us to
     place and instrument hooks if needed.  Additionnally, some
     implementations of pthread do not provide spinlock and in that case
     we provide our own alternative.

 -- Member of lw6sys_spinlock_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6sys_spinlock_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Struct: lw6sys_thread_handler_s

     Thread handler is our own wrapper on the pthread object.  Why not
     use the pthread handler directly?  Basically to store basic flags
     and context data (void * pointer on our thread data for instance)
     along with the handler.  This is merely for debugging and
     convenience.  Internally this will be casted to
     _lw6sys_thread_handler_t.

 -- Member of lw6sys_thread_handler_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6sys_thread_handler_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Struct: lw6sys_url_s

     Describes an URL, with its elements splitted, this is just to be
     able to use half-parsed URLs and avoid redoing this parsing
     everytime.

 -- Member of lw6sys_url_s: use_ssl
     *Type:* 'int'

     *Definition:* 'int lw6sys_url_s::use_ssl'

     1 if in https, 0 if in http.

 -- Member of lw6sys_url_s: host
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_url_s::host'

     Host name.

 -- Member of lw6sys_url_s: port
     *Type:* 'int'

     *Definition:* 'int lw6sys_url_s::port'

     IP port.

 -- Member of lw6sys_url_s: uri
     *Type:* 'char *'

     *Definition:* 'char* lw6sys_url_s::uri'

     URI, that is, everything after the port.

 -- Struct: lw6sys_whd_s

     Contains the shape of a 3D box.  There are 3 differences with its
     "XYZ" equivalent.  First, sometimes w*h*d reads better than x,y,z.
     Then, xyz is signed, whd is unsigned.  Finally, these are real
     int32 values, they are not 14-bit limited.  It does not really cost
     any memory for it's usually used as a single "shape" attribute for
     a whole map.  At the same time, it's very often used as a test
     value in loops, so it's interesting to have it in a value that's
     easy to optimize for the compiler (exactly one register...)

 -- Member of lw6sys_whd_s: w
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6sys_whd_s::w'

     Width.

 -- Member of lw6sys_whd_s: h
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6sys_whd_s::h'

     Height.

 -- Member of lw6sys_whd_s: d
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6sys_whd_s::d'

     Depth.

 -- Struct: lw6sys_xyz_s

     All-in 32 bit 3D position, to save memory.It's a deliberate choice
     in Liquid War to handle "limited size" levels.  In fact 14 bits
     still allows 8000x8000 maps, which are at least 100 times too slow
     to play now (2008).  Should we follow Moore's law we'd have at
     least 6 years until those are playable, and well, until then, let's
     wait.  The point is that storing this information (x*y) on 4 bytes
     might be very important in some cases, since it can reduce memory
     footprint on structs which are stored in numerous quantities, and
     therefore maximize chances that we use level 1 &amp; 2 caches and
     other nice things which happen when memory consumption is not too
     high.Point is: why use INT32 and then limit it to 14 bits instead
     of using an INT16 or short in the first place?  Answer: it's easier
     to handle INT32 all the time in the rest of the code.  Compiler and
     CPU might even handle that better than short.  Then, and only when
     data will be read/written in the struct will it be truncated.
     Typical example is: we want to multiplicate y by w (which is a
     width).  Result is beyond INT16/short scope but we want to handle
     it!  Casting everything to INT32/int is a pain.  With this int y:14
     trick, we use y as a "full-featured" INT32/int and well, when it
     will be read/written we'll loose values over 8191, but we simply do
     not care.

 -- Member of lw6sys_xyz_s: x
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6sys_xyz_s::x'

     X position, from -8192 to +8191.

 -- Member of lw6sys_xyz_s: y
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6sys_xyz_s::y'

     Y position, from -8192 to +8191.

 -- Member of lw6sys_xyz_s: z
     *Type:* 'int32_t'

     *Definition:* 'int32_t lw6sys_xyz_s::z'

     Z position, from -8 to +7.

5.48 libtsk
===========

5.48.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/tsk/index.html>.

5.48.2 API
----------

 -- Function: void lw6tsk_loader_push_ldr (lw6sys_context_t *
          SYS_CONTEXT, lw6tsk_loader_t * LOADER, const char * MAP_PATH,
          const char * RELATIVE_PATH, lw6sys_assoc_t * DEFAULT_PARAM,
          lw6sys_assoc_t * FORCED_PARAM, int DISPLAY_W, int DISPLAY_H,
          int BENCH_VALUE, int MAGIC_NUMBER)
     SYS_CONTEXT: global system context

     LOADER: loader object

     MAP_PATH: map-path config entry

     RELATIVE_PATH: relative map path

     DEFAULT_PARAM: default parameters to use for load

     FORCED_PARAM: parameters to be forced and their values

     DISPLAY_W: display width

     DISPLAY_H: display height

     BENCH_VALUE: bench value, reflecting computer CPU power

     MAGIC_NUMBER: used to calibrate speed

     Pushes a load request to the loader.  Will stop the current load
     and push a new one.  The request concerns a map which should be
     loaded from a map directory on the filesystem.

     *Return value:* none.

 -- Function: void lw6tsk_loader_push_gen (lw6sys_context_t *
          SYS_CONTEXT, lw6tsk_loader_t * LOADER, const char * SEED, int
          DISPLAY_W, int DISPLAY_H, int BENCH_VALUE, int MAGIC_NUMBER)
     SYS_CONTEXT: global system context

     LOADER: loader object

     SEED: seed string used to create the map

     DISPLAY_W: display width

     DISPLAY_H: display height

     BENCH_VALUE: bench value, reflecting computer CPU power

     MAGIC_NUMBER: used to calibrate speed

     Pushes a load request to the loader.  Will stop the current load
     and push a new one.  The request is forwarded to the pseudo-random
     map generation module.

     *Return value:* none.

 -- Function: int lw6tsk_loader_pop (lw6sys_context_t * SYS_CONTEXT,
          lw6map_level_t ** LEVEL, lw6ker_game_struct_t ** GAME_STRUCT,
          lw6ker_game_state_t ** GAME_STATE, int * BENCH_VALUE,
          lw6tsk_loader_t * LOADER)
     SYS_CONTEXT: global system context

     LEVEL: loaded level (out param)

     GAME_STRUCT: loaded struct (out param)

     GAME_STATE: loaded state (out param)

     BENCH_VALUE: the bench_value used (out param)

     LOADER: loader object

     Pops data from the loader, will allocate everything dynamically.
     Function can either return just level or level and game struct and
     game state (3 of them together).  It's safe to use the received
     level, display it right away, then wait for the rest.  If things
     are loaded fast enough, you just receive everything at once.

     *Return value:* 1 if some data, 0 if none.

 -- Function: lw6tsk_loader_t * lw6tsk_loader_new (lw6sys_context_t *
          SYS_CONTEXT, float SLEEP, char * USER_DIR, volatile float *
          PROGRESS)
     SYS_CONTEXT: global system context

     SLEEP: how many seconds to wait between every poll

     USER_DIR: user directory

     PROGRESS: progress indicator to use

     Creates a new loader.  This object is used to do some reputed slow
     calculus in the background, in a separated thread.  Typical example
     is map loading.  This is a high-level objects which encapsulates
     threads and other wizardry.

     *Return value:* a pointer to the loader, NULL if failed.

 -- Function: void lw6tsk_loader_free (lw6sys_context_t * SYS_CONTEXT,
          lw6tsk_loader_t * LOADER)
     SYS_CONTEXT: global system context

     LOADER: the loader to free.

     Deletes a loader.  Will automatically stop the child thread, free
     data, and so on.

     *Return value:* none.

 -- Function: char * lw6tsk_loader_repr (lw6sys_context_t * SYS_CONTEXT,
          const lw6tsk_loader_t * LOADER)
     SYS_CONTEXT: global system context

     LOADER: the loader to represent.

     Creates a string which briefly describes the loader.

     *Return value:* a dynamically allocated pointer, must be freed.

 -- Function: int lw6tsk_loader_get_stage (lw6sys_context_t *
          SYS_CONTEXT, lw6tsk_loader_t * LOADER)
     SYS_CONTEXT: global system context

     LOADER: the loader to query.

     Returns the current stage of the loader.

     *Return value:* 0 if idle, 1 if loading the map from disk, 2 if
     build dynamic stuff such as game_state.

 -- Function: int lw6tsk_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libtsk module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6tsk_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'tsk' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6tsk_loader_s

     Loader object, allows asynchronous map loading.

 -- Member of lw6tsk_loader_s: id
     *Type:* 'u_int32_t'

     *Definition:* 'u_int32_t lw6tsk_loader_s::id'

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation.

 -- Member of lw6tsk_loader_s: thread
     *Type:* 'lw6sys_thread_handler_t *'

     *Definition:* 'lw6sys_thread_handler_t* lw6tsk_loader_s::thread'

     Thread used to run the loader.

 -- Member of lw6tsk_loader_s: data
     *Type:* 'void *'

     *Definition:* 'void* lw6tsk_loader_s::data'

     Data used by the loader.

5.49 libvox
===========

5.49.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
<http://www.ufoot.org/liquidwar/v6/doc/coverage/src/lib/vox/index.html>.

5.49.2 API
----------

 -- Function: lw6vox_renderer_t * lw6vox_renderer_new (lw6sys_context_t
          * SYS_CONTEXT, lw6ker_game_state_t * GAME_STATE)
     SYS_CONTEXT: global system context

     GAME_STATE: the game state to use

     Creates a voxel rendering object (todo, not implemented yet).

     *Return value:* renderer object

 -- Function: void lw6vox_renderer_free (lw6sys_context_t * SYS_CONTEXT,
          lw6vox_renderer_t * RENDERER)
     SYS_CONTEXT: global system context

     RENDERER: the renderer object

     Frees a voxel rendering object (todo, not implemented yet).

     *Return value:* none

 -- Function: int lw6vox_test_register (lw6sys_context_t * SYS_CONTEXT,
          int MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Registers all tests for the libvox module.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Function: int lw6vox_test_run (lw6sys_context_t * SYS_CONTEXT, int
          MODE)
     SYS_CONTEXT: global system context

     MODE: test mode (bitmask)

     Runs the 'vox' module test suite, testing most (if not all...)
     functions.

     *Return value:* 1 if test is successfull, 0 on error.

 -- Struct: lw6vox_renderer_s

     Voxel renderer object, not implemented yet.

 -- Member of lw6vox_renderer_s: dummy
     *Type:* 'int'

     *Definition:* 'int lw6vox_renderer_s::dummy'

     Todo...

Appendix A Authors
******************

Here's a list of contributors :

   Project maintainer, main developper :
   * Christian Mauduit (mailto:ufoot@ufoot.org)

   Original idea :
   * Thomas Colcombet

   Artwork, level design :
   * Kasper Hviid

   Musics :
   * Tim Chadburn (menus)
   * Robert Radamant (Free the sounds)
   * LapSuS (Heav'hypnosis)
   * Nighter313 (Oriental Travel)

   Libcaca backend :
   * A. Frances
   * R. Clavel
   * K. Lemmonnier

   Translations :
   * Karl Ove Hufthammer (NN, Norwegian)
   * Yevgeny Lezhnin (RU, Russian)

   Many people contributed to Liquid War 5
(http://www.ufoot.org/liquidwar/v5), their names are not listed here,
but without them Liquid War 6 would obviously never have been started.
Special thanks to all of them.  However this is not a direct
contribution to the project, in terms of code and other copyrightable
materials.

Appendix B 2005 .plan
*********************

Here's my .plan file, which describes what I (Christian Mauduit
(mailto:ufoot@ufoot.org)) have planned for Liquid War 6.  There's no
garantee that what's written here is a precise description of the real
future, however it should give a good idea of what I have in mind.

   Note that the information here was written in summer 2005, it might
or not be accurate now, as the main reason for plans to exist is that
people never follow them.  I'm no exception.

B.1 Complete rewrite
====================

Liquid War 6 will be an almost complete rewrite.  I mean that common
code between branches 5 and 6 might end up in representing 0% of the
total code.  I think this is a wise decision, for the current code is
really hard to maintain, and would not survive any serious cleanup.  LW5
was first written in 1998, for DOS, when I had much less experience in
programming.  In 7 years I - and other people as well - hacked major
enhancements in it such as cross-platform support, network games, and if
you compare release 5.0 with the latest 5.x.x release, you'll see that a
bunch of things have changed.  I had never expected I would patch and
fix this game for so long, and it's no surprise that it's bloated today.

   FYI, here's a list of what makes LW5 unsuitable for major
improvements without a complete rewrite:

   * global variable hell.  Lots of things are stored in globals.
   * hard-coded C GUI. Read src/level.c to get an idea of how horrible
     it is.
   * hard-coded 256 colors paletted mode.  A clever bet in 1998
     (performance...).  Not anymore.
   * generally bloated code.  Makes bug-finding very tricky.

B.2 Technologies
================

Liquid War 6 will use a different technical framework than Liquid War 5
(http://www.ufoot.org/liquidwar/v5).

B.2.1 Script + standard C + assembly
------------------------------------

It happens that coding a large project in pure C is a waist of time, if
possible at all.

   If one applies the standard 80/20 rule to a computer game, one might
state that 80% of the code eat up 20% of the CPU and the other 20% of
the code eat up 80% of the CPU, the former being high-level glue code
and the latter being low-level algorithmic code.

   With Liquid War, one could speak of the 99/01 rule.  I mean that 99%
of the CPU time concerns only 1% of the code, and vice-versa.
Basically, Liquid War has a very CPU-greedy core algorithm, still spends
a fair amount of CPU displaying stuff (but this is delegated to the
low-level game programming library) and the rest is totally
unsignificant, in terms of CPU. Point is this "rest" represents the vast
majority of the code, and also represents the very same buggy code I
spend nights to patch on Liquid War 5
(http://www.ufoot.org/liquidwar/v5).  I'm talking about network code,
GUI, and other high-level glue-code which are currently being written in
C.

   This idea is to write all this in a convenient scripting language.
There won't be any impact on performances.  I can't garantee Liquid War
6 will be blazingly fast, but for sure it won't be the scripting
language fault.  And of course if, as in Liquid War 3 and 5, I feel the
need to implement some stuff in assembly for performances issues, I will
do it.

   We end up with a multi-language architecture: script + C + assembly.

   My guess is that I'll use Scheme (http://www.gnu.org/software/guile/)
as an extension language.  Python (http://www.python.org) would be a
good choice too.  Let's say I'll give Scheme a chance, and if it's
really not adapted, I'll switch back to Python.  The point is that today
I know Python and don't really know Scheme, but, well, it's always a
pleasure for me to learn new things.  It's fun.

   So what is planned today is that Liquid War 6 will be a Scheme
program, which will call callbacks functions written in C and/or
assembly.  These functions will do all the low-level time consuming
algorithmic and graphical stuff.  The rest of the code being entirely
scripted.

B.2.2 OpenGL
------------

Liquid War is not a 3D game, so why use OpenGL?

   * it's a very convenient way to access video hardware acceleration
     with XFree86.
   * low-end computers and/or computers without 3D acceleration can
     still run Liquid War 5 (http://www.ufoot.org/liquidwar/v5).
   * I'm interested in learning/using this API 8-)

   This choice implies that I won't use Allegro
(http://alleg.sourceforge.net/) anymore.  Allegro stays a very
convenient library and I would recommend it for it's excellent, easy to
learn, powerfull, and stable.  But for the needs of Liquid War 6 I'll
use something else (because of OpenGL). I first thought of using GLUT
(http://freeglut.sourceforge.net/) but I might end up simply using SDL
(http://www.libsdl.org/).  The idea is just fo have an OpenGL wrapper
which sets up OpenGL in a similar manner on all platforms, and handles
basic things such as mouse or keyboard.

B.2.3 CSound
------------

I've got two excellent books on Csound (http://www.csounds.com/), and
the will to learn how to use this tool.

   I'll probably use Csound for a number of things, ranging from
"bubbling sounds" to full blown music.  Stay tuned 8-)

B.3 Functionnalities
====================

B.3.1 Visual enhancements
-------------------------

Of course Liquid War 6 will look nicer than Liquid War 5
(http://www.ufoot.org/liquidwar/v5), blah blah blah.  What do you think?

   Maybe I'll try to use some OpenGL features to make it possible to
play on a ball, on a Moebius ring, or other fancy things.  I have
zillion of ideas, future will decide which ones will be implemented
first.

   To make it clear, visual enhancements aren't my top-level priority.
However I'll try and make room for these enhancements, and prepare the
terrain correctly.  So it's possible that the first releases of Liquid
War 6 won't be that much better than Liquid War 5
(http://www.ufoot.org/liquidwar/v5), but at least Liquid War 6 will have
the possibility to evolve.  Something Liquid War 5
(http://www.ufoot.org/liquidwar/v5) doesn't have.

B.3.2 Rules enhancements
------------------------

There are many things that could be done easily:

   * several cursors for one team
   * alliances between teams
   * deep places on a map, where more liquid can reside
   * circular maps which "connect" the left border to the right one
   * ...

   As for graphical improvements, this is not my top-level priority.
Simply, I'll make the game ready-to-improve.  Again, all these
enhancements are very hard to code in Liquid War 5
(http://www.ufoot.org/liquidwar/v5), else I would already have coded
them.  Network enhancements

   That's my top-level prioriry.

   Why is that?  Well, think of Liquid War in terms of "what makes it a
good game?"  and "what makes it a poor game?".

   It's a good game because:

   * the idea is original
   * the gameplay is addictive
   * you can play on a LAN
   * all the family can play
   * it's cross-platform
   * it's Free Software

   It's a poor game because:

   * it's somewhat ugly and has a retro "back in the eighties" look
   * network games are slow on Internet
   * there are not enough active Internet servers

   For the ugliness, well, OpenGL and some artwork should make it.  But
for the network, what's the real problem?

   The real problem is that in the current situation, the server needs
to have all "keystrokes" before doing anything, and all players must be
connected before a game starts.  Here's what I plan to do to fix this:

   * players will be able to connect on a game "on the fly".  This is
     done by most online games, and it's IMHO a required features for a
     network mode to work on Internet (not speaking of local networks,
     but real wide online gaming).  How this will fit with Liquid War's
     rules is not totally decided, but I already know of several way to
     achieve this.
   * I'll implement an "anticipation" system "a la" U61
     (http://www.ufoot.org).  This means that no matter if a remote
     player has a poor network connection, things will behave as if
     everything was fine.  Internally, the system keeps 2 images of the
     game.  One which is "anticipated" and displayed to the player, and
     one which is validated but outdated, kept internally.  It's a
     little hard to explain, consumes twice as much CPU and memory, but
     it works.  It happens that today the lacking ressource for playing
     Liquid War online is more on the network side than on the local CPU
     and memory aspects.
   * I'll take it to the next level and implement a "peer-to-peer-like"
     network model, in which any client can become a server.  The idea
     behind is that if a server quits the game, then a client takes its
     role, letting the game continue for hours.  This way one could
     virtually have a never ending Liquid War game which would last
     weeks.  I believe this could be really cool.  I also believe no
     proprietary game will ever implement that, for in this model
     there's no way to force people to access a centralized server, this
     server usually being the major key in the business model of a
     company which sells proprietary software.

   This third point will be the real enhancement of Liquid War with
version 6.  It's one of the very points which drives me to rewrite it
completely.  First because it's impossible to implement it without some
heavy work.  Then because I find it very motivating.

B.3.3 Hey, you forgot my idea!!!
--------------------------------

Many gamers submitted suggestions, either by mail or by posting messages
on the mailing list.

   Don't worry, I keep them.  Not reading them here does not mean I
won't implement them.  It simply means I won't implement them first.  I
first need the game basically function before enhancing it with fancy
stuff.

B.4 Road map
============

As I stated on the mailing list, when thinking about Liquid War 6, think
of years rather than months (unless I get fired, jobless, or spend
several months in a hospital with a laptop).

   Note that this road map takes it for granted that I'll be the lone
coder on the project.  It's unlikely that someone is going to help me
for the first stages, until there's at least something real, something
playable.  Something that proves that the concept is valid.  Besides,
(real) team work implies a significant overhead, especially at project
start.  It's hard to figure out how to distribute tasks when the tasks
themselves are not clearly identified.  But for the rest (starting in
2007 or 2008), it's possible that external help might greatly...
...help!

   * 2005 : Project framework should be done.  This implies that the
     scripting engine is up and running, graphical mode works, config
     and data loading work, basic menus are available.  Nothing
     playable.
   * 2006 : Import the core algorithm from Liquid War 5
     (http://www.ufoot.org/liquidwar/v5), make the game playable in
     "demo mode" ("à la" Liquid War 2), implement the network
     "peer-to-peer-like" mode.  At this stage, it will be possible to
     know wether Liquid War 6 is true vaporware or not.
   * 2007 : glue all this together to make something usable by anyone,
     heavy work on the GUI, on the options, on error checking, many bug
     fixes.  The goal is to have a game which is equivalent to Liquid
     War 5 (http://www.ufoot.org/liquidwar/v5), with the network aspects
     pushed to the next level.
   * 2008 : tadaaaaaaaaaaa!  Release the game "publicly" - inform
     Freecode 8-) - and enhance it with all the feedback from gamers
     (bug reports and suggestions received since 1998).  Work on artwork
     (both graphics and musics).  Write documentation.
   * 2009 : stabilize the game, patch it for all those things which had
     been forgotten back then in 2005, optimize for speed, bug-fix
     bug-fix bug-fix.
   * 2010 : stop maintaining Liquid War 5
     (http://www.ufoot.org/liquidwar/v5), invite Liquid War fans and
     coders to a hudge party in my garden, sing all night, drink beers
     and wine, teach Liquid War strategies to my 5 and 6 year old
     daughters, remember the old times when Liquid War wasn't so cool
     8-)

Appendix C Fanfic
*****************

Quoting Gavin: "I wrote a liquid war fanfic some time ago [...]  I wrote
it after a friend claimed that there wasn't any liquid war fanfic
because it wasn't possible."

   So here it is, a Liquid War fanfic.  It was initially written for
Liquid War 5, but applies to Liquid War 6 as well.  Enjoy!

C.1 The Battle of Emberlificoted
================================


...

   The General presided over his massing army in his seat, or rather
hovering ring, of power.  It dipped slightly as he flew low over his
troops marching through the viscous marsh-like terrain.  They were like
children: obedient, loyal, and they ate a lot.

   Glancing at the status panel mounted in front of him he grimaced; the
other five armies: Yellow, Green, Orange, Turquoise, and, of course,
Red, were also readying armies of a similar size to his own.  His violet
clones would have to fight hard and eat well to win this day.

   Today would not be a battle of luck, the General mused, it would be a
battle of tactics, of alliances, and of betrayal.  Every clone was
identical - that was the general idea behind clones - and the terrain
seemed strangely symmetrical; it would not give advantage to any of the
six armies amassed today.  Glancing at the hologram of the battlefield
projected in front of him the General noted that he would have to move
quickly, Orange and Yellow were too close for comfort, though
fortunately Baron Red's army of eponymous coloured clones was the
furthest.

   General Violet's fingertips were sweaty even before they touched the
four main control keys in front of him.  They were labeled 'W', 'A',
'D', and, of course, the full retreat button - very useful for
misleading foes and ambushing them as they pursued - 'S'. The keys were
arrange in a roughly equilateral triangular pattern; with 'S' forming
the base and being adjacent to both 'A' and 'D', 'W' formed the tip of
the triangle.

   A long breath left his parched lips as at last he made his move.


   ...

   "Dammit!"  he screamed moments later.  He had misjudged Captain
Yellow and Commander Orange; he had expected one at least to attack
immediately, one he could have handled.  They were working together -
foiling his attempt to shoot between them to near the center of the
battlefield to gain a better vantage point.  Yellow had shot down
towards him, cutting off his advance, and now Orange had sealed his
escape route.  "It's not over yet" muttered the General.  He opened a
voice channel with Commander Orange:

   "Very clever.  Flawed, but still clever."

   "Flawed?"  came the reply.

   "Yes flawed, when the good Captain is finished devouring my army who
do you think he will turn to next?", bluffed the General - his hands
worked quickly as he manoeuvred his hovering control ring, all that his
troops ever saw of him, carefully towards the weakest section of his
attackers.  If he could just break out a few units he could soon turn
the tide against both Yellow and Orange.

   "We have an alliance..."  Orange's voice was unsure now.

   Time for some sarcasm to through her even more off balance, thought
the General,

   "I gathered", he spoke softly, slowly, and with too much meaning.
Then closing the channel he turned his attention back to his escape.


   ...

   "Yes!"  wooped the ecstatic figure of the General.  Fifty or so of
his troops had broken free undetected and were even now working their
way cautiously towards the camps of the Yellow army, only the front
lines were still actively fighting; this opening gambit of Yellow and
Orange had turned into a stale siege and Yellow's army had pitched tent.

   General Violet steered his hovering guidance ring to the center of
the Yellow camp.  His troops struck, both those who had got behind the
lines and those who were still besieged.  Yellow reacted too slowly and
suddenly found that her army, was shrinking back from the onslaught.
There was nowhere to run to, and bye now her only ally - Commander
Orange - had abandoned her to her fate; he was too busy engaging Sir.
Turquoise, who had managed to escape from the slaughter that the Baron
had caused to the Turquoise ranks and was even now valiantly attacking
the flanks of the Orange troops.

   A glance at the status panel showed that Yellow's life force was
fading quickly: 8%, 3%, 1%, Gone.

   The General smiled, he always enjoyed getting the first kill, and by
now his armies life force had grown and his clones had replicated.  With
his, now, formidable fighting force it was no problem to engulf both
Sir.  Turquoise and Commander Orange's brawling armies and annihilate
them.  Once again his army grew in size and power.  Now if only the
Baron didn't notice that..., thought the General.


   ...

   "Too late!"  yelped the General, now thrown into panic, as he saw the
approaching Baron.  His army had also grown in size and power - having
fatally injured the Turquoise army within the opening moments of the
battle, and having finally managed to catch the elusive fleeing form of,
or what remained of, Emperor Green.

   Gripping the controls harder the General thought quickly, his army
doesn't so completely outnumber me that this is already over, however
unless I can cause him to make a mistake that allows me to take the
upper hand then I will inevitably lose.  Maybe I can...

   This thought was terminated and replaced by another as the Baron's
angry red troops broke through the undergrowth that had covered their
movements and started to surround the General's army.  The thought that
now throbbed through the panic-stricken mind of General Violet was
simply 'Run!'.

   Even as he signaled the retreat and made for what seemed to be the
only possible means of escape the Baron's blood red control ring
appeared at the opening.  The General knew it was over, even before the
host of red beings appeared at the opening.

   There was no escape.  His life force was almost depleted and he was
surrounded.  Then it was that the Baron decided to communicate:

   "Too bad.  It was a good game"

   The General blinked, gaped, and was generally gobsmacked.  Just
before his life force completely failed and his own weary eyes closed in
defeat he snarled,

   "What!?  This is not a game!"  were the General's dying words.

Appendix D Links
****************

This section lists various Internet Liquid War related links.

D.1 Official links
==================

These are the "official" links, hopefully you'll find everything you
need here:

   * <http://www.gnu.org/software/liquidwar6/>: Liquid War 6 homepage
   * <http://www.gnu.org/software/liquidwar6/manual/>: Online manual
   * <http://ftp.gnu.org/gnu/liquidwar6/>: GNU downloads (source only)
   * <http://download.savannah.gnu.org/releases/liquidwar6/>: Savannah
     downloads (source and binaries)
   * <http://www.ufoot.org/download/liquidwar/v6/>: ufoot.org downloads
     (mirror)
   * <http://www.ufoot.org/liquidwar/v6/snapshots/>: Daily snapshots
   * <http://www.ufoot.org/liquidwar/v6/doc/>: Automatically generated
     doc
   * <http://www.ufoot.org/jenkins/job/liquidwar6/>: Jenkins continuous
     integration
   * <http://git.savannah.gnu.org/cgit/liquidwar6.git>: GIT repository
   * <http://savannah.gnu.org/projects/liquidwar6/>: Project on Savannah
   * <http://savannah.gnu.org/bugs/?func=additem&group=liquidwar6>:
     Submit a bug report
   * <http://lists.gnu.org/archive/html/help-liquidwar6/>: Mailing-list
     archives
   * <http://ufoot.org:8056/>: Permanent "seed" server running latest
     snapshot
   * <irc://irc.freenode.net/liquidwar>: IRC channel '#liquidwar' on
     irc.freenode.net

D.2 Other sites
===============

Note that some of these links might link to and/or promote proprietary
software.  It's important to emphasize Liquid War 6 is free software,
free as in speech, and you are encouraged to use software that protects
your freedom.  However, for your convenience, those links are provided,
they might give you a hopefully neutral idea of what the game is all
about.

   This list is also by no way extensive, it's provided "as is".

   * <http://en.wikipedia.org/wiki/Liquid_War>: Liquid War entry on
     Wikipedia
   * <http://fr.wikipedia.org/wiki/Liquid_War>: Liquid War entry on
     Wikipedia (French)
   * <http://freecode.com/projects/liquid-war-6>: Liquid War 6 on
     Freecode.
   * <http://www.openhub.net/p/liquidwar6>: Liquid War 6 on Open HUB.
   * <http://www.playdeb.net/software/Liquid%20War%206>: Liquid War 6 on
     PlayDeb.

D.3 Old stuff
=============

Various links that are deprecated, but still might contain interesting
informations for those who enjoy digging into the past.

   * <http://arch.sv.gnu.org/archives/liquidwar6/>: GNU Arch repository
     (replaced by Git as for this project)
   * <http://www.ufoot.org/liquidwar/v5>: Liquid War 5, the previous
     version of the game.
   * <http://git.savannah.gnu.org/gitweb/?p=liquidwar6.git>: Gitweb
     interface, cgit seems to be Savannah's default now.

Appendix E GNU GENERAL PUBLIC LICENSE
*************************************

                        Version 3, 29 June 2007

     Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.

Preamble
========

The GNU General Public License is a free, copyleft license for software
and other kinds of works.

   The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

   Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
modification follow.

TERMS AND CONDITIONS
====================

  0. Definitions.

     "This License" refers to version 3 of the GNU General Public
     License.

     "Copyright" also means copyright-like laws that apply to other
     kinds of works, such as semiconductor masks.

     "The Program" refers to any copyrightable work licensed under this
     License.  Each licensee is addressed as "you".  "Licensees" and
     "recipients" may be individuals or organizations.

     To "modify" a work means to copy from or adapt all or part of the
     work in a fashion requiring copyright permission, other than the
     making of an exact copy.  The resulting work is called a "modified
     version" of the earlier work or a work "based on" the earlier work.

     A "covered work" means either the unmodified Program or a work
     based on the Program.

     To "propagate" a work means to do anything with it that, without
     permission, would make you directly or secondarily liable for
     infringement under applicable copyright law, except executing it on
     a computer or modifying a private copy.  Propagation includes
     copying, distribution (with or without modification), making
     available to the public, and in some countries other activities as
     well.

     To "convey" a work means any kind of propagation that enables other
     parties to make or receive copies.  Mere interaction with a user
     through a computer network, with no transfer of a copy, is not
     conveying.

     An interactive user interface displays "Appropriate Legal Notices"
     to the extent that it includes a convenient and prominently visible
     feature that (1) displays an appropriate copyright notice, and (2)
     tells the user that there is no warranty for the work (except to
     the extent that warranties are provided), that licensees may convey
     the work under this License, and how to view a copy of this
     License.  If the interface presents a list of user commands or
     options, such as a menu, a prominent item in the list meets this
     criterion.

  1. Source Code.

     The "source code" for a work means the preferred form of the work
     for making modifications to it.  "Object code" means any non-source
     form of a work.

     A "Standard Interface" means an interface that either is an
     official standard defined by a recognized standards body, or, in
     the case of interfaces specified for a particular programming
     language, one that is widely used among developers working in that
     language.

     The "System Libraries" of an executable work include anything,
     other than the work as a whole, that (a) is included in the normal
     form of packaging a Major Component, but which is not part of that
     Major Component, and (b) serves only to enable use of the work with
     that Major Component, or to implement a Standard Interface for
     which an implementation is available to the public in source code
     form.  A "Major Component", in this context, means a major
     essential component (kernel, window system, and so on) of the
     specific operating system (if any) on which the executable work
     runs, or a compiler used to produce the work, or an object code
     interpreter used to run it.

     The "Corresponding Source" for a work in object code form means all
     the source code needed to generate, install, and (for an executable
     work) run the object code and to modify the work, including scripts
     to control those activities.  However, it does not include the
     work's System Libraries, or general-purpose tools or generally
     available free programs which are used unmodified in performing
     those activities but which are not part of the work.  For example,
     Corresponding Source includes interface definition files associated
     with source files for the work, and the source code for shared
     libraries and dynamically linked subprograms that the work is
     specifically designed to require, such as by intimate data
     communication or control flow between those subprograms and other
     parts of the work.

     The Corresponding Source need not include anything that users can
     regenerate automatically from other parts of the Corresponding
     Source.

     The Corresponding Source for a work in source code form is that
     same work.

  2. Basic Permissions.

     All rights granted under this License are granted for the term of
     copyright on the Program, and are irrevocable provided the stated
     conditions are met.  This License explicitly affirms your unlimited
     permission to run the unmodified Program.  The output from running
     a covered work is covered by this License only if the output, given
     its content, constitutes a covered work.  This License acknowledges
     your rights of fair use or other equivalent, as provided by
     copyright law.

     You may make, run and propagate covered works that you do not
     convey, without conditions so long as your license otherwise
     remains in force.  You may convey covered works to others for the
     sole purpose of having them make modifications exclusively for you,
     or provide you with facilities for running those works, provided
     that you comply with the terms of this License in conveying all
     material for which you do not control copyright.  Those thus making
     or running the covered works for you must do so exclusively on your
     behalf, under your direction and control, on terms that prohibit
     them from making any copies of your copyrighted material outside
     their relationship with you.

     Conveying under any other circumstances is permitted solely under
     the conditions stated below.  Sublicensing is not allowed; section
     10 makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

     No covered work shall be deemed part of an effective technological
     measure under any applicable law fulfilling obligations under
     article 11 of the WIPO copyright treaty adopted on 20 December
     1996, or similar laws prohibiting or restricting circumvention of
     such measures.

     When you convey a covered work, you waive any legal power to forbid
     circumvention of technological measures to the extent such
     circumvention is effected by exercising rights under this License
     with respect to the covered work, and you disclaim any intention to
     limit operation or modification of the work as a means of
     enforcing, against the work's users, your or third parties' legal
     rights to forbid circumvention of technological measures.

  4. Conveying Verbatim Copies.

     You may convey verbatim copies of the Program's source code as you
     receive it, in any medium, provided that you conspicuously and
     appropriately publish on each copy an appropriate copyright notice;
     keep intact all notices stating that this License and any
     non-permissive terms added in accord with section 7 apply to the
     code; keep intact all notices of the absence of any warranty; and
     give all recipients a copy of this License along with the Program.

     You may charge any price or no price for each copy that you convey,
     and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

     You may convey a work based on the Program, or the modifications to
     produce it from the Program, in the form of source code under the
     terms of section 4, provided that you also meet all of these
     conditions:

       a. The work must carry prominent notices stating that you
          modified it, and giving a relevant date.

       b. The work must carry prominent notices stating that it is
          released under this License and any conditions added under
          section 7.  This requirement modifies the requirement in
          section 4 to "keep intact all notices".

       c. You must license the entire work, as a whole, under this
          License to anyone who comes into possession of a copy.  This
          License will therefore apply, along with any applicable
          section 7 additional terms, to the whole of the work, and all
          its parts, regardless of how they are packaged.  This License
          gives no permission to license the work in any other way, but
          it does not invalidate such permission if you have separately
          received it.

       d. If the work has interactive user interfaces, each must display
          Appropriate Legal Notices; however, if the Program has
          interactive interfaces that do not display Appropriate Legal
          Notices, your work need not make them do so.

     A compilation of a covered work with other separate and independent
     works, which are not by their nature extensions of the covered
     work, and which are not combined with it such as to form a larger
     program, in or on a volume of a storage or distribution medium, is
     called an "aggregate" if the compilation and its resulting
     copyright are not used to limit the access or legal rights of the
     compilation's users beyond what the individual works permit.
     Inclusion of a covered work in an aggregate does not cause this
     License to apply to the other parts of the aggregate.

  6. Conveying Non-Source Forms.

     You may convey a covered work in object code form under the terms
     of sections 4 and 5, provided that you also convey the
     machine-readable Corresponding Source under the terms of this
     License, in one of these ways:

       a. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by the
          Corresponding Source fixed on a durable physical medium
          customarily used for software interchange.

       b. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by a
          written offer, valid for at least three years and valid for as
          long as you offer spare parts or customer support for that
          product model, to give anyone who possesses the object code
          either (1) a copy of the Corresponding Source for all the
          software in the product that is covered by this License, on a
          durable physical medium customarily used for software
          interchange, for a price no more than your reasonable cost of
          physically performing this conveying of source, or (2) access
          to copy the Corresponding Source from a network server at no
          charge.

       c. Convey individual copies of the object code with a copy of the
          written offer to provide the Corresponding Source.  This
          alternative is allowed only occasionally and noncommercially,
          and only if you received the object code with such an offer,
          in accord with subsection 6b.

       d. Convey the object code by offering access from a designated
          place (gratis or for a charge), and offer equivalent access to
          the Corresponding Source in the same way through the same
          place at no further charge.  You need not require recipients
          to copy the Corresponding Source along with the object code.
          If the place to copy the object code is a network server, the
          Corresponding Source may be on a different server (operated by
          you or a third party) that supports equivalent copying
          facilities, provided you maintain clear directions next to the
          object code saying where to find the Corresponding Source.
          Regardless of what server hosts the Corresponding Source, you
          remain obligated to ensure that it is available for as long as
          needed to satisfy these requirements.

       e. Convey the object code using peer-to-peer transmission,
          provided you inform other peers where the object code and
          Corresponding Source of the work are being offered to the
          general public at no charge under subsection 6d.

     A separable portion of the object code, whose source code is
     excluded from the Corresponding Source as a System Library, need
     not be included in conveying the object code work.

     A "User Product" is either (1) a "consumer product", which means
     any tangible personal property which is normally used for personal,
     family, or household purposes, or (2) anything designed or sold for
     incorporation into a dwelling.  In determining whether a product is
     a consumer product, doubtful cases shall be resolved in favor of
     coverage.  For a particular product received by a particular user,
     "normally used" refers to a typical or common use of that class of
     product, regardless of the status of the particular user or of the
     way in which the particular user actually uses, or expects or is
     expected to use, the product.  A product is a consumer product
     regardless of whether the product has substantial commercial,
     industrial or non-consumer uses, unless such uses represent the
     only significant mode of use of the product.

     "Installation Information" for a User Product means any methods,
     procedures, authorization keys, or other information required to
     install and execute modified versions of a covered work in that
     User Product from a modified version of its Corresponding Source.
     The information must suffice to ensure that the continued
     functioning of the modified object code is in no case prevented or
     interfered with solely because modification has been made.

     If you convey an object code work under this section in, or with,
     or specifically for use in, a User Product, and the conveying
     occurs as part of a transaction in which the right of possession
     and use of the User Product is transferred to the recipient in
     perpetuity or for a fixed term (regardless of how the transaction
     is characterized), the Corresponding Source conveyed under this
     section must be accompanied by the Installation Information.  But
     this requirement does not apply if neither you nor any third party
     retains the ability to install modified object code on the User
     Product (for example, the work has been installed in ROM).

     The requirement to provide Installation Information does not
     include a requirement to continue to provide support service,
     warranty, or updates for a work that has been modified or installed
     by the recipient, or for the User Product in which it has been
     modified or installed.  Access to a network may be denied when the
     modification itself materially and adversely affects the operation
     of the network or violates the rules and protocols for
     communication across the network.

     Corresponding Source conveyed, and Installation Information
     provided, in accord with this section must be in a format that is
     publicly documented (and with an implementation available to the
     public in source code form), and must require no special password
     or key for unpacking, reading or copying.

  7. Additional Terms.

     "Additional permissions" are terms that supplement the terms of
     this License by making exceptions from one or more of its
     conditions.  Additional permissions that are applicable to the
     entire Program shall be treated as though they were included in
     this License, to the extent that they are valid under applicable
     law.  If additional permissions apply only to part of the Program,
     that part may be used separately under those permissions, but the
     entire Program remains governed by this License without regard to
     the additional permissions.

     When you convey a copy of a covered work, you may at your option
     remove any additional permissions from that copy, or from any part
     of it.  (Additional permissions may be written to require their own
     removal in certain cases when you modify the work.)  You may place
     additional permissions on material, added by you to a covered work,
     for which you have or can give appropriate copyright permission.

     Notwithstanding any other provision of this License, for material
     you add to a covered work, you may (if authorized by the copyright
     holders of that material) supplement the terms of this License with
     terms:

       a. Disclaiming warranty or limiting liability differently from
          the terms of sections 15 and 16 of this License; or

       b. Requiring preservation of specified reasonable legal notices
          or author attributions in that material or in the Appropriate
          Legal Notices displayed by works containing it; or

       c. Prohibiting misrepresentation of the origin of that material,
          or requiring that modified versions of such material be marked
          in reasonable ways as different from the original version; or

       d. Limiting the use for publicity purposes of names of licensors
          or authors of the material; or

       e. Declining to grant rights under trademark law for use of some
          trade names, trademarks, or service marks; or

       f. Requiring indemnification of licensors and authors of that
          material by anyone who conveys the material (or modified
          versions of it) with contractual assumptions of liability to
          the recipient, for any liability that these contractual
          assumptions directly impose on those licensors and authors.

     All other non-permissive additional terms are considered "further
     restrictions" within the meaning of section 10.  If the Program as
     you received it, or any part of it, contains a notice stating that
     it is governed by this License along with a term that is a further
     restriction, you may remove that term.  If a license document
     contains a further restriction but permits relicensing or conveying
     under this License, you may add to a covered work material governed
     by the terms of that license document, provided that the further
     restriction does not survive such relicensing or conveying.

     If you add terms to a covered work in accord with this section, you
     must place, in the relevant source files, a statement of the
     additional terms that apply to those files, or a notice indicating
     where to find the applicable terms.

     Additional terms, permissive or non-permissive, may be stated in
     the form of a separately written license, or stated as exceptions;
     the above requirements apply either way.

  8. Termination.

     You may not propagate or modify a covered work except as expressly
     provided under this License.  Any attempt otherwise to propagate or
     modify it is void, and will automatically terminate your rights
     under this License (including any patent licenses granted under the
     third paragraph of section 11).

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, you do not qualify to receive new licenses
     for the same material under section 10.

  9. Acceptance Not Required for Having Copies.

     You are not required to accept this License in order to receive or
     run a copy of the Program.  Ancillary propagation of a covered work
     occurring solely as a consequence of using peer-to-peer
     transmission to receive a copy likewise does not require
     acceptance.  However, nothing other than this License grants you
     permission to propagate or modify any covered work.  These actions
     infringe copyright if you do not accept this License.  Therefore,
     by modifying or propagating a covered work, you indicate your
     acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

     Each time you convey a covered work, the recipient automatically
     receives a license from the original licensors, to run, modify and
     propagate that work, subject to this License.  You are not
     responsible for enforcing compliance by third parties with this
     License.

     An "entity transaction" is a transaction transferring control of an
     organization, or substantially all assets of one, or subdividing an
     organization, or merging organizations.  If propagation of a
     covered work results from an entity transaction, each party to that
     transaction who receives a copy of the work also receives whatever
     licenses to the work the party's predecessor in interest had or
     could give under the previous paragraph, plus a right to possession
     of the Corresponding Source of the work from the predecessor in
     interest, if the predecessor has it or can get it with reasonable
     efforts.

     You may not impose any further restrictions on the exercise of the
     rights granted or affirmed under this License.  For example, you
     may not impose a license fee, royalty, or other charge for exercise
     of rights granted under this License, and you may not initiate
     litigation (including a cross-claim or counterclaim in a lawsuit)
     alleging that any patent claim is infringed by making, using,
     selling, offering for sale, or importing the Program or any portion
     of it.

  11. Patents.

     A "contributor" is a copyright holder who authorizes use under this
     License of the Program or a work on which the Program is based.
     The work thus licensed is called the contributor's "contributor
     version".

     A contributor's "essential patent claims" are all patent claims
     owned or controlled by the contributor, whether already acquired or
     hereafter acquired, that would be infringed by some manner,
     permitted by this License, of making, using, or selling its
     contributor version, but do not include claims that would be
     infringed only as a consequence of further modification of the
     contributor version.  For purposes of this definition, "control"
     includes the right to grant patent sublicenses in a manner
     consistent with the requirements of this License.

     Each contributor grants you a non-exclusive, worldwide,
     royalty-free patent license under the contributor's essential
     patent claims, to make, use, sell, offer for sale, import and
     otherwise run, modify and propagate the contents of its contributor
     version.

     In the following three paragraphs, a "patent license" is any
     express agreement or commitment, however denominated, not to
     enforce a patent (such as an express permission to practice a
     patent or covenant not to sue for patent infringement).  To "grant"
     such a patent license to a party means to make such an agreement or
     commitment not to enforce a patent against the party.

     If you convey a covered work, knowingly relying on a patent
     license, and the Corresponding Source of the work is not available
     for anyone to copy, free of charge and under the terms of this
     License, through a publicly available network server or other
     readily accessible means, then you must either (1) cause the
     Corresponding Source to be so available, or (2) arrange to deprive
     yourself of the benefit of the patent license for this particular
     work, or (3) arrange, in a manner consistent with the requirements
     of this License, to extend the patent license to downstream
     recipients.  "Knowingly relying" means you have actual knowledge
     that, but for the patent license, your conveying the covered work
     in a country, or your recipient's use of the covered work in a
     country, would infringe one or more identifiable patents in that
     country that you have reason to believe are valid.

     If, pursuant to or in connection with a single transaction or
     arrangement, you convey, or propagate by procuring conveyance of, a
     covered work, and grant a patent license to some of the parties
     receiving the covered work authorizing them to use, propagate,
     modify or convey a specific copy of the covered work, then the
     patent license you grant is automatically extended to all
     recipients of the covered work and works based on it.

     A patent license is "discriminatory" if it does not include within
     the scope of its coverage, prohibits the exercise of, or is
     conditioned on the non-exercise of one or more of the rights that
     are specifically granted under this License.  You may not convey a
     covered work if you are a party to an arrangement with a third
     party that is in the business of distributing software, under which
     you make payment to the third party based on the extent of your
     activity of conveying the work, and under which the third party
     grants, to any of the parties who would receive the covered work
     from you, a discriminatory patent license (a) in connection with
     copies of the covered work conveyed by you (or copies made from
     those copies), or (b) primarily for and in connection with specific
     products or compilations that contain the covered work, unless you
     entered into that arrangement, or that patent license was granted,
     prior to 28 March 2007.

     Nothing in this License shall be construed as excluding or limiting
     any implied license or other defenses to infringement that may
     otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

     If conditions are imposed on you (whether by court order, agreement
     or otherwise) that contradict the conditions of this License, they
     do not excuse you from the conditions of this License.  If you
     cannot convey a covered work so as to satisfy simultaneously your
     obligations under this License and any other pertinent obligations,
     then as a consequence you may not convey it at all.  For example,
     if you agree to terms that obligate you to collect a royalty for
     further conveying from those to whom you convey the Program, the
     only way you could satisfy both those terms and this License would
     be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

     Notwithstanding any other provision of this License, you have
     permission to link or combine any covered work with a work licensed
     under version 3 of the GNU Affero General Public License into a
     single combined work, and to convey the resulting work.  The terms
     of this License will continue to apply to the part which is the
     covered work, but the special requirements of the GNU Affero
     General Public License, section 13, concerning interaction through
     a network will apply to the combination as such.

  14. Revised Versions of this License.

     The Free Software Foundation may publish revised and/or new
     versions of the GNU General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies that a certain numbered version of the GNU
     General Public License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that numbered version or of any later version published by the Free
     Software Foundation.  If the Program does not specify a version
     number of the GNU General Public License, you may choose any
     version ever published by the Free Software Foundation.

     If the Program specifies that a proxy can decide which future
     versions of the GNU General Public License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Program.

     Later license versions may give you additional or different
     permissions.  However, no additional obligations are imposed on any
     author or copyright holder as a result of your choosing to follow a
     later version.

  15. Disclaimer of Warranty.

     THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
     APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE
     COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS"
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
     RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
     SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
     NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

     IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
     AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
     DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
     THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
     BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
     PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF
     THE POSSIBILITY OF SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

     If the disclaimer of warranty and limitation of liability provided
     above cannot be given local legal effect according to their terms,
     reviewing courts shall apply local law that most closely
     approximates an absolute waiver of all civil liability in
     connection with the Program, unless a warranty or assumption of
     liability accompanies a copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS
===========================

How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR NAME OF AUTHOR

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Also add information on how to contact you by electronic and paper
mail.

   If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

     PROGRAM Copyright (C) YEAR NAME OF AUTHOR
     This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type 'show c' for details.

   The hypothetical commands 'show w' and 'show c' should show the
appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an "about box".

   You should also get your employer (if you work as a programmer) or
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  For more information on this, and how to apply and follow
the GNU GPL, see <http://www.gnu.org/licenses/>.

   The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.  But first,
please read <http://www.gnu.org/philosophy/why-not-lgpl.html>.

Appendix F GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled "History" in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          "History" section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts."  line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.

Appendix G Indexes
******************

G.1 Concept index
=================

* Menu:

* Apple:                                 Compilation tips.  (line  4135)
* Arch:                                  Using GNU Arch.    (line  5143)
* Bug report:                            Mailing lists.     (line  1527)
* Bug report <1>:                        Report bugs.       (line  2620)
* Compilation:                           Troubleshooting.   (line  2019)
* Compilation <1>:                       Compilation tips.  (line  3891)
* CVS:                                   Using GIT.         (line  5282)
* Download:                              Getting the game.  (line  1556)
* GIT:                                   Using GIT.         (line  5282)
* GPL, GNU General Public License:       Copying.           (line 46410)
* hints.xml:                             Designing levels.  (line  2983)
* Log file:                              Logs.              (line  2601)
* Mac OS X:                              Compilation tips.  (line  4135)
* Microsoft Windows:                     Compilation tips.  (line  3891)
* rules.xml:                             Designing levels.  (line  2937)
* source code:                           Using GIT.         (line  5281)
* style.xml:                             Designing levels.  (line  3005)
* subversion:                            Using GIT.         (line  5282)
* SVN:                                   Using GIT.         (line  5282)
* teams.xml:                             Designing levels.  (line  3016)

G.2 Function and keyword index
==============================

* Menu:

* '--about=<value>':                     Basic options.     (line  5374)
* '--ambiance-exclude=<value>':          Sound options.     (line  7025)
* '--ambiance-file=<value>':             Sound options.     (line  7038)
* '--ambiance-filter=<value>':           Sound options.     (line  7051)
* '--animation-density=<value>':         Map style.xml.     (line 10060)
* '--animation-speed=<value>':           Map style.xml.     (line 10075)
* '--audit':                             Basic options.     (line  5389)
* '--auto-release-delay=<value>':        Input options.     (line  6632)
* '--background-color-auto=<value>':     Map hints.xml.     (line  9684)
* '--background-color-root-bg=<value>':  Map style.xml.     (line 10090)
* '--background-color-root-fg=<value>':  Map style.xml.     (line 10105)
* '--background-color-stuff-bg=<value>': Map style.xml.     (line 10122)
* '--background-color-stuff-fg=<value>': Map style.xml.     (line 10139)
* '--background-style=<value>':          Map style.xml.     (line 10157)
* '--base64-decode':                     Advanced settings. (line 11196)
* '--base64-encode':                     Advanced settings. (line 11206)
* '--bench':                             Advanced settings. (line 11216)
* '--bench-value=<value>':               Advanced settings. (line 11228)
* '--bin-id=<value>':                    Advanced settings. (line 11244)
* '--bind-ip=<value>':                   Network options.   (line  7122)
* '--bind-port=<value>':                 Network options.   (line  7136)
* '--blink-cursor=<value>':              Map style.xml.     (line 10172)
* '--boost-power=<value>':               Map rules.xml.     (line  7431)
* '--bot-iq=<value>':                    Map teams.xml.     (line 10881)
* '--bot-speed=<value>':                 Map teams.xml.     (line 10897)
* '--bot1-ai=<value>':                   Map teams.xml.     (line 10911)
* '--bot1-color=<value>':                Map teams.xml.     (line 10923)
* '--bot2-ai=<value>':                   Map teams.xml.     (line 10935)
* '--bot2-color=<value>':                Map teams.xml.     (line 10947)
* '--bot3-ai=<value>':                   Map teams.xml.     (line 10959)
* '--bot3-color=<value>':                Map teams.xml.     (line 10971)
* '--bot4-ai=<value>':                   Map teams.xml.     (line 10983)
* '--bot4-color=<value>':                Map teams.xml.     (line 10995)
* '--bot5-ai=<value>':                   Map teams.xml.     (line 11007)
* '--bot5-color=<value>':                Map teams.xml.     (line 11019)
* '--bot6-ai=<value>':                   Map teams.xml.     (line 11031)
* '--bot6-color=<value>':                Map teams.xml.     (line 11043)
* '--bot7-ai=<value>':                   Map teams.xml.     (line 11055)
* '--bot7-color=<value>':                Map teams.xml.     (line 11067)
* '--bot8-ai=<value>':                   Map teams.xml.     (line 11079)
* '--bot8-color=<value>':                Map teams.xml.     (line 11091)
* '--bot9-ai=<value>':                   Map teams.xml.     (line 11103)
* '--bot9-color=<value>':                Map teams.xml.     (line 11115)
* '--broadcast=<value>':                 Network options.   (line  7151)
* '--capture=<value>':                   Graphics options.  (line  6922)
* '--check':                             Advanced settings. (line 11258)
* '--chosen-map=<value>':                Map parameters.    (line  7294)
* '--cli-backends=<value>':              Network options.   (line  7166)
* '--click-to-focus=<value>':            Input options.     (line  6648)
* '--color-alternate-bg=<value>':        Map style.xml.     (line 10187)
* '--color-alternate-fg=<value>':        Map style.xml.     (line 10203)
* '--color-base-bg=<value>':             Map style.xml.     (line 10219)
* '--color-base-fg=<value>':             Map style.xml.     (line 10235)
* '--color-conflict-mode=<value>':       Map rules.xml.     (line  7446)
* '--colorize-cursor=<value>':           Map style.xml.     (line 10267)
* '--colorize=<value>':                  Map style.xml.     (line 10251)
* '--commands-per-sec=<value>':          Advanced settings. (line 11268)
* '--config-file':                       Path options.      (line  6290)
* '--copyright':                         Basic options.     (line  5398)
* '--credits':                           Basic options.     (line  5404)
* '--cunit':                             Advanced settings. (line 11284)
* '--cursor-pot-init=<value>':           Map rules.xml.     (line  7466)
* '--cursor-sensitivity=<value>':        Input options.     (line  6662)
* '--cursor-size=<value>':               Map style.xml.     (line 10283)
* '--custom-alt=<value>':                Input options.     (line  6677)
* '--custom-ctrl=<value>':               Input options.     (line  6689)
* '--custom-down=<value>':               Input options.     (line  6701)
* '--custom-enter=<value>':              Input options.     (line  6713)
* '--custom-esc=<value>':                Input options.     (line  6725)
* '--custom-left=<value>':               Input options.     (line  6737)
* '--custom-pgdown=<value>':             Input options.     (line  6749)
* '--custom-pgup=<value>':               Input options.     (line  6761)
* '--custom-right=<value>':              Input options.     (line  6773)
* '--custom-up=<value>':                 Input options.     (line  6785)
* '--daemon':                            Advanced settings. (line 11294)
* '--danger-power=<value>':              Map rules.xml.     (line  7480)
* '--data-dir':                          Path options.      (line  6301)
* '--debug':                             Basic options.     (line  5411)
* '--debug-layer-id=<value>':            Advanced settings. (line 11302)
* '--debug-team-id=<value>':             Advanced settings. (line 11315)
* '--defaults':                          Basic options.     (line  5419)
* '--demo':                              Advanced settings. (line 11328)
* '--dialog-timeout=<value>':            Advanced settings. (line 11335)
* '--dirty-read=<value>':                Advanced settings. (line 11351)
* '--display-background=<value>':        Advanced settings. (line 11368)
* '--display-console=<value>':           Advanced settings. (line 11381)
* '--display-cursors=<value>':           Advanced settings. (line 11396)
* '--display-debug-gradient=<value>':    Advanced settings. (line 11409)
* '--display-debug-zones=<value>':       Advanced settings. (line 11422)
* '--display-fighters=<value>':          Advanced settings. (line 11435)
* '--display-fps=<value>':               Advanced settings. (line 11448)
* '--display-hud=<value>':               Advanced settings. (line 11462)
* '--display-log=<value>':               Advanced settings. (line 11475)
* '--display-map=<value>':               Advanced settings. (line 11488)
* '--display-menu=<value>':              Advanced settings. (line 11501)
* '--display-meta=<value>':              Advanced settings. (line 11514)
* '--display-mouse=<value>':             Advanced settings. (line 11527)
* '--display-mps=<value>':               Advanced settings. (line 11539)
* '--display-preview=<value>':           Advanced settings. (line 11553)
* '--display-progress=<value>':          Advanced settings. (line 11566)
* '--display-score=<value>':             Advanced settings. (line 11579)
* '--display-splash=<value>':            Advanced settings. (line 11591)
* '--display-url=<value>':               Advanced settings. (line 11604)
* '--double-click-delay=<value>':        Input options.     (line  6797)
* '--downsize-using-bench-value=<value>': Map hints.xml.    (line  9701)
* '--downsize-using-fighter-scale=<value>': Map hints.xml.  (line  9718)
* '--example-hints-xml':                 Doc options.       (line  5485)
* '--example-rules-xml':                 Doc options.       (line  5492)
* '--example-style-xml':                 Doc options.       (line  5500)
* '--example-teams-xml':                 Doc options.       (line  5507)
* '--executed-again=<value>':            Advanced settings. (line 11618)
* '--exp=<value>':                       Map rules.xml.     (line  7496)
* '--fighter-attack=<value>':            Map rules.xml.     (line  7512)
* '--fighter-defense=<value>':           Map rules.xml.     (line  7529)
* '--fighter-new-health=<value>':        Map rules.xml.     (line  7545)
* '--fighter-regenerate=<value>':        Map rules.xml.     (line  7563)
* '--fighter-scale=<value>':             Map hints.xml.     (line  9734)
* '--force=<value>':                     Map parameters.    (line  7308)
* '--frags-fade-out=<value>':            Map rules.xml.     (line  7578)
* '--frags-mode=<value>':                Map rules.xml.     (line  7597)
* '--frags-to-distribute=<value>':       Map rules.xml.     (line  7616)
* '--fullscreen=<value>':                Graphics options.  (line  6935)
* '--fx-volume=<value>':                 Sound options.     (line  7067)
* '--gfx-backend=<value>':               Graphics options.  (line  6948)
* '--gfx-cpu-usage=<value>':             Advanced settings. (line 11634)
* '--gfx-debug=<value>':                 Advanced settings. (line 11651)
* '--gfx-quality=<value>':               Graphics options.  (line  6962)
* '--glue-power=<value>':                Map rules.xml.     (line  7632)
* '--guess-colors=<value>':              Map hints.xml.     (line  9760)
* '--guess-moves-per-sec=<value>':       Map hints.xml.     (line  9779)
* '--height=<value>':                    Graphics options.  (line  6978)
* '--help':                              Basic options.     (line  5427)
* '--hidden-layer-alpha=<value>':        Map style.xml.     (line 10297)
* '--highest-team-color-allowed=<value>': Map rules.xml.    (line  7647)
* '--highest-weapon-allowed=<value>':    Map rules.xml.     (line  7664)
* '--host':                              Basic options.     (line  5433)
* '--hud-color-auto=<value>':            Map hints.xml.     (line  9792)
* '--hud-color-frame-bg=<value>':        Map style.xml.     (line 10314)
* '--hud-color-frame-fg=<value>':        Map style.xml.     (line 10327)
* '--hud-color-text-bg=<value>':         Map style.xml.     (line 10340)
* '--hud-color-text-fg=<value>':         Map style.xml.     (line 10353)
* '--hud-style=<value>':                 Map style.xml.     (line 10366)
* '--io-per-sec=<value>':                Advanced settings. (line 11664)
* '--jpeg-quality=<value>':              Advanced settings. (line 11678)
* '--keep-ratio=<value>':                Map style.xml.     (line 10380)
* '--known-nodes=<value>':               Network options.   (line  7181)
* '--list':                              Basic options.     (line  5440)
* '--list-advanced':                     Doc options.       (line  5514)
* '--list-aliases':                      Doc options.       (line  5520)
* '--list-doc':                          Doc options.       (line  5526)
* '--list-funcs':                        Doc options.       (line  5533)
* '--list-graphics':                     Doc options.       (line  5540)
* '--list-hooks':                        Doc options.       (line  5546)
* '--list-input':                        Doc options.       (line  5552)
* '--list-map':                          Doc options.       (line  5559)
* '--list-map-hints':                    Doc options.       (line  5566)
* '--list-map-rules':                    Doc options.       (line  5573)
* '--list-map-style':                    Doc options.       (line  5580)
* '--list-map-teams':                    Doc options.       (line  5587)
* '--list-network':                      Doc options.       (line  5594)
* '--list-path':                         Doc options.       (line  5600)
* '--list-players':                      Doc options.       (line  5607)
* '--list-quick':                        Doc options.       (line  5613)
* '--list-show':                         Doc options.       (line  5620)
* '--list-sound':                        Doc options.       (line  5628)
* '--list-team-colors':                  Doc options.       (line  5634)
* '--list-weapons':                      Doc options.       (line  5640)
* '--loader-sleep=<value>':              Advanced settings. (line 11691)
* '--local-bench-delta=<value>':         Advanced settings. (line 11704)
* '--log-file=<value>':                  Path options.      (line  6312)
* '--log-level=<value>':                 Advanced settings. (line 11718)
* '--log-timeout=<value>':               Advanced settings. (line 11735)
* '--magic-number=<value>':              Advanced settings. (line 11748)
* '--map-dir':                           Path options.      (line  6325)
* '--map-path=<value>':                  Path options.      (line  6339)
* '--max-cursor-pot-offset=<value>':     Map rules.xml.     (line  7695)
* '--max-cursor-pot=<value>':            Map rules.xml.     (line  7681)
* '--max-cursor-speed=<value>':          Input options.     (line  6810)
* '--max-local-bench-value=<value>':     Advanced settings. (line 11772)
* '--max-map-height=<value>':            Map hints.xml.     (line  9809)
* '--max-map-surface=<value>':           Map hints.xml.     (line  9826)
* '--max-map-width=<value>':             Map hints.xml.     (line  9841)
* '--max-nb-cursors=<value>':            Map rules.xml.     (line  7712)
* '--max-nb-nodes=<value>':              Map rules.xml.     (line  7726)
* '--max-nb-teams=<value>':              Map rules.xml.     (line  7740)
* '--max-network-bench-value=<value>':   Advanced settings. (line 11789)
* '--max-round-delta=<value>':           Map rules.xml.     (line  7753)
* '--max-zone-size=<value>':             Map rules.xml.     (line  7768)
* '--medicine-power=<value>':            Map rules.xml.     (line  7791)
* '--memory-bazooka-eraser=<value>':     Advanced settings. (line 11804)
* '--memory-bazooka-size=<value>':       Advanced settings. (line 11824)
* '--menu-color-auto=<value>':           Map hints.xml.     (line  9858)
* '--menu-color-default-bg=<value>':     Map style.xml.     (line 10393)
* '--menu-color-default-fg=<value>':     Map style.xml.     (line 10406)
* '--menu-color-disabled-bg=<value>':    Map style.xml.     (line 10421)
* '--menu-color-disabled-fg=<value>':    Map style.xml.     (line 10434)
* '--menu-color-selected-bg=<value>':    Map style.xml.     (line 10447)
* '--menu-color-selected-fg=<value>':    Map style.xml.     (line 10460)
* '--menu-style=<value>':                Map style.xml.     (line 10473)
* '--min-map-height=<value>':            Map hints.xml.     (line  9877)
* '--min-map-surface=<value>':           Map hints.xml.     (line  9894)
* '--min-map-width=<value>':             Map hints.xml.     (line  9909)
* '--mod-dir':                           Path options.      (line  6367)
* '--modules':                           Basic options.     (line  5449)
* '--mouse-sensitivity=<value>':         Input options.     (line  6823)
* '--moves-per-round=<value>':           Map rules.xml.     (line  7807)
* '--music-dir=<value>':                 Path options.      (line  6381)
* '--music-exclude=<value>':             Map style.xml.     (line 10486)
* '--music-file=<value>':                Map style.xml.     (line 10499)
* '--music-filter=<value>':              Map style.xml.     (line 10516)
* '--music-path=<value>':                Path options.      (line  6399)
* '--music-volume=<value>':              Sound options.     (line  7080)
* '--nb-attack-tries=<value>':           Map rules.xml.     (line  7825)
* '--nb-bots=<value>':                   Map teams.xml.     (line 11127)
* '--nb-defense-tries=<value>':          Map rules.xml.     (line  7843)
* '--nb-move-tries=<value>':             Map rules.xml.     (line  7860)
* '--net-log=<value>':                   Advanced settings. (line 11846)
* '--net-per-sec=<value>':               Advanced settings. (line 11861)
* '--network-bench-delta=<value>':       Advanced settings. (line 11876)
* '--network-reliability=<value>':       Advanced settings. (line 11890)
* '--node-description=<value>':          Network options.   (line  7199)
* '--node-title=<value>':                Network options.   (line  7214)
* '--open-relay=<value>':                Advanced settings. (line 11913)
* '--password=<value>':                  Network options.   (line  7229)
* '--pedigree':                          Basic options.     (line  5457)
* '--pilot-lag=<value>':                 Advanced settings. (line 11931)
* '--pixelize=<value>':                  Map style.xml.     (line 10532)
* '--player1-color=<value>':             Map teams.xml.     (line 11141)
* '--player1-control=<value>':           Players options.   (line  6473)
* '--player1-name=<value>':              Players options.   (line  6486)
* '--player1-status=<value>':            Players options.   (line  6499)
* '--player2-color=<value>':             Map teams.xml.     (line 11154)
* '--player2-control=<value>':           Players options.   (line  6512)
* '--player2-name=<value>':              Players options.   (line  6525)
* '--player2-status=<value>':            Players options.   (line  6538)
* '--player3-color=<value>':             Map teams.xml.     (line 11167)
* '--player3-control=<value>':           Players options.   (line  6551)
* '--player3-name=<value>':              Players options.   (line  6564)
* '--player3-status=<value>':            Players options.   (line  6577)
* '--player4-color=<value>':             Map teams.xml.     (line 11180)
* '--player4-control=<value>':           Players options.   (line  6590)
* '--player4-name=<value>':              Players options.   (line  6603)
* '--player4-status=<value>':            Players options.   (line  6616)
* '--prefix':                            Path options.      (line  6427)
* '--public-url=<value>':                Network options.   (line  7247)
* '--quick-start':                       Advanced settings. (line 11945)
* '--repeat-delay=<value>':              Input options.     (line  6837)
* '--repeat-interval=<value>':           Input options.     (line  6850)
* '--resample=<value>':                  Map hints.xml.     (line  9926)
* '--reset':                             Advanced settings. (line 11952)
* '--reset-config-on-upgrade=<value>':   Advanced settings. (line 11961)
* '--respawn-delay=<value>':             Map rules.xml.     (line  7881)
* '--respawn-position-mode=<value>':     Map rules.xml.     (line  7894)
* '--respawn-team=<value>':              Map rules.xml.     (line  7910)
* '--round-delta=<value>':               Map rules.xml.     (line  7926)
* '--rounds-per-sec=<value>':            Map rules.xml.     (line  7951)
* '--screenshots-per-min=<value>':       Advanced settings. (line 11974)
* '--script-file':                       Path options.      (line  6441)
* '--server':                            Advanced settings. (line 11988)
* '--show-build-abs-srcdir':             Show options.      (line  5649)
* '--show-build-bin-id':                 Show options.      (line  5656)
* '--show-build-bugs-url':               Show options.      (line  5664)
* '--show-build-cflags':                 Show options.      (line  5670)
* '--show-build-codename':               Show options.      (line  5678)
* '--show-build-configure-args':         Show options.      (line  5685)
* '--show-build-copyright':              Show options.      (line  5693)
* '--show-build-datadir':                Show options.      (line  5699)
* '--show-build-date':                   Show options.      (line  5710)
* '--show-build-docdir':                 Show options.      (line  5716)
* '--show-build-enable-allinone':        Show options.      (line  5724)
* '--show-build-enable-console':         Show options.      (line  5731)
* '--show-build-enable-fullstatic':      Show options.      (line  5739)
* '--show-build-enable-gcov':            Show options.      (line  5746)
* '--show-build-enable-gprof':           Show options.      (line  5753)
* '--show-build-enable-gtk':             Show options.      (line  5760)
* '--show-build-enable-instrument':      Show options.      (line  5769)
* '--show-build-enable-mod-caca':        Show options.      (line  5776)
* '--show-build-enable-mod-csound':      Show options.      (line  5785)
* '--show-build-enable-mod-gl1':         Show options.      (line  5793)
* '--show-build-enable-mod-gles2':       Show options.      (line  5802)
* '--show-build-enable-mod-http':        Show options.      (line  5811)
* '--show-build-enable-mod-ogg':         Show options.      (line  5819)
* '--show-build-enable-mod-soft':        Show options.      (line  5828)
* '--show-build-enable-openmp':          Show options.      (line  5836)
* '--show-build-enable-optimize':        Show options.      (line  5843)
* '--show-build-enable-paranoid':        Show options.      (line  5850)
* '--show-build-enable-profiler':        Show options.      (line  5858)
* '--show-build-enable-valgrind':        Show options.      (line  5865)
* '--show-build-endianness':             Show options.      (line  5872)
* '--show-build-gcc-version':            Show options.      (line  5879)
* '--show-build-gnu':                    Show options.      (line  5886)
* '--show-build-gp2x':                   Show options.      (line  5893)
* '--show-build-home-url':               Show options.      (line  5899)
* '--show-build-host-cpu':               Show options.      (line  5905)
* '--show-build-host-os':                Show options.      (line  5911)
* '--show-build-hostname':               Show options.      (line  5917)
* '--show-build-includedir':             Show options.      (line  5923)
* '--show-build-ldflags':                Show options.      (line  5931)
* '--show-build-libdir':                 Show options.      (line  5938)
* '--show-build-license':                Show options.      (line  5949)
* '--show-build-localedir':              Show options.      (line  5955)
* '--show-build-mac-os-x':               Show options.      (line  5963)
* '--show-build-md5sum':                 Show options.      (line  5969)
* '--show-build-ms-windows':             Show options.      (line  5976)
* '--show-build-package-id':             Show options.      (line  5982)
* '--show-build-package-name':           Show options.      (line  5989)
* '--show-build-package-string':         Show options.      (line  5995)
* '--show-build-package-tarname':        Show options.      (line  6001)
* '--show-build-pointer-size':           Show options.      (line  6007)
* '--show-build-prefix':                 Show options.      (line  6014)
* '--show-build-stamp':                  Show options.      (line  6022)
* '--show-build-time':                   Show options.      (line  6034)
* '--show-build-top-srcdir':             Show options.      (line  6040)
* '--show-build-unix':                   Show options.      (line  6047)
* '--show-build-version':                Show options.      (line  6054)
* '--show-build-version-base':           Show options.      (line  6063)
* '--show-build-version-major':          Show options.      (line  6073)
* '--show-build-version-minor':          Show options.      (line  6080)
* '--show-build-x86':                    Show options.      (line  6087)
* '--show-config-file':                  Show options.      (line  6093)
* '--show-cwd':                          Show options.      (line  6100)
* '--show-data-dir':                     Show options.      (line  6107)
* '--show-default-config-file':          Show options.      (line  6116)
* '--show-default-data-dir':             Show options.      (line  6123)
* '--show-default-log-file':             Show options.      (line  6132)
* '--show-default-map-dir':              Show options.      (line  6139)
* '--show-default-map-path':             Show options.      (line  6146)
* '--show-default-mod-dir':              Show options.      (line  6155)
* '--show-default-music-dir':            Show options.      (line  6163)
* '--show-default-music-path':           Show options.      (line  6171)
* '--show-default-prefix':               Show options.      (line  6180)
* '--show-default-script-file':          Show options.      (line  6189)
* '--show-default-user-dir':             Show options.      (line  6199)
* '--show-log-file':                     Show options.      (line  6207)
* '--show-map-dir':                      Show options.      (line  6213)
* '--show-map-path':                     Show options.      (line  6220)
* '--show-mod-dir':                      Show options.      (line  6229)
* '--show-music-dir':                    Show options.      (line  6237)
* '--show-music-path':                   Show options.      (line  6244)
* '--show-prefix':                       Show options.      (line  6253)
* '--show-run-dir':                      Show options.      (line  6262)
* '--show-script-file':                  Show options.      (line  6270)
* '--show-user-dir':                     Show options.      (line  6280)
* '--side-attack-factor=<value>':        Map rules.xml.     (line  7968)
* '--side-defense-factor=<value>':       Map rules.xml.     (line  7985)
* '--simulate-basic':                    Advanced settings. (line 12001)
* '--simulate-full':                     Advanced settings. (line 12012)
* '--single-army-size=<value>':          Map rules.xml.     (line  7999)
* '--skip-network=<value>':              Network options.   (line  7263)
* '--snd-backend=<value>':               Sound options.     (line  7093)
* '--speed=<value>':                     Map hints.xml.     (line  9940)
* '--spread-mode=<value>':               Map rules.xml.     (line  8017)
* '--spread-thread=<value>':             Map rules.xml.     (line  8032)
* '--spreads-per-round=<value>':         Map rules.xml.     (line  8049)
* '--srv-backends=<value>':              Network options.   (line  7276)
* '--start-blue-x=<value>':              Map rules.xml.     (line  8068)
* '--start-blue-y=<value>':              Map rules.xml.     (line  8081)
* '--start-cyan-x=<value>':              Map rules.xml.     (line  8094)
* '--start-cyan-y=<value>':              Map rules.xml.     (line  8107)
* '--start-green-x=<value>':             Map rules.xml.     (line  8120)
* '--start-green-y=<value>':             Map rules.xml.     (line  8133)
* '--start-lightblue-x=<value>':         Map rules.xml.     (line  8146)
* '--start-lightblue-y=<value>':         Map rules.xml.     (line  8159)
* '--start-magenta-x=<value>':           Map rules.xml.     (line  8172)
* '--start-magenta-y=<value>':           Map rules.xml.     (line  8185)
* '--start-orange-x=<value>':            Map rules.xml.     (line  8198)
* '--start-orange-y=<value>':            Map rules.xml.     (line  8211)
* '--start-pink-x=<value>':              Map rules.xml.     (line  8224)
* '--start-pink-y=<value>':              Map rules.xml.     (line  8237)
* '--start-position-mode=<value>':       Map rules.xml.     (line  8250)
* '--start-purple-x=<value>':            Map rules.xml.     (line  8266)
* '--start-purple-y=<value>':            Map rules.xml.     (line  8279)
* '--start-red-x=<value>':               Map rules.xml.     (line  8292)
* '--start-red-y=<value>':               Map rules.xml.     (line  8305)
* '--start-yellow-x=<value>':            Map rules.xml.     (line  8318)
* '--start-yellow-y=<value>':            Map rules.xml.     (line  8331)
* '--system-color-auto=<value>':         Map hints.xml.     (line  9964)
* '--system-color-bg=<value>':           Map style.xml.     (line 10546)
* '--system-color-fg=<value>':           Map style.xml.     (line 10560)
* '--target-fps=<value>':                Advanced settings. (line 12024)
* '--team-color-blue=<value>':           Map style.xml.     (line 10574)
* '--team-color-cyan=<value>':           Map style.xml.     (line 10587)
* '--team-color-dead=<value>':           Map style.xml.     (line 10600)
* '--team-color-green=<value>':          Map style.xml.     (line 10614)
* '--team-color-lightblue=<value>':      Map style.xml.     (line 10627)
* '--team-color-magenta=<value>':        Map style.xml.     (line 10640)
* '--team-color-orange=<value>':         Map style.xml.     (line 10653)
* '--team-color-pink=<value>':           Map style.xml.     (line 10666)
* '--team-color-purple=<value>':         Map style.xml.     (line 10679)
* '--team-color-red=<value>':            Map style.xml.     (line 10692)
* '--team-color-yellow=<value>':         Map style.xml.     (line 10705)
* '--team-profile-blue-aggressive=<value>': Map rules.xml.  (line  8344)
* '--team-profile-blue-fast=<value>':    Map rules.xml.     (line  8359)
* '--team-profile-blue-handicap=<value>': Map rules.xml.    (line  8374)
* '--team-profile-blue-mobile=<value>':  Map rules.xml.     (line  8386)
* '--team-profile-blue-vulnerable=<value>': Map rules.xml.  (line  8402)
* '--team-profile-blue-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  8417)
* '--team-profile-blue-weapon-id=<value>': Map rules.xml.   (line  8431)
* '--team-profile-blue-weapon-mode=<value>': Map rules.xml. (line  8444)
* '--team-profile-cyan-aggressive=<value>': Map rules.xml.  (line  8458)
* '--team-profile-cyan-fast=<value>':    Map rules.xml.     (line  8473)
* '--team-profile-cyan-handicap=<value>': Map rules.xml.    (line  8488)
* '--team-profile-cyan-mobile=<value>':  Map rules.xml.     (line  8500)
* '--team-profile-cyan-vulnerable=<value>': Map rules.xml.  (line  8516)
* '--team-profile-cyan-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  8531)
* '--team-profile-cyan-weapon-id=<value>': Map rules.xml.   (line  8545)
* '--team-profile-cyan-weapon-mode=<value>': Map rules.xml. (line  8558)
* '--team-profile-green-aggressive=<value>': Map rules.xml. (line  8572)
* '--team-profile-green-fast=<value>':   Map rules.xml.     (line  8587)
* '--team-profile-green-handicap=<value>': Map rules.xml.   (line  8602)
* '--team-profile-green-mobile=<value>': Map rules.xml.     (line  8614)
* '--team-profile-green-vulnerable=<value>': Map rules.xml. (line  8630)
* '--team-profile-green-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  8645)
* '--team-profile-green-weapon-id=<value>': Map rules.xml.  (line  8659)
* '--team-profile-green-weapon-mode=<value>': Map rules.xml.
                                                            (line  8672)
* '--team-profile-lightblue-aggressive=<value>': Map rules.xml.
                                                            (line  8686)
* '--team-profile-lightblue-fast=<value>': Map rules.xml.   (line  8701)
* '--team-profile-lightblue-handicap=<value>': Map rules.xml.
                                                            (line  8716)
* '--team-profile-lightblue-mobile=<value>': Map rules.xml. (line  8728)
* '--team-profile-lightblue-vulnerable=<value>': Map rules.xml.
                                                            (line  8744)
* '--team-profile-lightblue-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  8759)
* '--team-profile-lightblue-weapon-id=<value>': Map rules.xml.
                                                            (line  8774)
* '--team-profile-lightblue-weapon-mode=<value>': Map rules.xml.
                                                            (line  8787)
* '--team-profile-magenta-aggressive=<value>': Map rules.xml.
                                                            (line  8801)
* '--team-profile-magenta-fast=<value>': Map rules.xml.     (line  8816)
* '--team-profile-magenta-handicap=<value>': Map rules.xml. (line  8831)
* '--team-profile-magenta-mobile=<value>': Map rules.xml.   (line  8843)
* '--team-profile-magenta-vulnerable=<value>': Map rules.xml.
                                                            (line  8859)
* '--team-profile-magenta-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  8874)
* '--team-profile-magenta-weapon-id=<value>': Map rules.xml.
                                                            (line  8888)
* '--team-profile-magenta-weapon-mode=<value>': Map rules.xml.
                                                            (line  8901)
* '--team-profile-orange-aggressive=<value>': Map rules.xml.
                                                            (line  8915)
* '--team-profile-orange-fast=<value>':  Map rules.xml.     (line  8930)
* '--team-profile-orange-handicap=<value>': Map rules.xml.  (line  8945)
* '--team-profile-orange-mobile=<value>': Map rules.xml.    (line  8957)
* '--team-profile-orange-vulnerable=<value>': Map rules.xml.
                                                            (line  8973)
* '--team-profile-orange-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  8988)
* '--team-profile-orange-weapon-id=<value>': Map rules.xml. (line  9002)
* '--team-profile-orange-weapon-mode=<value>': Map rules.xml.
                                                            (line  9015)
* '--team-profile-pink-aggressive=<value>': Map rules.xml.  (line  9029)
* '--team-profile-pink-fast=<value>':    Map rules.xml.     (line  9044)
* '--team-profile-pink-handicap=<value>': Map rules.xml.    (line  9059)
* '--team-profile-pink-mobile=<value>':  Map rules.xml.     (line  9071)
* '--team-profile-pink-vulnerable=<value>': Map rules.xml.  (line  9087)
* '--team-profile-pink-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  9102)
* '--team-profile-pink-weapon-id=<value>': Map rules.xml.   (line  9116)
* '--team-profile-pink-weapon-mode=<value>': Map rules.xml. (line  9129)
* '--team-profile-purple-aggressive=<value>': Map rules.xml.
                                                            (line  9143)
* '--team-profile-purple-fast=<value>':  Map rules.xml.     (line  9158)
* '--team-profile-purple-handicap=<value>': Map rules.xml.  (line  9173)
* '--team-profile-purple-mobile=<value>': Map rules.xml.    (line  9185)
* '--team-profile-purple-vulnerable=<value>': Map rules.xml.
                                                            (line  9201)
* '--team-profile-purple-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  9216)
* '--team-profile-purple-weapon-id=<value>': Map rules.xml. (line  9230)
* '--team-profile-purple-weapon-mode=<value>': Map rules.xml.
                                                            (line  9243)
* '--team-profile-red-aggressive=<value>': Map rules.xml.   (line  9257)
* '--team-profile-red-fast=<value>':     Map rules.xml.     (line  9272)
* '--team-profile-red-handicap=<value>': Map rules.xml.     (line  9287)
* '--team-profile-red-mobile=<value>':   Map rules.xml.     (line  9299)
* '--team-profile-red-vulnerable=<value>': Map rules.xml.   (line  9315)
* '--team-profile-red-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  9330)
* '--team-profile-red-weapon-id=<value>': Map rules.xml.    (line  9344)
* '--team-profile-red-weapon-mode=<value>': Map rules.xml.  (line  9357)
* '--team-profile-yellow-aggressive=<value>': Map rules.xml.
                                                            (line  9371)
* '--team-profile-yellow-fast=<value>':  Map rules.xml.     (line  9386)
* '--team-profile-yellow-handicap=<value>': Map rules.xml.  (line  9401)
* '--team-profile-yellow-mobile=<value>': Map rules.xml.    (line  9413)
* '--team-profile-yellow-vulnerable=<value>': Map rules.xml.
                                                            (line  9429)
* '--team-profile-yellow-weapon-alternate-id=<value>': Map rules.xml.
                                                            (line  9444)
* '--team-profile-yellow-weapon-id=<value>': Map rules.xml. (line  9458)
* '--team-profile-yellow-weapon-mode=<value>': Map rules.xml.
                                                            (line  9471)
* '--test':                              Basic options.     (line  5466)
* '--total-armies-size=<value>':         Map rules.xml.     (line  9485)
* '--total-time=<value>':                Map rules.xml.     (line  9506)
* '--trap-errors=<value>':               Advanced settings. (line 12043)
* '--trojan=<value>':                    Advanced settings. (line 12057)
* '--upsize-using-bench-value=<value>':  Map hints.xml.     (line  9981)
* '--upsize-using-fighter-scale=<value>': Map hints.xml.    (line  9998)
* '--use-cursor-texture=<value>':        Map parameters.    (line  7326)
* '--use-double-click=<value>':          Input options.     (line  6863)
* '--use-esc-button=<value>':            Input options.     (line  6880)
* '--use-hints-xml=<value>':             Map parameters.    (line  7340)
* '--use-music-file=<value>':            Map parameters.    (line  7353)
* '--use-rules-xml=<value>':             Map parameters.    (line  7367)
* '--use-style-xml=<value>':             Map parameters.    (line  7381)
* '--use-team-profiles=<value>':         Map rules.xml.     (line  9524)
* '--use-teams-xml=<value>':             Map parameters.    (line  7396)
* '--use-texture=<value>':               Map parameters.    (line  7411)
* '--user-dir=<value>':                  Path options.      (line  6455)
* '--version':                           Basic options.     (line  5475)
* '--vertical-move=<value>':             Map rules.xml.     (line  9539)
* '--view-color-auto=<value>':           Map hints.xml.     (line 10014)
* '--view-color-cursor-bg=<value>':      Map style.xml.     (line 10718)
* '--view-color-cursor-fg=<value>':      Map style.xml.     (line 10732)
* '--view-color-map-bg=<value>':         Map style.xml.     (line 10746)
* '--view-color-map-fg=<value>':         Map style.xml.     (line 10761)
* '--view-style=<value>':                Map style.xml.     (line 10776)
* '--wall-grease=<value>':               Map hints.xml.     (line 10032)
* '--water-volume=<value>':              Sound options.     (line  7106)
* '--waves=<value>':                     Map style.xml.     (line 10792)
* '--weapon-charge-delay=<value>':       Map rules.xml.     (line  9555)
* '--weapon-charge-max=<value>':         Map rules.xml.     (line  9568)
* '--weapon-duration=<value>':           Map rules.xml.     (line  9585)
* '--weapon-tune-berzerk-power=<value>': Map rules.xml.     (line  9598)
* '--weapon-tune-turbo-power=<value>':   Map rules.xml.     (line  9611)
* '--width=<value>':                     Graphics options.  (line  6992)
* '--windowed-mode-limit=<value>':       Graphics options.  (line  7006)
* '--x-polarity=<value>':                Map rules.xml.     (line  9624)
* '--x-wrap=<value>':                    Map style.xml.     (line 10805)
* '--y-polarity=<value>':                Map rules.xml.     (line  9643)
* '--y-wrap=<value>':                    Map style.xml.     (line 10821)
* '--z-decode':                          Advanced settings. (line 12073)
* '--z-encode':                          Advanced settings. (line 12083)
* '--z-polarity=<value>':                Map rules.xml.     (line  9662)
* '--zoom-max=<value>':                  Map style.xml.     (line 10851)
* '--zoom-min=<value>':                  Map style.xml.     (line 10865)
* '--zoom-step=<value>':                 Input options.     (line  6894)
* '--zoom-stick-delay=<value>':          Input options.     (line  6907)
* '--zoom=<value>':                      Map style.xml.     (line 10837)
* _lw6p2p_db_now:                        libp2p.            (line 35027)
* _lw6p2p_db_timestamp:                  libp2p.            (line 35009)
* 'ambiance-exclude':                    Sound options.     (line  7027)
* 'ambiance-file':                       Sound options.     (line  7040)
* 'ambiance-filter':                     Sound options.     (line  7053)
* 'animation-density':                   Map style.xml.     (line 10062)
* 'animation-speed':                     Map style.xml.     (line 10077)
* 'auto-release-delay':                  Input options.     (line  6634)
* 'background-color-auto':               Map hints.xml.     (line  9686)
* 'background-color-root-bg':            Map style.xml.     (line 10092)
* 'background-color-root-fg':            Map style.xml.     (line 10107)
* 'background-color-stuff-bg':           Map style.xml.     (line 10124)
* 'background-color-stuff-fg':           Map style.xml.     (line 10141)
* 'background-style':                    Map style.xml.     (line 10159)
* 'bench-value':                         Advanced settings. (line 11230)
* 'bin-id':                              Advanced settings. (line 11246)
* 'bind-ip':                             Network options.   (line  7124)
* 'bind-port':                           Network options.   (line  7138)
* 'blink-cursor':                        Map style.xml.     (line 10174)
* 'boost-power':                         Map rules.xml.     (line  7433)
* 'bot-iq':                              Map teams.xml.     (line 10883)
* 'bot-speed':                           Map teams.xml.     (line 10899)
* 'bot1-ai':                             Map teams.xml.     (line 10913)
* 'bot1-color':                          Map teams.xml.     (line 10925)
* 'bot2-ai':                             Map teams.xml.     (line 10937)
* 'bot2-color':                          Map teams.xml.     (line 10949)
* 'bot3-ai':                             Map teams.xml.     (line 10961)
* 'bot3-color':                          Map teams.xml.     (line 10973)
* 'bot4-ai':                             Map teams.xml.     (line 10985)
* 'bot4-color':                          Map teams.xml.     (line 10997)
* 'bot5-ai':                             Map teams.xml.     (line 11009)
* 'bot5-color':                          Map teams.xml.     (line 11021)
* 'bot6-ai':                             Map teams.xml.     (line 11033)
* 'bot6-color':                          Map teams.xml.     (line 11045)
* 'bot7-ai':                             Map teams.xml.     (line 11057)
* 'bot7-color':                          Map teams.xml.     (line 11069)
* 'bot8-ai':                             Map teams.xml.     (line 11081)
* 'bot8-color':                          Map teams.xml.     (line 11093)
* 'bot9-ai':                             Map teams.xml.     (line 11105)
* 'bot9-color':                          Map teams.xml.     (line 11117)
* 'broadcast':                           Network options.   (line  7153)
* 'c-gettext':                           C to Guile.        (line 12095)
* 'c-lw6-exit':                          C to Guile.        (line 12103)
* 'c-lw6-get-ret':                       C to Guile.        (line 12109)
* 'c-lw6-release':                       C to Guile.        (line 12115)
* 'c-lw6-set-ret':                       C to Guile.        (line 12121)
* 'c-lw6bot-get-backends':               C to Guile.        (line 12127)
* 'c-lw6bot-new':                        C to Guile.        (line 12133)
* 'c-lw6bot-next-move':                  C to Guile.        (line 12139)
* 'c-lw6cfg-defaults':                   C to Guile.        (line 12145)
* 'c-lw6cfg-get-option':                 C to Guile.        (line 12151)
* 'c-lw6cfg-init':                       C to Guile.        (line 12157)
* 'c-lw6cfg-load':                       C to Guile.        (line 12163)
* 'c-lw6cfg-option-exists':              C to Guile.        (line 12169)
* 'c-lw6cfg-quit':                       C to Guile.        (line 12175)
* 'c-lw6cfg-save':                       C to Guile.        (line 12181)
* 'c-lw6cfg-set-option':                 C to Guile.        (line 12187)
* 'c-lw6cfg-unified-get-log-file':       C to Guile.        (line 12193)
* 'c-lw6cfg-unified-get-map-path':       C to Guile.        (line 12199)
* 'c-lw6cfg-unified-get-music-path':     C to Guile.        (line 12205)
* 'c-lw6cfg-unified-get-user-dir':       C to Guile.        (line 12211)
* 'c-lw6cli-get-backends':               C to Guile.        (line 12217)
* 'c-lw6cns-console-support':            C to Guile.        (line 12223)
* 'c-lw6cns-init':                       C to Guile.        (line 12229)
* 'c-lw6cns-poll':                       C to Guile.        (line 12235)
* 'c-lw6cns-quit':                       C to Guile.        (line 12241)
* 'c-lw6cns-term-support':               C to Guile.        (line 12247)
* 'c-lw6dsp-get-average-fps':            C to Guile.        (line 12253)
* 'c-lw6dsp-get-fullscreen-modes':       C to Guile.        (line 12259)
* 'c-lw6dsp-get-instant-fps':            C to Guile.        (line 12265)
* 'c-lw6dsp-get-last-frame-rendering-time': C to Guile.     (line 12271)
* 'c-lw6dsp-get-nb-frames':              C to Guile.        (line 12278)
* 'c-lw6dsp-get-video-mode':             C to Guile.        (line 12284)
* 'c-lw6dsp-new':                        C to Guile.        (line 12290)
* 'c-lw6dsp-release':                    C to Guile.        (line 12296)
* 'c-lw6dsp-update':                     C to Guile.        (line 12302)
* 'c-lw6gen-create-from-seed':           C to Guile.        (line 12308)
* 'c-lw6gen-seed-new':                   C to Guile.        (line 12314)
* 'c-lw6gen-seed-normalize':             C to Guile.        (line 12320)
* 'c-lw6gfx-get-backends':               C to Guile.        (line 12326)
* 'c-lw6gui-default-look':               C to Guile.        (line 12332)
* 'c-lw6gui-input-reset':                C to Guile.        (line 12338)
* 'c-lw6gui-joystick1-get-move-pad':     C to Guile.        (line 12344)
* 'c-lw6gui-joystick1-pop-button-a':     C to Guile.        (line 12350)
* 'c-lw6gui-joystick1-pop-button-b':     C to Guile.        (line 12356)
* 'c-lw6gui-joystick1-pop-button-c':     C to Guile.        (line 12362)
* 'c-lw6gui-joystick1-pop-button-d':     C to Guile.        (line 12368)
* 'c-lw6gui-joystick1-pop-button-e':     C to Guile.        (line 12374)
* 'c-lw6gui-joystick1-pop-button-f':     C to Guile.        (line 12380)
* 'c-lw6gui-joystick1-pop-pad-down':     C to Guile.        (line 12386)
* 'c-lw6gui-joystick1-pop-pad-left':     C to Guile.        (line 12392)
* 'c-lw6gui-joystick1-pop-pad-right':    C to Guile.        (line 12398)
* 'c-lw6gui-joystick1-pop-pad-up':       C to Guile.        (line 12404)
* 'c-lw6gui-joystick2-get-move-pad':     C to Guile.        (line 12410)
* 'c-lw6gui-joystick2-pop-button-a':     C to Guile.        (line 12416)
* 'c-lw6gui-joystick2-pop-button-b':     C to Guile.        (line 12422)
* 'c-lw6gui-joystick2-pop-button-c':     C to Guile.        (line 12428)
* 'c-lw6gui-joystick2-pop-button-d':     C to Guile.        (line 12434)
* 'c-lw6gui-joystick2-pop-button-e':     C to Guile.        (line 12440)
* 'c-lw6gui-joystick2-pop-button-f':     C to Guile.        (line 12446)
* 'c-lw6gui-joystick2-pop-pad-down':     C to Guile.        (line 12452)
* 'c-lw6gui-joystick2-pop-pad-left':     C to Guile.        (line 12458)
* 'c-lw6gui-joystick2-pop-pad-right':    C to Guile.        (line 12464)
* 'c-lw6gui-joystick2-pop-pad-up':       C to Guile.        (line 12470)
* 'c-lw6gui-keyboard-get-move-pad':      C to Guile.        (line 12476)
* 'c-lw6gui-keyboard-is-pressed':        C to Guile.        (line 12482)
* 'c-lw6gui-keyboard-pop-arrow-down':    C to Guile.        (line 12488)
* 'c-lw6gui-keyboard-pop-arrow-left':    C to Guile.        (line 12494)
* 'c-lw6gui-keyboard-pop-arrow-right':   C to Guile.        (line 12500)
* 'c-lw6gui-keyboard-pop-arrow-up':      C to Guile.        (line 12506)
* 'c-lw6gui-keyboard-pop-key-alt':       C to Guile.        (line 12512)
* 'c-lw6gui-keyboard-pop-key-ctrl':      C to Guile.        (line 12518)
* 'c-lw6gui-keyboard-pop-key-enter':     C to Guile.        (line 12524)
* 'c-lw6gui-keyboard-pop-key-esc':       C to Guile.        (line 12530)
* 'c-lw6gui-keyboard-pop-key-pgdown':    C to Guile.        (line 12536)
* 'c-lw6gui-keyboard-pop-key-pgup':      C to Guile.        (line 12542)
* 'c-lw6gui-look-get':                   C to Guile.        (line 12548)
* 'c-lw6gui-look-set':                   C to Guile.        (line 12554)
* 'c-lw6gui-look-zoom-in':               C to Guile.        (line 12560)
* 'c-lw6gui-look-zoom-out':              C to Guile.        (line 12566)
* 'c-lw6gui-menu-append':                C to Guile.        (line 12572)
* 'c-lw6gui-menu-close-popup':           C to Guile.        (line 12578)
* 'c-lw6gui-menu-enable-esc':            C to Guile.        (line 12584)
* 'c-lw6gui-menu-has-popup':             C to Guile.        (line 12590)
* 'c-lw6gui-menu-new':                   C to Guile.        (line 12596)
* 'c-lw6gui-menu-remove':                C to Guile.        (line 12602)
* 'c-lw6gui-menu-remove-all':            C to Guile.        (line 12608)
* 'c-lw6gui-menu-scroll-down':           C to Guile.        (line 12614)
* 'c-lw6gui-menu-scroll-up':             C to Guile.        (line 12620)
* 'c-lw6gui-menu-select':                C to Guile.        (line 12626)
* 'c-lw6gui-menu-select-esc':            C to Guile.        (line 12632)
* 'c-lw6gui-menu-set-breadcrumbs':       C to Guile.        (line 12638)
* 'c-lw6gui-menu-sync':                  C to Guile.        (line 12644)
* 'c-lw6gui-mouse-get-state':            C to Guile.        (line 12650)
* 'c-lw6gui-mouse-poll-move':            C to Guile.        (line 12656)
* 'c-lw6gui-mouse-pop-button-left':      C to Guile.        (line 12662)
* 'c-lw6gui-mouse-pop-button-middle':    C to Guile.        (line 12668)
* 'c-lw6gui-mouse-pop-button-right':     C to Guile.        (line 12674)
* 'c-lw6gui-mouse-pop-double-click':     C to Guile.        (line 12680)
* 'c-lw6gui-mouse-pop-simple-click':     C to Guile.        (line 12686)
* 'c-lw6gui-mouse-pop-triple-click':     C to Guile.        (line 12692)
* 'c-lw6gui-mouse-pop-wheel-down':       C to Guile.        (line 12698)
* 'c-lw6gui-mouse-pop-wheel-up':         C to Guile.        (line 12704)
* 'c-lw6hlp-about':                      C to Guile.        (line 12710)
* 'c-lw6hlp-get-default-value':          C to Guile.        (line 12716)
* 'c-lw6hlp-list':                       C to Guile.        (line 12722)
* 'c-lw6hlp-list-advanced':              C to Guile.        (line 12728)
* 'c-lw6hlp-list-aliases':               C to Guile.        (line 12734)
* 'c-lw6hlp-list-doc':                   C to Guile.        (line 12740)
* 'c-lw6hlp-list-funcs':                 C to Guile.        (line 12746)
* 'c-lw6hlp-list-graphics':              C to Guile.        (line 12752)
* 'c-lw6hlp-list-hooks':                 C to Guile.        (line 12758)
* 'c-lw6hlp-list-input':                 C to Guile.        (line 12764)
* 'c-lw6hlp-list-map':                   C to Guile.        (line 12770)
* 'c-lw6hlp-list-map-hints':             C to Guile.        (line 12776)
* 'c-lw6hlp-list-map-rules':             C to Guile.        (line 12782)
* 'c-lw6hlp-list-map-style':             C to Guile.        (line 12788)
* 'c-lw6hlp-list-map-teams':             C to Guile.        (line 12794)
* 'c-lw6hlp-list-network':               C to Guile.        (line 12800)
* 'c-lw6hlp-list-path':                  C to Guile.        (line 12806)
* 'c-lw6hlp-list-players':               C to Guile.        (line 12812)
* 'c-lw6hlp-list-quick':                 C to Guile.        (line 12818)
* 'c-lw6hlp-list-show':                  C to Guile.        (line 12824)
* 'c-lw6hlp-list-sound':                 C to Guile.        (line 12830)
* 'c-lw6hlp-list-team-colors':           C to Guile.        (line 12836)
* 'c-lw6hlp-list-weapons':               C to Guile.        (line 12842)
* 'c-lw6img-screenshot':                 C to Guile.        (line 12848)
* 'c-lw6ker-add-cursor':                 C to Guile.        (line 12854)
* 'c-lw6ker-build-game-state':           C to Guile.        (line 12860)
* 'c-lw6ker-build-game-struct':          C to Guile.        (line 12866)
* 'c-lw6ker-cursor-exists':              C to Guile.        (line 12872)
* 'c-lw6ker-did-cursor-win':             C to Guile.        (line 12878)
* 'c-lw6ker-do-round':                   C to Guile.        (line 12884)
* 'c-lw6ker-dup-game-state':             C to Guile.        (line 12890)
* 'c-lw6ker-game-state-checksum':        C to Guile.        (line 12896)
* 'c-lw6ker-game-struct-checksum':       C to Guile.        (line 12902)
* 'c-lw6ker-get-cursor':                 C to Guile.        (line 12908)
* 'c-lw6ker-get-moves':                  C to Guile.        (line 12914)
* 'c-lw6ker-get-nb-colors':              C to Guile.        (line 12920)
* 'c-lw6ker-get-nb-cursors':             C to Guile.        (line 12926)
* 'c-lw6ker-get-nb-nodes':               C to Guile.        (line 12932)
* 'c-lw6ker-get-rounds':                 C to Guile.        (line 12938)
* 'c-lw6ker-get-spreads':                C to Guile.        (line 12944)
* 'c-lw6ker-is-over':                    C to Guile.        (line 12950)
* 'c-lw6ker-node-exists':                C to Guile.        (line 12956)
* 'c-lw6ker-register-node':              C to Guile.        (line 12962)
* 'c-lw6ker-remove-cursor':              C to Guile.        (line 12968)
* 'c-lw6ker-set-cursor':                 C to Guile.        (line 12974)
* 'c-lw6ker-sync-game-state':            C to Guile.        (line 12980)
* 'c-lw6ker-unregister-node':            C to Guile.        (line 12986)
* 'c-lw6ldr-chain-entry':                C to Guile.        (line 12992)
* 'c-lw6ldr-exp-validate':               C to Guile.        (line 12998)
* 'c-lw6ldr-get-entries':                C to Guile.        (line 13004)
* 'c-lw6ldr-hints-get-default':          C to Guile.        (line 13010)
* 'c-lw6ldr-print-examples':             C to Guile.        (line 13016)
* 'c-lw6ldr-read':                       C to Guile.        (line 13022)
* 'c-lw6ldr-read-relative':              C to Guile.        (line 13028)
* 'c-lw6map-exp-get-unlocked-team-color': C to Guile.       (line 13034)
* 'c-lw6map-exp-get-unlocked-weapon':    C to Guile.        (line 13040)
* 'c-lw6map-exp-is-team-color-allowed':  C to Guile.        (line 13046)
* 'c-lw6map-exp-is-weapon-allowed':      C to Guile.        (line 13052)
* 'c-lw6map-get-look':                   C to Guile.        (line 13058)
* 'c-lw6map-get-max-nb-colors':          C to Guile.        (line 13064)
* 'c-lw6map-get-max-nb-cursors':         C to Guile.        (line 13070)
* 'c-lw6map-get-max-nb-nodes':           C to Guile.        (line 13076)
* 'c-lw6map-get-music-dir':              C to Guile.        (line 13082)
* 'c-lw6map-get-title':                  C to Guile.        (line 13088)
* 'c-lw6map-param-get':                  C to Guile.        (line 13094)
* 'c-lw6map-rules-get-default':          C to Guile.        (line 13100)
* 'c-lw6map-rules-get-int':              C to Guile.        (line 13106)
* 'c-lw6map-rules-get-max':              C to Guile.        (line 13112)
* 'c-lw6map-rules-get-min':              C to Guile.        (line 13118)
* 'c-lw6map-style-get-default':          C to Guile.        (line 13124)
* 'c-lw6map-team-color-index-to-key':    C to Guile.        (line 13130)
* 'c-lw6map-team-color-index-to-label':  C to Guile.        (line 13136)
* 'c-lw6map-team-color-key-to-index':    C to Guile.        (line 13142)
* 'c-lw6map-team-color-list':            C to Guile.        (line 13148)
* 'c-lw6map-teams-get-default':          C to Guile.        (line 13154)
* 'c-lw6map-weapon-index-to-key':        C to Guile.        (line 13160)
* 'c-lw6map-weapon-index-to-label':      C to Guile.        (line 13166)
* 'c-lw6map-weapon-key-to-index':        C to Guile.        (line 13172)
* 'c-lw6map-weapon-list':                C to Guile.        (line 13178)
* 'c-lw6net-init':                       C to Guile.        (line 13184)
* 'c-lw6net-quit':                       C to Guile.        (line 13190)
* 'c-lw6p2p-db-default-name':            C to Guile.        (line 13196)
* 'c-lw6p2p-db-new':                     C to Guile.        (line 13202)
* 'c-lw6p2p-db-reset':                   C to Guile.        (line 13208)
* 'c-lw6p2p-node-calibrate':             C to Guile.        (line 13214)
* 'c-lw6p2p-node-client-join':           C to Guile.        (line 13220)
* 'c-lw6p2p-node-close':                 C to Guile.        (line 13226)
* 'c-lw6p2p-node-disconnect':            C to Guile.        (line 13232)
* 'c-lw6p2p-node-get-entries':           C to Guile.        (line 13238)
* 'c-lw6p2p-node-get-id':                C to Guile.        (line 13244)
* 'c-lw6p2p-node-get-local-seq-0':       C to Guile.        (line 13250)
* 'c-lw6p2p-node-get-local-seq-last':    C to Guile.        (line 13256)
* 'c-lw6p2p-node-get-next-draft-msg':    C to Guile.        (line 13262)
* 'c-lw6p2p-node-get-next-reference-msg': C to Guile.       (line 13268)
* 'c-lw6p2p-node-get-seq-draft':         C to Guile.        (line 13274)
* 'c-lw6p2p-node-get-seq-max':           C to Guile.        (line 13280)
* 'c-lw6p2p-node-get-seq-min':           C to Guile.        (line 13286)
* 'c-lw6p2p-node-get-seq-reference':     C to Guile.        (line 13292)
* 'c-lw6p2p-node-is-dump-needed':        C to Guile.        (line 13298)
* 'c-lw6p2p-node-is-peer-connected':     C to Guile.        (line 13304)
* 'c-lw6p2p-node-is-peer-registered':    C to Guile.        (line 13310)
* 'c-lw6p2p-node-is-seed-needed':        C to Guile.        (line 13316)
* 'c-lw6p2p-node-new':                   C to Guile.        (line 13322)
* 'c-lw6p2p-node-poll':                  C to Guile.        (line 13328)
* 'c-lw6p2p-node-put-local-msg':         C to Guile.        (line 13334)
* 'c-lw6p2p-node-refresh-peer':          C to Guile.        (line 13340)
* 'c-lw6p2p-node-server-start':          C to Guile.        (line 13346)
* 'c-lw6p2p-node-update-info':           C to Guile.        (line 13352)
* 'c-lw6pil-bench':                      C to Guile.        (line 13358)
* 'c-lw6pil-build-pilot':                C to Guile.        (line 13364)
* 'c-lw6pil-calibrate':                  C to Guile.        (line 13370)
* 'c-lw6pil-commit':                     C to Guile.        (line 13376)
* 'c-lw6pil-did-cursor-win':             C to Guile.        (line 13382)
* 'c-lw6pil-dump-command-generate':      C to Guile.        (line 13388)
* 'c-lw6pil-execute-command':            C to Guile.        (line 13394)
* 'c-lw6pil-fix-coords':                 C to Guile.        (line 13400)
* 'c-lw6pil-fix-coords-x10':             C to Guile.        (line 13406)
* 'c-lw6pil-get-last-commit-seq':        C to Guile.        (line 13412)
* 'c-lw6pil-get-looser':                 C to Guile.        (line 13418)
* 'c-lw6pil-get-max-seq':                C to Guile.        (line 13424)
* 'c-lw6pil-get-next-seq':               C to Guile.        (line 13430)
* 'c-lw6pil-get-reference-current-seq':  C to Guile.        (line 13436)
* 'c-lw6pil-get-reference-target-seq':   C to Guile.        (line 13442)
* 'c-lw6pil-get-round-0':                C to Guile.        (line 13448)
* 'c-lw6pil-get-seq-0':                  C to Guile.        (line 13454)
* 'c-lw6pil-get-winner':                 C to Guile.        (line 13460)
* 'c-lw6pil-is-over':                    C to Guile.        (line 13466)
* 'c-lw6pil-local-command':              C to Guile.        (line 13472)
* 'c-lw6pil-local-cursors-set-main':     C to Guile.        (line 13478)
* 'c-lw6pil-local-cursors-set-mouse-controlled': C to Guile.
                                                            (line 13484)
* 'c-lw6pil-make-backup':                C to Guile.        (line 13491)
* 'c-lw6pil-poll-dump':                  C to Guile.        (line 13497)
* 'c-lw6pil-round2seq':                  C to Guile.        (line 13503)
* 'c-lw6pil-seed-command-generate':      C to Guile.        (line 13509)
* 'c-lw6pil-send-command':               C to Guile.        (line 13515)
* 'c-lw6pil-seq-random-0':               C to Guile.        (line 13521)
* 'c-lw6pil-seq2round':                  C to Guile.        (line 13527)
* 'c-lw6pil-slow-down':                  C to Guile.        (line 13533)
* 'c-lw6pil-speed-up':                   C to Guile.        (line 13539)
* 'c-lw6pil-suite-get-checkpoint':       C to Guile.        (line 13545)
* 'c-lw6pil-suite-get-commands-by-node-index': C to Guile.  (line 13551)
* 'c-lw6pil-suite-get-commands-by-stage': C to Guile.       (line 13559)
* 'c-lw6pil-suite-get-node-id':          C to Guile.        (line 13566)
* 'c-lw6pil-suite-get-seq-0':            C to Guile.        (line 13572)
* 'c-lw6pil-suite-init':                 C to Guile.        (line 13578)
* 'c-lw6pil-sync-from-backup':           C to Guile.        (line 13584)
* 'c-lw6pil-sync-from-draft':            C to Guile.        (line 13590)
* 'c-lw6pil-sync-from-reference':        C to Guile.        (line 13596)
* 'c-lw6snd-get-backends':               C to Guile.        (line 13602)
* 'c-lw6snd-is-music-file':              C to Guile.        (line 13608)
* 'c-lw6snd-new':                        C to Guile.        (line 13614)
* 'c-lw6snd-play-fx':                    C to Guile.        (line 13620)
* 'c-lw6snd-play-music-file':            C to Guile.        (line 13626)
* 'c-lw6snd-play-music-random':          C to Guile.        (line 13632)
* 'c-lw6snd-poll':                       C to Guile.        (line 13638)
* 'c-lw6snd-release':                    C to Guile.        (line 13644)
* 'c-lw6snd-set-fx-volume':              C to Guile.        (line 13650)
* 'c-lw6snd-set-music-volume':           C to Guile.        (line 13656)
* 'c-lw6snd-set-water-volume':           C to Guile.        (line 13662)
* 'c-lw6snd-stop-music':                 C to Guile.        (line 13668)
* 'c-lw6srv-get-backends':               C to Guile.        (line 13674)
* 'c-lw6sys-build-get-abs-srcdir':       C to Guile.        (line 13680)
* 'c-lw6sys-build-get-bin-id':           C to Guile.        (line 13686)
* 'c-lw6sys-build-get-bugs-url':         C to Guile.        (line 13692)
* 'c-lw6sys-build-get-cflags':           C to Guile.        (line 13698)
* 'c-lw6sys-build-get-codename':         C to Guile.        (line 13704)
* 'c-lw6sys-build-get-configure-args':   C to Guile.        (line 13710)
* 'c-lw6sys-build-get-copyright':        C to Guile.        (line 13716)
* 'c-lw6sys-build-get-datadir':          C to Guile.        (line 13722)
* 'c-lw6sys-build-get-date':             C to Guile.        (line 13728)
* 'c-lw6sys-build-get-docdir':           C to Guile.        (line 13734)
* 'c-lw6sys-build-get-enable-allinone':  C to Guile.        (line 13740)
* 'c-lw6sys-build-get-enable-console':   C to Guile.        (line 13746)
* 'c-lw6sys-build-get-enable-fullstatic': C to Guile.       (line 13752)
* 'c-lw6sys-build-get-enable-gcov':      C to Guile.        (line 13758)
* 'c-lw6sys-build-get-enable-gprof':     C to Guile.        (line 13764)
* 'c-lw6sys-build-get-enable-gtk':       C to Guile.        (line 13770)
* 'c-lw6sys-build-get-enable-instrument': C to Guile.       (line 13776)
* 'c-lw6sys-build-get-enable-mod-caca':  C to Guile.        (line 13782)
* 'c-lw6sys-build-get-enable-mod-csound': C to Guile.       (line 13788)
* 'c-lw6sys-build-get-enable-mod-gl1':   C to Guile.        (line 13794)
* 'c-lw6sys-build-get-enable-mod-gles2': C to Guile.        (line 13800)
* 'c-lw6sys-build-get-enable-mod-http':  C to Guile.        (line 13806)
* 'c-lw6sys-build-get-enable-mod-ogg':   C to Guile.        (line 13812)
* 'c-lw6sys-build-get-enable-mod-soft':  C to Guile.        (line 13818)
* 'c-lw6sys-build-get-enable-openmp':    C to Guile.        (line 13824)
* 'c-lw6sys-build-get-enable-optimize':  C to Guile.        (line 13830)
* 'c-lw6sys-build-get-enable-paranoid':  C to Guile.        (line 13836)
* 'c-lw6sys-build-get-enable-profiler':  C to Guile.        (line 13842)
* 'c-lw6sys-build-get-enable-valgrind':  C to Guile.        (line 13848)
* 'c-lw6sys-build-get-endianness':       C to Guile.        (line 13854)
* 'c-lw6sys-build-get-gcc-version':      C to Guile.        (line 13860)
* 'c-lw6sys-build-get-home-url':         C to Guile.        (line 13866)
* 'c-lw6sys-build-get-host-cpu':         C to Guile.        (line 13872)
* 'c-lw6sys-build-get-host-os':          C to Guile.        (line 13878)
* 'c-lw6sys-build-get-hostname':         C to Guile.        (line 13884)
* 'c-lw6sys-build-get-includedir':       C to Guile.        (line 13890)
* 'c-lw6sys-build-get-ldflags':          C to Guile.        (line 13896)
* 'c-lw6sys-build-get-libdir':           C to Guile.        (line 13902)
* 'c-lw6sys-build-get-license':          C to Guile.        (line 13908)
* 'c-lw6sys-build-get-localedir':        C to Guile.        (line 13914)
* 'c-lw6sys-build-get-md5sum':           C to Guile.        (line 13920)
* 'c-lw6sys-build-get-package-id':       C to Guile.        (line 13926)
* 'c-lw6sys-build-get-package-name':     C to Guile.        (line 13932)
* 'c-lw6sys-build-get-package-string':   C to Guile.        (line 13938)
* 'c-lw6sys-build-get-package-tarname':  C to Guile.        (line 13944)
* 'c-lw6sys-build-get-pointer-size':     C to Guile.        (line 13950)
* 'c-lw6sys-build-get-prefix':           C to Guile.        (line 13956)
* 'c-lw6sys-build-get-stamp':            C to Guile.        (line 13962)
* 'c-lw6sys-build-get-time':             C to Guile.        (line 13968)
* 'c-lw6sys-build-get-top-srcdir':       C to Guile.        (line 13974)
* 'c-lw6sys-build-get-version':          C to Guile.        (line 13980)
* 'c-lw6sys-build-get-version-base':     C to Guile.        (line 13986)
* 'c-lw6sys-build-get-version-major':    C to Guile.        (line 13992)
* 'c-lw6sys-build-get-version-minor':    C to Guile.        (line 13998)
* 'c-lw6sys-build-is-gnu':               C to Guile.        (line 14004)
* 'c-lw6sys-build-is-gp2x':              C to Guile.        (line 14010)
* 'c-lw6sys-build-is-mac-os-x':          C to Guile.        (line 14016)
* 'c-lw6sys-build-is-ms-windows':        C to Guile.        (line 14022)
* 'c-lw6sys-build-is-unix':              C to Guile.        (line 14028)
* 'c-lw6sys-build-is-x86':               C to Guile.        (line 14034)
* 'c-lw6sys-debug-get':                  C to Guile.        (line 14040)
* 'c-lw6sys-debug-set':                  C to Guile.        (line 14046)
* 'c-lw6sys-delay':                      C to Guile.        (line 14052)
* 'c-lw6sys-dump':                       C to Guile.        (line 14058)
* 'c-lw6sys-dump-clear':                 C to Guile.        (line 14064)
* 'c-lw6sys-generate-id-16':             C to Guile.        (line 14070)
* 'c-lw6sys-generate-id-32':             C to Guile.        (line 14076)
* 'c-lw6sys-generate-id-64':             C to Guile.        (line 14082)
* 'c-lw6sys-get-config-file':            C to Guile.        (line 14088)
* 'c-lw6sys-get-cwd':                    C to Guile.        (line 14094)
* 'c-lw6sys-get-cycle':                  C to Guile.        (line 14100)
* 'c-lw6sys-get-data-dir':               C to Guile.        (line 14106)
* 'c-lw6sys-get-default-config-file':    C to Guile.        (line 14112)
* 'c-lw6sys-get-default-data-dir':       C to Guile.        (line 14118)
* 'c-lw6sys-get-default-log-file':       C to Guile.        (line 14124)
* 'c-lw6sys-get-default-map-dir':        C to Guile.        (line 14130)
* 'c-lw6sys-get-default-map-path':       C to Guile.        (line 14136)
* 'c-lw6sys-get-default-mod-dir':        C to Guile.        (line 14142)
* 'c-lw6sys-get-default-music-dir':      C to Guile.        (line 14148)
* 'c-lw6sys-get-default-music-path':     C to Guile.        (line 14154)
* 'c-lw6sys-get-default-prefix':         C to Guile.        (line 14160)
* 'c-lw6sys-get-default-script-file':    C to Guile.        (line 14166)
* 'c-lw6sys-get-default-user-dir':       C to Guile.        (line 14172)
* 'c-lw6sys-get-hostname':               C to Guile.        (line 14178)
* 'c-lw6sys-get-log-file':               C to Guile.        (line 14184)
* 'c-lw6sys-get-map-dir':                C to Guile.        (line 14190)
* 'c-lw6sys-get-map-path':               C to Guile.        (line 14196)
* 'c-lw6sys-get-memory-bazooka-eraser':  C to Guile.        (line 14202)
* 'c-lw6sys-get-memory-bazooka-size':    C to Guile.        (line 14208)
* 'c-lw6sys-get-mod-dir':                C to Guile.        (line 14214)
* 'c-lw6sys-get-music-dir':              C to Guile.        (line 14220)
* 'c-lw6sys-get-music-path':             C to Guile.        (line 14226)
* 'c-lw6sys-get-prefix':                 C to Guile.        (line 14232)
* 'c-lw6sys-get-run-dir':                C to Guile.        (line 14238)
* 'c-lw6sys-get-script-file':            C to Guile.        (line 14244)
* 'c-lw6sys-get-timestamp':              C to Guile.        (line 14250)
* 'c-lw6sys-get-uptime':                 C to Guile.        (line 14256)
* 'c-lw6sys-get-user-dir':               C to Guile.        (line 14262)
* 'c-lw6sys-get-username':               C to Guile.        (line 14268)
* 'c-lw6sys-getenv':                     C to Guile.        (line 14274)
* 'c-lw6sys-getenv-prefixed':            C to Guile.        (line 14280)
* 'c-lw6sys-idle':                       C to Guile.        (line 14286)
* 'c-lw6sys-log':                        C to Guile.        (line 14292)
* 'c-lw6sys-log-get-backtrace-mode':     C to Guile.        (line 14298)
* 'c-lw6sys-log-get-level':              C to Guile.        (line 14304)
* 'c-lw6sys-log-set-backtrace-mode':     C to Guile.        (line 14310)
* 'c-lw6sys-log-set-dialog-timeout':     C to Guile.        (line 14316)
* 'c-lw6sys-log-set-level':              C to Guile.        (line 14322)
* 'c-lw6sys-megabytes-available':        C to Guile.        (line 14328)
* 'c-lw6sys-openmp-get-num-procs':       C to Guile.        (line 14334)
* 'c-lw6sys-path-concat':                C to Guile.        (line 14340)
* 'c-lw6sys-path-file-only':             C to Guile.        (line 14346)
* 'c-lw6sys-path-parent':                C to Guile.        (line 14352)
* 'c-lw6sys-path-split':                 C to Guile.        (line 14358)
* 'c-lw6sys-set-memory-bazooka-eraser':  C to Guile.        (line 14364)
* 'c-lw6sys-set-memory-bazooka-size':    C to Guile.        (line 14370)
* 'c-lw6sys-signal-custom':              C to Guile.        (line 14376)
* 'c-lw6sys-signal-default':             C to Guile.        (line 14382)
* 'c-lw6sys-signal-poll-quit':           C to Guile.        (line 14388)
* 'c-lw6sys-signal-send-quit':           C to Guile.        (line 14394)
* 'c-lw6sys-sleep':                      C to Guile.        (line 14400)
* 'c-lw6sys-snooze':                     C to Guile.        (line 14406)
* 'c-lw6sys-url-canonize':               C to Guile.        (line 14412)
* 'c-lw6tsk-loader-get-stage':           C to Guile.        (line 14418)
* 'c-lw6tsk-loader-new':                 C to Guile.        (line 14424)
* 'c-lw6tsk-loader-pop':                 C to Guile.        (line 14430)
* 'c-lw6tsk-loader-push-gen':            C to Guile.        (line 14436)
* 'c-lw6tsk-loader-push-ldr':            C to Guile.        (line 14442)
* 'capture':                             Graphics options.  (line  6924)
* 'chosen-map':                          Map parameters.    (line  7296)
* 'cli-backends':                        Network options.   (line  7168)
* 'click-to-focus':                      Input options.     (line  6650)
* 'color-alternate-bg':                  Map style.xml.     (line 10189)
* 'color-alternate-fg':                  Map style.xml.     (line 10205)
* 'color-base-bg':                       Map style.xml.     (line 10221)
* 'color-base-fg':                       Map style.xml.     (line 10237)
* 'color-conflict-mode':                 Map rules.xml.     (line  7448)
* 'colorize':                            Map style.xml.     (line 10253)
* 'colorize-cursor':                     Map style.xml.     (line 10269)
* 'commands-per-sec':                    Advanced settings. (line 11270)
* 'cursor-pot-init':                     Map rules.xml.     (line  7468)
* 'cursor-sensitivity':                  Input options.     (line  6664)
* 'cursor-size':                         Map style.xml.     (line 10285)
* 'custom-alt':                          Input options.     (line  6679)
* 'custom-ctrl':                         Input options.     (line  6691)
* 'custom-down':                         Input options.     (line  6703)
* 'custom-enter':                        Input options.     (line  6715)
* 'custom-esc':                          Input options.     (line  6727)
* 'custom-left':                         Input options.     (line  6739)
* 'custom-pgdown':                       Input options.     (line  6751)
* 'custom-pgup':                         Input options.     (line  6763)
* 'custom-right':                        Input options.     (line  6775)
* 'custom-up':                           Input options.     (line  6787)
* 'danger-power':                        Map rules.xml.     (line  7482)
* 'debug-layer-id':                      Advanced settings. (line 11304)
* 'debug-team-id':                       Advanced settings. (line 11317)
* 'dialog-timeout':                      Advanced settings. (line 11337)
* 'dirty-read':                          Advanced settings. (line 11353)
* 'display-background':                  Advanced settings. (line 11370)
* 'display-console':                     Advanced settings. (line 11383)
* 'display-cursors':                     Advanced settings. (line 11398)
* 'display-debug-gradient':              Advanced settings. (line 11411)
* 'display-debug-zones':                 Advanced settings. (line 11424)
* 'display-fighters':                    Advanced settings. (line 11437)
* 'display-fps':                         Advanced settings. (line 11450)
* 'display-hud':                         Advanced settings. (line 11464)
* 'display-log':                         Advanced settings. (line 11477)
* 'display-map':                         Advanced settings. (line 11490)
* 'display-menu':                        Advanced settings. (line 11503)
* 'display-meta':                        Advanced settings. (line 11516)
* 'display-mouse':                       Advanced settings. (line 11529)
* 'display-mps':                         Advanced settings. (line 11541)
* 'display-preview':                     Advanced settings. (line 11555)
* 'display-progress':                    Advanced settings. (line 11568)
* 'display-score':                       Advanced settings. (line 11581)
* 'display-splash':                      Advanced settings. (line 11593)
* 'display-url':                         Advanced settings. (line 11606)
* 'double-click-delay':                  Input options.     (line  6799)
* 'downsize-using-bench-value':          Map hints.xml.     (line  9703)
* 'downsize-using-fighter-scale':        Map hints.xml.     (line  9720)
* 'executed-again':                      Advanced settings. (line 11620)
* 'exp':                                 Map rules.xml.     (line  7498)
* 'fighter-attack':                      Map rules.xml.     (line  7514)
* 'fighter-defense':                     Map rules.xml.     (line  7531)
* 'fighter-new-health':                  Map rules.xml.     (line  7547)
* 'fighter-regenerate':                  Map rules.xml.     (line  7565)
* 'fighter-scale':                       Map hints.xml.     (line  9736)
* 'force':                               Map parameters.    (line  7310)
* 'frags-fade-out':                      Map rules.xml.     (line  7580)
* 'frags-mode':                          Map rules.xml.     (line  7599)
* 'frags-to-distribute':                 Map rules.xml.     (line  7618)
* 'fullscreen':                          Graphics options.  (line  6937)
* 'fx-volume':                           Sound options.     (line  7069)
* 'gfx-backend':                         Graphics options.  (line  6950)
* 'gfx-cpu-usage':                       Advanced settings. (line 11636)
* 'gfx-debug':                           Advanced settings. (line 11653)
* 'gfx-quality':                         Graphics options.  (line  6964)
* 'glue-power':                          Map rules.xml.     (line  7634)
* 'guess-colors':                        Map hints.xml.     (line  9762)
* 'guess-moves-per-sec':                 Map hints.xml.     (line  9781)
* 'height':                              Graphics options.  (line  6980)
* 'hidden-layer-alpha':                  Map style.xml.     (line 10299)
* 'highest-team-color-allowed':          Map rules.xml.     (line  7649)
* 'highest-weapon-allowed':              Map rules.xml.     (line  7666)
* 'hud-color-auto':                      Map hints.xml.     (line  9794)
* 'hud-color-frame-bg':                  Map style.xml.     (line 10316)
* 'hud-color-frame-fg':                  Map style.xml.     (line 10329)
* 'hud-color-text-bg':                   Map style.xml.     (line 10342)
* 'hud-color-text-fg':                   Map style.xml.     (line 10355)
* 'hud-style':                           Map style.xml.     (line 10368)
* 'io-per-sec':                          Advanced settings. (line 11666)
* 'jpeg-quality':                        Advanced settings. (line 11680)
* 'keep-ratio':                          Map style.xml.     (line 10382)
* 'known-nodes':                         Network options.   (line  7183)
* 'loader-sleep':                        Advanced settings. (line 11693)
* 'local-bench-delta':                   Advanced settings. (line 11706)
* 'log-file':                            Path options.      (line  6314)
* 'log-level':                           Advanced settings. (line 11720)
* 'log-timeout':                         Advanced settings. (line 11737)
* lw6bot_create_backend:                 libbot.            (line 15395)
* lw6bot_destroy_backend:                libbot.            (line 15413)
* lw6bot_get_backends:                   libbot.            (line 15378)
* lw6bot_init:                           libbot.            (line 15330)
* lw6bot_next_move:                      libbot.            (line 15353)
* lw6bot_quit:                           libbot.            (line 15345)
* lw6bot_repr:                           libbot.            (line 15368)
* lw6bot_test_register:                  libbot.            (line 15424)
* lw6bot_test_run:                       libbot.            (line 15434)
* lw6cfg_defaults:                       libcfg.            (line 15840)
* lw6cfg_format:                         libcfg.            (line 15885)
* lw6cfg_format_guess_type:              libcfg.            (line 15903)
* lw6cfg_get_option:                     libcfg.            (line 15947)
* lw6cfg_get_option_bool:                libcfg.            (line 16005)
* lw6cfg_get_option_int:                 libcfg.            (line 15977)
* lw6cfg_init:                           libcfg.            (line 16066)
* lw6cfg_load:                           libcfg.            (line 15921)
* lw6cfg_load_exp:                       libcfg.            (line 15861)
* lw6cfg_merge_env:                      libcfg.            (line 15850)
* lw6cfg_must_be_saved:                  libcfg.            (line 16037)
* lw6cfg_option_exists:                  libcfg.            (line 15935)
* lw6cfg_parse_command_line:             libcfg.            (line 15830)
* lw6cfg_quit:                           libcfg.            (line 16080)
* lw6cfg_read_key_value_xml_file:        libcfg.            (line 16321)
* lw6cfg_read_xml_bool:                  libcfg.            (line 16237)
* lw6cfg_read_xml_color:                 libcfg.            (line 16300)
* lw6cfg_read_xml_float:                 libcfg.            (line 16258)
* lw6cfg_read_xml_int:                   libcfg.            (line 16216)
* lw6cfg_read_xml_string:                libcfg.            (line 16279)
* lw6cfg_reset:                          libcfg.            (line 16091)
* lw6cfg_save:                           libcfg.            (line 16051)
* lw6cfg_save_exp:                       libcfg.            (line 15873)
* lw6cfg_set_option:                     libcfg.            (line 15961)
* lw6cfg_set_option_bool:                libcfg.            (line 16020)
* lw6cfg_set_option_int:                 libcfg.            (line 15988)
* lw6cfg_test_register:                  libcfg.            (line 16102)
* lw6cfg_test_run:                       libcfg.            (line 16112)
* lw6cfg_unified_get_log_file:           libcfg.            (line 16161)
* lw6cfg_unified_get_map_path:           libcfg.            (line 16189)
* lw6cfg_unified_get_music_path:         libcfg.            (line 16175)
* lw6cfg_unified_get_user_dir:           libcfg.            (line 16147)
* lw6cfg_unified_get_value:              libcfg.            (line 16123)
* lw6cfg_write_xml_bool:                 libcfg.            (line 16354)
* lw6cfg_write_xml_color:                libcfg.            (line 16396)
* lw6cfg_write_xml_float:                libcfg.            (line 16368)
* lw6cfg_write_xml_guess_type:           libcfg.            (line 16411)
* lw6cfg_write_xml_guess_type_skip_same: libcfg.            (line 16431)
* lw6cfg_write_xml_int:                  libcfg.            (line 16340)
* lw6cfg_write_xml_string:               libcfg.            (line 16382)
* lw6cfg_xml_element:                    libcfg.            (line 16203)
* lw6cli_can_send:                       libcli.            (line 16575)
* lw6cli_close:                          libcli.            (line 16536)
* lw6cli_create_backend:                 libcli.            (line 16671)
* lw6cli_default_backends:               libcli.            (line 16646)
* lw6cli_destroy_backend:                libcli.            (line 16689)
* lw6cli_get_backends:                   libcli.            (line 16654)
* lw6cli_init:                           libcli.            (line 16466)
* lw6cli_oob_free:                       libcli.            (line 16636)
* lw6cli_oob_new:                        libcli.            (line 16616)
* lw6cli_open:                           libcli.            (line 16505)
* lw6cli_poll:                           libcli.            (line 16590)
* lw6cli_process_oob:                    libcli.            (line 16485)
* lw6cli_quit:                           libcli.            (line 16477)
* lw6cli_repr:                           libcli.            (line 16604)
* lw6cli_send:                           libcli.            (line 16548)
* lw6cli_test_register:                  libcli.            (line 16699)
* lw6cli_test_run:                       libcli.            (line 16709)
* lw6cns_console_support:                libcns.            (line 17136)
* lw6cns_handler_callback:               libcns.            (line 17088)
* lw6cns_handler_install:                libcns.            (line 17100)
* lw6cns_handler_poll:                   libcns.            (line 17110)
* lw6cns_handler_remove:                 libcns.            (line 17117)
* lw6cns_history_add_if_needed:          libcns.            (line 17125)
* lw6cns_term_support:                   libcns.            (line 17144)
* lw6cns_test_register:                  libcns.            (line 17152)
* lw6cns_test_run:                       libcns.            (line 17162)
* lw6cnx_connection_free:                libcnx.            (line 17219)
* lw6cnx_connection_init_foo_bar_key:    libcnx.            (line 17242)
* lw6cnx_connection_lock_send:           libcnx.            (line 17258)
* lw6cnx_connection_new:                 libcnx.            (line 17186)
* lw6cnx_connection_reliability_filter:  libcnx.            (line 17284)
* lw6cnx_connection_should_send_foo:     libcnx.            (line 17230)
* lw6cnx_connection_unlock_send:         libcnx.            (line 17271)
* lw6cnx_packet_checksum:                libcnx.            (line 17326)
* lw6cnx_packet_compare:                 libcnx.            (line 17336)
* lw6cnx_packet_free:                    libcnx.            (line 17316)
* lw6cnx_packet_new:                     libcnx.            (line 17295)
* lw6cnx_packet_sort_callback:           libcnx.            (line 17353)
* lw6cnx_password_checksum:              libcnx.            (line 17370)
* lw6cnx_password_verify:                libcnx.            (line 17389)
* lw6cnx_test_register:                  libcnx.            (line 17407)
* lw6cnx_test_run:                       libcnx.            (line 17417)
* lw6cnx_ticket_table_ack_recv:          libcnx.            (line 17479)
* lw6cnx_ticket_table_clear:             libcnx.            (line 17453)
* lw6cnx_ticket_table_get_recv:          libcnx.            (line 17463)
* lw6cnx_ticket_table_get_send:          libcnx.            (line 17518)
* lw6cnx_ticket_table_init:              libcnx.            (line 17438)
* lw6cnx_ticket_table_set_send:          libcnx.            (line 17534)
* lw6cnx_ticket_table_was_recv_exchanged: libcnx.           (line 17502)
* lw6cnx_ticket_table_zero:              libcnx.            (line 17428)
* lw6dat_miss_free:                      libdat.            (line 17941)
* lw6dat_miss_is_included:               libdat.            (line 17969)
* lw6dat_miss_is_same:                   libdat.            (line 17959)
* lw6dat_miss_new:                       libdat.            (line 17927)
* lw6dat_miss_overlaps:                  libdat.            (line 17979)
* lw6dat_miss_sync:                      libdat.            (line 17949)
* lw6dat_test_register:                  libdat.            (line 17989)
* lw6dat_test_run:                       libdat.            (line 17999)
* lw6dat_warehouse_calc_serial_draft_and_reference: libdat. (line 18187)
* lw6dat_warehouse_clear:                libdat.            (line 18049)
* lw6dat_warehouse_free:                 libdat.            (line 18039)
* lw6dat_warehouse_get_atom_str_list_not_sent: libdat.      (line 18294)
* lw6dat_warehouse_get_local_id:         libdat.            (line 18081)
* lw6dat_warehouse_get_local_seq_0:      libdat.            (line 18101)
* lw6dat_warehouse_get_local_seq_last:   libdat.            (line 18124)
* lw6dat_warehouse_get_local_serial:     libdat.            (line 18091)
* lw6dat_warehouse_get_miss_list:        libdat.            (line 18309)
* lw6dat_warehouse_get_msg_list_by_seq:  libdat.            (line 18271)
* lw6dat_warehouse_get_nb_atom_parts_since_last_poll: libdat.
                                                            (line 18377)
* lw6dat_warehouse_get_nb_nodes:         libdat.            (line 18071)
* lw6dat_warehouse_get_seq_draft:        libdat.            (line 18242)
* lw6dat_warehouse_get_seq_max:          libdat.            (line 18230)
* lw6dat_warehouse_get_seq_min:          libdat.            (line 18217)
* lw6dat_warehouse_get_seq_reference:    libdat.            (line 18256)
* lw6dat_warehouse_init:                 libdat.            (line 18010)
* lw6dat_warehouse_is_node_registered:   libdat.            (line 18158)
* lw6dat_warehouse_meta_get:             libdat.            (line 18410)
* lw6dat_warehouse_meta_put:             libdat.            (line 18396)
* lw6dat_warehouse_miss_invalidate:      libdat.            (line 18331)
* lw6dat_warehouse_new:                  libdat.            (line 18026)
* lw6dat_warehouse_purge:                libdat.            (line 18060)
* lw6dat_warehouse_put_atom_str:         libdat.            (line 18171)
* lw6dat_warehouse_put_local_msg:        libdat.            (line 18204)
* lw6dat_warehouse_register_node:        libdat.            (line 18138)
* lw6dat_warehouse_reset_nb_atom_parts_since_last_poll: libdat.
                                                            (line 18366)
* lw6dat_warehouse_set_local_seq_0:      libdat.            (line 18112)
* lw6dat_warehouse_update_serial_miss_max: libdat.          (line 18353)
* lw6dsp_create_backend:                 libdsp.            (line 18498)
* lw6dsp_destroy_backend:                libdsp.            (line 18518)
* lw6dsp_get_average_fps:                libdsp.            (line 18622)
* lw6dsp_get_fullscreen_modes:           libdsp.            (line 18649)
* lw6dsp_get_instant_fps:                libdsp.            (line 18611)
* lw6dsp_get_last_frame_rendering_time:  libdsp.            (line 18602)
* lw6dsp_get_nb_frames:                  libdsp.            (line 18591)
* lw6dsp_get_video_mode:                 libdsp.            (line 18634)
* lw6dsp_init:                           libdsp.            (line 18539)
* lw6dsp_param_zero:                     libdsp.            (line 18666)
* lw6dsp_quit:                           libdsp.            (line 18559)
* lw6dsp_repr:                           libdsp.            (line 18529)
* lw6dsp_test_register:                  libdsp.            (line 18677)
* lw6dsp_test_run:                       libdsp.            (line 18687)
* lw6dsp_update:                         libdsp.            (line 18570)
* lw6dyn_dlclose_backend:                libdyn.            (line 18974)
* lw6dyn_dlclose_shared:                 libdyn.            (line 18985)
* lw6dyn_dlopen_backend:                 libdyn.            (line 18932)
* lw6dyn_dlopen_backend_so:              libdyn.            (line 18912)
* lw6dyn_dlopen_shared:                  libdyn.            (line 18953)
* lw6dyn_dlopen_shared_so:               libdyn.            (line 18922)
* lw6dyn_dlsym:                          libdyn.            (line 18997)
* lw6dyn_list_backends:                  libdyn.            (line 19009)
* lw6dyn_path_find_backend:              libdyn.            (line 19028)
* lw6dyn_path_find_shared:               libdyn.            (line 19051)
* lw6dyn_test_register:                  libdyn.            (line 19080)
* lw6dyn_test_run:                       libdyn.            (line 19090)
* lw6gen_create_from_seed:               libgen.            (line 19162)
* lw6gen_seed_char:                      libgen.            (line 19199)
* lw6gen_seed_new:                       libgen.            (line 19179)
* lw6gen_seed_normalize:                 libgen.            (line 19187)
* lw6gen_test_register:                  libgen.            (line 19206)
* lw6gen_test_run:                       libgen.            (line 19216)
* lw6gfx_create_backend:                 libgfx.            (line 19408)
* lw6gfx_destroy_backend:                libgfx.            (line 19426)
* lw6gfx_display:                        libgfx.            (line 19339)
* lw6gfx_get_backends:                   libgfx.            (line 19391)
* lw6gfx_get_fullscreen_modes:           libgfx.            (line 19312)
* lw6gfx_get_video_mode:                 libgfx.            (line 19299)
* lw6gfx_init:                           libgfx.            (line 19240)
* lw6gfx_pump_events:                    libgfx.            (line 19326)
* lw6gfx_quit:                           libgfx.            (line 19259)
* lw6gfx_repr:                           libgfx.            (line 19270)
* lw6gfx_set_video_mode:                 libgfx.            (line 19280)
* lw6gfx_test_register:                  libgfx.            (line 19437)
* lw6gfx_test_run:                       libgfx.            (line 19447)
* lw6glb_base64_decode_bin:              libglb.            (line 19808)
* lw6glb_base64_decode_bin_prefix:       libglb.            (line 19857)
* lw6glb_base64_decode_str:              libglb.            (line 19832)
* lw6glb_base64_decode_str_prefix:       libglb.            (line 19888)
* lw6glb_base64_encode_bin:              libglb.            (line 19796)
* lw6glb_base64_encode_bin_prefix:       libglb.            (line 19842)
* lw6glb_base64_encode_str:              libglb.            (line 19822)
* lw6glb_base64_encode_str_prefix:       libglb.            (line 19875)
* lw6glb_sha1_hmac_32_bin:               libglb.            (line 19930)
* lw6glb_sha1_hmac_32_str:               libglb.            (line 19947)
* lw6glb_sha1_hmac_80_bin:               libglb.            (line 19901)
* lw6glb_sha1_hmac_80_str:               libglb.            (line 19917)
* lw6glb_test_register:                  libglb.            (line 19959)
* lw6glb_test_run:                       libglb.            (line 19969)
* lw6gui_button_is_pressed:              libgui.            (line 20015)
* lw6gui_button_pop_double_click:        libgui.            (line 20056)
* lw6gui_button_pop_press:               libgui.            (line 20025)
* lw6gui_button_pop_simple_click:        libgui.            (line 20041)
* lw6gui_button_pop_triple_click:        libgui.            (line 20070)
* lw6gui_button_register_down:           libgui.            (line 19993)
* lw6gui_button_register_up:             libgui.            (line 20005)
* lw6gui_button_sync:                    libgui.            (line 20101)
* lw6gui_button_update_repeat:           libgui.            (line 20084)
* lw6gui_coords_fix_xy_float:            libgui.            (line 20151)
* lw6gui_coord_calc_xy:                  libgui.            (line 20117)
* lw6gui_input_enable_auto_release:      libgui.            (line 20292)
* lw6gui_input_free:                     libgui.            (line 20213)
* lw6gui_input_init:                     libgui.            (line 20182)
* lw6gui_input_need_sync:                libgui.            (line 20262)
* lw6gui_input_new:                      libgui.            (line 20204)
* lw6gui_input_quit:                     libgui.            (line 20193)
* lw6gui_input_register_change:          libgui.            (line 20250)
* lw6gui_input_reset:                    libgui.            (line 20223)
* lw6gui_input_sync:                     libgui.            (line 20273)
* lw6gui_input_update_repeat:            libgui.            (line 20234)
* lw6gui_joystick_check_index:           libgui.            (line 20303)
* lw6gui_joystick_get_move_pad:          libgui.            (line 20379)
* lw6gui_joystick_sync:                  libgui.            (line 20366)
* lw6gui_joystick_update_axis_x:         libgui.            (line 20314)
* lw6gui_joystick_update_axis_y:         libgui.            (line 20333)
* lw6gui_joystick_update_repeat:         libgui.            (line 20350)
* lw6gui_keyboard_check_keysym:          libgui.            (line 20393)
* lw6gui_keyboard_get_move_pad:          libgui.            (line 20492)
* lw6gui_keyboard_is_pressed:            libgui.            (line 20415)
* lw6gui_keyboard_pop_keypress:          libgui.            (line 20403)
* lw6gui_keyboard_register_key_down:     libgui.            (line 20426)
* lw6gui_keyboard_register_key_up:       libgui.            (line 20450)
* lw6gui_keyboard_sync:                  libgui.            (line 20478)
* lw6gui_keyboard_update_repeat:         libgui.            (line 20462)
* lw6gui_keypress_free:                  libgui.            (line 20521)
* lw6gui_keypress_new:                   libgui.            (line 20506)
* lw6gui_keypress_repr:                  libgui.            (line 20531)
* lw6gui_look_dup:                       libgui.            (line 20626)
* lw6gui_look_fix:                       libgui.            (line 20636)
* lw6gui_look_free:                      libgui.            (line 20552)
* lw6gui_look_get:                       libgui.            (line 20597)
* lw6gui_look_is_same:                   libgui.            (line 20611)
* lw6gui_look_memory_footprint:          libgui.            (line 20562)
* lw6gui_look_new:                       libgui.            (line 20541)
* lw6gui_look_repr:                      libgui.            (line 20572)
* lw6gui_look_set:                       libgui.            (line 20582)
* lw6gui_look_zoom_in:                   libgui.            (line 20647)
* lw6gui_look_zoom_out:                  libgui.            (line 20660)
* lw6gui_menuitem_checksum:              libgui.            (line 21324)
* lw6gui_menuitem_dup:                   libgui.            (line 21349)
* lw6gui_menuitem_enable:                libgui.            (line 21306)
* lw6gui_menuitem_free:                  libgui.            (line 21194)
* lw6gui_menuitem_is_same:               libgui.            (line 21336)
* lw6gui_menuitem_memory_footprint:      libgui.            (line 21204)
* lw6gui_menuitem_new:                   libgui.            (line 21163)
* lw6gui_menuitem_repr:                  libgui.            (line 21216)
* lw6gui_menuitem_select:                libgui.            (line 21288)
* lw6gui_menuitem_set_label:             libgui.            (line 21229)
* lw6gui_menuitem_set_tooltip:           libgui.            (line 21249)
* lw6gui_menuitem_set_value:             libgui.            (line 21269)
* lw6gui_menuitem_sync:                  libgui.            (line 21359)
* lw6gui_menu_append:                    libgui.            (line 20940)
* lw6gui_menu_append_for_id_use:         libgui.            (line 21037)
* lw6gui_menu_center:                    libgui.            (line 20902)
* lw6gui_menu_close_popup:               libgui.            (line 20776)
* lw6gui_menu_dup:                       libgui.            (line 21134)
* lw6gui_menu_enable_esc:                libgui.            (line 20848)
* lw6gui_menu_free:                      libgui.            (line 20696)
* lw6gui_menu_get_item:                  libgui.            (line 20801)
* lw6gui_menu_has_popup:                 libgui.            (line 20787)
* lw6gui_menu_insert:                    libgui.            (line 20917)
* lw6gui_menu_insert_for_id_use:         libgui.            (line 21001)
* lw6gui_menu_is_same:                   libgui.            (line 21122)
* lw6gui_menu_memory_footprint:          libgui.            (line 20706)
* lw6gui_menu_new:                       libgui.            (line 20673)
* lw6gui_menu_remove:                    libgui.            (line 20957)
* lw6gui_menu_remove_all:                libgui.            (line 20971)
* lw6gui_menu_remove_using_id:           libgui.            (line 21068)
* lw6gui_menu_repr:                      libgui.            (line 20718)
* lw6gui_menu_scroll_down:               libgui.            (line 20875)
* lw6gui_menu_scroll_up:                 libgui.            (line 20863)
* lw6gui_menu_select:                    libgui.            (line 20814)
* lw6gui_menu_select_esc:                libgui.            (line 20833)
* lw6gui_menu_set_breadcrumbs:           libgui.            (line 20887)
* lw6gui_menu_set_help:                  libgui.            (line 20746)
* lw6gui_menu_set_popup:                 libgui.            (line 20761)
* lw6gui_menu_set_title:                 libgui.            (line 20731)
* lw6gui_menu_sync:                      libgui.            (line 21144)
* lw6gui_menu_sync_using_id:             libgui.            (line 21087)
* lw6gui_menu_update_display_range:      libgui.            (line 20984)
* lw6gui_mouse_drag_begin:               libgui.            (line 21434)
* lw6gui_mouse_drag_end:                 libgui.            (line 21445)
* lw6gui_mouse_drag_pop:                 libgui.            (line 21456)
* lw6gui_mouse_poll_move:                libgui.            (line 21389)
* lw6gui_mouse_register_move:            libgui.            (line 21372)
* lw6gui_mouse_sync:                     libgui.            (line 21420)
* lw6gui_mouse_update_repeat:            libgui.            (line 21406)
* lw6gui_point_is_inside_rect:           libgui.            (line 21480)
* lw6gui_power_of_two_ge:                libgui.            (line 21493)
* lw6gui_power_of_two_le:                libgui.            (line 21504)
* lw6gui_quad_is_inside_rect:            libgui.            (line 21515)
* lw6gui_rect_array_get_tile_and_quad:   libgui.            (line 21590)
* lw6gui_rect_array_get_tile_by_i:       libgui.            (line 21573)
* lw6gui_rect_array_get_tile_by_source_xy: libgui.          (line 21550)
* lw6gui_rect_array_init:                libgui.            (line 21529)
* lw6gui_rect_clip:                      libgui.            (line 21656)
* lw6gui_rect_init_x1y1x2y2:             libgui.            (line 21619)
* lw6gui_rect_init_xywh:                 libgui.            (line 21638)
* lw6gui_segment_is_inside_rect:         libgui.            (line 21671)
* lw6gui_smoother_fix_overflow:          libgui.            (line 21742)
* lw6gui_smoother_get_value:             libgui.            (line 21730)
* lw6gui_smoother_immediate_force:       libgui.            (line 21702)
* lw6gui_smoother_init:                  libgui.            (line 21686)
* lw6gui_smoother_set_target:            libgui.            (line 21714)
* lw6gui_test_register:                  libgui.            (line 21756)
* lw6gui_test_run:                       libgui.            (line 21766)
* lw6gui_triangle_is_inside_rect:        libgui.            (line 21777)
* lw6gui_video_mode_find_closest:        libgui.            (line 21792)
* lw6gui_video_mode_is_same:             libgui.            (line 21812)
* lw6gui_video_mode_sync_ratio:          libgui.            (line 21825)
* lw6gui_viewport_calc_drag:             libgui.            (line 21941)
* lw6gui_viewport_init:                  libgui.            (line 21839)
* lw6gui_viewport_map_to_screen:         libgui.            (line 21893)
* lw6gui_viewport_screen_to_map:         libgui.            (line 21916)
* lw6gui_zone_clip:                      libgui.            (line 22003)
* lw6gui_zone_init_x1y1x2y2:             libgui.            (line 21965)
* lw6gui_zone_init_xywh:                 libgui.            (line 21984)
* lw6hlp_about:                          libhlp.            (line 23345)
* lw6hlp_get_credits:                    libhlp.            (line 23418)
* lw6hlp_get_default_value:              libhlp.            (line 23381)
* lw6hlp_get_max_value:                  libhlp.            (line 23406)
* lw6hlp_get_min_value:                  libhlp.            (line 23394)
* lw6hlp_get_type:                       libhlp.            (line 23371)
* lw6hlp_is_documented:                  libhlp.            (line 23335)
* lw6hlp_list:                           libhlp.            (line 23605)
* lw6hlp_list_advanced:                  libhlp.            (line 23573)
* lw6hlp_list_aliases:                   libhlp.            (line 23581)
* lw6hlp_list_doc:                       libhlp.            (line 23453)
* lw6hlp_list_funcs:                     libhlp.            (line 23557)
* lw6hlp_list_graphics:                  libhlp.            (line 23493)
* lw6hlp_list_hooks:                     libhlp.            (line 23565)
* lw6hlp_list_input:                     libhlp.            (line 23485)
* lw6hlp_list_map:                       libhlp.            (line 23517)
* lw6hlp_list_map_hints:                 libhlp.            (line 23533)
* lw6hlp_list_map_rules:                 libhlp.            (line 23525)
* lw6hlp_list_map_style:                 libhlp.            (line 23541)
* lw6hlp_list_map_teams:                 libhlp.            (line 23549)
* lw6hlp_list_network:                   libhlp.            (line 23509)
* lw6hlp_list_path:                      libhlp.            (line 23469)
* lw6hlp_list_players:                   libhlp.            (line 23477)
* lw6hlp_list_quick:                     libhlp.            (line 23445)
* lw6hlp_list_show:                      libhlp.            (line 23461)
* lw6hlp_list_sound:                     libhlp.            (line 23501)
* lw6hlp_list_team_colors:               libhlp.            (line 23589)
* lw6hlp_list_weapons:                   libhlp.            (line 23597)
* lw6hlp_match:                          libhlp.            (line 23431)
* lw6hlp_print_about:                    libhlp.            (line 23660)
* lw6hlp_print_audit:                    libhlp.            (line 23744)
* lw6hlp_print_bench:                    libhlp.            (line 23713)
* lw6hlp_print_content:                  libhlp.            (line 23646)
* lw6hlp_print_credits:                  libhlp.            (line 23764)
* lw6hlp_print_goodbye:                  libhlp.            (line 23998)
* lw6hlp_print_hello:                    libhlp.            (line 23986)
* lw6hlp_print_help:                     libhlp.            (line 23673)
* lw6hlp_print_host:                     libhlp.            (line 23734)
* lw6hlp_print_keyword:                  libhlp.            (line 23634)
* lw6hlp_print_list:                     libhlp.            (line 23976)
* lw6hlp_print_list_advanced:            libhlp.            (line 23936)
* lw6hlp_print_list_aliases:             libhlp.            (line 23946)
* lw6hlp_print_list_doc:                 libhlp.            (line 23786)
* lw6hlp_print_list_funcs:               libhlp.            (line 23916)
* lw6hlp_print_list_graphics:            libhlp.            (line 23836)
* lw6hlp_print_list_hooks:               libhlp.            (line 23926)
* lw6hlp_print_list_input:               libhlp.            (line 23826)
* lw6hlp_print_list_map:                 libhlp.            (line 23866)
* lw6hlp_print_list_map_hints:           libhlp.            (line 23886)
* lw6hlp_print_list_map_rules:           libhlp.            (line 23876)
* lw6hlp_print_list_map_style:           libhlp.            (line 23896)
* lw6hlp_print_list_map_teams:           libhlp.            (line 23906)
* lw6hlp_print_list_network:             libhlp.            (line 23856)
* lw6hlp_print_list_path:                libhlp.            (line 23806)
* lw6hlp_print_list_players:             libhlp.            (line 23816)
* lw6hlp_print_list_quick:               libhlp.            (line 23776)
* lw6hlp_print_list_show:                libhlp.            (line 23796)
* lw6hlp_print_list_sound:               libhlp.            (line 23846)
* lw6hlp_print_list_team_colors:         libhlp.            (line 23956)
* lw6hlp_print_list_weapons:             libhlp.            (line 23966)
* lw6hlp_print_long_copyright:           libhlp.            (line 23703)
* lw6hlp_print_modules:                  libhlp.            (line 23754)
* lw6hlp_print_pedigree:                 libhlp.            (line 23723)
* lw6hlp_print_short_copyright:          libhlp.            (line 23693)
* lw6hlp_print_version:                  libhlp.            (line 23683)
* lw6hlp_process_non_run_options:        libhlp.            (line 23613)
* lw6hlp_reference_init:                 libhlp.            (line 24006)
* lw6hlp_reference_quit:                 libhlp.            (line 24014)
* lw6hlp_test_register:                  libhlp.            (line 24023)
* lw6hlp_test_run:                       libhlp.            (line 24033)
* lw6img_repr:                           libimg.            (line 24057)
* lw6img_screenshot_free:                libimg.            (line 24090)
* lw6img_screenshot_new:                 libimg.            (line 24070)
* lw6img_test_register:                  libimg.            (line 24098)
* lw6img_test_run:                       libimg.            (line 24108)
* lw6ker_capture_str:                    libker.            (line 24165)
* lw6ker_cursor_reset:                   libker.            (line 24193)
* lw6ker_game_state_add_cursor:          libker.            (line 24433)
* lw6ker_game_state_can_sync:            libker.            (line 24267)
* lw6ker_game_state_checksum:            libker.            (line 24317)
* lw6ker_game_state_checksum_log_set_interval: libker.      (line 24177)
* lw6ker_game_state_cursor_exists:       libker.            (line 24469)
* lw6ker_game_state_did_cursor_win:      libker.            (line 24697)
* lw6ker_game_state_do_move:             libker.            (line 24596)
* lw6ker_game_state_do_round:            libker.            (line 24627)
* lw6ker_game_state_do_spread:           libker.            (line 24578)
* lw6ker_game_state_dup:                 libker.            (line 24301)
* lw6ker_game_state_finish_round:        libker.            (line 24615)
* lw6ker_game_state_free:                libker.            (line 24219)
* lw6ker_game_state_from_hexa:           libker.            (line 25392)
* lw6ker_game_state_get_charge_per1000:  libker.            (line 25020)
* lw6ker_game_state_get_cursor:          libker.            (line 24482)
* lw6ker_game_state_get_cursor_by_index: libker.            (line 24497)
* lw6ker_game_state_get_d:               libker.            (line 24362)
* lw6ker_game_state_get_fighter_id:      libker.            (line 24854)
* lw6ker_game_state_get_fighter_ro_by_id: libker.           (line 24940)
* lw6ker_game_state_get_fighter_ro_safe: libker.            (line 24958)
* lw6ker_game_state_get_fighter_ro_unsafe: libker.          (line 24981)
* lw6ker_game_state_get_fighter_rw_by_id: libker.           (line 24878)
* lw6ker_game_state_get_fighter_rw_safe: libker.            (line 24895)
* lw6ker_game_state_get_fighter_rw_unsafe: libker.          (line 24917)
* lw6ker_game_state_get_global_history:  libker.            (line 24790)
* lw6ker_game_state_get_global_history_max: libker.         (line 24828)
* lw6ker_game_state_get_h:               libker.            (line 24352)
* lw6ker_game_state_get_latest_history:  libker.            (line 24809)
* lw6ker_game_state_get_latest_history_max: libker.         (line 24841)
* lw6ker_game_state_get_latest_weapon:   libker.            (line 25050)
* lw6ker_game_state_get_looser:          libker.            (line 24729)
* lw6ker_game_state_get_moves:           libker.            (line 24641)
* lw6ker_game_state_get_nb_active_fighters: libker.         (line 24748)
* lw6ker_game_state_get_nb_colors:       libker.            (line 25071)
* lw6ker_game_state_get_nb_cursors:      libker.            (line 25083)
* lw6ker_game_state_get_nb_nodes:        libker.            (line 25095)
* lw6ker_game_state_get_nb_teams:        libker.            (line 24566)
* lw6ker_game_state_get_node_info:       libker.            (line 24416)
* lw6ker_game_state_get_rounds:          libker.            (line 24661)
* lw6ker_game_state_get_shape:           libker.            (line 24329)
* lw6ker_game_state_get_spreads:         libker.            (line 24651)
* lw6ker_game_state_get_team_info:       libker.            (line 24547)
* lw6ker_game_state_get_time_elapsed:    libker.            (line 24761)
* lw6ker_game_state_get_time_left:       libker.            (line 24775)
* lw6ker_game_state_get_total_rounds:    libker.            (line 24671)
* lw6ker_game_state_get_w:               libker.            (line 24342)
* lw6ker_game_state_get_weapon_per1000_left: libker.        (line 25035)
* lw6ker_game_state_get_winner:          libker.            (line 24710)
* lw6ker_game_state_get_zone_potential:  libker.            (line 25005)
* lw6ker_game_state_is_over:             libker.            (line 24686)
* lw6ker_game_state_memory_footprint:    libker.            (line 24247)
* lw6ker_game_state_new:                 libker.            (line 24205)
* lw6ker_game_state_node_exists:         libker.            (line 24403)
* lw6ker_game_state_point_to:            libker.            (line 24230)
* lw6ker_game_state_register_node:       libker.            (line 24373)
* lw6ker_game_state_remove_cursor:       libker.            (line 24453)
* lw6ker_game_state_repr:                libker.            (line 24257)
* lw6ker_game_state_set_cursor:          libker.            (line 24514)
* lw6ker_game_state_sync:                libker.            (line 24283)
* lw6ker_game_state_team_exists:         libker.            (line 24533)
* lw6ker_game_state_to_hexa:             libker.            (line 25379)
* lw6ker_game_state_unregister_node:     libker.            (line 24388)
* lw6ker_game_struct_checksum:           libker.            (line 25188)
* lw6ker_game_struct_dup:                libker.            (line 25172)
* lw6ker_game_struct_find_free_slot_near: libker.           (line 25334)
* lw6ker_game_struct_free:               libker.            (line 25124)
* lw6ker_game_struct_from_hexa:          libker.            (line 25364)
* lw6ker_game_struct_get_d:              libker.            (line 25233)
* lw6ker_game_struct_get_h:              libker.            (line 25223)
* lw6ker_game_struct_get_shape:          libker.            (line 25200)
* lw6ker_game_struct_get_w:              libker.            (line 25213)
* lw6ker_game_struct_get_zones_info:     libker.            (line 25281)
* lw6ker_game_struct_get_zone_id:        libker.            (line 25316)
* lw6ker_game_struct_get_zone_info:      libker.            (line 25297)
* lw6ker_game_struct_is_bg:              libker.            (line 25263)
* lw6ker_game_struct_is_fg:              libker.            (line 25244)
* lw6ker_game_struct_memory_footprint:   libker.            (line 25152)
* lw6ker_game_struct_new:                libker.            (line 25107)
* lw6ker_game_struct_point_to:           libker.            (line 25135)
* lw6ker_game_struct_repr:               libker.            (line 25162)
* lw6ker_game_struct_to_hexa:            libker.            (line 25351)
* lw6ker_move_get_best_next_pos:         libker.            (line 25407)
* lw6ker_score_array_update:             libker.            (line 25430)
* lw6ker_team_mask_best:                 libker.            (line 25460)
* lw6ker_team_mask_color2mask:           libker.            (line 25491)
* lw6ker_team_mask_get:                  libker.            (line 25444)
* lw6ker_team_mask_is_concerned:         libker.            (line 25479)
* lw6ker_test_register:                  libker.            (line 25499)
* lw6ker_test_run:                       libker.            (line 25513)
* lw6ldr_auto_colors:                    libldr.            (line 25896)
* lw6ldr_body_read:                      libldr.            (line 25865)
* lw6ldr_chain_entry:                    libldr.            (line 25987)
* lw6ldr_cursor_texture_read:            libldr.            (line 25910)
* lw6ldr_dup_entry:                      libldr.            (line 25934)
* lw6ldr_exp_validate:                   libldr.            (line 26003)
* lw6ldr_for_all_entries:                libldr.            (line 25963)
* lw6ldr_free_entry:                     libldr.            (line 25924)
* lw6ldr_get_entries:                    libldr.            (line 25944)
* lw6ldr_grease_apply:                   libldr.            (line 26015)
* lw6ldr_hints_clear:                    libldr.            (line 26053)
* lw6ldr_hints_defaults:                 libldr.            (line 26032)
* lw6ldr_hints_get:                      libldr.            (line 26094)
* lw6ldr_hints_get_default:              libldr.            (line 26107)
* lw6ldr_hints_read:                     libldr.            (line 26064)
* lw6ldr_hints_set:                      libldr.            (line 26076)
* lw6ldr_hints_update:                   libldr.            (line 26117)
* lw6ldr_hints_zero:                     libldr.            (line 26042)
* lw6ldr_layer_read_first:               libldr.            (line 26133)
* lw6ldr_layer_read_next:                libldr.            (line 26169)
* lw6ldr_metadata_read:                  libldr.            (line 26187)
* lw6ldr_meta_layer_read:                libldr.            (line 26201)
* lw6ldr_meta_layer_read_if_exists:      libldr.            (line 26221)
* lw6ldr_param_read:                     libldr.            (line 26267)
* lw6ldr_param_update:                   libldr.            (line 26282)
* lw6ldr_print_examples:                 libldr.            (line 26339)
* lw6ldr_print_example_hints_xml:        libldr.            (line 26309)
* lw6ldr_print_example_rules_xml:        libldr.            (line 26299)
* lw6ldr_print_example_style_xml:        libldr.            (line 26319)
* lw6ldr_print_example_teams_xml:        libldr.            (line 26329)
* lw6ldr_process_non_run_options:        libldr.            (line 26246)
* lw6ldr_read:                           libldr.            (line 26350)
* lw6ldr_read_relative:                  libldr.            (line 26388)
* lw6ldr_resampler_force:                libldr.            (line 26492)
* lw6ldr_resampler_init:                 libldr.            (line 26424)
* lw6ldr_resampler_source2target:        libldr.            (line 26512)
* lw6ldr_resampler_target2source:        libldr.            (line 26530)
* lw6ldr_resampler_use_for_gen:          libldr.            (line 26467)
* lw6ldr_rules_read:                     libldr.            (line 26551)
* lw6ldr_rules_update:                   libldr.            (line 26563)
* lw6ldr_style_read:                     libldr.            (line 26579)
* lw6ldr_style_set:                      libldr.            (line 26591)
* lw6ldr_style_update:                   libldr.            (line 26609)
* lw6ldr_teams_read:                     libldr.            (line 26625)
* lw6ldr_teams_update:                   libldr.            (line 26637)
* lw6ldr_test_register:                  libldr.            (line 26653)
* lw6ldr_test_run:                       libldr.            (line 26663)
* lw6ldr_texture_read:                   libldr.            (line 26674)
* lw6ldr_use_clear:                      libldr.            (line 26720)
* lw6ldr_use_defaults:                   libldr.            (line 26708)
* lw6ldr_use_set:                        libldr.            (line 26730)
* lw6ldr_use_update:                     libldr.            (line 26747)
* lw6map_body_builtin_custom:            libmap.            (line 27076)
* lw6map_body_check_and_fix_holes:       libmap.            (line 27117)
* lw6map_body_clear:                     libmap.            (line 27097)
* lw6map_body_coord_from_texture:        libmap.            (line 27132)
* lw6map_body_fix_checksum:              libmap.            (line 27107)
* lw6map_body_get_with_texture_coord:    libmap.            (line 27151)
* lw6map_builtin_custom:                 libmap.            (line 27472)
* lw6map_builtin_defaults:               libmap.            (line 27449)
* lw6map_builtin_scale:                  libmap.            (line 27458)
* lw6map_color_invert:                   libmap.            (line 27169)
* lw6map_color_is_same:                  libmap.            (line 27179)
* lw6map_color_set_is_same:              libmap.            (line 28061)
* lw6map_coords_fix_xy:                  libmap.            (line 27224)
* lw6map_coords_fix_z:                   libmap.            (line 27241)
* lw6map_cursor_texture_builtin:         libmap.            (line 27266)
* lw6map_cursor_texture_clear:           libmap.            (line 27256)
* lw6map_cursor_texture_layer_get:       libmap.            (line 27294)
* lw6map_cursor_texture_layer_set:       libmap.            (line 27277)
* lw6map_dup:                            libmap.            (line 27310)
* lw6map_exp_get_highest_team_color_allowed: libmap.        (line 27324)
* lw6map_exp_get_highest_weapon_allowed: libmap.            (line 27334)
* lw6map_exp_get_unlocked_team_color:    libmap.            (line 27368)
* lw6map_exp_get_unlocked_weapon:        libmap.            (line 27378)
* lw6map_exp_is_team_color_allowed:      libmap.            (line 27344)
* lw6map_exp_is_weapon_allowed:          libmap.            (line 27356)
* lw6map_free:                           libmap.            (line 27490)
* lw6map_from_hexa:                      libmap.            (line 27399)
* lw6map_get_max_nb_colors:              libmap.            (line 27541)
* lw6map_get_max_nb_cursors:             libmap.            (line 27551)
* lw6map_get_max_nb_nodes:               libmap.            (line 27563)
* lw6map_get_title:                      libmap.            (line 27530)
* lw6map_is_same:                        libmap.            (line 27517)
* lw6map_layer_builtin_custom:           libmap.            (line 27410)
* lw6map_layer_clear:                    libmap.            (line 27426)
* lw6map_local_info_clear:               libmap.            (line 27589)
* lw6map_local_info_set_music_dir:       libmap.            (line 27575)
* lw6map_memory_footprint:               libmap.            (line 27498)
* lw6map_metadata_clear:                 libmap.            (line 27612)
* lw6map_metadata_defaults:              libmap.            (line 27600)
* lw6map_metadata_is_same:               libmap.            (line 27623)
* lw6map_meta_layer_builtin_custom:      libmap.            (line 27679)
* lw6map_meta_layer_clear:               libmap.            (line 27668)
* lw6map_meta_layer_get:                 libmap.            (line 27653)
* lw6map_meta_layer_set:                 libmap.            (line 27636)
* lw6map_new:                            libmap.            (line 27437)
* lw6map_param_clear:                    libmap.            (line 27724)
* lw6map_param_copy:                     libmap.            (line 27736)
* lw6map_param_defaults:                 libmap.            (line 27713)
* lw6map_param_get:                      libmap.            (line 27766)
* lw6map_param_is_same:                  libmap.            (line 27781)
* lw6map_param_set:                      libmap.            (line 27749)
* lw6map_param_zero:                     libmap.            (line 27702)
* lw6map_repr:                           libmap.            (line 27506)
* lw6map_rules_clear:                    libmap.            (line 27936)
* lw6map_rules_copy:                     libmap.            (line 27816)
* lw6map_rules_defaults:                 libmap.            (line 27805)
* lw6map_rules_get_bool:                 libmap.            (line 27908)
* lw6map_rules_get_default:              libmap.            (line 27842)
* lw6map_rules_get_int:                  libmap.            (line 27878)
* lw6map_rules_get_max:                  libmap.            (line 27866)
* lw6map_rules_get_min:                  libmap.            (line 27854)
* lw6map_rules_is_same:                  libmap.            (line 27947)
* lw6map_rules_sanity_check:             libmap.            (line 27960)
* lw6map_rules_set_bool:                 libmap.            (line 27922)
* lw6map_rules_set_int:                  libmap.            (line 27892)
* lw6map_rules_update_checksum:          libmap.            (line 27829)
* lw6map_rules_zero:                     libmap.            (line 27794)
* lw6map_style_clear:                    libmap.            (line 27993)
* lw6map_style_copy:                     libmap.            (line 28005)
* lw6map_style_defaults:                 libmap.            (line 27981)
* lw6map_style_get:                      libmap.            (line 28034)
* lw6map_style_get_default:              libmap.            (line 28048)
* lw6map_style_is_same:                  libmap.            (line 28074)
* lw6map_style_set:                      libmap.            (line 28019)
* lw6map_style_zero:                     libmap.            (line 27970)
* lw6map_teams_clear:                    libmap.            (line 28109)
* lw6map_teams_copy:                     libmap.            (line 28122)
* lw6map_teams_defaults:                 libmap.            (line 28099)
* lw6map_teams_get:                      libmap.            (line 28153)
* lw6map_teams_get_default:              libmap.            (line 28166)
* lw6map_teams_is_same:                  libmap.            (line 28176)
* lw6map_teams_set:                      libmap.            (line 28135)
* lw6map_teams_zero:                     libmap.            (line 28088)
* lw6map_team_color_index_to_key:        libmap.            (line 27192)
* lw6map_team_color_index_to_label:      libmap.            (line 27213)
* lw6map_team_color_key_to_index:        libmap.            (line 27203)
* lw6map_test_register:                  libmap.            (line 28189)
* lw6map_test_run:                       libmap.            (line 28199)
* lw6map_texture_clear:                  libmap.            (line 28227)
* lw6map_texture_coord_from_body:        libmap.            (line 28238)
* lw6map_texture_from_body:              libmap.            (line 28210)
* lw6map_texture_get_with_body_coord:    libmap.            (line 28257)
* lw6map_texture_has_alpha:              libmap.            (line 28273)
* lw6map_to_hexa:                        libmap.            (line 27388)
* lw6map_weapon_index_to_key:            libmap.            (line 28287)
* lw6map_weapon_index_to_label:          libmap.            (line 28308)
* lw6map_weapon_key_to_index:            libmap.            (line 28298)
* lw6mat_dmat2_det:                      libmat.            (line 29559)
* lw6mat_dmat2_identity:                 libmat.            (line 29513)
* lw6mat_dmat2_inv:                      libmat.            (line 29576)
* lw6mat_dmat2_is_same:                  libmat.            (line 29542)
* lw6mat_dmat2_mul_dmat2:                libmat.            (line 29591)
* lw6mat_dmat2_mul_dvec2:                libmat.            (line 29603)
* lw6mat_dmat2_mul_scale:                libmat.            (line 29566)
* lw6mat_dmat2_repr:                     libmat.            (line 29619)
* lw6mat_dmat2_scale:                    libmat.            (line 29532)
* lw6mat_dmat2_translation:              libmat.            (line 29521)
* lw6mat_dmat2_transpose:                libmat.            (line 29552)
* lw6mat_dmat2_zero:                     libmat.            (line 29504)
* lw6mat_dmat3_det:                      libmat.            (line 29695)
* lw6mat_dmat3_identity:                 libmat.            (line 29637)
* lw6mat_dmat3_inv:                      libmat.            (line 29712)
* lw6mat_dmat3_is_same:                  libmat.            (line 29678)
* lw6mat_dmat3_mul_dmat3:                libmat.            (line 29727)
* lw6mat_dmat3_mul_dvec2:                libmat.            (line 29755)
* lw6mat_dmat3_mul_dvec3:                libmat.            (line 29739)
* lw6mat_dmat3_mul_scale:                libmat.            (line 29702)
* lw6mat_dmat3_repr:                     libmat.            (line 29771)
* lw6mat_dmat3_rot:                      libmat.            (line 29667)
* lw6mat_dmat3_scale:                    libmat.            (line 29656)
* lw6mat_dmat3_translation:              libmat.            (line 29645)
* lw6mat_dmat3_transpose:                libmat.            (line 29688)
* lw6mat_dmat3_zero:                     libmat.            (line 29628)
* lw6mat_dmat4_det:                      libmat.            (line 29917)
* lw6mat_dmat4_identity:                 libmat.            (line 29789)
* lw6mat_dmat4_inv:                      libmat.            (line 29934)
* lw6mat_dmat4_is_same:                  libmat.            (line 29900)
* lw6mat_dmat4_mul_dmat4:                libmat.            (line 29949)
* lw6mat_dmat4_mul_dvec3:                libmat.            (line 29979)
* lw6mat_dmat4_mul_dvec4:                libmat.            (line 29961)
* lw6mat_dmat4_mul_scale:                libmat.            (line 29924)
* lw6mat_dmat4_ortho:                    libmat.            (line 29849)
* lw6mat_dmat4_perspective:              libmat.            (line 29881)
* lw6mat_dmat4_repr:                     libmat.            (line 29999)
* lw6mat_dmat4_rot_x:                    libmat.            (line 29819)
* lw6mat_dmat4_rot_y:                    libmat.            (line 29829)
* lw6mat_dmat4_rot_z:                    libmat.            (line 29839)
* lw6mat_dmat4_scale:                    libmat.            (line 29808)
* lw6mat_dmat4_translation:              libmat.            (line 29797)
* lw6mat_dmat4_transpose:                libmat.            (line 29910)
* lw6mat_dmat4_zero:                     libmat.            (line 29780)
* lw6mat_dvec2_add:                      libmat.            (line 30075)
* lw6mat_dvec2_cross:                    libmat.            (line 30109)
* lw6mat_dvec2_dot:                      libmat.            (line 30099)
* lw6mat_dvec2_homogeneous:              libmat.            (line 30056)
* lw6mat_dvec2_is_same:                  libmat.            (line 30017)
* lw6mat_dvec2_len:                      libmat.            (line 30037)
* lw6mat_dvec2_len_sq:                   libmat.            (line 30027)
* lw6mat_dvec2_mul_dvec2:                libmat.            (line 30134)
* lw6mat_dvec2_mul_scale:                libmat.            (line 30124)
* lw6mat_dvec2_neg:                      libmat.            (line 30068)
* lw6mat_dvec2_normalize:                libmat.            (line 30045)
* lw6mat_dvec2_repr:                     libmat.            (line 30146)
* lw6mat_dvec2_sub:                      libmat.            (line 30087)
* lw6mat_dvec2_zero:                     libmat.            (line 30008)
* lw6mat_dvec3_add:                      libmat.            (line 30221)
* lw6mat_dvec3_cross:                    libmat.            (line 30255)
* lw6mat_dvec3_dot:                      libmat.            (line 30245)
* lw6mat_dvec3_homogeneous:              libmat.            (line 30202)
* lw6mat_dvec3_is_same:                  libmat.            (line 30163)
* lw6mat_dvec3_len:                      libmat.            (line 30183)
* lw6mat_dvec3_len_sq:                   libmat.            (line 30173)
* lw6mat_dvec3_mul_dvec3:                libmat.            (line 30277)
* lw6mat_dvec3_mul_scale:                libmat.            (line 30267)
* lw6mat_dvec3_neg:                      libmat.            (line 30214)
* lw6mat_dvec3_normalize:                libmat.            (line 30191)
* lw6mat_dvec3_repr:                     libmat.            (line 30289)
* lw6mat_dvec3_sub:                      libmat.            (line 30233)
* lw6mat_dvec3_zero:                     libmat.            (line 30154)
* lw6mat_dvec4_add:                      libmat.            (line 30364)
* lw6mat_dvec4_cross:                    libmat.            (line 30398)
* lw6mat_dvec4_dot:                      libmat.            (line 30388)
* lw6mat_dvec4_homogeneous:              libmat.            (line 30345)
* lw6mat_dvec4_is_same:                  libmat.            (line 30306)
* lw6mat_dvec4_len:                      libmat.            (line 30326)
* lw6mat_dvec4_len_sq:                   libmat.            (line 30316)
* lw6mat_dvec4_mul_dvec4:                libmat.            (line 30423)
* lw6mat_dvec4_mul_scale:                libmat.            (line 30413)
* lw6mat_dvec4_neg:                      libmat.            (line 30357)
* lw6mat_dvec4_normalize:                libmat.            (line 30334)
* lw6mat_dvec4_repr:                     libmat.            (line 30435)
* lw6mat_dvec4_sub:                      libmat.            (line 30376)
* lw6mat_dvec4_zero:                     libmat.            (line 30297)
* lw6mat_fmat2_det:                      libmat.            (line 30498)
* lw6mat_fmat2_identity:                 libmat.            (line 30452)
* lw6mat_fmat2_inv:                      libmat.            (line 30515)
* lw6mat_fmat2_is_same:                  libmat.            (line 30481)
* lw6mat_fmat2_mul_fmat2:                libmat.            (line 30530)
* lw6mat_fmat2_mul_fvec2:                libmat.            (line 30542)
* lw6mat_fmat2_mul_scale:                libmat.            (line 30505)
* lw6mat_fmat2_repr:                     libmat.            (line 30558)
* lw6mat_fmat2_scale:                    libmat.            (line 30471)
* lw6mat_fmat2_translation:              libmat.            (line 30460)
* lw6mat_fmat2_transpose:                libmat.            (line 30491)
* lw6mat_fmat2_zero:                     libmat.            (line 30443)
* lw6mat_fmat3_det:                      libmat.            (line 30634)
* lw6mat_fmat3_identity:                 libmat.            (line 30576)
* lw6mat_fmat3_inv:                      libmat.            (line 30651)
* lw6mat_fmat3_is_same:                  libmat.            (line 30617)
* lw6mat_fmat3_mul_fmat3:                libmat.            (line 30666)
* lw6mat_fmat3_mul_fvec2:                libmat.            (line 30694)
* lw6mat_fmat3_mul_fvec3:                libmat.            (line 30678)
* lw6mat_fmat3_mul_scale:                libmat.            (line 30641)
* lw6mat_fmat3_repr:                     libmat.            (line 30710)
* lw6mat_fmat3_rot:                      libmat.            (line 30606)
* lw6mat_fmat3_scale:                    libmat.            (line 30595)
* lw6mat_fmat3_translation:              libmat.            (line 30584)
* lw6mat_fmat3_transpose:                libmat.            (line 30627)
* lw6mat_fmat3_zero:                     libmat.            (line 30567)
* lw6mat_fmat4_det:                      libmat.            (line 30856)
* lw6mat_fmat4_identity:                 libmat.            (line 30728)
* lw6mat_fmat4_inv:                      libmat.            (line 30873)
* lw6mat_fmat4_is_same:                  libmat.            (line 30839)
* lw6mat_fmat4_mul_fmat4:                libmat.            (line 30888)
* lw6mat_fmat4_mul_fvec3:                libmat.            (line 30918)
* lw6mat_fmat4_mul_fvec4:                libmat.            (line 30900)
* lw6mat_fmat4_mul_scale:                libmat.            (line 30863)
* lw6mat_fmat4_ortho:                    libmat.            (line 30788)
* lw6mat_fmat4_perspective:              libmat.            (line 30820)
* lw6mat_fmat4_repr:                     libmat.            (line 30938)
* lw6mat_fmat4_rot_x:                    libmat.            (line 30758)
* lw6mat_fmat4_rot_y:                    libmat.            (line 30768)
* lw6mat_fmat4_rot_z:                    libmat.            (line 30778)
* lw6mat_fmat4_scale:                    libmat.            (line 30747)
* lw6mat_fmat4_translation:              libmat.            (line 30736)
* lw6mat_fmat4_transpose:                libmat.            (line 30849)
* lw6mat_fmat4_zero:                     libmat.            (line 30719)
* lw6mat_fvec2_add:                      libmat.            (line 31014)
* lw6mat_fvec2_cross:                    libmat.            (line 31048)
* lw6mat_fvec2_dot:                      libmat.            (line 31038)
* lw6mat_fvec2_homogeneous:              libmat.            (line 30995)
* lw6mat_fvec2_is_same:                  libmat.            (line 30956)
* lw6mat_fvec2_len:                      libmat.            (line 30976)
* lw6mat_fvec2_len_sq:                   libmat.            (line 30966)
* lw6mat_fvec2_mul_fvec2:                libmat.            (line 31073)
* lw6mat_fvec2_mul_scale:                libmat.            (line 31063)
* lw6mat_fvec2_neg:                      libmat.            (line 31007)
* lw6mat_fvec2_normalize:                libmat.            (line 30984)
* lw6mat_fvec2_repr:                     libmat.            (line 31085)
* lw6mat_fvec2_sub:                      libmat.            (line 31026)
* lw6mat_fvec2_zero:                     libmat.            (line 30947)
* lw6mat_fvec3_add:                      libmat.            (line 31160)
* lw6mat_fvec3_cross:                    libmat.            (line 31194)
* lw6mat_fvec3_dot:                      libmat.            (line 31184)
* lw6mat_fvec3_homogeneous:              libmat.            (line 31141)
* lw6mat_fvec3_is_same:                  libmat.            (line 31102)
* lw6mat_fvec3_len:                      libmat.            (line 31122)
* lw6mat_fvec3_len_sq:                   libmat.            (line 31112)
* lw6mat_fvec3_mul_fvec3:                libmat.            (line 31216)
* lw6mat_fvec3_mul_scale:                libmat.            (line 31206)
* lw6mat_fvec3_neg:                      libmat.            (line 31153)
* lw6mat_fvec3_normalize:                libmat.            (line 31130)
* lw6mat_fvec3_repr:                     libmat.            (line 31228)
* lw6mat_fvec3_sub:                      libmat.            (line 31172)
* lw6mat_fvec3_zero:                     libmat.            (line 31093)
* lw6mat_fvec4_add:                      libmat.            (line 31303)
* lw6mat_fvec4_cross:                    libmat.            (line 31337)
* lw6mat_fvec4_dot:                      libmat.            (line 31327)
* lw6mat_fvec4_homogeneous:              libmat.            (line 31284)
* lw6mat_fvec4_is_same:                  libmat.            (line 31245)
* lw6mat_fvec4_len:                      libmat.            (line 31265)
* lw6mat_fvec4_len_sq:                   libmat.            (line 31255)
* lw6mat_fvec4_mul_fvec4:                libmat.            (line 31362)
* lw6mat_fvec4_mul_scale:                libmat.            (line 31352)
* lw6mat_fvec4_neg:                      libmat.            (line 31296)
* lw6mat_fvec4_normalize:                libmat.            (line 31273)
* lw6mat_fvec4_repr:                     libmat.            (line 31374)
* lw6mat_fvec4_sub:                      libmat.            (line 31315)
* lw6mat_fvec4_zero:                     libmat.            (line 31236)
* lw6mat_is_similar_d:                   libmat.            (line 31408)
* lw6mat_is_similar_f:                   libmat.            (line 31382)
* lw6mat_is_similar_i:                   libmat.            (line 31395)
* lw6mat_is_similar_x:                   libmat.            (line 31421)
* lw6mat_test_register:                  libmat.            (line 31434)
* lw6mat_test_run:                       libmat.            (line 31444)
* lw6msg_cmd_analyse_bar:                libmsg.            (line 32834)
* lw6msg_cmd_analyse_data:               libmsg.            (line 32883)
* lw6msg_cmd_analyse_foo:                libmsg.            (line 32817)
* lw6msg_cmd_analyse_goodbye:            libmsg.            (line 32871)
* lw6msg_cmd_analyse_hello:              libmsg.            (line 32790)
* lw6msg_cmd_analyse_join:               libmsg.            (line 32851)
* lw6msg_cmd_analyse_meta:               libmsg.            (line 32904)
* lw6msg_cmd_analyse_miss:               libmsg.            (line 32925)
* lw6msg_cmd_analyse_ticket:             libmsg.            (line 32802)
* lw6msg_cmd_generate_bar:               libmsg.            (line 32684)
* lw6msg_cmd_generate_data:              libmsg.            (line 32729)
* lw6msg_cmd_generate_foo:               libmsg.            (line 32670)
* lw6msg_cmd_generate_goodbye:           libmsg.            (line 32719)
* lw6msg_cmd_generate_hello:             libmsg.            (line 32648)
* lw6msg_cmd_generate_join:              libmsg.            (line 32698)
* lw6msg_cmd_generate_meta:              libmsg.            (line 32750)
* lw6msg_cmd_generate_miss:              libmsg.            (line 32771)
* lw6msg_cmd_generate_ticket:            libmsg.            (line 32658)
* lw6msg_cmd_guess_from_url:             libmsg.            (line 32948)
* lw6msg_envelope_analyse:               libmsg.            (line 32994)
* lw6msg_envelope_generate:              libmsg.            (line 32958)
* lw6msg_meta_array2str:                 libmsg.            (line 33125)
* lw6msg_meta_array_exists:              libmsg.            (line 33067)
* lw6msg_meta_array_find:                libmsg.            (line 33053)
* lw6msg_meta_array_set:                 libmsg.            (line 33081)
* lw6msg_meta_array_unset:               libmsg.            (line 33099)
* lw6msg_meta_array_zero:                libmsg.            (line 33043)
* lw6msg_meta_str2array:                 libmsg.            (line 33112)
* lw6msg_oob_analyse_pong:               libmsg.            (line 33223)
* lw6msg_oob_analyse_request:            libmsg.            (line 33197)
* lw6msg_oob_generate_info:              libmsg.            (line 33137)
* lw6msg_oob_generate_list:              libmsg.            (line 33150)
* lw6msg_oob_generate_pong:              libmsg.            (line 33165)
* lw6msg_oob_generate_request:           libmsg.            (line 33178)
* lw6msg_sort_str_by_seq_callback:       libmsg.            (line 33235)
* lw6msg_test_register:                  libmsg.            (line 33252)
* lw6msg_test_run:                       libmsg.            (line 33262)
* lw6msg_ticket_calc_sig:                libmsg.            (line 33273)
* lw6msg_ticket_check_sig:               libmsg.            (line 33293)
* lw6msg_utils_get_assoc_int_with_default: libmsg.          (line 33363)
* lw6msg_utils_get_assoc_str_with_default: libmsg.          (line 33345)
* lw6msg_utils_parse_key_value_to_assoc: libmsg.            (line 33328)
* lw6msg_utils_parse_key_value_to_ptr:   libmsg.            (line 33312)
* lw6msg_word_first:                     libmsg.            (line 33382)
* lw6msg_word_first_base64:              libmsg.            (line 33420)
* lw6msg_word_first_id_16:               libmsg.            (line 33540)
* lw6msg_word_first_id_32:               libmsg.            (line 33557)
* lw6msg_word_first_id_64:               libmsg.            (line 33574)
* lw6msg_word_first_int_32:              libmsg.            (line 33440)
* lw6msg_word_first_int_32_ge0:          libmsg.            (line 33456)
* lw6msg_word_first_int_32_gt0:          libmsg.            (line 33473)
* lw6msg_word_first_int_64:              libmsg.            (line 33490)
* lw6msg_word_first_int_64_ge0:          libmsg.            (line 33506)
* lw6msg_word_first_int_64_gt0:          libmsg.            (line 33523)
* lw6msg_word_first_x:                   libmsg.            (line 33399)
* lw6msg_z_decode:                       libmsg.            (line 33610)
* lw6msg_z_encode:                       libmsg.            (line 33591)
* lw6net_dns_gethostbyname:              libnet.            (line 33734)
* lw6net_dns_is_ip:                      libnet.            (line 33724)
* lw6net_dns_lock:                       libnet.            (line 33744)
* lw6net_dns_unlock:                     libnet.            (line 33756)
* lw6net_if_guess_local:                 libnet.            (line 33773)
* lw6net_if_guess_public_url:            libnet.            (line 33787)
* lw6net_init:                           libnet.            (line 33899)
* lw6net_is_connectable:                 libnet.            (line 33689)
* lw6net_last_error:                     libnet.            (line 33763)
* lw6net_quit:                           libnet.            (line 33915)
* lw6net_recv_lines_udp:                 libnet.            (line 33857)
* lw6net_recv_line_tcp:                  libnet.            (line 33804)
* lw6net_recv_line_udp:                  libnet.            (line 33835)
* lw6net_send_line_tcp:                  libnet.            (line 33820)
* lw6net_send_line_udp:                  libnet.            (line 33881)
* lw6net_set_connectable:                libnet.            (line 33704)
* lw6net_socket_close:                   libnet.            (line 33949)
* lw6net_socket_is_valid:                libnet.            (line 33936)
* lw6net_socket_set_blocking_mode:       libnet.            (line 33923)
* lw6net_tcp_accept:                     libnet.            (line 33975)
* lw6net_tcp_connect:                    libnet.            (line 33993)
* lw6net_tcp_is_alive:                   libnet.            (line 34068)
* lw6net_tcp_listen:                     libnet.            (line 33963)
* lw6net_tcp_peek:                       libnet.            (line 34028)
* lw6net_tcp_recv:                       libnet.            (line 34047)
* lw6net_tcp_send:                       libnet.            (line 34007)
* lw6net_test_register:                  libnet.            (line 34080)
* lw6net_test_run:                       libnet.            (line 34090)
* lw6net_udp_client:                     libnet.            (line 34101)
* lw6net_udp_peek:                       libnet.            (line 34143)
* lw6net_udp_recv:                       libnet.            (line 34158)
* lw6net_udp_send:                       libnet.            (line 34122)
* lw6net_udp_server:                     libnet.            (line 34109)
* lw6nod_dyn_info_free:                  libnod.            (line 34378)
* lw6nod_info_add_discovered_node:       libnod.            (line 34545)
* lw6nod_info_community_add:             libnod.            (line 34186)
* lw6nod_info_community_count:           libnod.            (line 34312)
* lw6nod_info_community_get_id_from_url: libnod.            (line 34262)
* lw6nod_info_community_get_peer_id_list_str: libnod.       (line 34337)
* lw6nod_info_community_get_url_from_id: libnod.            (line 34275)
* lw6nod_info_community_has_id:          libnod.            (line 34222)
* lw6nod_info_community_has_id_without_url: libnod.         (line 34235)
* lw6nod_info_community_has_url:         libnod.            (line 34249)
* lw6nod_info_community_id_without_url_map: libnod.         (line 34362)
* lw6nod_info_community_is_member:       libnod.            (line 34201)
* lw6nod_info_community_remove_by_id:    libnod.            (line 34288)
* lw6nod_info_community_remove_by_url:   libnod.            (line 34300)
* lw6nod_info_community_reset:           libnod.            (line 34327)
* lw6nod_info_community_set_peer_id_list_str: libnod.       (line 34347)
* lw6nod_info_dup_dyn:                   libnod.            (line 34522)
* lw6nod_info_free:                      libnod.            (line 34434)
* lw6nod_info_idle:                      libnod.            (line 34466)
* lw6nod_info_lock:                      libnod.            (line 34444)
* lw6nod_info_map_verified_nodes:        libnod.            (line 34600)
* lw6nod_info_new:                       libnod.            (line 34389)
* lw6nod_info_new_discovered_nodes:      libnod.            (line 34534)
* lw6nod_info_new_verified_nodes:        libnod.            (line 34572)
* lw6nod_info_pop_discovered_nodes:      libnod.            (line 34561)
* lw6nod_info_set_verified_nodes:        libnod.            (line 34582)
* lw6nod_info_unlock:                    libnod.            (line 34455)
* lw6nod_info_update:                    libnod.            (line 34478)
* lw6nod_test_register:                  libnod.            (line 34618)
* lw6nod_test_run:                       libnod.            (line 34628)
* lw6p2p_db_close:                       libp2p.            (line 34964)
* lw6p2p_db_default_name:                libp2p.            (line 34999)
* lw6p2p_db_open:                        libp2p.            (line 34946)
* lw6p2p_db_repr:                        libp2p.            (line 34974)
* lw6p2p_db_reset:                       libp2p.            (line 34984)
* lw6p2p_entry_free:                     libp2p.            (line 35109)
* lw6p2p_entry_new:                      libp2p.            (line 35042)
* lw6p2p_entry_repr:                     libp2p.            (line 35119)
* lw6p2p_node_calibrate:                 libp2p.            (line 35349)
* lw6p2p_node_client_join:               libp2p.            (line 35266)
* lw6p2p_node_close:                     libp2p.            (line 35213)
* lw6p2p_node_disconnect:                libp2p.            (line 35302)
* lw6p2p_node_free:                      libp2p.            (line 35180)
* lw6p2p_node_get_entries:               libp2p.            (line 35237)
* lw6p2p_node_get_id:                    libp2p.            (line 35226)
* lw6p2p_node_get_local_seq_0:           libp2p.            (line 35365)
* lw6p2p_node_get_local_seq_last:        libp2p.            (line 35377)
* lw6p2p_node_get_next_draft_msg:        libp2p.            (line 35528)
* lw6p2p_node_get_next_reference_msg:    libp2p.            (line 35513)
* lw6p2p_node_get_seq_draft:             libp2p.            (line 35415)
* lw6p2p_node_get_seq_max:               libp2p.            (line 35403)
* lw6p2p_node_get_seq_min:               libp2p.            (line 35391)
* lw6p2p_node_get_seq_reference:         libp2p.            (line 35428)
* lw6p2p_node_is_dump_needed:            libp2p.            (line 35486)
* lw6p2p_node_is_peer_connected:         libp2p.            (line 35441)
* lw6p2p_node_is_peer_registered:        libp2p.            (line 35456)
* lw6p2p_node_is_seed_needed:            libp2p.            (line 35472)
* lw6p2p_node_new:                       libp2p.            (line 35129)
* lw6p2p_node_poll:                      libp2p.            (line 35200)
* lw6p2p_node_put_local_msg:             libp2p.            (line 35500)
* lw6p2p_node_refresh_peer:              libp2p.            (line 35285)
* lw6p2p_node_repr:                      libp2p.            (line 35190)
* lw6p2p_node_server_start:              libp2p.            (line 35253)
* lw6p2p_node_update_info:               libp2p.            (line 35314)
* lw6p2p_test_register:                  libp2p.            (line 35543)
* lw6p2p_test_run:                       libp2p.            (line 35553)
* lw6pil_bench:                          libpil.            (line 35796)
* lw6pil_command_dup:                    libpil.            (line 35831)
* lw6pil_command_execute:                libpil.            (line 35861)
* lw6pil_command_execute_local:          libpil.            (line 35905)
* lw6pil_command_execute_local_text:     libpil.            (line 35919)
* lw6pil_command_execute_text:           libpil.            (line 35881)
* lw6pil_command_free:                   libpil.            (line 35841)
* lw6pil_command_new:                    libpil.            (line 35814)
* lw6pil_command_repr:                   libpil.            (line 35851)
* lw6pil_coords_fix:                     libpil.            (line 35933)
* lw6pil_coords_fix_x10:                 libpil.            (line 35954)
* lw6pil_dump_clear:                     libpil.            (line 35985)
* lw6pil_dump_command_execute:           libpil.            (line 36027)
* lw6pil_dump_command_generate:          libpil.            (line 36007)
* lw6pil_dump_exists:                    libpil.            (line 35996)
* lw6pil_dump_zero:                      libpil.            (line 35975)
* lw6pil_local_cursors_get_cursor:       libpil.            (line 36061)
* lw6pil_local_cursors_get_info:         libpil.            (line 36075)
* lw6pil_local_cursors_get_main_info:    libpil.            (line 36132)
* lw6pil_local_cursors_reset:            libpil.            (line 36048)
* lw6pil_local_cursors_set_main:         libpil.            (line 36154)
* lw6pil_local_cursors_set_mouse_controlled: libpil.        (line 36114)
* lw6pil_local_cursors_set_xy:           libpil.            (line 36095)
* lw6pil_nopilot_poll_dump:              libpil.            (line 36170)
* lw6pil_pilot_calibrate:                libpil.            (line 36379)
* lw6pil_pilot_can_sync:                 libpil.            (line 36285)
* lw6pil_pilot_checksum_log_set_interval: libpil.           (line 36591)
* lw6pil_pilot_commit:                   libpil.            (line 36259)
* lw6pil_pilot_did_cursor_win:           libpil.            (line 36547)
* lw6pil_pilot_dirty_read:               libpil.            (line 36356)
* lw6pil_pilot_free:                     libpil.            (line 36211)
* lw6pil_pilot_get_last_commit_seq:      libpil.            (line 36486)
* lw6pil_pilot_get_local_cursors:        libpil.            (line 36580)
* lw6pil_pilot_get_looser:               libpil.            (line 36570)
* lw6pil_pilot_get_max_seq:              libpil.            (line 36525)
* lw6pil_pilot_get_next_seq:             libpil.            (line 36473)
* lw6pil_pilot_get_reference_current_seq: libpil.           (line 36512)
* lw6pil_pilot_get_reference_target_seq: libpil.            (line 36497)
* lw6pil_pilot_get_round_0:              libpil.            (line 36421)
* lw6pil_pilot_get_seq_0:                libpil.            (line 36432)
* lw6pil_pilot_get_winner:               libpil.            (line 36560)
* lw6pil_pilot_is_over:                  libpil.            (line 36537)
* lw6pil_pilot_local_command:            libpil.            (line 36237)
* lw6pil_pilot_make_backup:              libpil.            (line 36274)
* lw6pil_pilot_new:                      libpil.            (line 36190)
* lw6pil_pilot_repr:                     libpil.            (line 36368)
* lw6pil_pilot_round2seq:                libpil.            (line 36458)
* lw6pil_pilot_send_command:             libpil.            (line 36222)
* lw6pil_pilot_seq2round:                libpil.            (line 36443)
* lw6pil_pilot_slow_down:                libpil.            (line 36408)
* lw6pil_pilot_speed_up:                 libpil.            (line 36395)
* lw6pil_pilot_sync_from_backup:         libpil.            (line 36299)
* lw6pil_pilot_sync_from_draft:          libpil.            (line 36331)
* lw6pil_pilot_sync_from_reference:      libpil.            (line 36314)
* lw6pil_seed_command_generate:          libpil.            (line 36609)
* lw6pil_seq_random_0:                   libpil.            (line 36626)
* lw6pil_suite_get_checkpoint:           libpil.            (line 36710)
* lw6pil_suite_get_command_by_node_index: libpil.           (line 36671)
* lw6pil_suite_get_command_by_stage:     libpil.            (line 36686)
* lw6pil_suite_get_command_by_step:      libpil.            (line 36699)
* lw6pil_suite_get_node_id:              libpil.            (line 36659)
* lw6pil_suite_get_seq_0:                libpil.            (line 36651)
* lw6pil_suite_init:                     libpil.            (line 36637)
* lw6pil_test_register:                  libpil.            (line 36729)
* lw6pil_test_run:                       libpil.            (line 36739)
* lw6scm_coverage_call:                  libscm.            (line 37178)
* lw6scm_coverage_check:                 libscm.            (line 37201)
* lw6scm_coverage_log:                   libscm.            (line 37190)
* lw6scm_coverage_new:                   libscm.            (line 37164)
* lw6scm_c_define_gsubr:                 libscm.            (line 37333)
* lw6scm_c_primitive_load:               libscm.            (line 37355)
* lw6scm_funcname_c2scm:                 libscm.            (line 37232)
* lw6scm_funcname_scm2c:                 libscm.            (line 37222)
* lw6scm_gettext:                        libscm.            (line 37242)
* lw6scm_test_register:                  libscm.            (line 37254)
* lw6scm_test_run:                       libscm.            (line 37264)
* lw6scm_utils_to_0str:                  libscm.            (line 37275)
* lw6scm_utils_to_scm_str_assoc:         libscm.            (line 37298)
* lw6scm_utils_to_scm_str_list:          libscm.            (line 37287)
* lw6scm_utils_to_sys_str_assoc:         libscm.            (line 37321)
* lw6scm_utils_to_sys_str_list:          libscm.            (line 37309)
* lw6scm_with_guile:                     libscm.            (line 37366)
* lw6sim_print:                          libsim.            (line 37391)
* lw6sim_results_update_percents:        libsim.            (line 37413)
* lw6sim_results_zero:                   libsim.            (line 37403)
* lw6sim_simulate:                       libsim.            (line 37423)
* lw6sim_simulate_basic:                 libsim.            (line 37445)
* lw6sim_simulate_full:                  libsim.            (line 37461)
* lw6sim_test_register:                  libsim.            (line 37477)
* lw6sim_test_run:                       libsim.            (line 37487)
* lw6snd_create_backend:                 libsnd.            (line 37721)
* lw6snd_destroy_backend:                libsnd.            (line 37739)
* lw6snd_get_backends:                   libsnd.            (line 37704)
* lw6snd_init:                           libsnd.            (line 37617)
* lw6snd_is_music_file:                  libsnd.            (line 37553)
* lw6snd_play_fx:                        libsnd.            (line 37541)
* lw6snd_play_music_file:                libsnd.            (line 37572)
* lw6snd_play_music_random:              libsnd.            (line 37587)
* lw6snd_poll:                           libsnd.            (line 37673)
* lw6snd_quit:                           libsnd.            (line 37683)
* lw6snd_repr:                           libsnd.            (line 37694)
* lw6snd_set_fx_volume:                  libsnd.            (line 37637)
* lw6snd_set_music_volume:               libsnd.            (line 37661)
* lw6snd_set_water_volume:               libsnd.            (line 37649)
* lw6snd_stop_music:                     libsnd.            (line 37607)
* lw6snd_test_register:                  libsnd.            (line 37750)
* lw6snd_test_run:                       libsnd.            (line 37760)
* lw6srv_analyse_tcp:                    libsrv.            (line 38051)
* lw6srv_analyse_udp:                    libsrv.            (line 38074)
* lw6srv_can_send:                       libsrv.            (line 38223)
* lw6srv_close:                          libsrv.            (line 38183)
* lw6srv_create_backend:                 libsrv.            (line 38340)
* lw6srv_default_backends:               libsrv.            (line 38315)
* lw6srv_destroy_backend:                libsrv.            (line 38358)
* lw6srv_feed_with_tcp:                  libsrv.            (line 38151)
* lw6srv_feed_with_udp:                  libsrv.            (line 38168)
* lw6srv_get_backends:                   libsrv.            (line 38323)
* lw6srv_init:                           libsrv.            (line 38030)
* lw6srv_oob_free:                       libsrv.            (line 38305)
* lw6srv_oob_new:                        libsrv.            (line 38285)
* lw6srv_open:                           libsrv.            (line 38112)
* lw6srv_poll:                           libsrv.            (line 38238)
* lw6srv_process_oob:                    libsrv.            (line 38097)
* lw6srv_quit:                           libsrv.            (line 38043)
* lw6srv_repr:                           libsrv.            (line 38250)
* lw6srv_send:                           libsrv.            (line 38195)
* lw6srv_start:                          libsrv.            (line 38262)
* lw6srv_stop:                           libsrv.            (line 38275)
* lw6srv_tcp_accepter_free:              libsrv.            (line 38382)
* lw6srv_tcp_accepter_new:               libsrv.            (line 38368)
* lw6srv_test_register:                  libsrv.            (line 38390)
* lw6srv_test_run:                       libsrv.            (line 38400)
* lw6srv_udp_buffer_free:                libsrv.            (line 38428)
* lw6srv_udp_buffer_new:                 libsrv.            (line 38411)
* lw6sys_arg_exists:                     libsys.            (line 39005)
* lw6sys_arg_get_value:                  libsys.            (line 39020)
* lw6sys_arg_get_value_with_env:         libsys.            (line 39035)
* lw6sys_arg_match:                      libsys.            (line 38982)
* lw6sys_arg_test_mode:                  libsys.            (line 39057)
* lw6sys_assoc_dup:                      libsys.            (line 39216)
* lw6sys_assoc_free:                     libsys.            (line 39091)
* lw6sys_assoc_get:                      libsys.            (line 39116)
* lw6sys_assoc_has_key:                  libsys.            (line 39102)
* lw6sys_assoc_keys:                     libsys.            (line 39165)
* lw6sys_assoc_map:                      libsys.            (line 39179)
* lw6sys_assoc_new:                      libsys.            (line 39072)
* lw6sys_assoc_set:                      libsys.            (line 39130)
* lw6sys_assoc_sort_and_map:             libsys.            (line 39198)
* lw6sys_assoc_unset:                    libsys.            (line 39151)
* lw6sys_atob:                           libsys.            (line 40687)
* lw6sys_atof:                           libsys.            (line 40699)
* lw6sys_atoi:                           libsys.            (line 40665)
* lw6sys_atoll:                          libsys.            (line 40676)
* lw6sys_backtrace:                      libsys.            (line 39233)
* lw6sys_btoa:                           libsys.            (line 40734)
* lw6sys_buf_sprintf:                    libsys.            (line 44204)
* lw6sys_build_get_abs_srcdir:           libsys.            (line 39747)
* lw6sys_build_get_bin_id:               libsys.            (line 39931)
* lw6sys_build_get_bugs_url:             libsys.            (line 39583)
* lw6sys_build_get_cflags:               libsys.            (line 39608)
* lw6sys_build_get_codename:             libsys.            (line 39484)
* lw6sys_build_get_configure_args:       libsys.            (line 39590)
* lw6sys_build_get_copyright:            libsys.            (line 39562)
* lw6sys_build_get_datadir:              libsys.            (line 39762)
* lw6sys_build_get_date:                 libsys.            (line 39636)
* lw6sys_build_get_docdir:               libsys.            (line 39805)
* lw6sys_build_get_enable_allinone:      libsys.            (line 39879)
* lw6sys_build_get_enable_console:       libsys.            (line 39813)
* lw6sys_build_get_enable_fullstatic:    libsys.            (line 39885)
* lw6sys_build_get_enable_gcov:          libsys.            (line 39918)
* lw6sys_build_get_enable_gprof:         libsys.            (line 39897)
* lw6sys_build_get_enable_gtk:           libsys.            (line 39819)
* lw6sys_build_get_enable_instrument:    libsys.            (line 39904)
* lw6sys_build_get_enable_mod_caca:      libsys.            (line 39843)
* lw6sys_build_get_enable_mod_csound:    libsys.            (line 39849)
* lw6sys_build_get_enable_mod_gl1:       libsys.            (line 39825)
* lw6sys_build_get_enable_mod_gles2:     libsys.            (line 39831)
* lw6sys_build_get_enable_mod_http:      libsys.            (line 39861)
* lw6sys_build_get_enable_mod_ogg:       libsys.            (line 39855)
* lw6sys_build_get_enable_mod_soft:      libsys.            (line 39837)
* lw6sys_build_get_enable_openmp:        libsys.            (line 39867)
* lw6sys_build_get_enable_optimize:      libsys.            (line 39873)
* lw6sys_build_get_enable_paranoid:      libsys.            (line 39891)
* lw6sys_build_get_enable_profiler:      libsys.            (line 39911)
* lw6sys_build_get_enable_valgrind:      libsys.            (line 39925)
* lw6sys_build_get_endianness:           libsys.            (line 39662)
* lw6sys_build_get_gcc_version:          libsys.            (line 39601)
* lw6sys_build_get_home_url:             libsys.            (line 39576)
* lw6sys_build_get_hostname:             libsys.            (line 39628)
* lw6sys_build_get_host_cpu:             libsys.            (line 39654)
* lw6sys_build_get_host_os:              libsys.            (line 39689)
* lw6sys_build_get_includedir:           libsys.            (line 39786)
* lw6sys_build_get_ldflags:              libsys.            (line 39617)
* lw6sys_build_get_libdir:               libsys.            (line 39774)
* lw6sys_build_get_license:              libsys.            (line 39569)
* lw6sys_build_get_localedir:            libsys.            (line 39796)
* lw6sys_build_get_md5sum:               libsys.            (line 39547)
* lw6sys_build_get_package_id:           libsys.            (line 39462)
* lw6sys_build_get_package_name:         libsys.            (line 39436)
* lw6sys_build_get_package_string:       libsys.            (line 39449)
* lw6sys_build_get_package_tarname:      libsys.            (line 39425)
* lw6sys_build_get_pointer_size:         libsys.            (line 39671)
* lw6sys_build_get_prefix:               libsys.            (line 39754)
* lw6sys_build_get_stamp:                libsys.            (line 39527)
* lw6sys_build_get_time:                 libsys.            (line 39645)
* lw6sys_build_get_top_srcdir:           libsys.            (line 39727)
* lw6sys_build_get_version:              libsys.            (line 39471)
* lw6sys_build_get_version_base:         libsys.            (line 39495)
* lw6sys_build_get_version_major:        libsys.            (line 39508)
* lw6sys_build_get_version_minor:        libsys.            (line 39518)
* lw6sys_build_is_amd64:                 libsys.            (line 39683)
* lw6sys_build_is_gnu:                   libsys.            (line 39696)
* lw6sys_build_is_gp2x:                  libsys.            (line 39721)
* lw6sys_build_is_mac_os_x:              libsys.            (line 39715)
* lw6sys_build_is_ms_windows:            libsys.            (line 39708)
* lw6sys_build_is_unix:                  libsys.            (line 39702)
* lw6sys_build_is_x86:                   libsys.            (line 39677)
* lw6sys_build_log_all:                  libsys.            (line 39940)
* lw6sys_cache_free:                     libsys.            (line 39972)
* lw6sys_cache_free_callback:            libsys.            (line 39983)
* lw6sys_cache_get:                      libsys.            (line 40011)
* lw6sys_cache_has_key:                  libsys.            (line 39997)
* lw6sys_cache_new:                      libsys.            (line 39949)
* lw6sys_cache_set:                      libsys.            (line 40029)
* lw6sys_cache_unset:                    libsys.            (line 40047)
* lw6sys_calloc:                         libsys.            (line 42647)
* lw6sys_checksum:                       libsys.            (line 40061)
* lw6sys_checksum_int32:                 libsys.            (line 40094)
* lw6sys_checksum_int64:                 libsys.            (line 40108)
* lw6sys_checksum_str:                   libsys.            (line 40082)
* lw6sys_checksum_update:                libsys.            (line 40145)
* lw6sys_checksum_update_int32:          libsys.            (line 40178)
* lw6sys_checksum_update_int64:          libsys.            (line 40193)
* lw6sys_checksum_update_str:            libsys.            (line 40163)
* lw6sys_checksum_update_whd:            libsys.            (line 40208)
* lw6sys_checksum_update_xyz:            libsys.            (line 40223)
* lw6sys_checksum_whd:                   libsys.            (line 40119)
* lw6sys_checksum_xyz:                   libsys.            (line 40132)
* lw6sys_check_id:                       libsys.            (line 41824)
* lw6sys_check_id_16:                    libsys.            (line 41794)
* lw6sys_check_id_32:                    libsys.            (line 41804)
* lw6sys_check_id_64:                    libsys.            (line 41814)
* lw6sys_check_mutex_count:              libsys.            (line 42887)
* lw6sys_check_thread_count:             libsys.            (line 44733)
* lw6sys_check_types_size:               libsys.            (line 42758)
* lw6sys_clear_file:                     libsys.            (line 41128)
* lw6sys_clear_memory_bazooka:           libsys.            (line 39264)
* lw6sys_color_8_solid:                  libsys.            (line 40596)
* lw6sys_color_8_to_a:                   libsys.            (line 40470)
* lw6sys_color_8_to_f:                   libsys.            (line 40263)
* lw6sys_color_8_to_iabgr:               libsys.            (line 40352)
* lw6sys_color_8_to_iargb:               libsys.            (line 40341)
* lw6sys_color_8_to_ibgra:               libsys.            (line 40330)
* lw6sys_color_8_to_irgba:               libsys.            (line 40319)
* lw6sys_color_average:                  libsys.            (line 40535)
* lw6sys_color_a_to_8:                   libsys.            (line 40443)
* lw6sys_color_a_to_f:                   libsys.            (line 40455)
* lw6sys_color_char2float:               libsys.            (line 40246)
* lw6sys_color_distance:                 libsys.            (line 40568)
* lw6sys_color_float2char:               libsys.            (line 40238)
* lw6sys_color_f_solid:                  libsys.            (line 40603)
* lw6sys_color_f_to_8:                   libsys.            (line 40254)
* lw6sys_color_f_to_iabgr:               libsys.            (line 40308)
* lw6sys_color_f_to_iargb:               libsys.            (line 40297)
* lw6sys_color_f_to_ibgra:               libsys.            (line 40286)
* lw6sys_color_f_to_irgba:               libsys.            (line 40275)
* lw6sys_color_hsv_invert:               libsys.            (line 40509)
* lw6sys_color_hsv_to_rgb:               libsys.            (line 40497)
* lw6sys_color_iabgr_to_8:               libsys.            (line 40434)
* lw6sys_color_iabgr_to_f:               libsys.            (line 40396)
* lw6sys_color_iargb_to_8:               libsys.            (line 40425)
* lw6sys_color_iargb_to_f:               libsys.            (line 40385)
* lw6sys_color_ibgra_to_8:               libsys.            (line 40416)
* lw6sys_color_ibgra_to_f:               libsys.            (line 40374)
* lw6sys_color_irgba_to_8:               libsys.            (line 40407)
* lw6sys_color_irgba_to_f:               libsys.            (line 40363)
* lw6sys_color_is_grey:                  libsys.            (line 40527)
* lw6sys_color_is_same:                  libsys.            (line 40584)
* lw6sys_color_ponderate:                libsys.            (line 40549)
* lw6sys_color_rgb_to_hsv:               libsys.            (line 40482)
* lw6sys_context_begin:                  libsys.            (line 40626)
* lw6sys_context_end:                    libsys.            (line 40636)
* lw6sys_context_free:                   libsys.            (line 40618)
* lw6sys_context_init:                   libsys.            (line 40648)
* lw6sys_context_new:                    libsys.            (line 40610)
* lw6sys_context_quit:                   libsys.            (line 40655)
* lw6sys_create_dir:                     libsys.            (line 43257)
* lw6sys_create_dir_silent:              libsys.            (line 43268)
* lw6sys_cunit_clear:                    libsys.            (line 40769)
* lw6sys_cunit_lock:                     libsys.            (line 40776)
* lw6sys_cunit_run_tests:                libsys.            (line 40758)
* lw6sys_cunit_unlock:                   libsys.            (line 40786)
* lw6sys_daemon_pid_file:                libsys.            (line 40796)
* lw6sys_daemon_start:                   libsys.            (line 40809)
* lw6sys_daemon_stop:                    libsys.            (line 40824)
* lw6sys_date_clf:                       libsys.            (line 44852)
* lw6sys_date_rfc1123:                   libsys.            (line 44841)
* lw6sys_debug_get:                      libsys.            (line 40835)
* lw6sys_debug_set:                      libsys.            (line 40840)
* lw6sys_default_memory_bazooka:         libsys.            (line 39254)
* lw6sys_delay:                          libsys.            (line 44805)
* lw6sys_dir_exists:                     libsys.            (line 43222)
* lw6sys_dir_exists_with_readme:         libsys.            (line 43232)
* lw6sys_dir_exists_with_readme_containing_text: libsys.    (line 43243)
* lw6sys_dir_list:                       libsys.            (line 43398)
* lw6sys_dump:                           libsys.            (line 40858)
* lw6sys_dump_clear:                     libsys.            (line 40848)
* lw6sys_env_concat:                     libsys.            (line 40890)
* lw6sys_env_exists_prefixed:            libsys.            (line 40903)
* lw6sys_env_separator_char:             libsys.            (line 40873)
* lw6sys_env_separator_str:              libsys.            (line 40881)
* lw6sys_env_split:                      libsys.            (line 40982)
* lw6sys_eol:                            libsys.            (line 44376)
* lw6sys_escape_html_attribute:          libsys.            (line 41046)
* lw6sys_escape_http_uri:                libsys.            (line 41028)
* lw6sys_escape_sql_value:               libsys.            (line 41058)
* lw6sys_exec_again:                     libsys.            (line 41097)
* lw6sys_exec_find_myself:               libsys.            (line 41070)
* lw6sys_exec_restart:                   libsys.            (line 41115)
* lw6sys_false:                          libsys.            (line 42901)
* lw6sys_fifo_pop:                       libsys.            (line 42119)
* lw6sys_fifo_push:                      libsys.            (line 42108)
* lw6sys_fifo_r_pop:                     libsys.            (line 42304)
* lw6sys_fifo_r_push:                    libsys.            (line 42291)
* lw6sys_file_exists:                    libsys.            (line 43211)
* lw6sys_find_in_dir_and_path:           libsys.            (line 43438)
* lw6sys_free:                           libsys.            (line 42691)
* lw6sys_free_callback:                  libsys.            (line 42712)
* lw6sys_ftoa:                           libsys.            (line 40746)
* lw6sys_generate_id_16:                 libsys.            (line 41764)
* lw6sys_generate_id_32:                 libsys.            (line 41774)
* lw6sys_generate_id_64:                 libsys.            (line 41784)
* lw6sys_getenv:                         libsys.            (line 40919)
* lw6sys_getenv_prefixed:                libsys.            (line 40933)
* lw6sys_get_config_file:                libsys.            (line 43058)
* lw6sys_get_cwd:                        libsys.            (line 42920)
* lw6sys_get_cycle:                      libsys.            (line 44763)
* lw6sys_get_data_dir:                   libsys.            (line 43114)
* lw6sys_get_default_config_file:        libsys.            (line 42937)
* lw6sys_get_default_data_dir:           libsys.            (line 42973)
* lw6sys_get_default_log_file:           libsys.            (line 42947)
* lw6sys_get_default_map_dir:            libsys.            (line 42998)
* lw6sys_get_default_map_path:           libsys.            (line 43006)
* lw6sys_get_default_mod_dir:            libsys.            (line 42964)
* lw6sys_get_default_music_dir:          libsys.            (line 42981)
* lw6sys_get_default_music_path:         libsys.            (line 42989)
* lw6sys_get_default_prefix:             libsys.            (line 42956)
* lw6sys_get_default_script_file:        libsys.            (line 43015)
* lw6sys_get_default_user_dir:           libsys.            (line 42927)
* lw6sys_get_home:                       libsys.            (line 40994)
* lw6sys_get_hostname:                   libsys.            (line 41018)
* lw6sys_get_log_file:                   libsys.            (line 43072)
* lw6sys_get_map_dir:                    libsys.            (line 43156)
* lw6sys_get_map_path:                   libsys.            (line 43170)
* lw6sys_get_memory_bazooka_free_count:  libsys.            (line 39324)
* lw6sys_get_memory_bazooka_free_megabytes: libsys.         (line 39370)
* lw6sys_get_memory_bazooka_malloc_count: libsys.           (line 39313)
* lw6sys_get_memory_bazooka_malloc_current_bytes: libsys.   (line 39381)
* lw6sys_get_memory_bazooka_malloc_current_count: libsys.   (line 39335)
* lw6sys_get_memory_bazooka_malloc_max_bytes: libsys.       (line 39393)
* lw6sys_get_memory_bazooka_malloc_max_count: libsys.       (line 39347)
* lw6sys_get_memory_bazooka_malloc_megabytes: libsys.       (line 39359)
* lw6sys_get_memory_bazooka_size:        libsys.            (line 39290)
* lw6sys_get_mod_dir:                    libsys.            (line 43100)
* lw6sys_get_music_dir:                  libsys.            (line 43128)
* lw6sys_get_music_path:                 libsys.            (line 43142)
* lw6sys_get_mutex_lock_count:           libsys.            (line 42870)
* lw6sys_get_mutex_unlock_count:         libsys.            (line 42879)
* lw6sys_get_prefix:                     libsys.            (line 43086)
* lw6sys_get_run_dir:                    libsys.            (line 43030)
* lw6sys_get_script_file:                libsys.            (line 43184)
* lw6sys_get_thread_create_count:        libsys.            (line 44715)
* lw6sys_get_thread_join_count:          libsys.            (line 44724)
* lw6sys_get_timestamp:                  libsys.            (line 44744)
* lw6sys_get_uptime:                     libsys.            (line 44755)
* lw6sys_get_username:                   libsys.            (line 41005)
* lw6sys_get_user_dir:                   libsys.            (line 43044)
* lw6sys_hash_dup:                       libsys.            (line 41335)
* lw6sys_hash_free:                      libsys.            (line 41210)
* lw6sys_hash_get:                       libsys.            (line 41234)
* lw6sys_hash_has_key:                   libsys.            (line 41221)
* lw6sys_hash_keys:                      libsys.            (line 41284)
* lw6sys_hash_map:                       libsys.            (line 41298)
* lw6sys_hash_new:                       libsys.            (line 41189)
* lw6sys_hash_set:                       libsys.            (line 41251)
* lw6sys_hash_sort_and_map:              libsys.            (line 41317)
* lw6sys_hash_unset:                     libsys.            (line 41271)
* lw6sys_hexa_buf_to_str:                libsys.            (line 41666)
* lw6sys_hexa_ptr_to_str:                libsys.            (line 41694)
* lw6sys_hexa_serializer_as_string:      libsys.            (line 41398)
* lw6sys_hexa_serializer_eof:            libsys.            (line 41386)
* lw6sys_hexa_serializer_free:           libsys.            (line 41364)
* lw6sys_hexa_serializer_new:            libsys.            (line 41351)
* lw6sys_hexa_serializer_pop_color:      libsys.            (line 41638)
* lw6sys_hexa_serializer_pop_float:      libsys.            (line 41584)
* lw6sys_hexa_serializer_pop_int16:      libsys.            (line 41558)
* lw6sys_hexa_serializer_pop_int32:      libsys.            (line 41545)
* lw6sys_hexa_serializer_pop_int64:      libsys.            (line 41532)
* lw6sys_hexa_serializer_pop_int8:       libsys.            (line 41571)
* lw6sys_hexa_serializer_pop_str:        libsys.            (line 41597)
* lw6sys_hexa_serializer_pop_whd:        libsys.            (line 41626)
* lw6sys_hexa_serializer_pop_xyz:        libsys.            (line 41612)
* lw6sys_hexa_serializer_push_color:     libsys.            (line 41519)
* lw6sys_hexa_serializer_push_float:     libsys.            (line 41463)
* lw6sys_hexa_serializer_push_int16:     libsys.            (line 41437)
* lw6sys_hexa_serializer_push_int32:     libsys.            (line 41424)
* lw6sys_hexa_serializer_push_int64:     libsys.            (line 41411)
* lw6sys_hexa_serializer_push_int8:      libsys.            (line 41450)
* lw6sys_hexa_serializer_push_str:       libsys.            (line 41476)
* lw6sys_hexa_serializer_push_whd:       libsys.            (line 41505)
* lw6sys_hexa_serializer_push_xyz:       libsys.            (line 41491)
* lw6sys_hexa_serializer_rewind:         libsys.            (line 41374)
* lw6sys_hexa_str_to_buf:                libsys.            (line 41651)
* lw6sys_hexa_str_to_ptr:                libsys.            (line 41678)
* lw6sys_history_free:                   libsys.            (line 41739)
* lw6sys_history_get:                    libsys.            (line 41728)
* lw6sys_history_init:                   libsys.            (line 41710)
* lw6sys_history_register:               libsys.            (line 41718)
* lw6sys_idle:                           libsys.            (line 44820)
* lw6sys_id_atol:                        libsys.            (line 41846)
* lw6sys_id_ltoa:                        libsys.            (line 41834)
* lw6sys_is_big_endian:                  libsys.            (line 42741)
* lw6sys_is_executed_again:              libsys.            (line 41083)
* lw6sys_is_little_endian:               libsys.            (line 42749)
* lw6sys_is_memory_bazooka_trustable:    libsys.            (line 39405)
* lw6sys_itoa:                           libsys.            (line 40712)
* lw6sys_keyword_as_arg:                 libsys.            (line 41871)
* lw6sys_keyword_as_env:                 libsys.            (line 41882)
* lw6sys_keyword_as_key:                 libsys.            (line 41858)
* lw6sys_keyword_as_xml:                 libsys.            (line 41892)
* lw6sys_lifo_pop:                       libsys.            (line 42097)
* lw6sys_lifo_push:                      libsys.            (line 42086)
* lw6sys_lifo_r_pop:                     libsys.            (line 42283)
* lw6sys_lifo_r_push:                    libsys.            (line 42270)
* lw6sys_list_dup:                       libsys.            (line 42131)
* lw6sys_list_filter:                    libsys.            (line 41985)
* lw6sys_list_free:                      libsys.            (line 41917)
* lw6sys_list_is_empty:                  libsys.            (line 41939)
* lw6sys_list_length:                    libsys.            (line 41952)
* lw6sys_list_map:                       libsys.            (line 41963)
* lw6sys_list_new:                       libsys.            (line 41903)
* lw6sys_list_next:                      libsys.            (line 41928)
* lw6sys_list_pop_back:                  libsys.            (line 42065)
* lw6sys_list_pop_front:                 libsys.            (line 42024)
* lw6sys_list_push_back:                 libsys.            (line 42045)
* lw6sys_list_push_front:                libsys.            (line 42004)
* lw6sys_list_r_dup:                     libsys.            (line 42312)
* lw6sys_list_r_filter:                  libsys.            (line 42212)
* lw6sys_list_r_free:                    libsys.            (line 42161)
* lw6sys_list_r_is_empty:                libsys.            (line 42172)
* lw6sys_list_r_length:                  libsys.            (line 42184)
* lw6sys_list_r_map:                     libsys.            (line 42196)
* lw6sys_list_r_new:                     libsys.            (line 42148)
* lw6sys_list_r_pop_back:                libsys.            (line 42262)
* lw6sys_list_r_pop_front:               libsys.            (line 42241)
* lw6sys_list_r_push_back:               libsys.            (line 42249)
* lw6sys_list_r_push_front:              libsys.            (line 42228)
* lw6sys_list_r_transfer_from:           libsys.            (line 42342)
* lw6sys_list_r_transfer_to:             libsys.            (line 42326)
* lw6sys_lltoa:                          libsys.            (line 40724)
* lw6sys_locale_to_utf8:                 libsys.            (line 41749)
* lw6sys_log:                            libsys.            (line 42416)
* lw6sys_log_clear:                      libsys.            (line 42390)
* lw6sys_log_critical:                   libsys.            (line 42447)
* lw6sys_log_errno_str:                  libsys.            (line 42364)
* lw6sys_log_get_backtrace_mode:         libsys.            (line 42476)
* lw6sys_log_get_console_state:          libsys.            (line 42493)
* lw6sys_log_get_level:                  libsys.            (line 42462)
* lw6sys_log_set_backtrace_mode:         libsys.            (line 42482)
* lw6sys_log_set_console_state:          libsys.            (line 42503)
* lw6sys_log_set_dialog_timeout:         libsys.            (line 42402)
* lw6sys_log_set_file:                   libsys.            (line 42378)
* lw6sys_log_set_level:                  libsys.            (line 42467)
* lw6sys_malloc:                         libsys.            (line 42625)
* lw6sys_math_angle_360:                 libsys.            (line 42541)
* lw6sys_math_blink:                     libsys.            (line 42570)
* lw6sys_math_deg2rad:                   libsys.            (line 42611)
* lw6sys_math_heartbeat:                 libsys.            (line 42555)
* lw6sys_math_lin2log:                   libsys.            (line 42583)
* lw6sys_math_log2lin:                   libsys.            (line 42598)
* lw6sys_math_poly_wy1y2s1:              libsys.            (line 42516)
* lw6sys_math_rad2deg:                   libsys.            (line 42618)
* lw6sys_megabytes_available:            libsys.            (line 42731)
* lw6sys_memory_bazooka_report:          libsys.            (line 39414)
* lw6sys_mutex_create:                   libsys.            (line 42768)
* lw6sys_mutex_destroy:                  libsys.            (line 42785)
* lw6sys_mutex_lock:                     libsys.            (line 42805)
* lw6sys_mutex_trylock:                  libsys.            (line 42827)
* lw6sys_mutex_unlock:                   libsys.            (line 42850)
* lw6sys_new_sprintf:                    libsys.            (line 44186)
* lw6sys_openmp_get_num_procs:           libsys.            (line 42910)
* lw6sys_options_log:                    libsys.            (line 43198)
* lw6sys_options_log_defaults:           libsys.            (line 43023)
* lw6sys_path_add_slash:                 libsys.            (line 43281)
* lw6sys_path_concat:                    libsys.            (line 43305)
* lw6sys_path_file_only:                 libsys.            (line 43332)
* lw6sys_path_is_cwd:                    libsys.            (line 43352)
* lw6sys_path_is_relative:               libsys.            (line 43342)
* lw6sys_path_list:                      libsys.            (line 43417)
* lw6sys_path_parent:                    libsys.            (line 43362)
* lw6sys_path_split:                     libsys.            (line 43319)
* lw6sys_path_strip_slash:               libsys.            (line 43293)
* lw6sys_path_unparent:                  libsys.            (line 43373)
* lw6sys_path_unparent_no_malloc:        libsys.            (line 43384)
* lw6sys_print_xml_footer:               libsys.            (line 43468)
* lw6sys_print_xml_header:               libsys.            (line 43457)
* lw6sys_process_fork_and_call:          libsys.            (line 43492)
* lw6sys_process_is_fully_supported:     libsys.            (line 43479)
* lw6sys_process_kill_1_9:               libsys.            (line 43505)
* lw6sys_profiler_check:                 libsys.            (line 43520)
* lw6sys_progress_begin:                 libsys.            (line 43683)
* lw6sys_progress_bind:                  libsys.            (line 43532)
* lw6sys_progress_default:               libsys.            (line 43545)
* lw6sys_progress_end:                   libsys.            (line 43704)
* lw6sys_progress_half:                  libsys.            (line 43693)
* lw6sys_progress_split:                 libsys.            (line 43582)
* lw6sys_progress_split3:                libsys.            (line 43619)
* lw6sys_progress_split4:                libsys.            (line 43638)
* lw6sys_progress_split5:                libsys.            (line 43659)
* lw6sys_progress_split_here:            libsys.            (line 43599)
* lw6sys_progress_update:                libsys.            (line 43559)
* lw6sys_random:                         libsys.            (line 43714)
* lw6sys_random_float:                   libsys.            (line 43728)
* lw6sys_readable_uptime:                libsys.            (line 44860)
* lw6sys_read_file_content:              libsys.            (line 41140)
* lw6sys_read_file_content_bin:          libsys.            (line 41154)
* lw6sys_realloc:                        libsys.            (line 42669)
* lw6sys_sdl_register:                   libsys.            (line 43739)
* lw6sys_sdl_unregister:                 libsys.            (line 43755)
* lw6sys_serialize_int16:                libsys.            (line 43808)
* lw6sys_serialize_int32:                libsys.            (line 43786)
* lw6sys_serialize_int64:                libsys.            (line 43764)
* lw6sys_setenv:                         libsys.            (line 40950)
* lw6sys_setenv_prefixed:                libsys.            (line 40964)
* lw6sys_set_memory_bazooka_eraser:      libsys.            (line 39300)
* lw6sys_set_memory_bazooka_size:        libsys.            (line 39272)
* lw6sys_shape_check_min_max_whd:        libsys.            (line 43830)
* lw6sys_shape_check_pos:                libsys.            (line 43846)
* lw6sys_shape_is_same:                  libsys.            (line 43859)
* lw6sys_shape_is_same_xy:               libsys.            (line 43871)
* lw6sys_shape_surface_wh:               libsys.            (line 43894)
* lw6sys_shape_volume_whd:               libsys.            (line 43884)
* lw6sys_signal_custom:                  libsys.            (line 43904)
* lw6sys_signal_default:                 libsys.            (line 43920)
* lw6sys_signal_fpe_handler:             libsys.            (line 43962)
* lw6sys_signal_hup_handler:             libsys.            (line 43947)
* lw6sys_signal_int_handler:             libsys.            (line 43938)
* lw6sys_signal_poll_quit:               libsys.            (line 43978)
* lw6sys_signal_segv_handler:            libsys.            (line 43955)
* lw6sys_signal_send_quit:               libsys.            (line 43969)
* lw6sys_signal_term_handler:            libsys.            (line 43929)
* lw6sys_skip_blanks:                    libsys.            (line 44309)
* lw6sys_sleep:                          libsys.            (line 44795)
* lw6sys_snooze:                         libsys.            (line 44828)
* lw6sys_sort:                           libsys.            (line 44091)
* lw6sys_sort_float_callback:            libsys.            (line 44021)
* lw6sys_sort_float_desc_callback:       libsys.            (line 44038)
* lw6sys_sort_int_callback:              libsys.            (line 43987)
* lw6sys_sort_int_desc_callback:         libsys.            (line 44004)
* lw6sys_sort_str_callback:              libsys.            (line 44056)
* lw6sys_sort_str_desc_callback:         libsys.            (line 44073)
* lw6sys_spinlock_create:                libsys.            (line 44108)
* lw6sys_spinlock_destroy:               libsys.            (line 44116)
* lw6sys_spinlock_lock:                  libsys.            (line 44126)
* lw6sys_spinlock_trylock:               libsys.            (line 44138)
* lw6sys_spinlock_unlock:                libsys.            (line 44151)
* lw6sys_stream_file_to_str:             libsys.            (line 44540)
* lw6sys_stream_str_to_file:             libsys.            (line 44557)
* lw6sys_str_cleanup:                    libsys.            (line 44320)
* lw6sys_str_cleanup_ascii7:             libsys.            (line 44332)
* lw6sys_str_concat:                     libsys.            (line 44173)
* lw6sys_str_copy:                       libsys.            (line 44161)
* lw6sys_str_empty_if_null:              libsys.            (line 44242)
* lw6sys_str_is_bin:                     libsys.            (line 44527)
* lw6sys_str_is_blank:                   libsys.            (line 44221)
* lw6sys_str_is_null_or_empty:           libsys.            (line 44232)
* lw6sys_str_is_same:                    libsys.            (line 44254)
* lw6sys_str_is_same_no_case:            libsys.            (line 44269)
* lw6sys_str_join:                       libsys.            (line 44428)
* lw6sys_str_random:                     libsys.            (line 44493)
* lw6sys_str_random_word:                libsys.            (line 44515)
* lw6sys_str_random_words:               libsys.            (line 44503)
* lw6sys_str_reformat:                   libsys.            (line 44347)
* lw6sys_str_reformat_this:              libsys.            (line 44363)
* lw6sys_str_split:                      libsys.            (line 44389)
* lw6sys_str_split_config_item:          libsys.            (line 44415)
* lw6sys_str_split_no_0:                 libsys.            (line 44402)
* lw6sys_str_starts_with:                libsys.            (line 44284)
* lw6sys_str_starts_with_no_case:        libsys.            (line 44296)
* lw6sys_str_tolower:                    libsys.            (line 44453)
* lw6sys_str_toupper:                    libsys.            (line 44442)
* lw6sys_str_truncate:                   libsys.            (line 44464)
* lw6sys_str_truncate_middle:            libsys.            (line 44477)
* lw6sys_test_and_set:                   libsys.            (line 44570)
* lw6sys_test_and_set <1>:               libsys.            (line 44579)
* lw6sys_test_exec:                      libsys.            (line 44611)
* lw6sys_test_register:                  libsys.            (line 44588)
* lw6sys_test_run:                       libsys.            (line 44598)
* lw6sys_thread_create:                  libsys.            (line 44631)
* lw6sys_thread_get_data:                libsys.            (line 44691)
* lw6sys_thread_get_id:                  libsys.            (line 44680)
* lw6sys_thread_is_callback_done:        libsys.            (line 44656)
* lw6sys_thread_join:                    libsys.            (line 44702)
* lw6sys_thread_wait_callback_done:      libsys.            (line 44667)
* lw6sys_timer_update:                   libsys.            (line 44781)
* lw6sys_time_init:                      libsys.            (line 44836)
* lw6sys_true:                           libsys.            (line 42896)
* lw6sys_unserialize_int16:              libsys.            (line 43821)
* lw6sys_unserialize_int32:              libsys.            (line 43799)
* lw6sys_unserialize_int64:              libsys.            (line 43777)
* lw6sys_url_canonize:                   libsys.            (line 44908)
* lw6sys_url_free:                       libsys.            (line 44898)
* lw6sys_url_http_from_ip_port:          libsys.            (line 44872)
* lw6sys_url_is_canonized:               libsys.            (line 44922)
* lw6sys_url_parse:                      libsys.            (line 44886)
* lw6sys_version_is_compatible:          libsys.            (line 44932)
* lw6sys_vthread_create:                 libsys.            (line 44989)
* lw6sys_vthread_is_running:             libsys.            (line 44975)
* lw6sys_vthread_join:                   libsys.            (line 45011)
* lw6sys_vthread_run:                    libsys.            (line 44948)
* lw6sys_write_file_content:             libsys.            (line 41174)
* lw6tsk_loader_free:                    libtsk.            (line 45745)
* lw6tsk_loader_get_stage:               libtsk.            (line 45766)
* lw6tsk_loader_new:                     libtsk.            (line 45727)
* lw6tsk_loader_pop:                     libtsk.            (line 45703)
* lw6tsk_loader_push_gen:                libtsk.            (line 45680)
* lw6tsk_loader_push_ldr:                libtsk.            (line 45649)
* lw6tsk_loader_repr:                    libtsk.            (line 45756)
* lw6tsk_test_register:                  libtsk.            (line 45777)
* lw6tsk_test_run:                       libtsk.            (line 45787)
* lw6vox_renderer_free:                  libvox.            (line 45847)
* lw6vox_renderer_new:                   libvox.            (line 45837)
* lw6vox_test_register:                  libvox.            (line 45857)
* lw6vox_test_run:                       libvox.            (line 45867)
* 'LW6_AMBIANCE_EXCLUDE':                Sound options.     (line  7026)
* 'LW6_AMBIANCE_FILE':                   Sound options.     (line  7039)
* 'LW6_AMBIANCE_FILTER':                 Sound options.     (line  7052)
* 'LW6_ANIMATION_DENSITY':               Map style.xml.     (line 10061)
* 'LW6_ANIMATION_SPEED':                 Map style.xml.     (line 10076)
* 'LW6_AUTO_RELEASE_DELAY':              Input options.     (line  6633)
* 'LW6_BACKGROUND_COLOR_AUTO':           Map hints.xml.     (line  9685)
* 'LW6_BACKGROUND_COLOR_ROOT_BG':        Map style.xml.     (line 10091)
* 'LW6_BACKGROUND_COLOR_ROOT_FG':        Map style.xml.     (line 10106)
* 'LW6_BACKGROUND_COLOR_STUFF_BG':       Map style.xml.     (line 10123)
* 'LW6_BACKGROUND_COLOR_STUFF_FG':       Map style.xml.     (line 10140)
* 'LW6_BACKGROUND_STYLE':                Map style.xml.     (line 10158)
* 'LW6_BENCH_VALUE':                     Advanced settings. (line 11229)
* 'LW6_BIND_IP':                         Network options.   (line  7123)
* 'LW6_BIND_PORT':                       Network options.   (line  7137)
* 'LW6_BIN_ID':                          Advanced settings. (line 11245)
* 'LW6_BLINK_CURSOR':                    Map style.xml.     (line 10173)
* 'LW6_BOOST_POWER':                     Map rules.xml.     (line  7432)
* 'LW6_BOT1_AI':                         Map teams.xml.     (line 10912)
* 'LW6_BOT1_COLOR':                      Map teams.xml.     (line 10924)
* 'LW6_BOT2_AI':                         Map teams.xml.     (line 10936)
* 'LW6_BOT2_COLOR':                      Map teams.xml.     (line 10948)
* 'LW6_BOT3_AI':                         Map teams.xml.     (line 10960)
* 'LW6_BOT3_COLOR':                      Map teams.xml.     (line 10972)
* 'LW6_BOT4_AI':                         Map teams.xml.     (line 10984)
* 'LW6_BOT4_COLOR':                      Map teams.xml.     (line 10996)
* 'LW6_BOT5_AI':                         Map teams.xml.     (line 11008)
* 'LW6_BOT5_COLOR':                      Map teams.xml.     (line 11020)
* 'LW6_BOT6_AI':                         Map teams.xml.     (line 11032)
* 'LW6_BOT6_COLOR':                      Map teams.xml.     (line 11044)
* 'LW6_BOT7_AI':                         Map teams.xml.     (line 11056)
* 'LW6_BOT7_COLOR':                      Map teams.xml.     (line 11068)
* 'LW6_BOT8_AI':                         Map teams.xml.     (line 11080)
* 'LW6_BOT8_COLOR':                      Map teams.xml.     (line 11092)
* 'LW6_BOT9_AI':                         Map teams.xml.     (line 11104)
* 'LW6_BOT9_COLOR':                      Map teams.xml.     (line 11116)
* 'LW6_BOT_IQ':                          Map teams.xml.     (line 10882)
* 'LW6_BOT_SPEED':                       Map teams.xml.     (line 10898)
* 'LW6_BROADCAST':                       Network options.   (line  7152)
* 'LW6_CAPTURE':                         Graphics options.  (line  6923)
* 'LW6_CHOSEN_MAP':                      Map parameters.    (line  7295)
* 'LW6_CLICK_TO_FOCUS':                  Input options.     (line  6649)
* 'LW6_CLI_BACKENDS':                    Network options.   (line  7167)
* lw6_cns_handler:                       libliquidwar6.     (line 14583)
* 'LW6_COLORIZE':                        Map style.xml.     (line 10252)
* 'LW6_COLORIZE_CURSOR':                 Map style.xml.     (line 10268)
* 'LW6_COLOR_ALTERNATE_BG':              Map style.xml.     (line 10188)
* 'LW6_COLOR_ALTERNATE_FG':              Map style.xml.     (line 10204)
* 'LW6_COLOR_BASE_BG':                   Map style.xml.     (line 10220)
* 'LW6_COLOR_BASE_FG':                   Map style.xml.     (line 10236)
* 'LW6_COLOR_CONFLICT_MODE':             Map rules.xml.     (line  7447)
* 'LW6_COMMANDS_PER_SEC':                Advanced settings. (line 11269)
* 'LW6_CURSOR_POT_INIT':                 Map rules.xml.     (line  7467)
* 'LW6_CURSOR_SENSITIVITY':              Input options.     (line  6663)
* 'LW6_CURSOR_SIZE':                     Map style.xml.     (line 10284)
* 'LW6_CUSTOM_ALT':                      Input options.     (line  6678)
* 'LW6_CUSTOM_CTRL':                     Input options.     (line  6690)
* 'LW6_CUSTOM_DOWN':                     Input options.     (line  6702)
* 'LW6_CUSTOM_ENTER':                    Input options.     (line  6714)
* 'LW6_CUSTOM_ESC':                      Input options.     (line  6726)
* 'LW6_CUSTOM_LEFT':                     Input options.     (line  6738)
* 'LW6_CUSTOM_PGDOWN':                   Input options.     (line  6750)
* 'LW6_CUSTOM_PGUP':                     Input options.     (line  6762)
* 'LW6_CUSTOM_RIGHT':                    Input options.     (line  6774)
* 'LW6_CUSTOM_UP':                       Input options.     (line  6786)
* 'LW6_DANGER_POWER':                    Map rules.xml.     (line  7481)
* 'LW6_DEBUG_LAYER_ID':                  Advanced settings. (line 11303)
* 'LW6_DEBUG_TEAM_ID':                   Advanced settings. (line 11316)
* 'LW6_DIALOG_TIMEOUT':                  Advanced settings. (line 11336)
* 'LW6_DIRTY_READ':                      Advanced settings. (line 11352)
* 'LW6_DISPLAY_BACKGROUND':              Advanced settings. (line 11369)
* 'LW6_DISPLAY_CONSOLE':                 Advanced settings. (line 11382)
* 'LW6_DISPLAY_CURSORS':                 Advanced settings. (line 11397)
* 'LW6_DISPLAY_DEBUG_GRADIENT':          Advanced settings. (line 11410)
* 'LW6_DISPLAY_DEBUG_ZONES':             Advanced settings. (line 11423)
* 'LW6_DISPLAY_FIGHTERS':                Advanced settings. (line 11436)
* 'LW6_DISPLAY_FPS':                     Advanced settings. (line 11449)
* 'LW6_DISPLAY_HUD':                     Advanced settings. (line 11463)
* 'LW6_DISPLAY_LOG':                     Advanced settings. (line 11476)
* 'LW6_DISPLAY_MAP':                     Advanced settings. (line 11489)
* 'LW6_DISPLAY_MENU':                    Advanced settings. (line 11502)
* 'LW6_DISPLAY_META':                    Advanced settings. (line 11515)
* 'LW6_DISPLAY_MOUSE':                   Advanced settings. (line 11528)
* 'LW6_DISPLAY_MPS':                     Advanced settings. (line 11540)
* 'LW6_DISPLAY_PREVIEW':                 Advanced settings. (line 11554)
* 'LW6_DISPLAY_PROGRESS':                Advanced settings. (line 11567)
* 'LW6_DISPLAY_SCORE':                   Advanced settings. (line 11580)
* 'LW6_DISPLAY_SPLASH':                  Advanced settings. (line 11592)
* 'LW6_DISPLAY_URL':                     Advanced settings. (line 11605)
* 'LW6_DOUBLE_CLICK_DELAY':              Input options.     (line  6798)
* 'LW6_DOWNSIZE_USING_BENCH_VALUE':      Map hints.xml.     (line  9702)
* 'LW6_DOWNSIZE_USING_FIGHTER_SCALE':    Map hints.xml.     (line  9719)
* 'LW6_EXECUTED_AGAIN':                  Advanced settings. (line 11619)
* lw6_exit:                              libliquidwar6.     (line 14528)
* 'LW6_EXP':                             Map rules.xml.     (line  7497)
* 'LW6_FIGHTER_ATTACK':                  Map rules.xml.     (line  7513)
* 'LW6_FIGHTER_DEFENSE':                 Map rules.xml.     (line  7530)
* 'LW6_FIGHTER_NEW_HEALTH':              Map rules.xml.     (line  7546)
* 'LW6_FIGHTER_REGENERATE':              Map rules.xml.     (line  7564)
* 'LW6_FIGHTER_SCALE':                   Map hints.xml.     (line  9735)
* lw6_fix_env:                           libliquidwar6.     (line 14551)
* 'LW6_FORCE':                           Map parameters.    (line  7309)
* 'LW6_FRAGS_FADE_OUT':                  Map rules.xml.     (line  7579)
* 'LW6_FRAGS_MODE':                      Map rules.xml.     (line  7598)
* 'LW6_FRAGS_TO_DISTRIBUTE':             Map rules.xml.     (line  7617)
* lw6_free_bot_smob:                     libliquidwar6.     (line 15108)
* lw6_free_db_smob:                      libliquidwar6.     (line 15207)
* lw6_free_dsp_smob:                     libliquidwar6.     (line 14862)
* lw6_free_game_state_smob:              libliquidwar6.     (line 15036)
* lw6_free_game_struct_smob:             libliquidwar6.     (line 14998)
* lw6_free_jpeg_smob:                    libliquidwar6.     (line 15276)
* lw6_free_loader_smob:                  libliquidwar6.     (line 15174)
* lw6_free_look_smob:                    libliquidwar6.     (line 15141)
* lw6_free_map_smob:                     libliquidwar6.     (line 14928)
* lw6_free_menu_smob:                    libliquidwar6.     (line 14961)
* lw6_free_node_smob:                    libliquidwar6.     (line 15243)
* lw6_free_pilot_smob:                   libliquidwar6.     (line 15069)
* lw6_free_snd_smob:                     libliquidwar6.     (line 14895)
* 'LW6_FULLSCREEN':                      Graphics options.  (line  6936)
* 'LW6_FX_VOLUME':                       Sound options.     (line  7068)
* lw6_get_ret:                           libliquidwar6.     (line 14544)
* 'LW6_GFX_BACKEND':                     Graphics options.  (line  6949)
* 'LW6_GFX_CPU_USAGE':                   Advanced settings. (line 11635)
* 'LW6_GFX_DEBUG':                       Advanced settings. (line 11652)
* 'LW6_GFX_QUALITY':                     Graphics options.  (line  6963)
* 'LW6_GLUE_POWER':                      Map rules.xml.     (line  7633)
* 'LW6_GUESS_COLORS':                    Map hints.xml.     (line  9761)
* 'LW6_GUESS_MOVES_PER_SEC':             Map hints.xml.     (line  9780)
* 'LW6_HEIGHT':                          Graphics options.  (line  6979)
* 'LW6_HIDDEN_LAYER_ALPHA':              Map style.xml.     (line 10298)
* 'LW6_HIGHEST_TEAM_COLOR_ALLOWED':      Map rules.xml.     (line  7648)
* 'LW6_HIGHEST_WEAPON_ALLOWED':          Map rules.xml.     (line  7665)
* 'LW6_HUD_COLOR_AUTO':                  Map hints.xml.     (line  9793)
* 'LW6_HUD_COLOR_FRAME_BG':              Map style.xml.     (line 10315)
* 'LW6_HUD_COLOR_FRAME_FG':              Map style.xml.     (line 10328)
* 'LW6_HUD_COLOR_TEXT_BG':               Map style.xml.     (line 10341)
* 'LW6_HUD_COLOR_TEXT_FG':               Map style.xml.     (line 10354)
* 'LW6_HUD_STYLE':                       Map style.xml.     (line 10367)
* lw6_init_global:                       libliquidwar6.     (line 14765)
* 'LW6_IO_PER_SEC':                      Advanced settings. (line 11665)
* 'LW6_JPEG_QUALITY':                    Advanced settings. (line 11679)
* 'LW6_KEEP_RATIO':                      Map style.xml.     (line 10381)
* 'LW6_KNOWN_NODES':                     Network options.   (line  7182)
* 'LW6_LOADER_SLEEP':                    Advanced settings. (line 11692)
* 'LW6_LOCAL_BENCH_DELTA':               Advanced settings. (line 11705)
* 'LW6_LOG_FILE':                        Path options.      (line  6313)
* 'LW6_LOG_LEVEL':                       Advanced settings. (line 11719)
* 'LW6_LOG_TIMEOUT':                     Advanced settings. (line 11736)
* 'LW6_MAGIC_NUMBER':                    Advanced settings. (line 11749)
* lw6_main:                              libliquidwar6.     (line 14798)
* lw6_make_scm_bot:                      libliquidwar6.     (line 15081)
* lw6_make_scm_db:                       libliquidwar6.     (line 15186)
* lw6_make_scm_dsp:                      libliquidwar6.     (line 14841)
* lw6_make_scm_game_state:               libliquidwar6.     (line 15010)
* lw6_make_scm_game_struct:              libliquidwar6.     (line 14973)
* lw6_make_scm_jpeg:                     libliquidwar6.     (line 15255)
* lw6_make_scm_loader:                   libliquidwar6.     (line 15153)
* lw6_make_scm_look:                     libliquidwar6.     (line 15120)
* lw6_make_scm_map:                      libliquidwar6.     (line 14907)
* lw6_make_scm_menu:                     libliquidwar6.     (line 14940)
* lw6_make_scm_node:                     libliquidwar6.     (line 15219)
* lw6_make_scm_pilot:                    libliquidwar6.     (line 15048)
* lw6_make_scm_snd:                      libliquidwar6.     (line 14874)
* 'LW6_MAP_PATH':                        Path options.      (line  6340)
* 'LW6_MAX_CURSOR_POT':                  Map rules.xml.     (line  7682)
* 'LW6_MAX_CURSOR_POT_OFFSET':           Map rules.xml.     (line  7696)
* 'LW6_MAX_CURSOR_SPEED':                Input options.     (line  6811)
* 'LW6_MAX_LOCAL_BENCH_VALUE':           Advanced settings. (line 11773)
* 'LW6_MAX_MAP_HEIGHT':                  Map hints.xml.     (line  9810)
* 'LW6_MAX_MAP_SURFACE':                 Map hints.xml.     (line  9827)
* 'LW6_MAX_MAP_WIDTH':                   Map hints.xml.     (line  9842)
* 'LW6_MAX_NB_CURSORS':                  Map rules.xml.     (line  7713)
* 'LW6_MAX_NB_NODES':                    Map rules.xml.     (line  7727)
* 'LW6_MAX_NB_TEAMS':                    Map rules.xml.     (line  7741)
* 'LW6_MAX_NETWORK_BENCH_VALUE':         Advanced settings. (line 11790)
* 'LW6_MAX_ROUND_DELTA':                 Map rules.xml.     (line  7754)
* 'LW6_MAX_ZONE_SIZE':                   Map rules.xml.     (line  7769)
* 'LW6_MEDICINE_POWER':                  Map rules.xml.     (line  7792)
* 'LW6_MEMORY_BAZOOKA_ERASER':           Advanced settings. (line 11805)
* 'LW6_MEMORY_BAZOOKA_SIZE':             Advanced settings. (line 11825)
* 'LW6_MENU_COLOR_AUTO':                 Map hints.xml.     (line  9859)
* 'LW6_MENU_COLOR_DEFAULT_BG':           Map style.xml.     (line 10394)
* 'LW6_MENU_COLOR_DEFAULT_FG':           Map style.xml.     (line 10407)
* 'LW6_MENU_COLOR_DISABLED_BG':          Map style.xml.     (line 10422)
* 'LW6_MENU_COLOR_DISABLED_FG':          Map style.xml.     (line 10435)
* 'LW6_MENU_COLOR_SELECTED_BG':          Map style.xml.     (line 10448)
* 'LW6_MENU_COLOR_SELECTED_FG':          Map style.xml.     (line 10461)
* 'LW6_MENU_STYLE':                      Map style.xml.     (line 10474)
* 'LW6_MIN_MAP_HEIGHT':                  Map hints.xml.     (line  9878)
* 'LW6_MIN_MAP_SURFACE':                 Map hints.xml.     (line  9895)
* 'LW6_MIN_MAP_WIDTH':                   Map hints.xml.     (line  9910)
* 'LW6_MOUSE_SENSITIVITY':               Input options.     (line  6824)
* 'LW6_MOVES_PER_ROUND':                 Map rules.xml.     (line  7808)
* 'LW6_MUSIC_DIR':                       Path options.      (line  6382)
* 'LW6_MUSIC_EXCLUDE':                   Map style.xml.     (line 10487)
* 'LW6_MUSIC_FILE':                      Map style.xml.     (line 10500)
* 'LW6_MUSIC_FILTER':                    Map style.xml.     (line 10517)
* 'LW6_MUSIC_PATH':                      Path options.      (line  6400)
* 'LW6_MUSIC_VOLUME':                    Sound options.     (line  7081)
* 'LW6_NB_ATTACK_TRIES':                 Map rules.xml.     (line  7826)
* 'LW6_NB_BOTS':                         Map teams.xml.     (line 11128)
* 'LW6_NB_DEFENSE_TRIES':                Map rules.xml.     (line  7844)
* 'LW6_NB_MOVE_TRIES':                   Map rules.xml.     (line  7861)
* 'LW6_NETWORK_BENCH_DELTA':             Advanced settings. (line 11877)
* 'LW6_NETWORK_RELIABILITY':             Advanced settings. (line 11891)
* 'LW6_NET_LOG':                         Advanced settings. (line 11847)
* 'LW6_NET_PER_SEC':                     Advanced settings. (line 11862)
* 'LW6_NODE_DESCRIPTION':                Network options.   (line  7200)
* 'LW6_NODE_TITLE':                      Network options.   (line  7215)
* 'LW6_OPEN_RELAY':                      Advanced settings. (line 11914)
* 'LW6_PASSWORD':                        Network options.   (line  7230)
* 'LW6_PILOT_LAG':                       Advanced settings. (line 11932)
* 'LW6_PIXELIZE':                        Map style.xml.     (line 10533)
* 'LW6_PLAYER1_COLOR':                   Map teams.xml.     (line 11142)
* 'LW6_PLAYER1_CONTROL':                 Players options.   (line  6474)
* 'LW6_PLAYER1_NAME':                    Players options.   (line  6487)
* 'LW6_PLAYER1_STATUS':                  Players options.   (line  6500)
* 'LW6_PLAYER2_COLOR':                   Map teams.xml.     (line 11155)
* 'LW6_PLAYER2_CONTROL':                 Players options.   (line  6513)
* 'LW6_PLAYER2_NAME':                    Players options.   (line  6526)
* 'LW6_PLAYER2_STATUS':                  Players options.   (line  6539)
* 'LW6_PLAYER3_COLOR':                   Map teams.xml.     (line 11168)
* 'LW6_PLAYER3_CONTROL':                 Players options.   (line  6552)
* 'LW6_PLAYER3_NAME':                    Players options.   (line  6565)
* 'LW6_PLAYER3_STATUS':                  Players options.   (line  6578)
* 'LW6_PLAYER4_COLOR':                   Map teams.xml.     (line 11181)
* 'LW6_PLAYER4_CONTROL':                 Players options.   (line  6591)
* 'LW6_PLAYER4_NAME':                    Players options.   (line  6604)
* 'LW6_PLAYER4_STATUS':                  Players options.   (line  6617)
* lw6_process_non_run_options:           libliquidwar6.     (line 14821)
* 'LW6_PUBLIC_URL':                      Network options.   (line  7248)
* lw6_quit_global:                       libliquidwar6.     (line 14777)
* lw6_register_funcs:                    libliquidwar6.     (line 14574)
* lw6_register_funcs_bot:                libliquidwar6.     (line 14565)
* lw6_register_funcs_cfg:                libliquidwar6.     (line 14594)
* lw6_register_funcs_cli:                libliquidwar6.     (line 14603)
* lw6_register_funcs_cns:                libliquidwar6.     (line 14612)
* lw6_register_funcs_dsp:                libliquidwar6.     (line 14621)
* lw6_register_funcs_gen:                libliquidwar6.     (line 14630)
* lw6_register_funcs_gfx:                libliquidwar6.     (line 14639)
* lw6_register_funcs_gui:                libliquidwar6.     (line 14648)
* lw6_register_funcs_hlp:                libliquidwar6.     (line 14657)
* lw6_register_funcs_img:                libliquidwar6.     (line 14666)
* lw6_register_funcs_ker:                libliquidwar6.     (line 14675)
* lw6_register_funcs_ldr:                libliquidwar6.     (line 14684)
* lw6_register_funcs_map:                libliquidwar6.     (line 14693)
* lw6_register_funcs_net:                libliquidwar6.     (line 14702)
* lw6_register_funcs_p2p:                libliquidwar6.     (line 14711)
* lw6_register_funcs_pil:                libliquidwar6.     (line 14720)
* lw6_register_funcs_snd:                libliquidwar6.     (line 14729)
* lw6_register_funcs_srv:                libliquidwar6.     (line 14738)
* lw6_register_funcs_sys:                libliquidwar6.     (line 14747)
* lw6_register_funcs_tsk:                libliquidwar6.     (line 14756)
* lw6_register_smobs:                    libliquidwar6.     (line 15288)
* lw6_release:                           libliquidwar6.     (line 14515)
* 'LW6_REPEAT_DELAY':                    Input options.     (line  6838)
* 'LW6_REPEAT_INTERVAL':                 Input options.     (line  6851)
* 'LW6_RESAMPLE':                        Map hints.xml.     (line  9927)
* 'LW6_RESET_CONFIG_ON_UPGRADE':         Advanced settings. (line 11962)
* lw6_resize_callback:                   libliquidwar6.     (line 14499)
* 'LW6_RESPAWN_DELAY':                   Map rules.xml.     (line  7882)
* 'LW6_RESPAWN_POSITION_MODE':           Map rules.xml.     (line  7895)
* 'LW6_RESPAWN_TEAM':                    Map rules.xml.     (line  7911)
* 'LW6_ROUNDS_PER_SEC':                  Map rules.xml.     (line  7952)
* 'LW6_ROUND_DELTA':                     Map rules.xml.     (line  7927)
* lw6_scm_to_bot:                        libliquidwar6.     (line 15097)
* lw6_scm_to_db:                         libliquidwar6.     (line 15196)
* lw6_scm_to_dsp:                        libliquidwar6.     (line 14851)
* lw6_scm_to_game_state:                 libliquidwar6.     (line 15025)
* lw6_scm_to_game_struct:                libliquidwar6.     (line 14987)
* lw6_scm_to_jpeg:                       libliquidwar6.     (line 15265)
* lw6_scm_to_loader:                     libliquidwar6.     (line 15163)
* lw6_scm_to_look:                       libliquidwar6.     (line 15130)
* lw6_scm_to_map:                        libliquidwar6.     (line 14917)
* lw6_scm_to_menu:                       libliquidwar6.     (line 14950)
* lw6_scm_to_node:                       libliquidwar6.     (line 15232)
* lw6_scm_to_pilot:                      libliquidwar6.     (line 15058)
* lw6_scm_to_snd:                        libliquidwar6.     (line 14884)
* 'LW6_SCREENSHOTS_PER_MIN':             Advanced settings. (line 11975)
* lw6_set_ret:                           libliquidwar6.     (line 14535)
* 'LW6_SIDE_ATTACK_FACTOR':              Map rules.xml.     (line  7969)
* 'LW6_SIDE_DEFENSE_FACTOR':             Map rules.xml.     (line  7986)
* 'LW6_SINGLE_ARMY_SIZE':                Map rules.xml.     (line  8000)
* 'LW6_SKIP_NETWORK':                    Network options.   (line  7264)
* 'LW6_SND_BACKEND':                     Sound options.     (line  7094)
* 'LW6_SPEED':                           Map hints.xml.     (line  9941)
* 'LW6_SPREADS_PER_ROUND':               Map rules.xml.     (line  8050)
* 'LW6_SPREAD_MODE':                     Map rules.xml.     (line  8018)
* 'LW6_SPREAD_THREAD':                   Map rules.xml.     (line  8033)
* 'LW6_SRV_BACKENDS':                    Network options.   (line  7277)
* 'LW6_START_BLUE_X':                    Map rules.xml.     (line  8069)
* 'LW6_START_BLUE_Y':                    Map rules.xml.     (line  8082)
* 'LW6_START_CYAN_X':                    Map rules.xml.     (line  8095)
* 'LW6_START_CYAN_Y':                    Map rules.xml.     (line  8108)
* 'LW6_START_GREEN_X':                   Map rules.xml.     (line  8121)
* 'LW6_START_GREEN_Y':                   Map rules.xml.     (line  8134)
* 'LW6_START_LIGHTBLUE_X':               Map rules.xml.     (line  8147)
* 'LW6_START_LIGHTBLUE_Y':               Map rules.xml.     (line  8160)
* 'LW6_START_MAGENTA_X':                 Map rules.xml.     (line  8173)
* 'LW6_START_MAGENTA_Y':                 Map rules.xml.     (line  8186)
* 'LW6_START_ORANGE_X':                  Map rules.xml.     (line  8199)
* 'LW6_START_ORANGE_Y':                  Map rules.xml.     (line  8212)
* 'LW6_START_PINK_X':                    Map rules.xml.     (line  8225)
* 'LW6_START_PINK_Y':                    Map rules.xml.     (line  8238)
* 'LW6_START_POSITION_MODE':             Map rules.xml.     (line  8251)
* 'LW6_START_PURPLE_X':                  Map rules.xml.     (line  8267)
* 'LW6_START_PURPLE_Y':                  Map rules.xml.     (line  8280)
* 'LW6_START_RED_X':                     Map rules.xml.     (line  8293)
* 'LW6_START_RED_Y':                     Map rules.xml.     (line  8306)
* 'LW6_START_YELLOW_X':                  Map rules.xml.     (line  8319)
* 'LW6_START_YELLOW_Y':                  Map rules.xml.     (line  8332)
* 'LW6_SYSTEM_COLOR_AUTO':               Map hints.xml.     (line  9965)
* 'LW6_SYSTEM_COLOR_BG':                 Map style.xml.     (line 10547)
* 'LW6_SYSTEM_COLOR_FG':                 Map style.xml.     (line 10561)
* 'LW6_TARGET_FPS':                      Advanced settings. (line 12025)
* 'LW6_TEAM_COLOR_BLUE':                 Map style.xml.     (line 10575)
* 'LW6_TEAM_COLOR_CYAN':                 Map style.xml.     (line 10588)
* 'LW6_TEAM_COLOR_DEAD':                 Map style.xml.     (line 10601)
* 'LW6_TEAM_COLOR_GREEN':                Map style.xml.     (line 10615)
* 'LW6_TEAM_COLOR_LIGHTBLUE':            Map style.xml.     (line 10628)
* 'LW6_TEAM_COLOR_MAGENTA':              Map style.xml.     (line 10641)
* 'LW6_TEAM_COLOR_ORANGE':               Map style.xml.     (line 10654)
* 'LW6_TEAM_COLOR_PINK':                 Map style.xml.     (line 10667)
* 'LW6_TEAM_COLOR_PURPLE':               Map style.xml.     (line 10680)
* 'LW6_TEAM_COLOR_RED':                  Map style.xml.     (line 10693)
* 'LW6_TEAM_COLOR_YELLOW':               Map style.xml.     (line 10706)
* 'LW6_TEAM_PROFILE_BLUE_AGGRESSIVE':    Map rules.xml.     (line  8345)
* 'LW6_TEAM_PROFILE_BLUE_FAST':          Map rules.xml.     (line  8360)
* 'LW6_TEAM_PROFILE_BLUE_HANDICAP':      Map rules.xml.     (line  8375)
* 'LW6_TEAM_PROFILE_BLUE_MOBILE':        Map rules.xml.     (line  8387)
* 'LW6_TEAM_PROFILE_BLUE_VULNERABLE':    Map rules.xml.     (line  8403)
* 'LW6_TEAM_PROFILE_BLUE_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  8419)
* 'LW6_TEAM_PROFILE_BLUE_WEAPON_ID':     Map rules.xml.     (line  8432)
* 'LW6_TEAM_PROFILE_BLUE_WEAPON_MODE':   Map rules.xml.     (line  8445)
* 'LW6_TEAM_PROFILE_CYAN_AGGRESSIVE':    Map rules.xml.     (line  8459)
* 'LW6_TEAM_PROFILE_CYAN_FAST':          Map rules.xml.     (line  8474)
* 'LW6_TEAM_PROFILE_CYAN_HANDICAP':      Map rules.xml.     (line  8489)
* 'LW6_TEAM_PROFILE_CYAN_MOBILE':        Map rules.xml.     (line  8501)
* 'LW6_TEAM_PROFILE_CYAN_VULNERABLE':    Map rules.xml.     (line  8517)
* 'LW6_TEAM_PROFILE_CYAN_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  8533)
* 'LW6_TEAM_PROFILE_CYAN_WEAPON_ID':     Map rules.xml.     (line  8546)
* 'LW6_TEAM_PROFILE_CYAN_WEAPON_MODE':   Map rules.xml.     (line  8559)
* 'LW6_TEAM_PROFILE_GREEN_AGGRESSIVE':   Map rules.xml.     (line  8573)
* 'LW6_TEAM_PROFILE_GREEN_FAST':         Map rules.xml.     (line  8588)
* 'LW6_TEAM_PROFILE_GREEN_HANDICAP':     Map rules.xml.     (line  8603)
* 'LW6_TEAM_PROFILE_GREEN_MOBILE':       Map rules.xml.     (line  8615)
* 'LW6_TEAM_PROFILE_GREEN_VULNERABLE':   Map rules.xml.     (line  8631)
* 'LW6_TEAM_PROFILE_GREEN_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  8647)
* 'LW6_TEAM_PROFILE_GREEN_WEAPON_ID':    Map rules.xml.     (line  8660)
* 'LW6_TEAM_PROFILE_GREEN_WEAPON_MODE':  Map rules.xml.     (line  8673)
* 'LW6_TEAM_PROFILE_LIGHTBLUE_AGGRESSIVE': Map rules.xml.   (line  8687)
* 'LW6_TEAM_PROFILE_LIGHTBLUE_FAST':     Map rules.xml.     (line  8702)
* 'LW6_TEAM_PROFILE_LIGHTBLUE_HANDICAP': Map rules.xml.     (line  8717)
* 'LW6_TEAM_PROFILE_LIGHTBLUE_MOBILE':   Map rules.xml.     (line  8729)
* 'LW6_TEAM_PROFILE_LIGHTBLUE_VULNERABLE': Map rules.xml.   (line  8745)
* 'LW6_TEAM_PROFILE_LIGHTBLUE_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  8761)
* 'LW6_TEAM_PROFILE_LIGHTBLUE_WEAPON_ID': Map rules.xml.    (line  8775)
* 'LW6_TEAM_PROFILE_LIGHTBLUE_WEAPON_MODE': Map rules.xml.  (line  8788)
* 'LW6_TEAM_PROFILE_MAGENTA_AGGRESSIVE': Map rules.xml.     (line  8802)
* 'LW6_TEAM_PROFILE_MAGENTA_FAST':       Map rules.xml.     (line  8817)
* 'LW6_TEAM_PROFILE_MAGENTA_HANDICAP':   Map rules.xml.     (line  8832)
* 'LW6_TEAM_PROFILE_MAGENTA_MOBILE':     Map rules.xml.     (line  8844)
* 'LW6_TEAM_PROFILE_MAGENTA_VULNERABLE': Map rules.xml.     (line  8860)
* 'LW6_TEAM_PROFILE_MAGENTA_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  8876)
* 'LW6_TEAM_PROFILE_MAGENTA_WEAPON_ID':  Map rules.xml.     (line  8889)
* 'LW6_TEAM_PROFILE_MAGENTA_WEAPON_MODE': Map rules.xml.    (line  8902)
* 'LW6_TEAM_PROFILE_ORANGE_AGGRESSIVE':  Map rules.xml.     (line  8916)
* 'LW6_TEAM_PROFILE_ORANGE_FAST':        Map rules.xml.     (line  8931)
* 'LW6_TEAM_PROFILE_ORANGE_HANDICAP':    Map rules.xml.     (line  8946)
* 'LW6_TEAM_PROFILE_ORANGE_MOBILE':      Map rules.xml.     (line  8958)
* 'LW6_TEAM_PROFILE_ORANGE_VULNERABLE':  Map rules.xml.     (line  8974)
* 'LW6_TEAM_PROFILE_ORANGE_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  8990)
* 'LW6_TEAM_PROFILE_ORANGE_WEAPON_ID':   Map rules.xml.     (line  9003)
* 'LW6_TEAM_PROFILE_ORANGE_WEAPON_MODE': Map rules.xml.     (line  9016)
* 'LW6_TEAM_PROFILE_PINK_AGGRESSIVE':    Map rules.xml.     (line  9030)
* 'LW6_TEAM_PROFILE_PINK_FAST':          Map rules.xml.     (line  9045)
* 'LW6_TEAM_PROFILE_PINK_HANDICAP':      Map rules.xml.     (line  9060)
* 'LW6_TEAM_PROFILE_PINK_MOBILE':        Map rules.xml.     (line  9072)
* 'LW6_TEAM_PROFILE_PINK_VULNERABLE':    Map rules.xml.     (line  9088)
* 'LW6_TEAM_PROFILE_PINK_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  9104)
* 'LW6_TEAM_PROFILE_PINK_WEAPON_ID':     Map rules.xml.     (line  9117)
* 'LW6_TEAM_PROFILE_PINK_WEAPON_MODE':   Map rules.xml.     (line  9130)
* 'LW6_TEAM_PROFILE_PURPLE_AGGRESSIVE':  Map rules.xml.     (line  9144)
* 'LW6_TEAM_PROFILE_PURPLE_FAST':        Map rules.xml.     (line  9159)
* 'LW6_TEAM_PROFILE_PURPLE_HANDICAP':    Map rules.xml.     (line  9174)
* 'LW6_TEAM_PROFILE_PURPLE_MOBILE':      Map rules.xml.     (line  9186)
* 'LW6_TEAM_PROFILE_PURPLE_VULNERABLE':  Map rules.xml.     (line  9202)
* 'LW6_TEAM_PROFILE_PURPLE_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  9218)
* 'LW6_TEAM_PROFILE_PURPLE_WEAPON_ID':   Map rules.xml.     (line  9231)
* 'LW6_TEAM_PROFILE_PURPLE_WEAPON_MODE': Map rules.xml.     (line  9244)
* 'LW6_TEAM_PROFILE_RED_AGGRESSIVE':     Map rules.xml.     (line  9258)
* 'LW6_TEAM_PROFILE_RED_FAST':           Map rules.xml.     (line  9273)
* 'LW6_TEAM_PROFILE_RED_HANDICAP':       Map rules.xml.     (line  9288)
* 'LW6_TEAM_PROFILE_RED_MOBILE':         Map rules.xml.     (line  9300)
* 'LW6_TEAM_PROFILE_RED_VULNERABLE':     Map rules.xml.     (line  9316)
* 'LW6_TEAM_PROFILE_RED_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  9332)
* 'LW6_TEAM_PROFILE_RED_WEAPON_ID':      Map rules.xml.     (line  9345)
* 'LW6_TEAM_PROFILE_RED_WEAPON_MODE':    Map rules.xml.     (line  9358)
* 'LW6_TEAM_PROFILE_YELLOW_AGGRESSIVE':  Map rules.xml.     (line  9372)
* 'LW6_TEAM_PROFILE_YELLOW_FAST':        Map rules.xml.     (line  9387)
* 'LW6_TEAM_PROFILE_YELLOW_HANDICAP':    Map rules.xml.     (line  9402)
* 'LW6_TEAM_PROFILE_YELLOW_MOBILE':      Map rules.xml.     (line  9414)
* 'LW6_TEAM_PROFILE_YELLOW_VULNERABLE':  Map rules.xml.     (line  9430)
* 'LW6_TEAM_PROFILE_YELLOW_WEAPON_ALTERNATE_ID': Map rules.xml.
                                                            (line  9446)
* 'LW6_TEAM_PROFILE_YELLOW_WEAPON_ID':   Map rules.xml.     (line  9459)
* 'LW6_TEAM_PROFILE_YELLOW_WEAPON_MODE': Map rules.xml.     (line  9472)
* lw6_test_register:                     libliquidwar6.     (line 15295)
* lw6_test_run:                          libliquidwar6.     (line 15305)
* 'LW6_TOTAL_ARMIES_SIZE':               Map rules.xml.     (line  9486)
* 'LW6_TOTAL_TIME':                      Map rules.xml.     (line  9507)
* 'LW6_TRAP_ERRORS':                     Advanced settings. (line 12044)
* 'LW6_TROJAN':                          Advanced settings. (line 12058)
* 'LW6_UPSIZE_USING_BENCH_VALUE':        Map hints.xml.     (line  9982)
* 'LW6_UPSIZE_USING_FIGHTER_SCALE':      Map hints.xml.     (line  9999)
* 'LW6_USER_DIR':                        Path options.      (line  6456)
* 'LW6_USE_CURSOR_TEXTURE':              Map parameters.    (line  7327)
* 'LW6_USE_DOUBLE_CLICK':                Input options.     (line  6864)
* 'LW6_USE_ESC_BUTTON':                  Input options.     (line  6881)
* 'LW6_USE_HINTS_XML':                   Map parameters.    (line  7341)
* 'LW6_USE_MUSIC_FILE':                  Map parameters.    (line  7354)
* 'LW6_USE_RULES_XML':                   Map parameters.    (line  7368)
* 'LW6_USE_STYLE_XML':                   Map parameters.    (line  7382)
* 'LW6_USE_TEAMS_XML':                   Map parameters.    (line  7397)
* 'LW6_USE_TEAM_PROFILES':               Map rules.xml.     (line  9525)
* 'LW6_USE_TEXTURE':                     Map parameters.    (line  7412)
* 'LW6_VERTICAL_MOVE':                   Map rules.xml.     (line  9540)
* 'LW6_VIEW_COLOR_AUTO':                 Map hints.xml.     (line 10015)
* 'LW6_VIEW_COLOR_CURSOR_BG':            Map style.xml.     (line 10719)
* 'LW6_VIEW_COLOR_CURSOR_FG':            Map style.xml.     (line 10733)
* 'LW6_VIEW_COLOR_MAP_BG':               Map style.xml.     (line 10747)
* 'LW6_VIEW_COLOR_MAP_FG':               Map style.xml.     (line 10762)
* 'LW6_VIEW_STYLE':                      Map style.xml.     (line 10777)
* 'LW6_WALL_GREASE':                     Map hints.xml.     (line 10033)
* 'LW6_WATER_VOLUME':                    Sound options.     (line  7107)
* 'LW6_WAVES':                           Map style.xml.     (line 10793)
* 'LW6_WEAPON_CHARGE_DELAY':             Map rules.xml.     (line  9556)
* 'LW6_WEAPON_CHARGE_MAX':               Map rules.xml.     (line  9569)
* 'LW6_WEAPON_DURATION':                 Map rules.xml.     (line  9586)
* 'LW6_WEAPON_TUNE_BERZERK_POWER':       Map rules.xml.     (line  9599)
* 'LW6_WEAPON_TUNE_TURBO_POWER':         Map rules.xml.     (line  9612)
* 'LW6_WIDTH':                           Graphics options.  (line  6993)
* 'LW6_WINDOWED_MODE_LIMIT':             Graphics options.  (line  7007)
* 'LW6_X_POLARITY':                      Map rules.xml.     (line  9625)
* 'LW6_X_WRAP':                          Map style.xml.     (line 10806)
* 'LW6_Y_POLARITY':                      Map rules.xml.     (line  9644)
* 'LW6_Y_WRAP':                          Map style.xml.     (line 10822)
* 'LW6_ZOOM':                            Map style.xml.     (line 10838)
* 'LW6_ZOOM_MAX':                        Map style.xml.     (line 10852)
* 'LW6_ZOOM_MIN':                        Map style.xml.     (line 10866)
* 'LW6_ZOOM_STEP':                       Input options.     (line  6895)
* 'LW6_ZOOM_STICK_DELAY':                Input options.     (line  6908)
* 'LW6_Z_POLARITY':                      Map rules.xml.     (line  9663)
* 'magic-number':                        Advanced settings. (line 11750)
* 'map-path':                            Path options.      (line  6341)
* 'max-cursor-pot':                      Map rules.xml.     (line  7683)
* 'max-cursor-pot-offset':               Map rules.xml.     (line  7697)
* 'max-cursor-speed':                    Input options.     (line  6812)
* 'max-local-bench-value':               Advanced settings. (line 11774)
* 'max-map-height':                      Map hints.xml.     (line  9811)
* 'max-map-surface':                     Map hints.xml.     (line  9828)
* 'max-map-width':                       Map hints.xml.     (line  9843)
* 'max-nb-cursors':                      Map rules.xml.     (line  7714)
* 'max-nb-nodes':                        Map rules.xml.     (line  7728)
* 'max-nb-teams':                        Map rules.xml.     (line  7742)
* 'max-network-bench-value':             Advanced settings. (line 11791)
* 'max-round-delta':                     Map rules.xml.     (line  7755)
* 'max-zone-size':                       Map rules.xml.     (line  7770)
* 'medicine-power':                      Map rules.xml.     (line  7793)
* 'memory-bazooka-eraser':               Advanced settings. (line 11806)
* 'memory-bazooka-size':                 Advanced settings. (line 11826)
* 'menu-color-auto':                     Map hints.xml.     (line  9860)
* 'menu-color-default-bg':               Map style.xml.     (line 10395)
* 'menu-color-default-fg':               Map style.xml.     (line 10408)
* 'menu-color-disabled-bg':              Map style.xml.     (line 10423)
* 'menu-color-disabled-fg':              Map style.xml.     (line 10436)
* 'menu-color-selected-bg':              Map style.xml.     (line 10449)
* 'menu-color-selected-fg':              Map style.xml.     (line 10462)
* 'menu-style':                          Map style.xml.     (line 10475)
* 'min-map-height':                      Map hints.xml.     (line  9879)
* 'min-map-surface':                     Map hints.xml.     (line  9896)
* 'min-map-width':                       Map hints.xml.     (line  9911)
* mod_brute_create_backend:              mod-brute.         (line 15662)
* mod_brute_get_pedigree:                mod-brute.         (line 15652)
* mod_brute_is_dlclose_safe:             mod-brute.         (line 15643)
* mod_brute_is_GPL_compatible:           mod-brute.         (line 15634)
* mod_caca_create_backend:               mod-caca.          (line 19775)
* mod_caca_get_pedigree:                 mod-caca.          (line 19766)
* mod_caca_is_GPL_compatible:            mod-caca.          (line 19757)
* mod_csound_create_backend:             mod-csound.        (line 37962)
* mod_csound_get_pedigree:               mod-csound.        (line 37952)
* mod_csound_is_dlclose_safe:            mod-csound.        (line 37943)
* mod_csound_is_GPL_compatible:          mod-csound.        (line 37934)
* mod_follow_create_backend:             mod-follow.        (line 15711)
* mod_follow_get_pedigree:               mod-follow.        (line 15701)
* mod_follow_is_dlclose_safe:            mod-follow.        (line 15692)
* mod_follow_is_GPL_compatible:          mod-follow.        (line 15683)
* mod_gl1_create_backend:                mod-gl1.           (line 19619)
* mod_gl1_get_pedigree:                  mod-gl1.           (line 19610)
* mod_gl1_is_GPL_compatible:             mod-gl1.           (line 19601)
* mod_gles2_create_backend:              mod-gles2.         (line 19663)
* mod_gles2_get_pedigree:                mod-gles2.         (line 19653)
* mod_gles2_is_GPL_compatible:           mod-gles2.         (line 19644)
* mod_httpd_create_backend:              mod-httpd.         (line 38867)
* mod_httpd_get_pedigree:                mod-httpd.         (line 38857)
* mod_httpd_is_dlclose_safe:             mod-httpd.         (line 38848)
* mod_httpd_is_GPL_compatible:           mod-httpd.         (line 38839)
* mod_http_create_backend:               mod-http.          (line 16973)
* mod_http_get_pedigree:                 mod-http.          (line 16964)
* mod_http_is_dlclose_safe:              mod-http.          (line 16956)
* mod_http_is_GPL_compatible:            mod-http.          (line 16947)
* mod_idiot_create_backend:              mod-idiot.         (line 15760)
* mod_idiot_get_pedigree:                mod-idiot.         (line 15750)
* mod_idiot_is_dlclose_safe:             mod-idiot.         (line 15741)
* mod_idiot_is_GPL_compatible:           mod-idiot.         (line 15732)
* mod_ogg_create_backend:                mod-ogg.           (line 38009)
* mod_ogg_get_pedigree:                  mod-ogg.           (line 38000)
* mod_ogg_is_dlclose_safe:               mod-ogg.           (line 37992)
* mod_ogg_is_GPL_compatible:             mod-ogg.           (line 37983)
* mod_random_create_backend:             mod-random.        (line 15809)
* mod_random_get_pedigree:               mod-random.        (line 15799)
* mod_random_is_dlclose_safe:            mod-random.        (line 15790)
* mod_random_is_GPL_compatible:          mod-random.        (line 15781)
* mod_soft_create_backend:               mod-soft.          (line 19706)
* mod_soft_get_pedigree:                 mod-soft.          (line 19697)
* mod_soft_is_GPL_compatible:            mod-soft.          (line 19688)
* mod_tcpd_create_backend:               mod-tcpd.          (line 38914)
* mod_tcpd_get_pedigree:                 mod-tcpd.          (line 38905)
* mod_tcpd_is_dlclose_safe:              mod-tcpd.          (line 38897)
* mod_tcpd_is_GPL_compatible:            mod-tcpd.          (line 38888)
* mod_tcp_create_backend:                mod-tcp.           (line 17020)
* mod_tcp_get_pedigree:                  mod-tcp.           (line 17011)
* mod_tcp_is_dlclose_safe:               mod-tcp.           (line 17003)
* mod_tcp_is_GPL_compatible:             mod-tcp.           (line 16994)
* mod_udpd_create_backend:               mod-udpd.          (line 38961)
* mod_udpd_get_pedigree:                 mod-udpd.          (line 38952)
* mod_udpd_is_dlclose_safe:              mod-udpd.          (line 38944)
* mod_udpd_is_GPL_compatible:            mod-udpd.          (line 38935)
* mod_udp_create_backend:                mod-udp.           (line 17067)
* mod_udp_get_pedigree:                  mod-udp.           (line 17058)
* mod_udp_is_dlclose_safe:               mod-udp.           (line 17050)
* mod_udp_is_GPL_compatible:             mod-udp.           (line 17041)
* 'mouse-sensitivity':                   Input options.     (line  6825)
* 'moves-per-round':                     Map rules.xml.     (line  7809)
* 'music-dir':                           Path options.      (line  6383)
* 'music-exclude':                       Map style.xml.     (line 10488)
* 'music-file':                          Map style.xml.     (line 10501)
* 'music-filter':                        Map style.xml.     (line 10518)
* 'music-path':                          Path options.      (line  6401)
* 'music-volume':                        Sound options.     (line  7082)
* 'nb-attack-tries':                     Map rules.xml.     (line  7827)
* 'nb-bots':                             Map teams.xml.     (line 11129)
* 'nb-defense-tries':                    Map rules.xml.     (line  7845)
* 'nb-move-tries':                       Map rules.xml.     (line  7862)
* 'net-log':                             Advanced settings. (line 11848)
* 'net-per-sec':                         Advanced settings. (line 11863)
* 'network-bench-delta':                 Advanced settings. (line 11878)
* 'network-reliability':                 Advanced settings. (line 11892)
* 'node-description':                    Network options.   (line  7201)
* 'node-title':                          Network options.   (line  7216)
* 'open-relay':                          Advanced settings. (line 11915)
* 'password':                            Network options.   (line  7231)
* 'pilot-lag':                           Advanced settings. (line 11933)
* 'pixelize':                            Map style.xml.     (line 10534)
* 'player1-color':                       Map teams.xml.     (line 11143)
* 'player1-control':                     Players options.   (line  6475)
* 'player1-name':                        Players options.   (line  6488)
* 'player1-status':                      Players options.   (line  6501)
* 'player2-color':                       Map teams.xml.     (line 11156)
* 'player2-control':                     Players options.   (line  6514)
* 'player2-name':                        Players options.   (line  6527)
* 'player2-status':                      Players options.   (line  6540)
* 'player3-color':                       Map teams.xml.     (line 11169)
* 'player3-control':                     Players options.   (line  6553)
* 'player3-name':                        Players options.   (line  6566)
* 'player3-status':                      Players options.   (line  6579)
* 'player4-color':                       Map teams.xml.     (line 11182)
* 'player4-control':                     Players options.   (line  6592)
* 'player4-name':                        Players options.   (line  6605)
* 'player4-status':                      Players options.   (line  6618)
* 'public-url':                          Network options.   (line  7249)
* 'repeat-delay':                        Input options.     (line  6839)
* 'repeat-interval':                     Input options.     (line  6852)
* 'resample':                            Map hints.xml.     (line  9928)
* 'reset-config-on-upgrade':             Advanced settings. (line 11963)
* 'respawn-delay':                       Map rules.xml.     (line  7883)
* 'respawn-position-mode':               Map rules.xml.     (line  7896)
* 'respawn-team':                        Map rules.xml.     (line  7912)
* 'round-delta':                         Map rules.xml.     (line  7928)
* 'rounds-per-sec':                      Map rules.xml.     (line  7953)
* 'screenshots-per-min':                 Advanced settings. (line 11976)
* shared_sdl_is_GPL_compatible:          shared-sdl.        (line 19731)
* 'side-attack-factor':                  Map rules.xml.     (line  7970)
* 'side-defense-factor':                 Map rules.xml.     (line  7987)
* 'single-army-size':                    Map rules.xml.     (line  8001)
* 'skip-network':                        Network options.   (line  7265)
* 'snd-backend':                         Sound options.     (line  7095)
* 'speed':                               Map hints.xml.     (line  9942)
* 'spread-mode':                         Map rules.xml.     (line  8019)
* 'spread-thread':                       Map rules.xml.     (line  8034)
* 'spreads-per-round':                   Map rules.xml.     (line  8051)
* 'srv-backends':                        Network options.   (line  7278)
* 'start-blue-x':                        Map rules.xml.     (line  8070)
* 'start-blue-y':                        Map rules.xml.     (line  8083)
* 'start-cyan-x':                        Map rules.xml.     (line  8096)
* 'start-cyan-y':                        Map rules.xml.     (line  8109)
* 'start-green-x':                       Map rules.xml.     (line  8122)
* 'start-green-y':                       Map rules.xml.     (line  8135)
* 'start-lightblue-x':                   Map rules.xml.     (line  8148)
* 'start-lightblue-y':                   Map rules.xml.     (line  8161)
* 'start-magenta-x':                     Map rules.xml.     (line  8174)
* 'start-magenta-y':                     Map rules.xml.     (line  8187)
* 'start-orange-x':                      Map rules.xml.     (line  8200)
* 'start-orange-y':                      Map rules.xml.     (line  8213)
* 'start-pink-x':                        Map rules.xml.     (line  8226)
* 'start-pink-y':                        Map rules.xml.     (line  8239)
* 'start-position-mode':                 Map rules.xml.     (line  8252)
* 'start-purple-x':                      Map rules.xml.     (line  8268)
* 'start-purple-y':                      Map rules.xml.     (line  8281)
* 'start-red-x':                         Map rules.xml.     (line  8294)
* 'start-red-y':                         Map rules.xml.     (line  8307)
* 'start-yellow-x':                      Map rules.xml.     (line  8320)
* 'start-yellow-y':                      Map rules.xml.     (line  8333)
* 'system-color-auto':                   Map hints.xml.     (line  9966)
* 'system-color-bg':                     Map style.xml.     (line 10548)
* 'system-color-fg':                     Map style.xml.     (line 10562)
* 'target-fps':                          Advanced settings. (line 12026)
* 'team-color-blue':                     Map style.xml.     (line 10576)
* 'team-color-cyan':                     Map style.xml.     (line 10589)
* 'team-color-dead':                     Map style.xml.     (line 10602)
* 'team-color-green':                    Map style.xml.     (line 10616)
* 'team-color-lightblue':                Map style.xml.     (line 10629)
* 'team-color-magenta':                  Map style.xml.     (line 10642)
* 'team-color-orange':                   Map style.xml.     (line 10655)
* 'team-color-pink':                     Map style.xml.     (line 10668)
* 'team-color-purple':                   Map style.xml.     (line 10681)
* 'team-color-red':                      Map style.xml.     (line 10694)
* 'team-color-yellow':                   Map style.xml.     (line 10707)
* 'team-profile-blue-aggressive':        Map rules.xml.     (line  8346)
* 'team-profile-blue-fast':              Map rules.xml.     (line  8361)
* 'team-profile-blue-handicap':          Map rules.xml.     (line  8376)
* 'team-profile-blue-mobile':            Map rules.xml.     (line  8388)
* 'team-profile-blue-vulnerable':        Map rules.xml.     (line  8404)
* 'team-profile-blue-weapon-alternate-id': Map rules.xml.   (line  8420)
* 'team-profile-blue-weapon-id':         Map rules.xml.     (line  8433)
* 'team-profile-blue-weapon-mode':       Map rules.xml.     (line  8446)
* 'team-profile-cyan-aggressive':        Map rules.xml.     (line  8460)
* 'team-profile-cyan-fast':              Map rules.xml.     (line  8475)
* 'team-profile-cyan-handicap':          Map rules.xml.     (line  8490)
* 'team-profile-cyan-mobile':            Map rules.xml.     (line  8502)
* 'team-profile-cyan-vulnerable':        Map rules.xml.     (line  8518)
* 'team-profile-cyan-weapon-alternate-id': Map rules.xml.   (line  8534)
* 'team-profile-cyan-weapon-id':         Map rules.xml.     (line  8547)
* 'team-profile-cyan-weapon-mode':       Map rules.xml.     (line  8560)
* 'team-profile-green-aggressive':       Map rules.xml.     (line  8574)
* 'team-profile-green-fast':             Map rules.xml.     (line  8589)
* 'team-profile-green-handicap':         Map rules.xml.     (line  8604)
* 'team-profile-green-mobile':           Map rules.xml.     (line  8616)
* 'team-profile-green-vulnerable':       Map rules.xml.     (line  8632)
* 'team-profile-green-weapon-alternate-id': Map rules.xml.  (line  8648)
* 'team-profile-green-weapon-id':        Map rules.xml.     (line  8661)
* 'team-profile-green-weapon-mode':      Map rules.xml.     (line  8674)
* 'team-profile-lightblue-aggressive':   Map rules.xml.     (line  8688)
* 'team-profile-lightblue-fast':         Map rules.xml.     (line  8703)
* 'team-profile-lightblue-handicap':     Map rules.xml.     (line  8718)
* 'team-profile-lightblue-mobile':       Map rules.xml.     (line  8730)
* 'team-profile-lightblue-vulnerable':   Map rules.xml.     (line  8746)
* 'team-profile-lightblue-weapon-alternate-id': Map rules.xml.
                                                            (line  8763)
* 'team-profile-lightblue-weapon-id':    Map rules.xml.     (line  8776)
* 'team-profile-lightblue-weapon-mode':  Map rules.xml.     (line  8789)
* 'team-profile-magenta-aggressive':     Map rules.xml.     (line  8803)
* 'team-profile-magenta-fast':           Map rules.xml.     (line  8818)
* 'team-profile-magenta-handicap':       Map rules.xml.     (line  8833)
* 'team-profile-magenta-mobile':         Map rules.xml.     (line  8845)
* 'team-profile-magenta-vulnerable':     Map rules.xml.     (line  8861)
* 'team-profile-magenta-weapon-alternate-id': Map rules.xml.
                                                            (line  8877)
* 'team-profile-magenta-weapon-id':      Map rules.xml.     (line  8890)
* 'team-profile-magenta-weapon-mode':    Map rules.xml.     (line  8903)
* 'team-profile-orange-aggressive':      Map rules.xml.     (line  8917)
* 'team-profile-orange-fast':            Map rules.xml.     (line  8932)
* 'team-profile-orange-handicap':        Map rules.xml.     (line  8947)
* 'team-profile-orange-mobile':          Map rules.xml.     (line  8959)
* 'team-profile-orange-vulnerable':      Map rules.xml.     (line  8975)
* 'team-profile-orange-weapon-alternate-id': Map rules.xml. (line  8991)
* 'team-profile-orange-weapon-id':       Map rules.xml.     (line  9004)
* 'team-profile-orange-weapon-mode':     Map rules.xml.     (line  9017)
* 'team-profile-pink-aggressive':        Map rules.xml.     (line  9031)
* 'team-profile-pink-fast':              Map rules.xml.     (line  9046)
* 'team-profile-pink-handicap':          Map rules.xml.     (line  9061)
* 'team-profile-pink-mobile':            Map rules.xml.     (line  9073)
* 'team-profile-pink-vulnerable':        Map rules.xml.     (line  9089)
* 'team-profile-pink-weapon-alternate-id': Map rules.xml.   (line  9105)
* 'team-profile-pink-weapon-id':         Map rules.xml.     (line  9118)
* 'team-profile-pink-weapon-mode':       Map rules.xml.     (line  9131)
* 'team-profile-purple-aggressive':      Map rules.xml.     (line  9145)
* 'team-profile-purple-fast':            Map rules.xml.     (line  9160)
* 'team-profile-purple-handicap':        Map rules.xml.     (line  9175)
* 'team-profile-purple-mobile':          Map rules.xml.     (line  9187)
* 'team-profile-purple-vulnerable':      Map rules.xml.     (line  9203)
* 'team-profile-purple-weapon-alternate-id': Map rules.xml. (line  9219)
* 'team-profile-purple-weapon-id':       Map rules.xml.     (line  9232)
* 'team-profile-purple-weapon-mode':     Map rules.xml.     (line  9245)
* 'team-profile-red-aggressive':         Map rules.xml.     (line  9259)
* 'team-profile-red-fast':               Map rules.xml.     (line  9274)
* 'team-profile-red-handicap':           Map rules.xml.     (line  9289)
* 'team-profile-red-mobile':             Map rules.xml.     (line  9301)
* 'team-profile-red-vulnerable':         Map rules.xml.     (line  9317)
* 'team-profile-red-weapon-alternate-id': Map rules.xml.    (line  9333)
* 'team-profile-red-weapon-id':          Map rules.xml.     (line  9346)
* 'team-profile-red-weapon-mode':        Map rules.xml.     (line  9359)
* 'team-profile-yellow-aggressive':      Map rules.xml.     (line  9373)
* 'team-profile-yellow-fast':            Map rules.xml.     (line  9388)
* 'team-profile-yellow-handicap':        Map rules.xml.     (line  9403)
* 'team-profile-yellow-mobile':          Map rules.xml.     (line  9415)
* 'team-profile-yellow-vulnerable':      Map rules.xml.     (line  9431)
* 'team-profile-yellow-weapon-alternate-id': Map rules.xml. (line  9447)
* 'team-profile-yellow-weapon-id':       Map rules.xml.     (line  9460)
* 'team-profile-yellow-weapon-mode':     Map rules.xml.     (line  9473)
* 'total-armies-size':                   Map rules.xml.     (line  9487)
* 'total-time':                          Map rules.xml.     (line  9508)
* 'trap-errors':                         Advanced settings. (line 12045)
* 'trojan':                              Advanced settings. (line 12059)
* 'upsize-using-bench-value':            Map hints.xml.     (line  9983)
* 'upsize-using-fighter-scale':          Map hints.xml.     (line 10000)
* 'use-cursor-texture':                  Map parameters.    (line  7328)
* 'use-double-click':                    Input options.     (line  6865)
* 'use-esc-button':                      Input options.     (line  6882)
* 'use-hints-xml':                       Map parameters.    (line  7342)
* 'use-music-file':                      Map parameters.    (line  7355)
* 'use-rules-xml':                       Map parameters.    (line  7369)
* 'use-style-xml':                       Map parameters.    (line  7383)
* 'use-team-profiles':                   Map rules.xml.     (line  9526)
* 'use-teams-xml':                       Map parameters.    (line  7398)
* 'use-texture':                         Map parameters.    (line  7413)
* 'user-dir':                            Path options.      (line  6457)
* 'vertical-move':                       Map rules.xml.     (line  9541)
* 'view-color-auto':                     Map hints.xml.     (line 10016)
* 'view-color-cursor-bg':                Map style.xml.     (line 10720)
* 'view-color-cursor-fg':                Map style.xml.     (line 10734)
* 'view-color-map-bg':                   Map style.xml.     (line 10748)
* 'view-color-map-fg':                   Map style.xml.     (line 10763)
* 'view-style':                          Map style.xml.     (line 10778)
* 'wall-grease':                         Map hints.xml.     (line 10034)
* 'water-volume':                        Sound options.     (line  7108)
* 'waves':                               Map style.xml.     (line 10794)
* 'weapon-charge-delay':                 Map rules.xml.     (line  9557)
* 'weapon-charge-max':                   Map rules.xml.     (line  9570)
* 'weapon-duration':                     Map rules.xml.     (line  9587)
* 'weapon-tune-berzerk-power':           Map rules.xml.     (line  9600)
* 'weapon-tune-turbo-power':             Map rules.xml.     (line  9613)
* 'width':                               Graphics options.  (line  6994)
* 'windowed-mode-limit':                 Graphics options.  (line  7008)
* 'x-polarity':                          Map rules.xml.     (line  9626)
* 'x-wrap':                              Map style.xml.     (line 10807)
* 'y-polarity':                          Map rules.xml.     (line  9645)
* 'y-wrap':                              Map style.xml.     (line 10823)
* 'z-polarity':                          Map rules.xml.     (line  9664)
* 'zoom':                                Map style.xml.     (line 10839)
* 'zoom-max':                            Map style.xml.     (line 10853)
* 'zoom-min':                            Map style.xml.     (line 10867)
* 'zoom-step':                           Input options.     (line  6896)
* 'zoom-stick-delay':                    Input options.     (line  6909)

G.3 Data types index
====================

* Menu:

* lw6bot_backend_s:                      libbot.            (line 15445)
* lw6bot_data_s:                         libbot.            (line 15530)
* lw6bot_param_s:                        libbot.            (line 15553)
* lw6bot_seed_s:                         libbot.            (line 15584)
* lw6cli_backend_s:                      libcli.            (line 16720)
* lw6cli_oob_data_s:                     libcli.            (line 16861)
* lw6cli_oob_s:                          libcli.            (line 16912)
* lw6cnx_connection_s:                   libcnx.            (line 17552)
* lw6cnx_packet_s:                       libcnx.            (line 17752)
* lw6cnx_properties_s:                   libcnx.            (line 17790)
* lw6cnx_ticket_table_s:                 libcnx.            (line 17850)
* lw6dat_miss_s:                         libdat.            (line 18428)
* lw6dat_warehouse_s:                    libdat.            (line 18457)
* lw6dsp_backend_s:                      libdsp.            (line 18698)
* lw6dsp_misc_s:                         libdsp.            (line 18740)
* lw6dsp_param_s:                        libdsp.            (line 18829)
* lw6dyn_dl_handle_s:                    libdyn.            (line 19101)
* lw6gfx_backend_s:                      libgfx.            (line 19458)
* lw6gui_button_s:                       libgui.            (line 22018)
* lw6gui_fullscreen_modes_s:             libgui.            (line 22108)
* lw6gui_input_s:                        libgui.            (line 22134)
* lw6gui_joystick_s:                     libgui.            (line 22170)
* lw6gui_keyboard_s:                     libgui.            (line 22252)
* lw6gui_keypress_s:                     libgui.            (line 22363)
* lw6gui_look_s:                         libgui.            (line 22393)
* lw6gui_menuitem_s:                     libgui.            (line 22432)
* lw6gui_menu_s:                         libgui.            (line 22513)
* lw6gui_mouse_pointer_s:                libgui.            (line 22620)
* lw6gui_mouse_s:                        libgui.            (line 22656)
* lw6gui_move_pad_s:                     libgui.            (line 22775)
* lw6gui_point_s:                        libgui.            (line 22808)
* lw6gui_quad_s:                         libgui.            (line 22833)
* lw6gui_rect_array_s:                   libgui.            (line 22865)
* lw6gui_rect_s:                         libgui.            (line 22937)
* lw6gui_repeat_settings_s:              libgui.            (line 22986)
* lw6gui_segment_s:                      libgui.            (line 23027)
* lw6gui_smoother_s:                     libgui.            (line 23045)
* lw6gui_triangle_s:                     libgui.            (line 23090)
* lw6gui_video_mode_s:                   libgui.            (line 23115)
* lw6gui_viewport_s:                     libgui.            (line 23141)
* lw6gui_zone_s:                         libgui.            (line 23273)
* lw6img_jpeg_s:                         libimg.            (line 24119)
* lw6ker_cursor_control_s:               libker.            (line 25524)
* lw6ker_cursor_s:                       libker.            (line 25550)
* lw6ker_fighter_s:                      libker.            (line 25630)
* lw6ker_game_state_s:                   libker.            (line 25681)
* lw6ker_game_struct_s:                  libker.            (line 25707)
* lw6ker_score_array_s:                  libker.            (line 25747)
* lw6ker_score_s:                        libker.            (line 25779)
* lw6ldr_entry_s:                        libldr.            (line 26763)
* lw6ldr_hints_s:                        libldr.            (line 26810)
* lw6ldr_resampler_s:                    libldr.            (line 26961)
* lw6ldr_use_s:                          libldr.            (line 27010)
* lw6map_body_s:                         libmap.            (line 28319)
* lw6map_bot_info_s:                     libmap.            (line 28407)
* lw6map_color_couple_s:                 libmap.            (line 28426)
* lw6map_color_set_s:                    libmap.            (line 28448)
* lw6map_cursor_texture_layer_s:         libmap.            (line 28566)
* lw6map_cursor_texture_s:               libmap.            (line 28579)
* lw6map_layer_s:                        libmap.            (line 28601)
* lw6map_level_s:                        libmap.            (line 28619)
* lw6map_local_info_s:                   libmap.            (line 28677)
* lw6map_metadata_s:                     libmap.            (line 28692)
* lw6map_meta_layer_s:                   libmap.            (line 28731)
* lw6map_param_s:                        libmap.            (line 28750)
* lw6map_rules_s:                        libmap.            (line 28775)
* lw6map_style_s:                        libmap.            (line 29227)
* lw6map_teams_s:                        libmap.            (line 29392)
* lw6map_texture_s:                      libmap.            (line 29434)
* lw6mat_dmat2_t:                        libmat.            (line 31455)
* lw6mat_dmat3_t:                        libmat.            (line 31478)
* lw6mat_dmat4_t:                        libmat.            (line 31501)
* lw6mat_dvec2_t:                        libmat.            (line 31524)
* lw6mat_dvec3_t:                        libmat.            (line 31569)
* lw6mat_dvec4_t:                        libmat.            (line 31653)
* lw6mat_fmat2_t:                        libmat.            (line 31759)
* lw6mat_fmat3_t:                        libmat.            (line 31782)
* lw6mat_fmat4_t:                        libmat.            (line 31805)
* lw6mat_fvec2_t:                        libmat.            (line 31828)
* lw6mat_fvec3_t:                        libmat.            (line 31873)
* lw6mat_fvec4_t:                        libmat.            (line 31957)
* lw6mat_imat2_t:                        libmat.            (line 32063)
* lw6mat_imat3_t:                        libmat.            (line 32087)
* lw6mat_imat4_t:                        libmat.            (line 32111)
* lw6mat_ivec2_t:                        libmat.            (line 32135)
* lw6mat_ivec3_t:                        libmat.            (line 32180)
* lw6mat_ivec4_t:                        libmat.            (line 32257)
* lw6mat_xmat2_t:                        libmat.            (line 32349)
* lw6mat_xmat3_t:                        libmat.            (line 32373)
* lw6mat_xmat4_t:                        libmat.            (line 32397)
* lw6mat_xvec2_t:                        libmat.            (line 32421)
* lw6mat_xvec3_t:                        libmat.            (line 32466)
* lw6mat_xvec4_t:                        libmat.            (line 32543)
* lw6msg_meta_array_item_s:              libmsg.            (line 33625)
* lw6msg_meta_array_s:                   libmsg.            (line 33642)
* lw6msg_word_s:                         libmsg.            (line 33655)
* lw6nod_const_info_s:                   libnod.            (line 34639)
* lw6nod_dyn_info_s:                     libnod.            (line 34744)
* lw6nod_info_s:                         libnod.            (line 34858)
* lw6nod_ref_info_s:                     libnod.            (line 34904)
* lw6p2p_db_s:                           libp2p.            (line 35564)
* lw6p2p_entry_s:                        libp2p.            (line 35578)
* lw6p2p_node_s:                         libp2p.            (line 35768)
* lw6pil_add_args_s:                     libpil.            (line 36750)
* lw6pil_command_args_u:                 libpil.            (line 37119)
* lw6pil_command_s:                      libpil.            (line 36768)
* lw6pil_dump_args_s:                    libpil.            (line 36819)
* lw6pil_dump_s:                         libpil.            (line 36844)
* lw6pil_local_cursors_s:                libpil.            (line 36878)
* lw6pil_local_cursor_s:                 libpil.            (line 36915)
* lw6pil_pilot_s:                        libpil.            (line 36960)
* lw6pil_remove_args_s:                  libpil.            (line 36977)
* lw6pil_set_args_s:                     libpil.            (line 36988)
* lw6pil_worker_s:                       libpil.            (line 37027)
* lw6sim_results_s:                      libsim.            (line 37498)
* lw6snd_backend_s:                      libsnd.            (line 37771)
* lw6srv_backend_s:                      libsrv.            (line 38438)
* lw6srv_client_id_s:                    libsrv.            (line 38626)
* lw6srv_listener_s:                     libsrv.            (line 38645)
* lw6srv_oob_data_s:                     libsrv.            (line 38693)
* lw6srv_oob_s:                          libsrv.            (line 38744)
* lw6srv_tcp_accepter_s:                 libsrv.            (line 38763)
* lw6srv_udp_buffer_s:                   libsrv.            (line 38806)
* lw6sys_assoc_s:                        libsys.            (line 45022)
* lw6sys_cache_item_s:                   libsys.            (line 45060)
* lw6sys_cache_s:                        libsys.            (line 45096)
* lw6sys_color_8_s:                      libsys.            (line 45124)
* lw6sys_color_f_s:                      libsys.            (line 45157)
* lw6sys_color_hsv_s:                    libsys.            (line 45190)
* lw6sys_context_s:                      libsys.            (line 45224)
* lw6sys_hash_s:                         libsys.            (line 45243)
* lw6sys_hexa_serializer_s:              libsys.            (line 45278)
* lw6sys_list_r_s:                       libsys.            (line 45309)
* lw6sys_list_s:                         libsys.            (line 45343)
* lw6sys_module_pedigree_s:              libsys.            (line 45377)
* lw6sys_mutex_s:                        libsys.            (line 45447)
* lw6sys_progress_s:                     libsys.            (line 45461)
* lw6sys_spinlock_s:                     libsys.            (line 45492)
* lw6sys_thread_handler_s:               libsys.            (line 45508)
* lw6sys_url_s:                          libsys.            (line 45525)
* lw6sys_whd_s:                          libsys.            (line 45559)
* lw6sys_xyz_s:                          libsys.            (line 45591)
* lw6tsk_loader_s:                       libtsk.            (line 45798)
* lw6vox_renderer_s:                     libvox.            (line 45878)

